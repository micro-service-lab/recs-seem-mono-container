// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: member.sql

package query

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countMembers = `-- name: CountMembers :one
SELECT COUNT(*) FROM m_members
WHERE
	CASE WHEN $1::boolean = true THEN m_members.name LIKE '%' || $2::text || '%' ELSE TRUE END
AND
	CASE WHEN $3::boolean = true THEN (SELECT COUNT(*) FROM m_role_associations WHERE role_id = m_members.role_id AND m_role_associations.policy_id = ANY($4::uuid[])) > 0 ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN m_members.attend_status_id = ANY($6::uuid[]) ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN m_members.grade_id = ANY($8::uuid[]) ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN m_members.group_id = ANY($10::uuid[]) ELSE TRUE END
`

type CountMembersParams struct {
	WhereLikeName      bool        `json:"where_like_name"`
	SearchName         string      `json:"search_name"`
	WhereHasPolicy     bool        `json:"where_has_policy"`
	HasPolicyIds       []uuid.UUID `json:"has_policy_ids"`
	WhenInAttendStatus bool        `json:"when_in_attend_status"`
	InAttendStatusIds  []uuid.UUID `json:"in_attend_status_ids"`
	WhenInGrade        bool        `json:"when_in_grade"`
	InGradeIds         []uuid.UUID `json:"in_grade_ids"`
	WhenInGroup        bool        `json:"when_in_group"`
	InGroupIds         []uuid.UUID `json:"in_group_ids"`
}

func (q *Queries) CountMembers(ctx context.Context, arg CountMembersParams) (int64, error) {
	row := q.db.QueryRow(ctx, countMembers,
		arg.WhereLikeName,
		arg.SearchName,
		arg.WhereHasPolicy,
		arg.HasPolicyIds,
		arg.WhenInAttendStatus,
		arg.InAttendStatusIds,
		arg.WhenInGrade,
		arg.InGradeIds,
		arg.WhenInGroup,
		arg.InGroupIds,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createMember = `-- name: CreateMember :one
INSERT INTO m_members (login_id, password, email, name, attend_status_id, grade_id, group_id, profile_image_id, role_id, personal_organization_id, created_at, updated_at) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12) RETURNING m_members_pkey, member_id, login_id, password, email, name, attend_status_id, profile_image_id, grade_id, group_id, personal_organization_id, role_id, created_at, updated_at
`

type CreateMemberParams struct {
	LoginID                string      `json:"login_id"`
	Password               string      `json:"password"`
	Email                  string      `json:"email"`
	Name                   string      `json:"name"`
	AttendStatusID         uuid.UUID   `json:"attend_status_id"`
	GradeID                uuid.UUID   `json:"grade_id"`
	GroupID                uuid.UUID   `json:"group_id"`
	ProfileImageID         pgtype.UUID `json:"profile_image_id"`
	RoleID                 pgtype.UUID `json:"role_id"`
	PersonalOrganizationID uuid.UUID   `json:"personal_organization_id"`
	CreatedAt              time.Time   `json:"created_at"`
	UpdatedAt              time.Time   `json:"updated_at"`
}

func (q *Queries) CreateMember(ctx context.Context, arg CreateMemberParams) (Member, error) {
	row := q.db.QueryRow(ctx, createMember,
		arg.LoginID,
		arg.Password,
		arg.Email,
		arg.Name,
		arg.AttendStatusID,
		arg.GradeID,
		arg.GroupID,
		arg.ProfileImageID,
		arg.RoleID,
		arg.PersonalOrganizationID,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Member
	err := row.Scan(
		&i.MMembersPkey,
		&i.MemberID,
		&i.LoginID,
		&i.Password,
		&i.Email,
		&i.Name,
		&i.AttendStatusID,
		&i.ProfileImageID,
		&i.GradeID,
		&i.GroupID,
		&i.PersonalOrganizationID,
		&i.RoleID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

type CreateMembersParams struct {
	LoginID                string      `json:"login_id"`
	Password               string      `json:"password"`
	Email                  string      `json:"email"`
	Name                   string      `json:"name"`
	AttendStatusID         uuid.UUID   `json:"attend_status_id"`
	GradeID                uuid.UUID   `json:"grade_id"`
	GroupID                uuid.UUID   `json:"group_id"`
	ProfileImageID         pgtype.UUID `json:"profile_image_id"`
	RoleID                 pgtype.UUID `json:"role_id"`
	PersonalOrganizationID uuid.UUID   `json:"personal_organization_id"`
	CreatedAt              time.Time   `json:"created_at"`
	UpdatedAt              time.Time   `json:"updated_at"`
}

const deleteMember = `-- name: DeleteMember :execrows
DELETE FROM m_members WHERE member_id = $1
`

func (q *Queries) DeleteMember(ctx context.Context, memberID uuid.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, deleteMember, memberID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const findMemberByID = `-- name: FindMemberByID :one
SELECT m_members_pkey, member_id, login_id, password, email, name, attend_status_id, profile_image_id, grade_id, group_id, personal_organization_id, role_id, created_at, updated_at FROM m_members WHERE member_id = $1
`

func (q *Queries) FindMemberByID(ctx context.Context, memberID uuid.UUID) (Member, error) {
	row := q.db.QueryRow(ctx, findMemberByID, memberID)
	var i Member
	err := row.Scan(
		&i.MMembersPkey,
		&i.MemberID,
		&i.LoginID,
		&i.Password,
		&i.Email,
		&i.Name,
		&i.AttendStatusID,
		&i.ProfileImageID,
		&i.GradeID,
		&i.GroupID,
		&i.PersonalOrganizationID,
		&i.RoleID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findMemberByIDWithAttendStatus = `-- name: FindMemberByIDWithAttendStatus :one
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_attend_statuses.m_attend_statuses_pkey, m_attend_statuses.attend_status_id, m_attend_statuses.name, m_attend_statuses.key FROM m_members
LEFT JOIN m_attend_statuses ON m_members.attend_status_id = m_attend_statuses.attend_status_id
WHERE member_id = $1
`

type FindMemberByIDWithAttendStatusRow struct {
	Member       Member       `json:"member"`
	AttendStatus AttendStatus `json:"attend_status"`
}

func (q *Queries) FindMemberByIDWithAttendStatus(ctx context.Context, memberID uuid.UUID) (FindMemberByIDWithAttendStatusRow, error) {
	row := q.db.QueryRow(ctx, findMemberByIDWithAttendStatus, memberID)
	var i FindMemberByIDWithAttendStatusRow
	err := row.Scan(
		&i.Member.MMembersPkey,
		&i.Member.MemberID,
		&i.Member.LoginID,
		&i.Member.Password,
		&i.Member.Email,
		&i.Member.Name,
		&i.Member.AttendStatusID,
		&i.Member.ProfileImageID,
		&i.Member.GradeID,
		&i.Member.GroupID,
		&i.Member.PersonalOrganizationID,
		&i.Member.RoleID,
		&i.Member.CreatedAt,
		&i.Member.UpdatedAt,
		&i.AttendStatus.MAttendStatusesPkey,
		&i.AttendStatus.AttendStatusID,
		&i.AttendStatus.Name,
		&i.AttendStatus.Key,
	)
	return i, err
}

const findMemberByIDWithGrade = `-- name: FindMemberByIDWithGrade :one
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_grades.m_grades_pkey, m_grades.grade_id, m_grades.key, m_grades.organization_id FROM m_members
LEFT JOIN m_grades ON m_members.grade_id = m_grades.grade_id
LEFT JOIN m_organizations ON m_grades.organization_id = m_organizations.organization_id
WHERE member_id = $1
`

type FindMemberByIDWithGradeRow struct {
	Member Member `json:"member"`
	Grade  Grade  `json:"grade"`
}

func (q *Queries) FindMemberByIDWithGrade(ctx context.Context, memberID uuid.UUID) (FindMemberByIDWithGradeRow, error) {
	row := q.db.QueryRow(ctx, findMemberByIDWithGrade, memberID)
	var i FindMemberByIDWithGradeRow
	err := row.Scan(
		&i.Member.MMembersPkey,
		&i.Member.MemberID,
		&i.Member.LoginID,
		&i.Member.Password,
		&i.Member.Email,
		&i.Member.Name,
		&i.Member.AttendStatusID,
		&i.Member.ProfileImageID,
		&i.Member.GradeID,
		&i.Member.GroupID,
		&i.Member.PersonalOrganizationID,
		&i.Member.RoleID,
		&i.Member.CreatedAt,
		&i.Member.UpdatedAt,
		&i.Grade.MGradesPkey,
		&i.Grade.GradeID,
		&i.Grade.Key,
		&i.Grade.OrganizationID,
	)
	return i, err
}

const findMemberByIDWithGroup = `-- name: FindMemberByIDWithGroup :one
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_groups.m_groups_pkey, m_groups.group_id, m_groups.key, m_groups.organization_id FROM m_members
LEFT JOIN m_groups ON m_members.group_id = m_groups.group_id
LEFT JOIN m_organizations ON m_groups.organization_id = m_organizations.organization_id
WHERE member_id = $1
`

type FindMemberByIDWithGroupRow struct {
	Member Member `json:"member"`
	Group  Group  `json:"group"`
}

func (q *Queries) FindMemberByIDWithGroup(ctx context.Context, memberID uuid.UUID) (FindMemberByIDWithGroupRow, error) {
	row := q.db.QueryRow(ctx, findMemberByIDWithGroup, memberID)
	var i FindMemberByIDWithGroupRow
	err := row.Scan(
		&i.Member.MMembersPkey,
		&i.Member.MemberID,
		&i.Member.LoginID,
		&i.Member.Password,
		&i.Member.Email,
		&i.Member.Name,
		&i.Member.AttendStatusID,
		&i.Member.ProfileImageID,
		&i.Member.GradeID,
		&i.Member.GroupID,
		&i.Member.PersonalOrganizationID,
		&i.Member.RoleID,
		&i.Member.CreatedAt,
		&i.Member.UpdatedAt,
		&i.Group.MGroupsPkey,
		&i.Group.GroupID,
		&i.Group.Key,
		&i.Group.OrganizationID,
	)
	return i, err
}

const findMemberByIDWithPersonalOrganization = `-- name: FindMemberByIDWithPersonalOrganization :one
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.color, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at, m_organizations.chat_room_id FROM m_members
LEFT JOIN m_organizations ON m_members.personal_organization_id = m_organizations.organization_id
WHERE member_id = $1
`

type FindMemberByIDWithPersonalOrganizationRow struct {
	Member       Member       `json:"member"`
	Organization Organization `json:"organization"`
}

func (q *Queries) FindMemberByIDWithPersonalOrganization(ctx context.Context, memberID uuid.UUID) (FindMemberByIDWithPersonalOrganizationRow, error) {
	row := q.db.QueryRow(ctx, findMemberByIDWithPersonalOrganization, memberID)
	var i FindMemberByIDWithPersonalOrganizationRow
	err := row.Scan(
		&i.Member.MMembersPkey,
		&i.Member.MemberID,
		&i.Member.LoginID,
		&i.Member.Password,
		&i.Member.Email,
		&i.Member.Name,
		&i.Member.AttendStatusID,
		&i.Member.ProfileImageID,
		&i.Member.GradeID,
		&i.Member.GroupID,
		&i.Member.PersonalOrganizationID,
		&i.Member.RoleID,
		&i.Member.CreatedAt,
		&i.Member.UpdatedAt,
		&i.Organization.MOrganizationsPkey,
		&i.Organization.OrganizationID,
		&i.Organization.Name,
		&i.Organization.Description,
		&i.Organization.Color,
		&i.Organization.IsPersonal,
		&i.Organization.IsWhole,
		&i.Organization.CreatedAt,
		&i.Organization.UpdatedAt,
		&i.Organization.ChatRoomID,
	)
	return i, err
}

const findMemberByIDWithRole = `-- name: FindMemberByIDWithRole :one
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_roles.m_roles_pkey, m_roles.role_id, m_roles.name, m_roles.description, m_roles.created_at, m_roles.updated_at FROM m_members
LEFT JOIN m_roles ON m_members.role_id = m_roles.role_id
WHERE member_id = $1
`

type FindMemberByIDWithRoleRow struct {
	Member Member `json:"member"`
	Role   Role   `json:"role"`
}

func (q *Queries) FindMemberByIDWithRole(ctx context.Context, memberID uuid.UUID) (FindMemberByIDWithRoleRow, error) {
	row := q.db.QueryRow(ctx, findMemberByIDWithRole, memberID)
	var i FindMemberByIDWithRoleRow
	err := row.Scan(
		&i.Member.MMembersPkey,
		&i.Member.MemberID,
		&i.Member.LoginID,
		&i.Member.Password,
		&i.Member.Email,
		&i.Member.Name,
		&i.Member.AttendStatusID,
		&i.Member.ProfileImageID,
		&i.Member.GradeID,
		&i.Member.GroupID,
		&i.Member.PersonalOrganizationID,
		&i.Member.RoleID,
		&i.Member.CreatedAt,
		&i.Member.UpdatedAt,
		&i.Role.MRolesPkey,
		&i.Role.RoleID,
		&i.Role.Name,
		&i.Role.Description,
		&i.Role.CreatedAt,
		&i.Role.UpdatedAt,
	)
	return i, err
}

const findMemberByLoginID = `-- name: FindMemberByLoginID :one
SELECT m_members_pkey, member_id, login_id, password, email, name, attend_status_id, profile_image_id, grade_id, group_id, personal_organization_id, role_id, created_at, updated_at FROM m_members WHERE login_id = $1
`

func (q *Queries) FindMemberByLoginID(ctx context.Context, loginID string) (Member, error) {
	row := q.db.QueryRow(ctx, findMemberByLoginID, loginID)
	var i Member
	err := row.Scan(
		&i.MMembersPkey,
		&i.MemberID,
		&i.LoginID,
		&i.Password,
		&i.Email,
		&i.Name,
		&i.AttendStatusID,
		&i.ProfileImageID,
		&i.GradeID,
		&i.GroupID,
		&i.PersonalOrganizationID,
		&i.RoleID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findMemberWithAll = `-- name: FindMemberWithAll :one
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_attend_statuses.m_attend_statuses_pkey, m_attend_statuses.attend_status_id, m_attend_statuses.name, m_attend_statuses.key, m_grades.m_grades_pkey, m_grades.grade_id, m_grades.key, m_grades.organization_id, m_groups.m_groups_pkey, m_groups.group_id, m_groups.key, m_groups.organization_id, m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.color, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at, m_organizations.chat_room_id, m_roles.m_roles_pkey, m_roles.role_id, m_roles.name, m_roles.description, m_roles.created_at, m_roles.updated_at FROM m_members
LEFT JOIN m_attend_statuses ON m_members.attend_status_id = m_attend_statuses.attend_status_id
LEFT JOIN m_grades ON m_members.grade_id = m_grades.grade_id
LEFT JOIN m_groups ON m_members.group_id = m_groups.group_id
LEFT JOIN m_organizations ON m_members.personal_organization_id = m_organizations.organization_id
LEFT JOIN m_roles ON m_members.role_id = m_roles.role_id
WHERE member_id = $1
`

type FindMemberWithAllRow struct {
	Member       Member       `json:"member"`
	AttendStatus AttendStatus `json:"attend_status"`
	Grade        Grade        `json:"grade"`
	Group        Group        `json:"group"`
	Organization Organization `json:"organization"`
	Role         Role         `json:"role"`
}

func (q *Queries) FindMemberWithAll(ctx context.Context, memberID uuid.UUID) (FindMemberWithAllRow, error) {
	row := q.db.QueryRow(ctx, findMemberWithAll, memberID)
	var i FindMemberWithAllRow
	err := row.Scan(
		&i.Member.MMembersPkey,
		&i.Member.MemberID,
		&i.Member.LoginID,
		&i.Member.Password,
		&i.Member.Email,
		&i.Member.Name,
		&i.Member.AttendStatusID,
		&i.Member.ProfileImageID,
		&i.Member.GradeID,
		&i.Member.GroupID,
		&i.Member.PersonalOrganizationID,
		&i.Member.RoleID,
		&i.Member.CreatedAt,
		&i.Member.UpdatedAt,
		&i.AttendStatus.MAttendStatusesPkey,
		&i.AttendStatus.AttendStatusID,
		&i.AttendStatus.Name,
		&i.AttendStatus.Key,
		&i.Grade.MGradesPkey,
		&i.Grade.GradeID,
		&i.Grade.Key,
		&i.Grade.OrganizationID,
		&i.Group.MGroupsPkey,
		&i.Group.GroupID,
		&i.Group.Key,
		&i.Group.OrganizationID,
		&i.Organization.MOrganizationsPkey,
		&i.Organization.OrganizationID,
		&i.Organization.Name,
		&i.Organization.Description,
		&i.Organization.Color,
		&i.Organization.IsPersonal,
		&i.Organization.IsWhole,
		&i.Organization.CreatedAt,
		&i.Organization.UpdatedAt,
		&i.Organization.ChatRoomID,
		&i.Role.MRolesPkey,
		&i.Role.RoleID,
		&i.Role.Name,
		&i.Role.Description,
		&i.Role.CreatedAt,
		&i.Role.UpdatedAt,
	)
	return i, err
}

const findMemberWithDetail = `-- name: FindMemberWithDetail :one
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_students.m_students_pkey, m_students.student_id, m_students.member_id, m_professors.m_professors_pkey, m_professors.professor_id, m_professors.member_id FROM m_members
LEFT JOIN m_students ON m_members.member_id = m_students.member_id
LEFT JOIN m_professors ON m_members.member_id = m_professor.member_id
WHERE m_members.member_id = $1
`

type FindMemberWithDetailRow struct {
	Member    Member    `json:"member"`
	Student   Student   `json:"student"`
	Professor Professor `json:"professor"`
}

func (q *Queries) FindMemberWithDetail(ctx context.Context, memberID uuid.UUID) (FindMemberWithDetailRow, error) {
	row := q.db.QueryRow(ctx, findMemberWithDetail, memberID)
	var i FindMemberWithDetailRow
	err := row.Scan(
		&i.Member.MMembersPkey,
		&i.Member.MemberID,
		&i.Member.LoginID,
		&i.Member.Password,
		&i.Member.Email,
		&i.Member.Name,
		&i.Member.AttendStatusID,
		&i.Member.ProfileImageID,
		&i.Member.GradeID,
		&i.Member.GroupID,
		&i.Member.PersonalOrganizationID,
		&i.Member.RoleID,
		&i.Member.CreatedAt,
		&i.Member.UpdatedAt,
		&i.Student.MStudentsPkey,
		&i.Student.StudentID,
		&i.Student.MemberID,
		&i.Professor.MProfessorsPkey,
		&i.Professor.ProfessorID,
		&i.Professor.MemberID,
	)
	return i, err
}

const getMembers = `-- name: GetMembers :many
SELECT m_members_pkey, member_id, login_id, password, email, name, attend_status_id, profile_image_id, grade_id, group_id, personal_organization_id, role_id, created_at, updated_at FROM m_members
WHERE
	CASE WHEN $1::boolean = true THEN m_members.name LIKE '%' || $2::text || '%' ELSE TRUE END
AND
	CASE WHEN $3::boolean = true THEN (SELECT COUNT(*) FROM m_role_associations WHERE role_id = m_members.role_id AND m_role_associations.policy_id = ANY($4::uuid[])) > 0 ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN m_members.attend_status_id = ANY($6::uuid[]) ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN m_members.grade_id = ANY($8::uuid[]) ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN m_members.group_id = ANY($10::uuid[]) ELSE TRUE END
ORDER BY
	CASE WHEN $11::text = 'name' THEN m_members.name END ASC,
	CASE WHEN $11::text = 'r_name' THEN m_members.name END DESC,
	m_members_pkey ASC
`

type GetMembersParams struct {
	WhereLikeName      bool        `json:"where_like_name"`
	SearchName         string      `json:"search_name"`
	WhereHasPolicy     bool        `json:"where_has_policy"`
	HasPolicyIds       []uuid.UUID `json:"has_policy_ids"`
	WhenInAttendStatus bool        `json:"when_in_attend_status"`
	InAttendStatusIds  []uuid.UUID `json:"in_attend_status_ids"`
	WhenInGrade        bool        `json:"when_in_grade"`
	InGradeIds         []uuid.UUID `json:"in_grade_ids"`
	WhenInGroup        bool        `json:"when_in_group"`
	InGroupIds         []uuid.UUID `json:"in_group_ids"`
	OrderMethod        string      `json:"order_method"`
}

func (q *Queries) GetMembers(ctx context.Context, arg GetMembersParams) ([]Member, error) {
	rows, err := q.db.Query(ctx, getMembers,
		arg.WhereLikeName,
		arg.SearchName,
		arg.WhereHasPolicy,
		arg.HasPolicyIds,
		arg.WhenInAttendStatus,
		arg.InAttendStatusIds,
		arg.WhenInGrade,
		arg.InGradeIds,
		arg.WhenInGroup,
		arg.InGroupIds,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Member{}
	for rows.Next() {
		var i Member
		if err := rows.Scan(
			&i.MMembersPkey,
			&i.MemberID,
			&i.LoginID,
			&i.Password,
			&i.Email,
			&i.Name,
			&i.AttendStatusID,
			&i.ProfileImageID,
			&i.GradeID,
			&i.GroupID,
			&i.PersonalOrganizationID,
			&i.RoleID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMembersUseKeysetPaginate = `-- name: GetMembersUseKeysetPaginate :many
SELECT m_members_pkey, member_id, login_id, password, email, name, attend_status_id, profile_image_id, grade_id, group_id, personal_organization_id, role_id, created_at, updated_at FROM m_members
WHERE
	CASE WHEN $2::boolean = true THEN m_members.name LIKE '%' || $3::text || '%' ELSE TRUE END
AND
	CASE WHEN $4::boolean = true THEN (SELECT COUNT(*) FROM m_role_associations WHERE role_id = m_members.role_id AND m_role_associations.policy_id = ANY($5::uuid[])) > 0 ELSE TRUE END
AND
	CASE WHEN $6::boolean = true THEN m_members.attend_status_id = ANY($7::uuid[]) ELSE TRUE END
AND
	CASE WHEN $8::boolean = true THEN m_members.grade_id = ANY($9::uuid[]) ELSE TRUE END
AND
	CASE WHEN $10::boolean = true THEN m_members.group_id = ANY($11::uuid[]) ELSE TRUE END
AND
	CASE $12::text
		WHEN 'next' THEN
			CASE $13::text
				WHEN 'name' THEN m_members.name > $14 OR (m_members.name = $14 AND m_members_pkey > $15::int)
				WHEN 'r_name' THEN m_members.name < $14 OR (m_members.name = $14 AND m_members_pkey > $15::int)
				ELSE m_members_pkey > $15::int
			END
		WHEN 'prev' THEN
			CASE $13::text
				WHEN 'name' THEN m_members.name < $14 OR (m_members.name = $14 AND m_members_pkey < $15::int)
				WHEN 'r_name' THEN m_members.name > $14 OR (m_members.name = $14 AND m_members_pkey < $15::int)
				ELSE m_members_pkey < $15::int
			END
	END
ORDER BY
	CASE WHEN $13::text = 'name' AND $12::text = 'next' THEN m_members.name END ASC,
	CASE WHEN $13::text = 'name' AND $12::text = 'prev' THEN m_members.name END DESC,
	CASE WHEN $13::text = 'r_name' AND $12::text = 'next' THEN m_members.name END DESC,
	CASE WHEN $13::text = 'r_name' AND $12::text = 'prev' THEN m_members.name END ASC,
	CASE WHEN $12::text = 'next' THEN m_members_pkey END ASC,
	CASE WHEN $12::text = 'prev' THEN m_members_pkey END DESC
LIMIT $1
`

type GetMembersUseKeysetPaginateParams struct {
	Limit              int32       `json:"limit"`
	WhereLikeName      bool        `json:"where_like_name"`
	SearchName         string      `json:"search_name"`
	WhereHasPolicy     bool        `json:"where_has_policy"`
	HasPolicyIds       []uuid.UUID `json:"has_policy_ids"`
	WhenInAttendStatus bool        `json:"when_in_attend_status"`
	InAttendStatusIds  []uuid.UUID `json:"in_attend_status_ids"`
	WhenInGrade        bool        `json:"when_in_grade"`
	InGradeIds         []uuid.UUID `json:"in_grade_ids"`
	WhenInGroup        bool        `json:"when_in_group"`
	InGroupIds         []uuid.UUID `json:"in_group_ids"`
	CursorDirection    string      `json:"cursor_direction"`
	OrderMethod        string      `json:"order_method"`
	NameCursor         string      `json:"name_cursor"`
	Cursor             int32       `json:"cursor"`
}

func (q *Queries) GetMembersUseKeysetPaginate(ctx context.Context, arg GetMembersUseKeysetPaginateParams) ([]Member, error) {
	rows, err := q.db.Query(ctx, getMembersUseKeysetPaginate,
		arg.Limit,
		arg.WhereLikeName,
		arg.SearchName,
		arg.WhereHasPolicy,
		arg.HasPolicyIds,
		arg.WhenInAttendStatus,
		arg.InAttendStatusIds,
		arg.WhenInGrade,
		arg.InGradeIds,
		arg.WhenInGroup,
		arg.InGroupIds,
		arg.CursorDirection,
		arg.OrderMethod,
		arg.NameCursor,
		arg.Cursor,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Member{}
	for rows.Next() {
		var i Member
		if err := rows.Scan(
			&i.MMembersPkey,
			&i.MemberID,
			&i.LoginID,
			&i.Password,
			&i.Email,
			&i.Name,
			&i.AttendStatusID,
			&i.ProfileImageID,
			&i.GradeID,
			&i.GroupID,
			&i.PersonalOrganizationID,
			&i.RoleID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMembersUseNumberedPaginate = `-- name: GetMembersUseNumberedPaginate :many
SELECT m_members_pkey, member_id, login_id, password, email, name, attend_status_id, profile_image_id, grade_id, group_id, personal_organization_id, role_id, created_at, updated_at FROM m_members
WHERE
	CASE WHEN $3::boolean = true THEN m_members.name LIKE '%' || $4::text || '%' ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN (SELECT COUNT(*) FROM m_role_associations WHERE role_id = m_members.role_id AND m_role_associations.policy_id = ANY($6::uuid[])) > 0 ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN m_members.attend_status_id = ANY($8::uuid[]) ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN m_members.grade_id = ANY($10::uuid[]) ELSE TRUE END
AND
	CASE WHEN $11::boolean = true THEN m_members.group_id = ANY($12::uuid[]) ELSE TRUE END
ORDER BY
	CASE WHEN $13::text = 'name' THEN m_members.name END ASC,
	CASE WHEN $13::text = 'r_name' THEN m_members.name END DESC,
	m_members_pkey ASC
LIMIT $1 OFFSET $2
`

type GetMembersUseNumberedPaginateParams struct {
	Limit              int32       `json:"limit"`
	Offset             int32       `json:"offset"`
	WhereLikeName      bool        `json:"where_like_name"`
	SearchName         string      `json:"search_name"`
	WhereHasPolicy     bool        `json:"where_has_policy"`
	HasPolicyIds       []uuid.UUID `json:"has_policy_ids"`
	WhenInAttendStatus bool        `json:"when_in_attend_status"`
	InAttendStatusIds  []uuid.UUID `json:"in_attend_status_ids"`
	WhenInGrade        bool        `json:"when_in_grade"`
	InGradeIds         []uuid.UUID `json:"in_grade_ids"`
	WhenInGroup        bool        `json:"when_in_group"`
	InGroupIds         []uuid.UUID `json:"in_group_ids"`
	OrderMethod        string      `json:"order_method"`
}

func (q *Queries) GetMembersUseNumberedPaginate(ctx context.Context, arg GetMembersUseNumberedPaginateParams) ([]Member, error) {
	rows, err := q.db.Query(ctx, getMembersUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.WhereLikeName,
		arg.SearchName,
		arg.WhereHasPolicy,
		arg.HasPolicyIds,
		arg.WhenInAttendStatus,
		arg.InAttendStatusIds,
		arg.WhenInGrade,
		arg.InGradeIds,
		arg.WhenInGroup,
		arg.InGroupIds,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Member{}
	for rows.Next() {
		var i Member
		if err := rows.Scan(
			&i.MMembersPkey,
			&i.MemberID,
			&i.LoginID,
			&i.Password,
			&i.Email,
			&i.Name,
			&i.AttendStatusID,
			&i.ProfileImageID,
			&i.GradeID,
			&i.GroupID,
			&i.PersonalOrganizationID,
			&i.RoleID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMembersWithAll = `-- name: GetMembersWithAll :many
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_attend_statuses.m_attend_statuses_pkey, m_attend_statuses.attend_status_id, m_attend_statuses.name, m_attend_statuses.key, m_grades.m_grades_pkey, m_grades.grade_id, m_grades.key, m_grades.organization_id, m_groups.m_groups_pkey, m_groups.group_id, m_groups.key, m_groups.organization_id, m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.color, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at, m_organizations.chat_room_id, m_roles.m_roles_pkey, m_roles.role_id, m_roles.name, m_roles.description, m_roles.created_at, m_roles.updated_at FROM m_members
LEFT JOIN m_attend_statuses ON m_members.attend_status_id = m_attend_statuses.attend_status_id
LEFT JOIN m_grades ON m_members.grade_id = m_grades.grade_id
LEFT JOIN m_groups ON m_members.group_id = m_groups.group_id
LEFT JOIN m_organizations ON m_members.personal_organization_id = m_organizations.organization_id
LEFT JOIN m_roles ON m_members.role_id = m_roles.role_id
WHERE
	CASE WHEN $1::boolean = true THEN m_members.name LIKE '%' || $2::text || '%' ELSE TRUE END
AND
	CASE WHEN $3::boolean = true THEN (SELECT COUNT(*) FROM m_role_associations WHERE role_id = m_members.role_id AND m_role_associations.policy_id = ANY($4::uuid[])) > 0 ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN m_members.attend_status_id = ANY($6::uuid[]) ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN m_members.grade_id = ANY($8::uuid[]) ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN m_members.group_id = ANY($10::uuid[]) ELSE TRUE END
ORDER BY
	CASE WHEN $11::text = 'name' THEN m_members.name END ASC,
	CASE WHEN $11::text = 'r_name' THEN m_members.name END DESC,
	m_members_pkey ASC
`

type GetMembersWithAllParams struct {
	WhereLikeName      bool        `json:"where_like_name"`
	SearchName         string      `json:"search_name"`
	WhereHasPolicy     bool        `json:"where_has_policy"`
	HasPolicyIds       []uuid.UUID `json:"has_policy_ids"`
	WhenInAttendStatus bool        `json:"when_in_attend_status"`
	InAttendStatusIds  []uuid.UUID `json:"in_attend_status_ids"`
	WhenInGrade        bool        `json:"when_in_grade"`
	InGradeIds         []uuid.UUID `json:"in_grade_ids"`
	WhenInGroup        bool        `json:"when_in_group"`
	InGroupIds         []uuid.UUID `json:"in_group_ids"`
	OrderMethod        string      `json:"order_method"`
}

type GetMembersWithAllRow struct {
	Member       Member       `json:"member"`
	AttendStatus AttendStatus `json:"attend_status"`
	Grade        Grade        `json:"grade"`
	Group        Group        `json:"group"`
	Organization Organization `json:"organization"`
	Role         Role         `json:"role"`
}

func (q *Queries) GetMembersWithAll(ctx context.Context, arg GetMembersWithAllParams) ([]GetMembersWithAllRow, error) {
	rows, err := q.db.Query(ctx, getMembersWithAll,
		arg.WhereLikeName,
		arg.SearchName,
		arg.WhereHasPolicy,
		arg.HasPolicyIds,
		arg.WhenInAttendStatus,
		arg.InAttendStatusIds,
		arg.WhenInGrade,
		arg.InGradeIds,
		arg.WhenInGroup,
		arg.InGroupIds,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMembersWithAllRow{}
	for rows.Next() {
		var i GetMembersWithAllRow
		if err := rows.Scan(
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageID,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
			&i.AttendStatus.MAttendStatusesPkey,
			&i.AttendStatus.AttendStatusID,
			&i.AttendStatus.Name,
			&i.AttendStatus.Key,
			&i.Grade.MGradesPkey,
			&i.Grade.GradeID,
			&i.Grade.Key,
			&i.Grade.OrganizationID,
			&i.Group.MGroupsPkey,
			&i.Group.GroupID,
			&i.Group.Key,
			&i.Group.OrganizationID,
			&i.Organization.MOrganizationsPkey,
			&i.Organization.OrganizationID,
			&i.Organization.Name,
			&i.Organization.Description,
			&i.Organization.Color,
			&i.Organization.IsPersonal,
			&i.Organization.IsWhole,
			&i.Organization.CreatedAt,
			&i.Organization.UpdatedAt,
			&i.Organization.ChatRoomID,
			&i.Role.MRolesPkey,
			&i.Role.RoleID,
			&i.Role.Name,
			&i.Role.Description,
			&i.Role.CreatedAt,
			&i.Role.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMembersWithAllUseKeysetPaginate = `-- name: GetMembersWithAllUseKeysetPaginate :many
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_attend_statuses.m_attend_statuses_pkey, m_attend_statuses.attend_status_id, m_attend_statuses.name, m_attend_statuses.key, m_grades.m_grades_pkey, m_grades.grade_id, m_grades.key, m_grades.organization_id, m_groups.m_groups_pkey, m_groups.group_id, m_groups.key, m_groups.organization_id, m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.color, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at, m_organizations.chat_room_id, m_roles.m_roles_pkey, m_roles.role_id, m_roles.name, m_roles.description, m_roles.created_at, m_roles.updated_at FROM m_members
LEFT JOIN m_attend_statuses ON m_members.attend_status_id = m_attend_statuses.attend_status_id
LEFT JOIN m_grades ON m_members.grade_id = m_grades.grade_id
LEFT JOIN m_groups ON m_members.group_id = m_groups.group_id
LEFT JOIN m_organizations ON m_members.personal_organization_id = m_organizations.organization_id
LEFT JOIN m_roles ON m_members.role_id = m_roles.role_id
WHERE
	CASE WHEN $2::boolean = true THEN m_members.name LIKE '%' || $3::text || '%' ELSE TRUE END
AND
	CASE WHEN $4::boolean = true THEN (SELECT COUNT(*) FROM m_role_associations WHERE role_id = m_members.role_id AND m_role_associations.policy_id = ANY($5::uuid[])) > 0 ELSE TRUE END
AND
	CASE WHEN $6::boolean = true THEN m_members.attend_status_id = ANY($7::uuid[]) ELSE TRUE END
AND
	CASE WHEN $8::boolean = true THEN m_members.grade_id = ANY($9::uuid[]) ELSE TRUE END
AND
	CASE WHEN $10::boolean = true THEN m_members.group_id = ANY($11::uuid[]) ELSE TRUE END
AND
	CASE $12::text
		WHEN 'next' THEN
			CASE $13::text
				WHEN 'name' THEN m_members.name > $14 OR (m_members.name = $14 AND m_members_pkey > $15::int)
				WHEN 'r_name' THEN m_members.name < $14 OR (m_members.name = $14 AND m_members_pkey > $15::int)
				ELSE m_members_pkey > $15::int
			END
		WHEN 'prev' THEN
			CASE $13::text
				WHEN 'name' THEN m_members.name < $14 OR (m_members.name = $14 AND m_members_pkey < $15::int)
				WHEN 'r_name' THEN m_members.name > $14 OR (m_members.name = $14 AND m_members_pkey < $15::int)
				ELSE m_members_pkey < $15::int
			END
	END
ORDER BY
	CASE WHEN $13::text = 'name' AND $12::text = 'next' THEN m_members.name END ASC,
	CASE WHEN $13::text = 'name' AND $12::text = 'prev' THEN m_members.name END DESC,
	CASE WHEN $13::text = 'r_name' AND $12::text = 'next' THEN m_members.name END DESC,
	CASE WHEN $13::text = 'r_name' AND $12::text = 'prev' THEN m_members.name END ASC,
	CASE WHEN $12::text = 'next' THEN m_members_pkey END ASC,
	CASE WHEN $12::text = 'prev' THEN m_members_pkey END DESC
LIMIT $1
`

type GetMembersWithAllUseKeysetPaginateParams struct {
	Limit              int32       `json:"limit"`
	WhereLikeName      bool        `json:"where_like_name"`
	SearchName         string      `json:"search_name"`
	WhereHasPolicy     bool        `json:"where_has_policy"`
	HasPolicyIds       []uuid.UUID `json:"has_policy_ids"`
	WhenInAttendStatus bool        `json:"when_in_attend_status"`
	InAttendStatusIds  []uuid.UUID `json:"in_attend_status_ids"`
	WhenInGrade        bool        `json:"when_in_grade"`
	InGradeIds         []uuid.UUID `json:"in_grade_ids"`
	WhenInGroup        bool        `json:"when_in_group"`
	InGroupIds         []uuid.UUID `json:"in_group_ids"`
	CursorDirection    string      `json:"cursor_direction"`
	OrderMethod        string      `json:"order_method"`
	NameCursor         string      `json:"name_cursor"`
	Cursor             int32       `json:"cursor"`
}

type GetMembersWithAllUseKeysetPaginateRow struct {
	Member       Member       `json:"member"`
	AttendStatus AttendStatus `json:"attend_status"`
	Grade        Grade        `json:"grade"`
	Group        Group        `json:"group"`
	Organization Organization `json:"organization"`
	Role         Role         `json:"role"`
}

func (q *Queries) GetMembersWithAllUseKeysetPaginate(ctx context.Context, arg GetMembersWithAllUseKeysetPaginateParams) ([]GetMembersWithAllUseKeysetPaginateRow, error) {
	rows, err := q.db.Query(ctx, getMembersWithAllUseKeysetPaginate,
		arg.Limit,
		arg.WhereLikeName,
		arg.SearchName,
		arg.WhereHasPolicy,
		arg.HasPolicyIds,
		arg.WhenInAttendStatus,
		arg.InAttendStatusIds,
		arg.WhenInGrade,
		arg.InGradeIds,
		arg.WhenInGroup,
		arg.InGroupIds,
		arg.CursorDirection,
		arg.OrderMethod,
		arg.NameCursor,
		arg.Cursor,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMembersWithAllUseKeysetPaginateRow{}
	for rows.Next() {
		var i GetMembersWithAllUseKeysetPaginateRow
		if err := rows.Scan(
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageID,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
			&i.AttendStatus.MAttendStatusesPkey,
			&i.AttendStatus.AttendStatusID,
			&i.AttendStatus.Name,
			&i.AttendStatus.Key,
			&i.Grade.MGradesPkey,
			&i.Grade.GradeID,
			&i.Grade.Key,
			&i.Grade.OrganizationID,
			&i.Group.MGroupsPkey,
			&i.Group.GroupID,
			&i.Group.Key,
			&i.Group.OrganizationID,
			&i.Organization.MOrganizationsPkey,
			&i.Organization.OrganizationID,
			&i.Organization.Name,
			&i.Organization.Description,
			&i.Organization.Color,
			&i.Organization.IsPersonal,
			&i.Organization.IsWhole,
			&i.Organization.CreatedAt,
			&i.Organization.UpdatedAt,
			&i.Organization.ChatRoomID,
			&i.Role.MRolesPkey,
			&i.Role.RoleID,
			&i.Role.Name,
			&i.Role.Description,
			&i.Role.CreatedAt,
			&i.Role.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMembersWithAllUseNumberedPaginate = `-- name: GetMembersWithAllUseNumberedPaginate :many
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_attend_statuses.m_attend_statuses_pkey, m_attend_statuses.attend_status_id, m_attend_statuses.name, m_attend_statuses.key, m_grades.m_grades_pkey, m_grades.grade_id, m_grades.key, m_grades.organization_id, m_groups.m_groups_pkey, m_groups.group_id, m_groups.key, m_groups.organization_id, m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.color, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at, m_organizations.chat_room_id, m_roles.m_roles_pkey, m_roles.role_id, m_roles.name, m_roles.description, m_roles.created_at, m_roles.updated_at FROM m_members
LEFT JOIN m_attend_statuses ON m_members.attend_status_id = m_attend_statuses.attend_status_id
LEFT JOIN m_grades ON m_members.grade_id = m_grades.grade_id
LEFT JOIN m_groups ON m_members.group_id = m_groups.group_id
LEFT JOIN m_organizations ON m_members.personal_organization_id = m_organizations.organization_id
LEFT JOIN m_roles ON m_members.role_id = m_roles.role_id
WHERE
	CASE WHEN $3::boolean = true THEN m_members.name LIKE '%' || $4::text || '%' ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN (SELECT COUNT(*) FROM m_role_associations WHERE role_id = m_members.role_id AND m_role_associations.policy_id = ANY($6::uuid[])) > 0 ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN m_members.attend_status_id = ANY($8::uuid[]) ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN m_members.grade_id = ANY($10::uuid[]) ELSE TRUE END
AND
	CASE WHEN $11::boolean = true THEN m_members.group_id = ANY($12::uuid[]) ELSE TRUE END
ORDER BY
	CASE WHEN $13::text = 'name' THEN m_members.name END ASC,
	CASE WHEN $13::text = 'r_name' THEN m_members.name END DESC,
	m_members_pkey ASC
LIMIT $1 OFFSET $2
`

type GetMembersWithAllUseNumberedPaginateParams struct {
	Limit              int32       `json:"limit"`
	Offset             int32       `json:"offset"`
	WhereLikeName      bool        `json:"where_like_name"`
	SearchName         string      `json:"search_name"`
	WhereHasPolicy     bool        `json:"where_has_policy"`
	HasPolicyIds       []uuid.UUID `json:"has_policy_ids"`
	WhenInAttendStatus bool        `json:"when_in_attend_status"`
	InAttendStatusIds  []uuid.UUID `json:"in_attend_status_ids"`
	WhenInGrade        bool        `json:"when_in_grade"`
	InGradeIds         []uuid.UUID `json:"in_grade_ids"`
	WhenInGroup        bool        `json:"when_in_group"`
	InGroupIds         []uuid.UUID `json:"in_group_ids"`
	OrderMethod        string      `json:"order_method"`
}

type GetMembersWithAllUseNumberedPaginateRow struct {
	Member       Member       `json:"member"`
	AttendStatus AttendStatus `json:"attend_status"`
	Grade        Grade        `json:"grade"`
	Group        Group        `json:"group"`
	Organization Organization `json:"organization"`
	Role         Role         `json:"role"`
}

func (q *Queries) GetMembersWithAllUseNumberedPaginate(ctx context.Context, arg GetMembersWithAllUseNumberedPaginateParams) ([]GetMembersWithAllUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getMembersWithAllUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.WhereLikeName,
		arg.SearchName,
		arg.WhereHasPolicy,
		arg.HasPolicyIds,
		arg.WhenInAttendStatus,
		arg.InAttendStatusIds,
		arg.WhenInGrade,
		arg.InGradeIds,
		arg.WhenInGroup,
		arg.InGroupIds,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMembersWithAllUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetMembersWithAllUseNumberedPaginateRow
		if err := rows.Scan(
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageID,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
			&i.AttendStatus.MAttendStatusesPkey,
			&i.AttendStatus.AttendStatusID,
			&i.AttendStatus.Name,
			&i.AttendStatus.Key,
			&i.Grade.MGradesPkey,
			&i.Grade.GradeID,
			&i.Grade.Key,
			&i.Grade.OrganizationID,
			&i.Group.MGroupsPkey,
			&i.Group.GroupID,
			&i.Group.Key,
			&i.Group.OrganizationID,
			&i.Organization.MOrganizationsPkey,
			&i.Organization.OrganizationID,
			&i.Organization.Name,
			&i.Organization.Description,
			&i.Organization.Color,
			&i.Organization.IsPersonal,
			&i.Organization.IsWhole,
			&i.Organization.CreatedAt,
			&i.Organization.UpdatedAt,
			&i.Organization.ChatRoomID,
			&i.Role.MRolesPkey,
			&i.Role.RoleID,
			&i.Role.Name,
			&i.Role.Description,
			&i.Role.CreatedAt,
			&i.Role.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMembersWithAttendStatus = `-- name: GetMembersWithAttendStatus :many
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_attend_statuses.m_attend_statuses_pkey, m_attend_statuses.attend_status_id, m_attend_statuses.name, m_attend_statuses.key FROM m_members
LEFT JOIN m_attend_statuses ON m_members.attend_status_id = m_attend_statuses.attend_status_id
WHERE
	CASE WHEN $1::boolean = true THEN m_members.name LIKE '%' || $2::text || '%' ELSE TRUE END
AND
	CASE WHEN $3::boolean = true THEN (SELECT COUNT(*) FROM m_role_associations WHERE role_id = m_members.role_id AND m_role_associations.policy_id = ANY($4::uuid[])) > 0 ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN m_members.attend_status_id = ANY($6::uuid[]) ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN m_members.grade_id = ANY($8::uuid[]) ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN m_members.group_id = ANY($10::uuid[]) ELSE TRUE END
ORDER BY
	CASE WHEN $11::text = 'name' THEN m_members.name END ASC,
	CASE WHEN $11::text = 'r_name' THEN m_members.name END DESC,
	m_members_pkey ASC
`

type GetMembersWithAttendStatusParams struct {
	WhereLikeName      bool        `json:"where_like_name"`
	SearchName         string      `json:"search_name"`
	WhereHasPolicy     bool        `json:"where_has_policy"`
	HasPolicyIds       []uuid.UUID `json:"has_policy_ids"`
	WhenInAttendStatus bool        `json:"when_in_attend_status"`
	InAttendStatusIds  []uuid.UUID `json:"in_attend_status_ids"`
	WhenInGrade        bool        `json:"when_in_grade"`
	InGradeIds         []uuid.UUID `json:"in_grade_ids"`
	WhenInGroup        bool        `json:"when_in_group"`
	InGroupIds         []uuid.UUID `json:"in_group_ids"`
	OrderMethod        string      `json:"order_method"`
}

type GetMembersWithAttendStatusRow struct {
	Member       Member       `json:"member"`
	AttendStatus AttendStatus `json:"attend_status"`
}

func (q *Queries) GetMembersWithAttendStatus(ctx context.Context, arg GetMembersWithAttendStatusParams) ([]GetMembersWithAttendStatusRow, error) {
	rows, err := q.db.Query(ctx, getMembersWithAttendStatus,
		arg.WhereLikeName,
		arg.SearchName,
		arg.WhereHasPolicy,
		arg.HasPolicyIds,
		arg.WhenInAttendStatus,
		arg.InAttendStatusIds,
		arg.WhenInGrade,
		arg.InGradeIds,
		arg.WhenInGroup,
		arg.InGroupIds,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMembersWithAttendStatusRow{}
	for rows.Next() {
		var i GetMembersWithAttendStatusRow
		if err := rows.Scan(
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageID,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
			&i.AttendStatus.MAttendStatusesPkey,
			&i.AttendStatus.AttendStatusID,
			&i.AttendStatus.Name,
			&i.AttendStatus.Key,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMembersWithAttendStatusUseKeysetPaginate = `-- name: GetMembersWithAttendStatusUseKeysetPaginate :many
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_attend_statuses.m_attend_statuses_pkey, m_attend_statuses.attend_status_id, m_attend_statuses.name, m_attend_statuses.key FROM m_members
LEFT JOIN m_attend_statuses ON m_members.attend_status_id = m_attend_statuses.attend_status_id
WHERE
	CASE WHEN $2::boolean = true THEN m_members.name LIKE '%' || $3::text || '%' ELSE TRUE END
AND
	CASE WHEN $4::boolean = true THEN (SELECT COUNT(*) FROM m_role_associations WHERE role_id = m_members.role_id AND m_role_associations.policy_id = ANY($5::uuid[])) > 0 ELSE TRUE END
AND
	CASE WHEN $6::boolean = true THEN m_members.attend_status_id = ANY($7::uuid[]) ELSE TRUE END
AND
	CASE WHEN $8::boolean = true THEN m_members.grade_id = ANY($9::uuid[]) ELSE TRUE END
AND
	CASE WHEN $10::boolean = true THEN m_members.group_id = ANY($11::uuid[]) ELSE TRUE END
AND
	CASE $12::text
		WHEN 'next' THEN
			CASE $13::text
				WHEN 'name' THEN m_members.name > $14 OR (m_members.name = $14 AND m_members_pkey > $15::int)
				WHEN 'r_name' THEN m_members.name < $14 OR (m_members.name = $14 AND m_members_pkey > $15::int)
				ELSE m_members_pkey > $15::int
			END
		WHEN 'prev' THEN
			CASE $13::text
				WHEN 'name' THEN m_members.name < $14 OR (m_members.name = $14 AND m_members_pkey < $15::int)
				WHEN 'r_name' THEN m_members.name > $14 OR (m_members.name = $14 AND m_members_pkey < $15::int)
				ELSE m_members_pkey < $15::int
			END
	END
ORDER BY
	CASE WHEN $13::text = 'name' AND $12::text = 'next' THEN m_members.name END ASC,
	CASE WHEN $13::text = 'name' AND $12::text = 'prev' THEN m_members.name END DESC,
	CASE WHEN $13::text = 'r_name' AND $12::text = 'next' THEN m_members.name END DESC,
	CASE WHEN $13::text = 'r_name' AND $12::text = 'prev' THEN m_members.name END ASC,
	CASE WHEN $12::text = 'next' THEN m_members_pkey END ASC,
	CASE WHEN $12::text = 'prev' THEN m_members_pkey END DESC
LIMIT $1
`

type GetMembersWithAttendStatusUseKeysetPaginateParams struct {
	Limit              int32       `json:"limit"`
	WhereLikeName      bool        `json:"where_like_name"`
	SearchName         string      `json:"search_name"`
	WhereHasPolicy     bool        `json:"where_has_policy"`
	HasPolicyIds       []uuid.UUID `json:"has_policy_ids"`
	WhenInAttendStatus bool        `json:"when_in_attend_status"`
	InAttendStatusIds  []uuid.UUID `json:"in_attend_status_ids"`
	WhenInGrade        bool        `json:"when_in_grade"`
	InGradeIds         []uuid.UUID `json:"in_grade_ids"`
	WhenInGroup        bool        `json:"when_in_group"`
	InGroupIds         []uuid.UUID `json:"in_group_ids"`
	CursorDirection    string      `json:"cursor_direction"`
	OrderMethod        string      `json:"order_method"`
	NameCursor         string      `json:"name_cursor"`
	Cursor             int32       `json:"cursor"`
}

type GetMembersWithAttendStatusUseKeysetPaginateRow struct {
	Member       Member       `json:"member"`
	AttendStatus AttendStatus `json:"attend_status"`
}

func (q *Queries) GetMembersWithAttendStatusUseKeysetPaginate(ctx context.Context, arg GetMembersWithAttendStatusUseKeysetPaginateParams) ([]GetMembersWithAttendStatusUseKeysetPaginateRow, error) {
	rows, err := q.db.Query(ctx, getMembersWithAttendStatusUseKeysetPaginate,
		arg.Limit,
		arg.WhereLikeName,
		arg.SearchName,
		arg.WhereHasPolicy,
		arg.HasPolicyIds,
		arg.WhenInAttendStatus,
		arg.InAttendStatusIds,
		arg.WhenInGrade,
		arg.InGradeIds,
		arg.WhenInGroup,
		arg.InGroupIds,
		arg.CursorDirection,
		arg.OrderMethod,
		arg.NameCursor,
		arg.Cursor,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMembersWithAttendStatusUseKeysetPaginateRow{}
	for rows.Next() {
		var i GetMembersWithAttendStatusUseKeysetPaginateRow
		if err := rows.Scan(
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageID,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
			&i.AttendStatus.MAttendStatusesPkey,
			&i.AttendStatus.AttendStatusID,
			&i.AttendStatus.Name,
			&i.AttendStatus.Key,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMembersWithAttendStatusUseNumberedPaginate = `-- name: GetMembersWithAttendStatusUseNumberedPaginate :many
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_attend_statuses.m_attend_statuses_pkey, m_attend_statuses.attend_status_id, m_attend_statuses.name, m_attend_statuses.key FROM m_members
LEFT JOIN m_attend_statuses ON m_members.attend_status_id = m_attend_statuses.attend_status_id
WHERE
	CASE WHEN $3::boolean = true THEN m_members.name LIKE '%' || $4::text || '%' ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN (SELECT COUNT(*) FROM m_role_associations WHERE role_id = m_members.role_id AND m_role_associations.policy_id = ANY($6::uuid[])) > 0 ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN m_members.attend_status_id = ANY($8::uuid[]) ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN m_members.grade_id = ANY($10::uuid[]) ELSE TRUE END
AND
	CASE WHEN $11::boolean = true THEN m_members.group_id = ANY($12::uuid[]) ELSE TRUE END
ORDER BY
	CASE WHEN $13::text = 'name' THEN m_members.name END ASC,
	CASE WHEN $13::text = 'r_name' THEN m_members.name END DESC,
	m_members_pkey ASC
LIMIT $1 OFFSET $2
`

type GetMembersWithAttendStatusUseNumberedPaginateParams struct {
	Limit              int32       `json:"limit"`
	Offset             int32       `json:"offset"`
	WhereLikeName      bool        `json:"where_like_name"`
	SearchName         string      `json:"search_name"`
	WhereHasPolicy     bool        `json:"where_has_policy"`
	HasPolicyIds       []uuid.UUID `json:"has_policy_ids"`
	WhenInAttendStatus bool        `json:"when_in_attend_status"`
	InAttendStatusIds  []uuid.UUID `json:"in_attend_status_ids"`
	WhenInGrade        bool        `json:"when_in_grade"`
	InGradeIds         []uuid.UUID `json:"in_grade_ids"`
	WhenInGroup        bool        `json:"when_in_group"`
	InGroupIds         []uuid.UUID `json:"in_group_ids"`
	OrderMethod        string      `json:"order_method"`
}

type GetMembersWithAttendStatusUseNumberedPaginateRow struct {
	Member       Member       `json:"member"`
	AttendStatus AttendStatus `json:"attend_status"`
}

func (q *Queries) GetMembersWithAttendStatusUseNumberedPaginate(ctx context.Context, arg GetMembersWithAttendStatusUseNumberedPaginateParams) ([]GetMembersWithAttendStatusUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getMembersWithAttendStatusUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.WhereLikeName,
		arg.SearchName,
		arg.WhereHasPolicy,
		arg.HasPolicyIds,
		arg.WhenInAttendStatus,
		arg.InAttendStatusIds,
		arg.WhenInGrade,
		arg.InGradeIds,
		arg.WhenInGroup,
		arg.InGroupIds,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMembersWithAttendStatusUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetMembersWithAttendStatusUseNumberedPaginateRow
		if err := rows.Scan(
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageID,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
			&i.AttendStatus.MAttendStatusesPkey,
			&i.AttendStatus.AttendStatusID,
			&i.AttendStatus.Name,
			&i.AttendStatus.Key,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMembersWithGrade = `-- name: GetMembersWithGrade :many
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_grades.m_grades_pkey, m_grades.grade_id, m_grades.key, m_grades.organization_id FROM m_members
LEFT JOIN m_grades ON m_members.grade_id = m_grades.grade_id
LEFT JOIN m_organizations ON m_grades.organization_id = m_organizations.organization_id
WHERE
	CASE WHEN $1::boolean = true THEN m_members.name LIKE '%' || $2::text || '%' ELSE TRUE END
AND
	CASE WHEN $3::boolean = true THEN (SELECT COUNT(*) FROM m_role_associations WHERE role_id = m_members.role_id AND m_role_associations.policy_id = ANY($4::uuid[])) > 0 ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN m_members.attend_status_id = ANY($6::uuid[]) ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN m_members.grade_id = ANY($8::uuid[]) ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN m_members.group_id = ANY($10::uuid[]) ELSE TRUE END
ORDER BY
	CASE WHEN $11::text = 'name' THEN m_members.name END ASC,
	CASE WHEN $11::text = 'r_name' THEN m_members.name END DESC,
	m_members_pkey ASC
`

type GetMembersWithGradeParams struct {
	WhereLikeName      bool        `json:"where_like_name"`
	SearchName         string      `json:"search_name"`
	WhereHasPolicy     bool        `json:"where_has_policy"`
	HasPolicyIds       []uuid.UUID `json:"has_policy_ids"`
	WhenInAttendStatus bool        `json:"when_in_attend_status"`
	InAttendStatusIds  []uuid.UUID `json:"in_attend_status_ids"`
	WhenInGrade        bool        `json:"when_in_grade"`
	InGradeIds         []uuid.UUID `json:"in_grade_ids"`
	WhenInGroup        bool        `json:"when_in_group"`
	InGroupIds         []uuid.UUID `json:"in_group_ids"`
	OrderMethod        string      `json:"order_method"`
}

type GetMembersWithGradeRow struct {
	Member Member `json:"member"`
	Grade  Grade  `json:"grade"`
}

func (q *Queries) GetMembersWithGrade(ctx context.Context, arg GetMembersWithGradeParams) ([]GetMembersWithGradeRow, error) {
	rows, err := q.db.Query(ctx, getMembersWithGrade,
		arg.WhereLikeName,
		arg.SearchName,
		arg.WhereHasPolicy,
		arg.HasPolicyIds,
		arg.WhenInAttendStatus,
		arg.InAttendStatusIds,
		arg.WhenInGrade,
		arg.InGradeIds,
		arg.WhenInGroup,
		arg.InGroupIds,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMembersWithGradeRow{}
	for rows.Next() {
		var i GetMembersWithGradeRow
		if err := rows.Scan(
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageID,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
			&i.Grade.MGradesPkey,
			&i.Grade.GradeID,
			&i.Grade.Key,
			&i.Grade.OrganizationID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMembersWithGradeUseKeysetPaginate = `-- name: GetMembersWithGradeUseKeysetPaginate :many
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_grades.m_grades_pkey, m_grades.grade_id, m_grades.key, m_grades.organization_id FROM m_members
LEFT JOIN m_grades ON m_members.grade_id = m_grades.grade_id
LEFT JOIN m_organizations ON m_grades.organization_id = m_organizations.organization_id
WHERE
	CASE WHEN $2::boolean = true THEN m_members.name LIKE '%' || $3::text || '%' ELSE TRUE END
AND
	CASE WHEN $4::boolean = true THEN (SELECT COUNT(*) FROM m_role_associations WHERE role_id = m_members.role_id AND m_role_associations.policy_id = ANY($5::uuid[])) > 0 ELSE TRUE END
AND
	CASE WHEN $6::boolean = true THEN m_members.attend_status_id = ANY($7::uuid[]) ELSE TRUE END
AND
	CASE WHEN $8::boolean = true THEN m_members.grade_id = ANY($9::uuid[]) ELSE TRUE END
AND
	CASE WHEN $10::boolean = true THEN m_members.group_id = ANY($11::uuid[]) ELSE TRUE END
AND
	CASE $12::text
		WHEN 'next' THEN
			CASE $13::text
				WHEN 'name' THEN m_members.name > $14 OR (m_members.name = $14 AND m_members_pkey > $15::int)
				WHEN 'r_name' THEN m_members.name < $14 OR (m_members.name = $14 AND m_members_pkey > $15::int)
				ELSE m_members_pkey > $15::int
			END
		WHEN 'prev' THEN
			CASE $13::text
				WHEN 'name' THEN m_members.name < $14 OR (m_members.name = $14 AND m_members_pkey < $15::int)
				WHEN 'r_name' THEN m_members.name > $14 OR (m_members.name = $14 AND m_members_pkey < $15::int)
				ELSE m_members_pkey < $15::int
			END
	END
ORDER BY
	CASE WHEN $13::text = 'name' AND $12::text = 'next' THEN m_members.name END ASC,
	CASE WHEN $13::text = 'name' AND $12::text = 'prev' THEN m_members.name END DESC,
	CASE WHEN $13::text = 'r_name' AND $12::text = 'next' THEN m_members.name END DESC,
	CASE WHEN $13::text = 'r_name' AND $12::text = 'prev' THEN m_members.name END ASC,
	CASE WHEN $12::text = 'next' THEN m_members_pkey END ASC,
	CASE WHEN $12::text = 'prev' THEN m_members_pkey END DESC
LIMIT $1
`

type GetMembersWithGradeUseKeysetPaginateParams struct {
	Limit              int32       `json:"limit"`
	WhereLikeName      bool        `json:"where_like_name"`
	SearchName         string      `json:"search_name"`
	WhereHasPolicy     bool        `json:"where_has_policy"`
	HasPolicyIds       []uuid.UUID `json:"has_policy_ids"`
	WhenInAttendStatus bool        `json:"when_in_attend_status"`
	InAttendStatusIds  []uuid.UUID `json:"in_attend_status_ids"`
	WhenInGrade        bool        `json:"when_in_grade"`
	InGradeIds         []uuid.UUID `json:"in_grade_ids"`
	WhenInGroup        bool        `json:"when_in_group"`
	InGroupIds         []uuid.UUID `json:"in_group_ids"`
	CursorDirection    string      `json:"cursor_direction"`
	OrderMethod        string      `json:"order_method"`
	NameCursor         string      `json:"name_cursor"`
	Cursor             int32       `json:"cursor"`
}

type GetMembersWithGradeUseKeysetPaginateRow struct {
	Member Member `json:"member"`
	Grade  Grade  `json:"grade"`
}

func (q *Queries) GetMembersWithGradeUseKeysetPaginate(ctx context.Context, arg GetMembersWithGradeUseKeysetPaginateParams) ([]GetMembersWithGradeUseKeysetPaginateRow, error) {
	rows, err := q.db.Query(ctx, getMembersWithGradeUseKeysetPaginate,
		arg.Limit,
		arg.WhereLikeName,
		arg.SearchName,
		arg.WhereHasPolicy,
		arg.HasPolicyIds,
		arg.WhenInAttendStatus,
		arg.InAttendStatusIds,
		arg.WhenInGrade,
		arg.InGradeIds,
		arg.WhenInGroup,
		arg.InGroupIds,
		arg.CursorDirection,
		arg.OrderMethod,
		arg.NameCursor,
		arg.Cursor,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMembersWithGradeUseKeysetPaginateRow{}
	for rows.Next() {
		var i GetMembersWithGradeUseKeysetPaginateRow
		if err := rows.Scan(
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageID,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
			&i.Grade.MGradesPkey,
			&i.Grade.GradeID,
			&i.Grade.Key,
			&i.Grade.OrganizationID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMembersWithGradeUseNumberedPaginate = `-- name: GetMembersWithGradeUseNumberedPaginate :many
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_grades.m_grades_pkey, m_grades.grade_id, m_grades.key, m_grades.organization_id FROM m_members
LEFT JOIN m_grades ON m_members.grade_id = m_grades.grade_id
LEFT JOIN m_organizations ON m_grades.organization_id = m_organizations.organization_id
WHERE
	CASE WHEN $3::boolean = true THEN m_members.name LIKE '%' || $4::text || '%' ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN (SELECT COUNT(*) FROM m_role_associations WHERE role_id = m_members.role_id AND m_role_associations.policy_id = ANY($6::uuid[])) > 0 ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN m_members.attend_status_id = ANY($8::uuid[]) ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN m_members.grade_id = ANY($10::uuid[]) ELSE TRUE END
AND
	CASE WHEN $11::boolean = true THEN m_members.group_id = ANY($12::uuid[]) ELSE TRUE END
ORDER BY
	CASE WHEN $13::text = 'name' THEN m_members.name END ASC,
	CASE WHEN $13::text = 'r_name' THEN m_members.name END DESC,
	m_members_pkey ASC
LIMIT $1 OFFSET $2
`

type GetMembersWithGradeUseNumberedPaginateParams struct {
	Limit              int32       `json:"limit"`
	Offset             int32       `json:"offset"`
	WhereLikeName      bool        `json:"where_like_name"`
	SearchName         string      `json:"search_name"`
	WhereHasPolicy     bool        `json:"where_has_policy"`
	HasPolicyIds       []uuid.UUID `json:"has_policy_ids"`
	WhenInAttendStatus bool        `json:"when_in_attend_status"`
	InAttendStatusIds  []uuid.UUID `json:"in_attend_status_ids"`
	WhenInGrade        bool        `json:"when_in_grade"`
	InGradeIds         []uuid.UUID `json:"in_grade_ids"`
	WhenInGroup        bool        `json:"when_in_group"`
	InGroupIds         []uuid.UUID `json:"in_group_ids"`
	OrderMethod        string      `json:"order_method"`
}

type GetMembersWithGradeUseNumberedPaginateRow struct {
	Member Member `json:"member"`
	Grade  Grade  `json:"grade"`
}

func (q *Queries) GetMembersWithGradeUseNumberedPaginate(ctx context.Context, arg GetMembersWithGradeUseNumberedPaginateParams) ([]GetMembersWithGradeUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getMembersWithGradeUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.WhereLikeName,
		arg.SearchName,
		arg.WhereHasPolicy,
		arg.HasPolicyIds,
		arg.WhenInAttendStatus,
		arg.InAttendStatusIds,
		arg.WhenInGrade,
		arg.InGradeIds,
		arg.WhenInGroup,
		arg.InGroupIds,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMembersWithGradeUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetMembersWithGradeUseNumberedPaginateRow
		if err := rows.Scan(
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageID,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
			&i.Grade.MGradesPkey,
			&i.Grade.GradeID,
			&i.Grade.Key,
			&i.Grade.OrganizationID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMembersWithGroup = `-- name: GetMembersWithGroup :many
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_groups.m_groups_pkey, m_groups.group_id, m_groups.key, m_groups.organization_id FROM m_members
LEFT JOIN m_groups ON m_members.group_id = m_groups.group_id
LEFT JOIN m_organizations ON m_groups.organization_id = m_organizations.organization_id
WHERE
	CASE WHEN $1::boolean = true THEN m_members.name LIKE '%' || $2::text || '%' ELSE TRUE END
AND
	CASE WHEN $3::boolean = true THEN (SELECT COUNT(*) FROM m_role_associations WHERE role_id = m_members.role_id AND m_role_associations.policy_id = ANY($4::uuid[])) > 0 ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN m_members.attend_status_id = ANY($6::uuid[]) ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN m_members.grade_id = ANY($8::uuid[]) ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN m_members.group_id = ANY($10::uuid[]) ELSE TRUE END
ORDER BY
	CASE WHEN $11::text = 'name' THEN m_members.name END ASC,
	CASE WHEN $11::text = 'r_name' THEN m_members.name END DESC,
	m_members_pkey ASC
`

type GetMembersWithGroupParams struct {
	WhereLikeName      bool        `json:"where_like_name"`
	SearchName         string      `json:"search_name"`
	WhereHasPolicy     bool        `json:"where_has_policy"`
	HasPolicyIds       []uuid.UUID `json:"has_policy_ids"`
	WhenInAttendStatus bool        `json:"when_in_attend_status"`
	InAttendStatusIds  []uuid.UUID `json:"in_attend_status_ids"`
	WhenInGrade        bool        `json:"when_in_grade"`
	InGradeIds         []uuid.UUID `json:"in_grade_ids"`
	WhenInGroup        bool        `json:"when_in_group"`
	InGroupIds         []uuid.UUID `json:"in_group_ids"`
	OrderMethod        string      `json:"order_method"`
}

type GetMembersWithGroupRow struct {
	Member Member `json:"member"`
	Group  Group  `json:"group"`
}

func (q *Queries) GetMembersWithGroup(ctx context.Context, arg GetMembersWithGroupParams) ([]GetMembersWithGroupRow, error) {
	rows, err := q.db.Query(ctx, getMembersWithGroup,
		arg.WhereLikeName,
		arg.SearchName,
		arg.WhereHasPolicy,
		arg.HasPolicyIds,
		arg.WhenInAttendStatus,
		arg.InAttendStatusIds,
		arg.WhenInGrade,
		arg.InGradeIds,
		arg.WhenInGroup,
		arg.InGroupIds,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMembersWithGroupRow{}
	for rows.Next() {
		var i GetMembersWithGroupRow
		if err := rows.Scan(
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageID,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
			&i.Group.MGroupsPkey,
			&i.Group.GroupID,
			&i.Group.Key,
			&i.Group.OrganizationID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMembersWithGroupUseKeysetPaginate = `-- name: GetMembersWithGroupUseKeysetPaginate :many
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_groups.m_groups_pkey, m_groups.group_id, m_groups.key, m_groups.organization_id FROM m_members
LEFT JOIN m_groups ON m_members.group_id = m_groups.group_id
LEFT JOIN m_organizations ON m_groups.organization_id = m_organizations.organization_id
WHERE
	CASE WHEN $2::boolean = true THEN m_members.name LIKE '%' || $3::text || '%' ELSE TRUE END
AND
	CASE WHEN $4::boolean = true THEN (SELECT COUNT(*) FROM m_role_associations WHERE role_id = m_members.role_id AND m_role_associations.policy_id = ANY($5::uuid[])) > 0 ELSE TRUE END
AND
	CASE WHEN $6::boolean = true THEN m_members.attend_status_id = ANY($7::uuid[]) ELSE TRUE END
AND
	CASE WHEN $8::boolean = true THEN m_members.grade_id = ANY($9::uuid[]) ELSE TRUE END
AND
	CASE WHEN $10::boolean = true THEN m_members.group_id = ANY($11::uuid[]) ELSE TRUE END
AND
	CASE $12::text
		WHEN 'next' THEN
			CASE $13::text
				WHEN 'name' THEN m_members.name > $14 OR (m_members.name = $14 AND m_members_pkey > $15::int)
				WHEN 'r_name' THEN m_members.name < $14 OR (m_members.name = $14 AND m_members_pkey > $15::int)
				ELSE m_members_pkey > $15::int
			END
		WHEN 'prev' THEN
			CASE $13::text
				WHEN 'name' THEN m_members.name < $14 OR (m_members.name = $14 AND m_members_pkey < $15::int)
				WHEN 'r_name' THEN m_members.name > $14 OR (m_members.name = $14 AND m_members_pkey < $15::int)
				ELSE m_members_pkey < $15::int
			END
	END
ORDER BY
	CASE WHEN $13::text = 'name' AND $12::text = 'next' THEN m_members.name END ASC,
	CASE WHEN $13::text = 'name' AND $12::text = 'prev' THEN m_members.name END DESC,
	CASE WHEN $13::text = 'r_name' AND $12::text = 'next' THEN m_members.name END DESC,
	CASE WHEN $13::text = 'r_name' AND $12::text = 'prev' THEN m_members.name END ASC,
	CASE WHEN $12::text = 'next' THEN m_members_pkey END ASC,
	CASE WHEN $12::text = 'prev' THEN m_members_pkey END DESC
LIMIT $1
`

type GetMembersWithGroupUseKeysetPaginateParams struct {
	Limit              int32       `json:"limit"`
	WhereLikeName      bool        `json:"where_like_name"`
	SearchName         string      `json:"search_name"`
	WhereHasPolicy     bool        `json:"where_has_policy"`
	HasPolicyIds       []uuid.UUID `json:"has_policy_ids"`
	WhenInAttendStatus bool        `json:"when_in_attend_status"`
	InAttendStatusIds  []uuid.UUID `json:"in_attend_status_ids"`
	WhenInGrade        bool        `json:"when_in_grade"`
	InGradeIds         []uuid.UUID `json:"in_grade_ids"`
	WhenInGroup        bool        `json:"when_in_group"`
	InGroupIds         []uuid.UUID `json:"in_group_ids"`
	CursorDirection    string      `json:"cursor_direction"`
	OrderMethod        string      `json:"order_method"`
	NameCursor         string      `json:"name_cursor"`
	Cursor             int32       `json:"cursor"`
}

type GetMembersWithGroupUseKeysetPaginateRow struct {
	Member Member `json:"member"`
	Group  Group  `json:"group"`
}

func (q *Queries) GetMembersWithGroupUseKeysetPaginate(ctx context.Context, arg GetMembersWithGroupUseKeysetPaginateParams) ([]GetMembersWithGroupUseKeysetPaginateRow, error) {
	rows, err := q.db.Query(ctx, getMembersWithGroupUseKeysetPaginate,
		arg.Limit,
		arg.WhereLikeName,
		arg.SearchName,
		arg.WhereHasPolicy,
		arg.HasPolicyIds,
		arg.WhenInAttendStatus,
		arg.InAttendStatusIds,
		arg.WhenInGrade,
		arg.InGradeIds,
		arg.WhenInGroup,
		arg.InGroupIds,
		arg.CursorDirection,
		arg.OrderMethod,
		arg.NameCursor,
		arg.Cursor,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMembersWithGroupUseKeysetPaginateRow{}
	for rows.Next() {
		var i GetMembersWithGroupUseKeysetPaginateRow
		if err := rows.Scan(
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageID,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
			&i.Group.MGroupsPkey,
			&i.Group.GroupID,
			&i.Group.Key,
			&i.Group.OrganizationID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMembersWithGroupUseNumberedPaginate = `-- name: GetMembersWithGroupUseNumberedPaginate :many
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_groups.m_groups_pkey, m_groups.group_id, m_groups.key, m_groups.organization_id FROM m_members
LEFT JOIN m_groups ON m_members.group_id = m_groups.group_id
LEFT JOIN m_organizations ON m_groups.organization_id = m_organizations.organization_id
WHERE
	CASE WHEN $3::boolean = true THEN m_members.name LIKE '%' || $4::text || '%' ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN (SELECT COUNT(*) FROM m_role_associations WHERE role_id = m_members.role_id AND m_role_associations.policy_id = ANY($6::uuid[])) > 0 ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN m_members.attend_status_id = ANY($8::uuid[]) ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN m_members.grade_id = ANY($10::uuid[]) ELSE TRUE END
AND
	CASE WHEN $11::boolean = true THEN m_members.group_id = ANY($12::uuid[]) ELSE TRUE END
ORDER BY
	CASE WHEN $13::text = 'name' THEN m_members.name END ASC,
	CASE WHEN $13::text = 'r_name' THEN m_members.name END DESC,
	m_members_pkey ASC
LIMIT $1 OFFSET $2
`

type GetMembersWithGroupUseNumberedPaginateParams struct {
	Limit              int32       `json:"limit"`
	Offset             int32       `json:"offset"`
	WhereLikeName      bool        `json:"where_like_name"`
	SearchName         string      `json:"search_name"`
	WhereHasPolicy     bool        `json:"where_has_policy"`
	HasPolicyIds       []uuid.UUID `json:"has_policy_ids"`
	WhenInAttendStatus bool        `json:"when_in_attend_status"`
	InAttendStatusIds  []uuid.UUID `json:"in_attend_status_ids"`
	WhenInGrade        bool        `json:"when_in_grade"`
	InGradeIds         []uuid.UUID `json:"in_grade_ids"`
	WhenInGroup        bool        `json:"when_in_group"`
	InGroupIds         []uuid.UUID `json:"in_group_ids"`
	OrderMethod        string      `json:"order_method"`
}

type GetMembersWithGroupUseNumberedPaginateRow struct {
	Member Member `json:"member"`
	Group  Group  `json:"group"`
}

func (q *Queries) GetMembersWithGroupUseNumberedPaginate(ctx context.Context, arg GetMembersWithGroupUseNumberedPaginateParams) ([]GetMembersWithGroupUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getMembersWithGroupUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.WhereLikeName,
		arg.SearchName,
		arg.WhereHasPolicy,
		arg.HasPolicyIds,
		arg.WhenInAttendStatus,
		arg.InAttendStatusIds,
		arg.WhenInGrade,
		arg.InGradeIds,
		arg.WhenInGroup,
		arg.InGroupIds,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMembersWithGroupUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetMembersWithGroupUseNumberedPaginateRow
		if err := rows.Scan(
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageID,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
			&i.Group.MGroupsPkey,
			&i.Group.GroupID,
			&i.Group.Key,
			&i.Group.OrganizationID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMembersWithPersonalOrganization = `-- name: GetMembersWithPersonalOrganization :many
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.color, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at, m_organizations.chat_room_id FROM m_members
LEFT JOIN m_organizations ON m_members.personal_organization_id = m_organizations.organization_id
WHERE
	CASE WHEN $1::boolean = true THEN m_members.name LIKE '%' || $2::text || '%' ELSE TRUE END
AND
	CASE WHEN $3::boolean = true THEN (SELECT COUNT(*) FROM m_role_associations WHERE role_id = m_members.role_id AND m_role_associations.policy_id = ANY($4::uuid[])) > 0 ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN m_members.attend_status_id = ANY($6::uuid[]) ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN m_members.grade_id = ANY($8::uuid[]) ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN m_members.group_id = ANY($10::uuid[]) ELSE TRUE END
ORDER BY
	CASE WHEN $11::text = 'name' THEN m_members.name END ASC,
	CASE WHEN $11::text = 'r_name' THEN m_members.name END DESC,
	m_members_pkey ASC
`

type GetMembersWithPersonalOrganizationParams struct {
	WhereLikeName      bool        `json:"where_like_name"`
	SearchName         string      `json:"search_name"`
	WhereHasPolicy     bool        `json:"where_has_policy"`
	HasPolicyIds       []uuid.UUID `json:"has_policy_ids"`
	WhenInAttendStatus bool        `json:"when_in_attend_status"`
	InAttendStatusIds  []uuid.UUID `json:"in_attend_status_ids"`
	WhenInGrade        bool        `json:"when_in_grade"`
	InGradeIds         []uuid.UUID `json:"in_grade_ids"`
	WhenInGroup        bool        `json:"when_in_group"`
	InGroupIds         []uuid.UUID `json:"in_group_ids"`
	OrderMethod        string      `json:"order_method"`
}

type GetMembersWithPersonalOrganizationRow struct {
	Member       Member       `json:"member"`
	Organization Organization `json:"organization"`
}

func (q *Queries) GetMembersWithPersonalOrganization(ctx context.Context, arg GetMembersWithPersonalOrganizationParams) ([]GetMembersWithPersonalOrganizationRow, error) {
	rows, err := q.db.Query(ctx, getMembersWithPersonalOrganization,
		arg.WhereLikeName,
		arg.SearchName,
		arg.WhereHasPolicy,
		arg.HasPolicyIds,
		arg.WhenInAttendStatus,
		arg.InAttendStatusIds,
		arg.WhenInGrade,
		arg.InGradeIds,
		arg.WhenInGroup,
		arg.InGroupIds,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMembersWithPersonalOrganizationRow{}
	for rows.Next() {
		var i GetMembersWithPersonalOrganizationRow
		if err := rows.Scan(
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageID,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
			&i.Organization.MOrganizationsPkey,
			&i.Organization.OrganizationID,
			&i.Organization.Name,
			&i.Organization.Description,
			&i.Organization.Color,
			&i.Organization.IsPersonal,
			&i.Organization.IsWhole,
			&i.Organization.CreatedAt,
			&i.Organization.UpdatedAt,
			&i.Organization.ChatRoomID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMembersWithPersonalOrganizationUseKeysetPaginate = `-- name: GetMembersWithPersonalOrganizationUseKeysetPaginate :many
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.color, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at, m_organizations.chat_room_id FROM m_members
LEFT JOIN m_organizations ON m_members.personal_organization_id = m_organizations.organization_id
WHERE
	CASE WHEN $2::boolean = true THEN m_members.name LIKE '%' || $3::text || '%' ELSE TRUE END
AND
	CASE WHEN $4::boolean = true THEN (SELECT COUNT(*) FROM m_role_associations WHERE role_id = m_members.role_id AND m_role_associations.policy_id = ANY($5::uuid[])) > 0 ELSE TRUE END
AND
	CASE WHEN $6::boolean = true THEN m_members.attend_status_id = ANY($7::uuid[]) ELSE TRUE END
AND
	CASE WHEN $8::boolean = true THEN m_members.grade_id = ANY($9::uuid[]) ELSE TRUE END
AND
	CASE WHEN $10::boolean = true THEN m_members.group_id = ANY($11::uuid[]) ELSE TRUE END
AND
	CASE $12::text
		WHEN 'next' THEN
			CASE $13::text
				WHEN 'name' THEN m_members.name > $14 OR (m_members.name = $14 AND m_members_pkey > $15::int)
				WHEN 'r_name' THEN m_members.name < $14 OR (m_members.name = $14 AND m_members_pkey > $15::int)
				ELSE m_members_pkey > $15::int
			END
		WHEN 'prev' THEN
			CASE $13::text
				WHEN 'name' THEN m_members.name < $14 OR (m_members.name = $14 AND m_members_pkey < $15::int)
				WHEN 'r_name' THEN m_members.name > $14 OR (m_members.name = $14 AND m_members_pkey < $15::int)
				ELSE m_members_pkey < $15::int
			END
	END
ORDER BY
	CASE WHEN $13::text = 'name' AND $12::text = 'next' THEN m_members.name END ASC,
	CASE WHEN $13::text = 'name' AND $12::text = 'prev' THEN m_members.name END DESC,
	CASE WHEN $13::text = 'r_name' AND $12::text = 'next' THEN m_members.name END DESC,
	CASE WHEN $13::text = 'r_name' AND $12::text = 'prev' THEN m_members.name END ASC,
	CASE WHEN $12::text = 'next' THEN m_members_pkey END ASC,
	CASE WHEN $12::text = 'prev' THEN m_members_pkey END DESC
LIMIT $1
`

type GetMembersWithPersonalOrganizationUseKeysetPaginateParams struct {
	Limit              int32       `json:"limit"`
	WhereLikeName      bool        `json:"where_like_name"`
	SearchName         string      `json:"search_name"`
	WhereHasPolicy     bool        `json:"where_has_policy"`
	HasPolicyIds       []uuid.UUID `json:"has_policy_ids"`
	WhenInAttendStatus bool        `json:"when_in_attend_status"`
	InAttendStatusIds  []uuid.UUID `json:"in_attend_status_ids"`
	WhenInGrade        bool        `json:"when_in_grade"`
	InGradeIds         []uuid.UUID `json:"in_grade_ids"`
	WhenInGroup        bool        `json:"when_in_group"`
	InGroupIds         []uuid.UUID `json:"in_group_ids"`
	CursorDirection    string      `json:"cursor_direction"`
	OrderMethod        string      `json:"order_method"`
	NameCursor         string      `json:"name_cursor"`
	Cursor             int32       `json:"cursor"`
}

type GetMembersWithPersonalOrganizationUseKeysetPaginateRow struct {
	Member       Member       `json:"member"`
	Organization Organization `json:"organization"`
}

func (q *Queries) GetMembersWithPersonalOrganizationUseKeysetPaginate(ctx context.Context, arg GetMembersWithPersonalOrganizationUseKeysetPaginateParams) ([]GetMembersWithPersonalOrganizationUseKeysetPaginateRow, error) {
	rows, err := q.db.Query(ctx, getMembersWithPersonalOrganizationUseKeysetPaginate,
		arg.Limit,
		arg.WhereLikeName,
		arg.SearchName,
		arg.WhereHasPolicy,
		arg.HasPolicyIds,
		arg.WhenInAttendStatus,
		arg.InAttendStatusIds,
		arg.WhenInGrade,
		arg.InGradeIds,
		arg.WhenInGroup,
		arg.InGroupIds,
		arg.CursorDirection,
		arg.OrderMethod,
		arg.NameCursor,
		arg.Cursor,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMembersWithPersonalOrganizationUseKeysetPaginateRow{}
	for rows.Next() {
		var i GetMembersWithPersonalOrganizationUseKeysetPaginateRow
		if err := rows.Scan(
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageID,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
			&i.Organization.MOrganizationsPkey,
			&i.Organization.OrganizationID,
			&i.Organization.Name,
			&i.Organization.Description,
			&i.Organization.Color,
			&i.Organization.IsPersonal,
			&i.Organization.IsWhole,
			&i.Organization.CreatedAt,
			&i.Organization.UpdatedAt,
			&i.Organization.ChatRoomID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMembersWithPersonalOrganizationUseNumberedPaginate = `-- name: GetMembersWithPersonalOrganizationUseNumberedPaginate :many
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.color, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at, m_organizations.chat_room_id FROM m_members
LEFT JOIN m_organizations ON m_members.personal_organization_id = m_organizations.organization_id
WHERE
	CASE WHEN $3::boolean = true THEN m_members.name LIKE '%' || $4::text || '%' ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN (SELECT COUNT(*) FROM m_role_associations WHERE role_id = m_members.role_id AND m_role_associations.policy_id = ANY($6::uuid[])) > 0 ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN m_members.attend_status_id = ANY($8::uuid[]) ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN m_members.grade_id = ANY($10::uuid[]) ELSE TRUE END
AND
	CASE WHEN $11::boolean = true THEN m_members.group_id = ANY($12::uuid[]) ELSE TRUE END
ORDER BY
	CASE WHEN $13::text = 'name' THEN m_members.name END ASC,
	CASE WHEN $13::text = 'r_name' THEN m_members.name END DESC,
	m_members_pkey ASC
LIMIT $1 OFFSET $2
`

type GetMembersWithPersonalOrganizationUseNumberedPaginateParams struct {
	Limit              int32       `json:"limit"`
	Offset             int32       `json:"offset"`
	WhereLikeName      bool        `json:"where_like_name"`
	SearchName         string      `json:"search_name"`
	WhereHasPolicy     bool        `json:"where_has_policy"`
	HasPolicyIds       []uuid.UUID `json:"has_policy_ids"`
	WhenInAttendStatus bool        `json:"when_in_attend_status"`
	InAttendStatusIds  []uuid.UUID `json:"in_attend_status_ids"`
	WhenInGrade        bool        `json:"when_in_grade"`
	InGradeIds         []uuid.UUID `json:"in_grade_ids"`
	WhenInGroup        bool        `json:"when_in_group"`
	InGroupIds         []uuid.UUID `json:"in_group_ids"`
	OrderMethod        string      `json:"order_method"`
}

type GetMembersWithPersonalOrganizationUseNumberedPaginateRow struct {
	Member       Member       `json:"member"`
	Organization Organization `json:"organization"`
}

func (q *Queries) GetMembersWithPersonalOrganizationUseNumberedPaginate(ctx context.Context, arg GetMembersWithPersonalOrganizationUseNumberedPaginateParams) ([]GetMembersWithPersonalOrganizationUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getMembersWithPersonalOrganizationUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.WhereLikeName,
		arg.SearchName,
		arg.WhereHasPolicy,
		arg.HasPolicyIds,
		arg.WhenInAttendStatus,
		arg.InAttendStatusIds,
		arg.WhenInGrade,
		arg.InGradeIds,
		arg.WhenInGroup,
		arg.InGroupIds,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMembersWithPersonalOrganizationUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetMembersWithPersonalOrganizationUseNumberedPaginateRow
		if err := rows.Scan(
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageID,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
			&i.Organization.MOrganizationsPkey,
			&i.Organization.OrganizationID,
			&i.Organization.Name,
			&i.Organization.Description,
			&i.Organization.Color,
			&i.Organization.IsPersonal,
			&i.Organization.IsWhole,
			&i.Organization.CreatedAt,
			&i.Organization.UpdatedAt,
			&i.Organization.ChatRoomID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMembersWithRole = `-- name: GetMembersWithRole :many
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_roles.m_roles_pkey, m_roles.role_id, m_roles.name, m_roles.description, m_roles.created_at, m_roles.updated_at FROM m_members
LEFT JOIN m_roles ON m_members.role_id = m_roles.role_id
WHERE
	CASE WHEN $1::boolean = true THEN m_members.name LIKE '%' || $2::text || '%' ELSE TRUE END
AND
	CASE WHEN $3::boolean = true THEN (SELECT COUNT(*) FROM m_role_associations WHERE role_id = m_members.role_id AND m_role_associations.policy_id = ANY($4::uuid[])) > 0 ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN m_members.attend_status_id = ANY($6::uuid[]) ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN m_members.grade_id = ANY($8::uuid[]) ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN m_members.group_id = ANY($10::uuid[]) ELSE TRUE END
ORDER BY
	CASE WHEN $11::text = 'name' THEN m_members.name END ASC,
	CASE WHEN $11::text = 'r_name' THEN m_members.name END DESC,
	m_members_pkey ASC
`

type GetMembersWithRoleParams struct {
	WhereLikeName      bool        `json:"where_like_name"`
	SearchName         string      `json:"search_name"`
	WhereHasPolicy     bool        `json:"where_has_policy"`
	HasPolicyIds       []uuid.UUID `json:"has_policy_ids"`
	WhenInAttendStatus bool        `json:"when_in_attend_status"`
	InAttendStatusIds  []uuid.UUID `json:"in_attend_status_ids"`
	WhenInGrade        bool        `json:"when_in_grade"`
	InGradeIds         []uuid.UUID `json:"in_grade_ids"`
	WhenInGroup        bool        `json:"when_in_group"`
	InGroupIds         []uuid.UUID `json:"in_group_ids"`
	OrderMethod        string      `json:"order_method"`
}

type GetMembersWithRoleRow struct {
	Member Member `json:"member"`
	Role   Role   `json:"role"`
}

func (q *Queries) GetMembersWithRole(ctx context.Context, arg GetMembersWithRoleParams) ([]GetMembersWithRoleRow, error) {
	rows, err := q.db.Query(ctx, getMembersWithRole,
		arg.WhereLikeName,
		arg.SearchName,
		arg.WhereHasPolicy,
		arg.HasPolicyIds,
		arg.WhenInAttendStatus,
		arg.InAttendStatusIds,
		arg.WhenInGrade,
		arg.InGradeIds,
		arg.WhenInGroup,
		arg.InGroupIds,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMembersWithRoleRow{}
	for rows.Next() {
		var i GetMembersWithRoleRow
		if err := rows.Scan(
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageID,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
			&i.Role.MRolesPkey,
			&i.Role.RoleID,
			&i.Role.Name,
			&i.Role.Description,
			&i.Role.CreatedAt,
			&i.Role.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMembersWithRoleUseKeysetPaginate = `-- name: GetMembersWithRoleUseKeysetPaginate :many
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_roles.m_roles_pkey, m_roles.role_id, m_roles.name, m_roles.description, m_roles.created_at, m_roles.updated_at FROM m_members
LEFT JOIN m_roles ON m_members.role_id = m_roles.role_id
WHERE
	CASE WHEN $2::boolean = true THEN m_members.name LIKE '%' || $3::text || '%' ELSE TRUE END
AND
	CASE WHEN $4::boolean = true THEN (SELECT COUNT(*) FROM m_role_associations WHERE role_id = m_members.role_id AND m_role_associations.policy_id = ANY($5::uuid[])) > 0 ELSE TRUE END
AND
	CASE WHEN $6::boolean = true THEN m_members.attend_status_id = ANY($7::uuid[]) ELSE TRUE END
AND
	CASE WHEN $8::boolean = true THEN m_members.grade_id = ANY($9::uuid[]) ELSE TRUE END
AND
	CASE WHEN $10::boolean = true THEN m_members.group_id = ANY($11::uuid[]) ELSE TRUE END
AND
	CASE $12::text
		WHEN 'next' THEN
			CASE $13::text
				WHEN 'name' THEN m_members.name > $14 OR (m_members.name = $14 AND m_members_pkey > $15::int)
				WHEN 'r_name' THEN m_members.name < $14 OR (m_members.name = $14 AND m_members_pkey > $15::int)
				ELSE m_members_pkey > $15::int
			END
		WHEN 'prev' THEN
			CASE $13::text
				WHEN 'name' THEN m_members.name < $14 OR (m_members.name = $14 AND m_members_pkey < $15::int)
				WHEN 'r_name' THEN m_members.name > $14 OR (m_members.name = $14 AND m_members_pkey < $15::int)
				ELSE m_members_pkey < $15::int
			END
	END
ORDER BY
	CASE WHEN $13::text = 'name' AND $12::text = 'next' THEN m_members.name END ASC,
	CASE WHEN $13::text = 'name' AND $12::text = 'prev' THEN m_members.name END DESC,
	CASE WHEN $13::text = 'r_name' AND $12::text = 'next' THEN m_members.name END DESC,
	CASE WHEN $13::text = 'r_name' AND $12::text = 'prev' THEN m_members.name END ASC,
	CASE WHEN $12::text = 'next' THEN m_members_pkey END ASC,
	CASE WHEN $12::text = 'prev' THEN m_members_pkey END DESC
LIMIT $1
`

type GetMembersWithRoleUseKeysetPaginateParams struct {
	Limit              int32       `json:"limit"`
	WhereLikeName      bool        `json:"where_like_name"`
	SearchName         string      `json:"search_name"`
	WhereHasPolicy     bool        `json:"where_has_policy"`
	HasPolicyIds       []uuid.UUID `json:"has_policy_ids"`
	WhenInAttendStatus bool        `json:"when_in_attend_status"`
	InAttendStatusIds  []uuid.UUID `json:"in_attend_status_ids"`
	WhenInGrade        bool        `json:"when_in_grade"`
	InGradeIds         []uuid.UUID `json:"in_grade_ids"`
	WhenInGroup        bool        `json:"when_in_group"`
	InGroupIds         []uuid.UUID `json:"in_group_ids"`
	CursorDirection    string      `json:"cursor_direction"`
	OrderMethod        string      `json:"order_method"`
	NameCursor         string      `json:"name_cursor"`
	Cursor             int32       `json:"cursor"`
}

type GetMembersWithRoleUseKeysetPaginateRow struct {
	Member Member `json:"member"`
	Role   Role   `json:"role"`
}

func (q *Queries) GetMembersWithRoleUseKeysetPaginate(ctx context.Context, arg GetMembersWithRoleUseKeysetPaginateParams) ([]GetMembersWithRoleUseKeysetPaginateRow, error) {
	rows, err := q.db.Query(ctx, getMembersWithRoleUseKeysetPaginate,
		arg.Limit,
		arg.WhereLikeName,
		arg.SearchName,
		arg.WhereHasPolicy,
		arg.HasPolicyIds,
		arg.WhenInAttendStatus,
		arg.InAttendStatusIds,
		arg.WhenInGrade,
		arg.InGradeIds,
		arg.WhenInGroup,
		arg.InGroupIds,
		arg.CursorDirection,
		arg.OrderMethod,
		arg.NameCursor,
		arg.Cursor,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMembersWithRoleUseKeysetPaginateRow{}
	for rows.Next() {
		var i GetMembersWithRoleUseKeysetPaginateRow
		if err := rows.Scan(
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageID,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
			&i.Role.MRolesPkey,
			&i.Role.RoleID,
			&i.Role.Name,
			&i.Role.Description,
			&i.Role.CreatedAt,
			&i.Role.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMembersWithRoleUseNumberedPaginate = `-- name: GetMembersWithRoleUseNumberedPaginate :many
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_roles.m_roles_pkey, m_roles.role_id, m_roles.name, m_roles.description, m_roles.created_at, m_roles.updated_at FROM m_members
LEFT JOIN m_roles ON m_members.role_id = m_roles.role_id
WHERE
	CASE WHEN $3::boolean = true THEN m_members.name LIKE '%' || $4::text || '%' ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN (SELECT COUNT(*) FROM m_role_associations WHERE role_id = m_members.role_id AND m_role_associations.policy_id = ANY($6::uuid[])) > 0 ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN m_members.attend_status_id = ANY($8::uuid[]) ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN m_members.grade_id = ANY($10::uuid[]) ELSE TRUE END
AND
	CASE WHEN $11::boolean = true THEN m_members.group_id = ANY($12::uuid[]) ELSE TRUE END
ORDER BY
	CASE WHEN $13::text = 'name' THEN m_members.name END ASC,
	CASE WHEN $13::text = 'r_name' THEN m_members.name END DESC,
	m_members_pkey ASC
LIMIT $1 OFFSET $2
`

type GetMembersWithRoleUseNumberedPaginateParams struct {
	Limit              int32       `json:"limit"`
	Offset             int32       `json:"offset"`
	WhereLikeName      bool        `json:"where_like_name"`
	SearchName         string      `json:"search_name"`
	WhereHasPolicy     bool        `json:"where_has_policy"`
	HasPolicyIds       []uuid.UUID `json:"has_policy_ids"`
	WhenInAttendStatus bool        `json:"when_in_attend_status"`
	InAttendStatusIds  []uuid.UUID `json:"in_attend_status_ids"`
	WhenInGrade        bool        `json:"when_in_grade"`
	InGradeIds         []uuid.UUID `json:"in_grade_ids"`
	WhenInGroup        bool        `json:"when_in_group"`
	InGroupIds         []uuid.UUID `json:"in_group_ids"`
	OrderMethod        string      `json:"order_method"`
}

type GetMembersWithRoleUseNumberedPaginateRow struct {
	Member Member `json:"member"`
	Role   Role   `json:"role"`
}

func (q *Queries) GetMembersWithRoleUseNumberedPaginate(ctx context.Context, arg GetMembersWithRoleUseNumberedPaginateParams) ([]GetMembersWithRoleUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getMembersWithRoleUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.WhereLikeName,
		arg.SearchName,
		arg.WhereHasPolicy,
		arg.HasPolicyIds,
		arg.WhenInAttendStatus,
		arg.InAttendStatusIds,
		arg.WhenInGrade,
		arg.InGradeIds,
		arg.WhenInGroup,
		arg.InGroupIds,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMembersWithRoleUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetMembersWithRoleUseNumberedPaginateRow
		if err := rows.Scan(
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageID,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
			&i.Role.MRolesPkey,
			&i.Role.RoleID,
			&i.Role.Name,
			&i.Role.Description,
			&i.Role.CreatedAt,
			&i.Role.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralMembers = `-- name: GetPluralMembers :many
SELECT m_members_pkey, member_id, login_id, password, email, name, attend_status_id, profile_image_id, grade_id, group_id, personal_organization_id, role_id, created_at, updated_at FROM m_members WHERE member_id = ANY($1::uuid[])
ORDER BY
	CASE WHEN $2::text = 'name' THEN m_members.name END ASC,
	CASE WHEN $2::text = 'r_name' THEN m_members.name END DESC,
	m_members_pkey ASC
`

type GetPluralMembersParams struct {
	MemberIds   []uuid.UUID `json:"member_ids"`
	OrderMethod string      `json:"order_method"`
}

func (q *Queries) GetPluralMembers(ctx context.Context, arg GetPluralMembersParams) ([]Member, error) {
	rows, err := q.db.Query(ctx, getPluralMembers, arg.MemberIds, arg.OrderMethod)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Member{}
	for rows.Next() {
		var i Member
		if err := rows.Scan(
			&i.MMembersPkey,
			&i.MemberID,
			&i.LoginID,
			&i.Password,
			&i.Email,
			&i.Name,
			&i.AttendStatusID,
			&i.ProfileImageID,
			&i.GradeID,
			&i.GroupID,
			&i.PersonalOrganizationID,
			&i.RoleID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralMembersUseNumberedPaginate = `-- name: GetPluralMembersUseNumberedPaginate :many
SELECT m_members_pkey, member_id, login_id, password, email, name, attend_status_id, profile_image_id, grade_id, group_id, personal_organization_id, role_id, created_at, updated_at FROM m_members WHERE member_id = ANY($3::uuid[])
ORDER BY
	CASE WHEN $4::text = 'name' THEN m_members.name END ASC,
	CASE WHEN $4::text = 'r_name' THEN m_members.name END DESC,
	m_members_pkey ASC
LIMIT $1 OFFSET $2
`

type GetPluralMembersUseNumberedPaginateParams struct {
	Limit       int32       `json:"limit"`
	Offset      int32       `json:"offset"`
	MemberIds   []uuid.UUID `json:"member_ids"`
	OrderMethod string      `json:"order_method"`
}

func (q *Queries) GetPluralMembersUseNumberedPaginate(ctx context.Context, arg GetPluralMembersUseNumberedPaginateParams) ([]Member, error) {
	rows, err := q.db.Query(ctx, getPluralMembersUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.MemberIds,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Member{}
	for rows.Next() {
		var i Member
		if err := rows.Scan(
			&i.MMembersPkey,
			&i.MemberID,
			&i.LoginID,
			&i.Password,
			&i.Email,
			&i.Name,
			&i.AttendStatusID,
			&i.ProfileImageID,
			&i.GradeID,
			&i.GroupID,
			&i.PersonalOrganizationID,
			&i.RoleID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralMembersWithAll = `-- name: GetPluralMembersWithAll :many
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_attend_statuses.m_attend_statuses_pkey, m_attend_statuses.attend_status_id, m_attend_statuses.name, m_attend_statuses.key, m_grades.m_grades_pkey, m_grades.grade_id, m_grades.key, m_grades.organization_id, m_groups.m_groups_pkey, m_groups.group_id, m_groups.key, m_groups.organization_id, m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.color, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at, m_organizations.chat_room_id, m_roles.m_roles_pkey, m_roles.role_id, m_roles.name, m_roles.description, m_roles.created_at, m_roles.updated_at FROM m_members
LEFT JOIN m_attend_statuses ON m_members.attend_status_id = m_attend_statuses.attend_status_id
LEFT JOIN m_grades ON m_members.grade_id = m_grades.grade_id
LEFT JOIN m_groups ON m_members.group_id = m_groups.group_id
LEFT JOIN m_organizations ON m_members.personal_organization_id = m_organizations.organization_id
LEFT JOIN m_roles ON m_members.role_id = m_roles.role_id
WHERE member_id = ANY($1::uuid[])
ORDER BY
	CASE WHEN $2::text = 'name' THEN m_members.name END ASC,
	CASE WHEN $2::text = 'r_name' THEN m_members.name END DESC,
	m_members_pkey ASC
`

type GetPluralMembersWithAllParams struct {
	MemberIds   []uuid.UUID `json:"member_ids"`
	OrderMethod string      `json:"order_method"`
}

type GetPluralMembersWithAllRow struct {
	Member       Member       `json:"member"`
	AttendStatus AttendStatus `json:"attend_status"`
	Grade        Grade        `json:"grade"`
	Group        Group        `json:"group"`
	Organization Organization `json:"organization"`
	Role         Role         `json:"role"`
}

func (q *Queries) GetPluralMembersWithAll(ctx context.Context, arg GetPluralMembersWithAllParams) ([]GetPluralMembersWithAllRow, error) {
	rows, err := q.db.Query(ctx, getPluralMembersWithAll, arg.MemberIds, arg.OrderMethod)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralMembersWithAllRow{}
	for rows.Next() {
		var i GetPluralMembersWithAllRow
		if err := rows.Scan(
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageID,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
			&i.AttendStatus.MAttendStatusesPkey,
			&i.AttendStatus.AttendStatusID,
			&i.AttendStatus.Name,
			&i.AttendStatus.Key,
			&i.Grade.MGradesPkey,
			&i.Grade.GradeID,
			&i.Grade.Key,
			&i.Grade.OrganizationID,
			&i.Group.MGroupsPkey,
			&i.Group.GroupID,
			&i.Group.Key,
			&i.Group.OrganizationID,
			&i.Organization.MOrganizationsPkey,
			&i.Organization.OrganizationID,
			&i.Organization.Name,
			&i.Organization.Description,
			&i.Organization.Color,
			&i.Organization.IsPersonal,
			&i.Organization.IsWhole,
			&i.Organization.CreatedAt,
			&i.Organization.UpdatedAt,
			&i.Organization.ChatRoomID,
			&i.Role.MRolesPkey,
			&i.Role.RoleID,
			&i.Role.Name,
			&i.Role.Description,
			&i.Role.CreatedAt,
			&i.Role.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralMembersWithAllUseNumberedPaginate = `-- name: GetPluralMembersWithAllUseNumberedPaginate :many
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_attend_statuses.m_attend_statuses_pkey, m_attend_statuses.attend_status_id, m_attend_statuses.name, m_attend_statuses.key, m_grades.m_grades_pkey, m_grades.grade_id, m_grades.key, m_grades.organization_id, m_groups.m_groups_pkey, m_groups.group_id, m_groups.key, m_groups.organization_id, m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.color, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at, m_organizations.chat_room_id, m_roles.m_roles_pkey, m_roles.role_id, m_roles.name, m_roles.description, m_roles.created_at, m_roles.updated_at FROM m_members
LEFT JOIN m_attend_statuses ON m_members.attend_status_id = m_attend_statuses.attend_status_id
LEFT JOIN m_grades ON m_members.grade_id = m_grades.grade_id
LEFT JOIN m_groups ON m_members.group_id = m_groups.group_id
LEFT JOIN m_organizations ON m_members.personal_organization_id = m_organizations.organization_id
LEFT JOIN m_roles ON m_members.role_id = m_roles.role_id
WHERE member_id = ANY($3::uuid[])
ORDER BY
	CASE WHEN $4::text = 'name' THEN m_members.name END ASC,
	CASE WHEN $4::text = 'r_name' THEN m_members.name END DESC,
	m_members_pkey ASC
LIMIT $1 OFFSET $2
`

type GetPluralMembersWithAllUseNumberedPaginateParams struct {
	Limit       int32       `json:"limit"`
	Offset      int32       `json:"offset"`
	MemberIds   []uuid.UUID `json:"member_ids"`
	OrderMethod string      `json:"order_method"`
}

type GetPluralMembersWithAllUseNumberedPaginateRow struct {
	Member       Member       `json:"member"`
	AttendStatus AttendStatus `json:"attend_status"`
	Grade        Grade        `json:"grade"`
	Group        Group        `json:"group"`
	Organization Organization `json:"organization"`
	Role         Role         `json:"role"`
}

func (q *Queries) GetPluralMembersWithAllUseNumberedPaginate(ctx context.Context, arg GetPluralMembersWithAllUseNumberedPaginateParams) ([]GetPluralMembersWithAllUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getPluralMembersWithAllUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.MemberIds,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralMembersWithAllUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetPluralMembersWithAllUseNumberedPaginateRow
		if err := rows.Scan(
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageID,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
			&i.AttendStatus.MAttendStatusesPkey,
			&i.AttendStatus.AttendStatusID,
			&i.AttendStatus.Name,
			&i.AttendStatus.Key,
			&i.Grade.MGradesPkey,
			&i.Grade.GradeID,
			&i.Grade.Key,
			&i.Grade.OrganizationID,
			&i.Group.MGroupsPkey,
			&i.Group.GroupID,
			&i.Group.Key,
			&i.Group.OrganizationID,
			&i.Organization.MOrganizationsPkey,
			&i.Organization.OrganizationID,
			&i.Organization.Name,
			&i.Organization.Description,
			&i.Organization.Color,
			&i.Organization.IsPersonal,
			&i.Organization.IsWhole,
			&i.Organization.CreatedAt,
			&i.Organization.UpdatedAt,
			&i.Organization.ChatRoomID,
			&i.Role.MRolesPkey,
			&i.Role.RoleID,
			&i.Role.Name,
			&i.Role.Description,
			&i.Role.CreatedAt,
			&i.Role.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralMembersWithAttendStatus = `-- name: GetPluralMembersWithAttendStatus :many
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_attend_statuses.m_attend_statuses_pkey, m_attend_statuses.attend_status_id, m_attend_statuses.name, m_attend_statuses.key FROM m_members
LEFT JOIN m_attend_statuses ON m_members.attend_status_id = m_attend_statuses.attend_status_id
WHERE member_id = ANY($1::uuid[])
ORDER BY
	CASE WHEN $2::text = 'name' THEN m_members.name END ASC,
	CASE WHEN $2::text = 'r_name' THEN m_members.name END DESC,
	m_members_pkey ASC
`

type GetPluralMembersWithAttendStatusParams struct {
	MemberIds   []uuid.UUID `json:"member_ids"`
	OrderMethod string      `json:"order_method"`
}

type GetPluralMembersWithAttendStatusRow struct {
	Member       Member       `json:"member"`
	AttendStatus AttendStatus `json:"attend_status"`
}

func (q *Queries) GetPluralMembersWithAttendStatus(ctx context.Context, arg GetPluralMembersWithAttendStatusParams) ([]GetPluralMembersWithAttendStatusRow, error) {
	rows, err := q.db.Query(ctx, getPluralMembersWithAttendStatus, arg.MemberIds, arg.OrderMethod)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralMembersWithAttendStatusRow{}
	for rows.Next() {
		var i GetPluralMembersWithAttendStatusRow
		if err := rows.Scan(
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageID,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
			&i.AttendStatus.MAttendStatusesPkey,
			&i.AttendStatus.AttendStatusID,
			&i.AttendStatus.Name,
			&i.AttendStatus.Key,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralMembersWithAttendStatusUseNumberedPaginate = `-- name: GetPluralMembersWithAttendStatusUseNumberedPaginate :many
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_attend_statuses.m_attend_statuses_pkey, m_attend_statuses.attend_status_id, m_attend_statuses.name, m_attend_statuses.key FROM m_members
LEFT JOIN m_attend_statuses ON m_members.attend_status_id = m_attend_statuses.attend_status_id
WHERE member_id = ANY($3::uuid[])
ORDER BY
	CASE WHEN $4::text = 'name' THEN m_members.name END ASC,
	CASE WHEN $4::text = 'r_name' THEN m_members.name END DESC,
	m_members_pkey ASC
LIMIT $1 OFFSET $2
`

type GetPluralMembersWithAttendStatusUseNumberedPaginateParams struct {
	Limit       int32       `json:"limit"`
	Offset      int32       `json:"offset"`
	MemberIds   []uuid.UUID `json:"member_ids"`
	OrderMethod string      `json:"order_method"`
}

type GetPluralMembersWithAttendStatusUseNumberedPaginateRow struct {
	Member       Member       `json:"member"`
	AttendStatus AttendStatus `json:"attend_status"`
}

func (q *Queries) GetPluralMembersWithAttendStatusUseNumberedPaginate(ctx context.Context, arg GetPluralMembersWithAttendStatusUseNumberedPaginateParams) ([]GetPluralMembersWithAttendStatusUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getPluralMembersWithAttendStatusUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.MemberIds,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralMembersWithAttendStatusUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetPluralMembersWithAttendStatusUseNumberedPaginateRow
		if err := rows.Scan(
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageID,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
			&i.AttendStatus.MAttendStatusesPkey,
			&i.AttendStatus.AttendStatusID,
			&i.AttendStatus.Name,
			&i.AttendStatus.Key,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralMembersWithGrade = `-- name: GetPluralMembersWithGrade :many
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_grades.m_grades_pkey, m_grades.grade_id, m_grades.key, m_grades.organization_id FROM m_members
LEFT JOIN m_grades ON m_members.grade_id = m_grades.grade_id
LEFT JOIN m_organizations ON m_grades.organization_id = m_organizations.organization_id
WHERE member_id = ANY($1::uuid[])
ORDER BY
	CASE WHEN $2::text = 'name' THEN m_members.name END ASC,
	CASE WHEN $2::text = 'r_name' THEN m_members.name END DESC,
	m_members_pkey ASC
`

type GetPluralMembersWithGradeParams struct {
	MemberIds   []uuid.UUID `json:"member_ids"`
	OrderMethod string      `json:"order_method"`
}

type GetPluralMembersWithGradeRow struct {
	Member Member `json:"member"`
	Grade  Grade  `json:"grade"`
}

func (q *Queries) GetPluralMembersWithGrade(ctx context.Context, arg GetPluralMembersWithGradeParams) ([]GetPluralMembersWithGradeRow, error) {
	rows, err := q.db.Query(ctx, getPluralMembersWithGrade, arg.MemberIds, arg.OrderMethod)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralMembersWithGradeRow{}
	for rows.Next() {
		var i GetPluralMembersWithGradeRow
		if err := rows.Scan(
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageID,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
			&i.Grade.MGradesPkey,
			&i.Grade.GradeID,
			&i.Grade.Key,
			&i.Grade.OrganizationID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralMembersWithGradeUseNumberedPaginate = `-- name: GetPluralMembersWithGradeUseNumberedPaginate :many
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_grades.m_grades_pkey, m_grades.grade_id, m_grades.key, m_grades.organization_id FROM m_members
LEFT JOIN m_grades ON m_members.grade_id = m_grades.grade_id
LEFT JOIN m_organizations ON m_grades.organization_id = m_organizations.organization_id
WHERE member_id = ANY($3::uuid[])
ORDER BY
	CASE WHEN $4::text = 'name' THEN m_members.name END ASC,
	CASE WHEN $4::text = 'r_name' THEN m_members.name END DESC,
	m_members_pkey ASC
LIMIT $1 OFFSET $2
`

type GetPluralMembersWithGradeUseNumberedPaginateParams struct {
	Limit       int32       `json:"limit"`
	Offset      int32       `json:"offset"`
	MemberIds   []uuid.UUID `json:"member_ids"`
	OrderMethod string      `json:"order_method"`
}

type GetPluralMembersWithGradeUseNumberedPaginateRow struct {
	Member Member `json:"member"`
	Grade  Grade  `json:"grade"`
}

func (q *Queries) GetPluralMembersWithGradeUseNumberedPaginate(ctx context.Context, arg GetPluralMembersWithGradeUseNumberedPaginateParams) ([]GetPluralMembersWithGradeUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getPluralMembersWithGradeUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.MemberIds,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralMembersWithGradeUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetPluralMembersWithGradeUseNumberedPaginateRow
		if err := rows.Scan(
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageID,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
			&i.Grade.MGradesPkey,
			&i.Grade.GradeID,
			&i.Grade.Key,
			&i.Grade.OrganizationID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralMembersWithGroup = `-- name: GetPluralMembersWithGroup :many
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_groups.m_groups_pkey, m_groups.group_id, m_groups.key, m_groups.organization_id FROM m_members
LEFT JOIN m_groups ON m_members.group_id = m_groups.group_id
LEFT JOIN m_organizations ON m_groups.organization_id = m_organizations.organization_id
WHERE member_id = ANY($1::uuid[])
ORDER BY
	CASE WHEN $2::text = 'name' THEN m_members.name END ASC,
	CASE WHEN $2::text = 'r_name' THEN m_members.name END DESC,
	m_members_pkey ASC
`

type GetPluralMembersWithGroupParams struct {
	MemberIds   []uuid.UUID `json:"member_ids"`
	OrderMethod string      `json:"order_method"`
}

type GetPluralMembersWithGroupRow struct {
	Member Member `json:"member"`
	Group  Group  `json:"group"`
}

func (q *Queries) GetPluralMembersWithGroup(ctx context.Context, arg GetPluralMembersWithGroupParams) ([]GetPluralMembersWithGroupRow, error) {
	rows, err := q.db.Query(ctx, getPluralMembersWithGroup, arg.MemberIds, arg.OrderMethod)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralMembersWithGroupRow{}
	for rows.Next() {
		var i GetPluralMembersWithGroupRow
		if err := rows.Scan(
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageID,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
			&i.Group.MGroupsPkey,
			&i.Group.GroupID,
			&i.Group.Key,
			&i.Group.OrganizationID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralMembersWithGroupUseNumberedPaginate = `-- name: GetPluralMembersWithGroupUseNumberedPaginate :many
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_groups.m_groups_pkey, m_groups.group_id, m_groups.key, m_groups.organization_id FROM m_members
LEFT JOIN m_groups ON m_members.group_id = m_groups.group_id
LEFT JOIN m_organizations ON m_groups.organization_id = m_organizations.organization_id
WHERE member_id = ANY($3::uuid[])
ORDER BY
	CASE WHEN $4::text = 'name' THEN m_members.name END ASC,
	CASE WHEN $4::text = 'r_name' THEN m_members.name END DESC,
	m_members_pkey ASC
LIMIT $1 OFFSET $2
`

type GetPluralMembersWithGroupUseNumberedPaginateParams struct {
	Limit       int32       `json:"limit"`
	Offset      int32       `json:"offset"`
	MemberIds   []uuid.UUID `json:"member_ids"`
	OrderMethod string      `json:"order_method"`
}

type GetPluralMembersWithGroupUseNumberedPaginateRow struct {
	Member Member `json:"member"`
	Group  Group  `json:"group"`
}

func (q *Queries) GetPluralMembersWithGroupUseNumberedPaginate(ctx context.Context, arg GetPluralMembersWithGroupUseNumberedPaginateParams) ([]GetPluralMembersWithGroupUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getPluralMembersWithGroupUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.MemberIds,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralMembersWithGroupUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetPluralMembersWithGroupUseNumberedPaginateRow
		if err := rows.Scan(
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageID,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
			&i.Group.MGroupsPkey,
			&i.Group.GroupID,
			&i.Group.Key,
			&i.Group.OrganizationID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralMembersWithPersonalOrganization = `-- name: GetPluralMembersWithPersonalOrganization :many
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.color, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at, m_organizations.chat_room_id FROM m_members
LEFT JOIN m_organizations ON m_members.personal_organization_id = m_organizations.organization_id
WHERE member_id = ANY($1::uuid[])
ORDER BY
	CASE WHEN $2::text = 'name' THEN m_members.name END ASC,
	CASE WHEN $2::text = 'r_name' THEN m_members.name END DESC,
	m_members_pkey ASC
`

type GetPluralMembersWithPersonalOrganizationParams struct {
	MemberIds   []uuid.UUID `json:"member_ids"`
	OrderMethod string      `json:"order_method"`
}

type GetPluralMembersWithPersonalOrganizationRow struct {
	Member       Member       `json:"member"`
	Organization Organization `json:"organization"`
}

func (q *Queries) GetPluralMembersWithPersonalOrganization(ctx context.Context, arg GetPluralMembersWithPersonalOrganizationParams) ([]GetPluralMembersWithPersonalOrganizationRow, error) {
	rows, err := q.db.Query(ctx, getPluralMembersWithPersonalOrganization, arg.MemberIds, arg.OrderMethod)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralMembersWithPersonalOrganizationRow{}
	for rows.Next() {
		var i GetPluralMembersWithPersonalOrganizationRow
		if err := rows.Scan(
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageID,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
			&i.Organization.MOrganizationsPkey,
			&i.Organization.OrganizationID,
			&i.Organization.Name,
			&i.Organization.Description,
			&i.Organization.Color,
			&i.Organization.IsPersonal,
			&i.Organization.IsWhole,
			&i.Organization.CreatedAt,
			&i.Organization.UpdatedAt,
			&i.Organization.ChatRoomID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralMembersWithPersonalOrganizationUseNumberedPaginate = `-- name: GetPluralMembersWithPersonalOrganizationUseNumberedPaginate :many
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.color, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at, m_organizations.chat_room_id FROM m_members
LEFT JOIN m_organizations ON m_members.personal_organization_id = m_organizations.organization_id
WHERE member_id = ANY($3::uuid[])
ORDER BY
	CASE WHEN $4::text = 'name' THEN m_members.name END ASC,
	CASE WHEN $4::text = 'r_name' THEN m_members.name END DESC,
	m_members_pkey ASC
LIMIT $1 OFFSET $2
`

type GetPluralMembersWithPersonalOrganizationUseNumberedPaginateParams struct {
	Limit       int32       `json:"limit"`
	Offset      int32       `json:"offset"`
	MemberIds   []uuid.UUID `json:"member_ids"`
	OrderMethod string      `json:"order_method"`
}

type GetPluralMembersWithPersonalOrganizationUseNumberedPaginateRow struct {
	Member       Member       `json:"member"`
	Organization Organization `json:"organization"`
}

func (q *Queries) GetPluralMembersWithPersonalOrganizationUseNumberedPaginate(ctx context.Context, arg GetPluralMembersWithPersonalOrganizationUseNumberedPaginateParams) ([]GetPluralMembersWithPersonalOrganizationUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getPluralMembersWithPersonalOrganizationUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.MemberIds,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralMembersWithPersonalOrganizationUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetPluralMembersWithPersonalOrganizationUseNumberedPaginateRow
		if err := rows.Scan(
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageID,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
			&i.Organization.MOrganizationsPkey,
			&i.Organization.OrganizationID,
			&i.Organization.Name,
			&i.Organization.Description,
			&i.Organization.Color,
			&i.Organization.IsPersonal,
			&i.Organization.IsWhole,
			&i.Organization.CreatedAt,
			&i.Organization.UpdatedAt,
			&i.Organization.ChatRoomID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralMembersWithRole = `-- name: GetPluralMembersWithRole :many
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_roles.m_roles_pkey, m_roles.role_id, m_roles.name, m_roles.description, m_roles.created_at, m_roles.updated_at FROM m_members
LEFT JOIN m_roles ON m_members.role_id = m_roles.role_id
WHERE member_id = ANY($1::uuid[])
ORDER BY
	CASE WHEN $2::text = 'name' THEN m_members.name END ASC,
	CASE WHEN $2::text = 'r_name' THEN m_members.name END DESC,
	m_members_pkey ASC
`

type GetPluralMembersWithRoleParams struct {
	MemberIds   []uuid.UUID `json:"member_ids"`
	OrderMethod string      `json:"order_method"`
}

type GetPluralMembersWithRoleRow struct {
	Member Member `json:"member"`
	Role   Role   `json:"role"`
}

func (q *Queries) GetPluralMembersWithRole(ctx context.Context, arg GetPluralMembersWithRoleParams) ([]GetPluralMembersWithRoleRow, error) {
	rows, err := q.db.Query(ctx, getPluralMembersWithRole, arg.MemberIds, arg.OrderMethod)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralMembersWithRoleRow{}
	for rows.Next() {
		var i GetPluralMembersWithRoleRow
		if err := rows.Scan(
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageID,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
			&i.Role.MRolesPkey,
			&i.Role.RoleID,
			&i.Role.Name,
			&i.Role.Description,
			&i.Role.CreatedAt,
			&i.Role.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralMembersWithRoleUseNumberedPaginate = `-- name: GetPluralMembersWithRoleUseNumberedPaginate :many
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_roles.m_roles_pkey, m_roles.role_id, m_roles.name, m_roles.description, m_roles.created_at, m_roles.updated_at FROM m_members
LEFT JOIN m_roles ON m_members.role_id = m_roles.role_id
WHERE member_id = ANY($3::uuid[])
ORDER BY
	CASE WHEN $4::text = 'name' THEN m_members.name END ASC,
	CASE WHEN $4::text = 'r_name' THEN m_members.name END DESC,
	m_members_pkey ASC
LIMIT $1 OFFSET $2
`

type GetPluralMembersWithRoleUseNumberedPaginateParams struct {
	Limit       int32       `json:"limit"`
	Offset      int32       `json:"offset"`
	MemberIds   []uuid.UUID `json:"member_ids"`
	OrderMethod string      `json:"order_method"`
}

type GetPluralMembersWithRoleUseNumberedPaginateRow struct {
	Member Member `json:"member"`
	Role   Role   `json:"role"`
}

func (q *Queries) GetPluralMembersWithRoleUseNumberedPaginate(ctx context.Context, arg GetPluralMembersWithRoleUseNumberedPaginateParams) ([]GetPluralMembersWithRoleUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getPluralMembersWithRoleUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.MemberIds,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralMembersWithRoleUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetPluralMembersWithRoleUseNumberedPaginateRow
		if err := rows.Scan(
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageID,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
			&i.Role.MRolesPkey,
			&i.Role.RoleID,
			&i.Role.Name,
			&i.Role.Description,
			&i.Role.CreatedAt,
			&i.Role.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const pluralDeleteMembers = `-- name: PluralDeleteMembers :execrows
DELETE FROM m_members WHERE member_id = ANY($1::uuid[])
`

func (q *Queries) PluralDeleteMembers(ctx context.Context, memberIds []uuid.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, pluralDeleteMembers, memberIds)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateMember = `-- name: UpdateMember :one
UPDATE m_members SET email = $2, name = $3, profile_image_id = $4, updated_at = $5 WHERE member_id = $1 RETURNING m_members_pkey, member_id, login_id, password, email, name, attend_status_id, profile_image_id, grade_id, group_id, personal_organization_id, role_id, created_at, updated_at
`

type UpdateMemberParams struct {
	MemberID       uuid.UUID   `json:"member_id"`
	Email          string      `json:"email"`
	Name           string      `json:"name"`
	ProfileImageID pgtype.UUID `json:"profile_image_id"`
	UpdatedAt      time.Time   `json:"updated_at"`
}

func (q *Queries) UpdateMember(ctx context.Context, arg UpdateMemberParams) (Member, error) {
	row := q.db.QueryRow(ctx, updateMember,
		arg.MemberID,
		arg.Email,
		arg.Name,
		arg.ProfileImageID,
		arg.UpdatedAt,
	)
	var i Member
	err := row.Scan(
		&i.MMembersPkey,
		&i.MemberID,
		&i.LoginID,
		&i.Password,
		&i.Email,
		&i.Name,
		&i.AttendStatusID,
		&i.ProfileImageID,
		&i.GradeID,
		&i.GroupID,
		&i.PersonalOrganizationID,
		&i.RoleID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateMemberAttendStatus = `-- name: UpdateMemberAttendStatus :one
UPDATE m_members SET attend_status_id = $2, updated_at = $3 WHERE member_id = $1 RETURNING m_members_pkey, member_id, login_id, password, email, name, attend_status_id, profile_image_id, grade_id, group_id, personal_organization_id, role_id, created_at, updated_at
`

type UpdateMemberAttendStatusParams struct {
	MemberID       uuid.UUID `json:"member_id"`
	AttendStatusID uuid.UUID `json:"attend_status_id"`
	UpdatedAt      time.Time `json:"updated_at"`
}

func (q *Queries) UpdateMemberAttendStatus(ctx context.Context, arg UpdateMemberAttendStatusParams) (Member, error) {
	row := q.db.QueryRow(ctx, updateMemberAttendStatus, arg.MemberID, arg.AttendStatusID, arg.UpdatedAt)
	var i Member
	err := row.Scan(
		&i.MMembersPkey,
		&i.MemberID,
		&i.LoginID,
		&i.Password,
		&i.Email,
		&i.Name,
		&i.AttendStatusID,
		&i.ProfileImageID,
		&i.GradeID,
		&i.GroupID,
		&i.PersonalOrganizationID,
		&i.RoleID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateMemberGrade = `-- name: UpdateMemberGrade :one
UPDATE m_members SET grade_id = $2, updated_at = $3 WHERE member_id = $1 RETURNING m_members_pkey, member_id, login_id, password, email, name, attend_status_id, profile_image_id, grade_id, group_id, personal_organization_id, role_id, created_at, updated_at
`

type UpdateMemberGradeParams struct {
	MemberID  uuid.UUID `json:"member_id"`
	GradeID   uuid.UUID `json:"grade_id"`
	UpdatedAt time.Time `json:"updated_at"`
}

func (q *Queries) UpdateMemberGrade(ctx context.Context, arg UpdateMemberGradeParams) (Member, error) {
	row := q.db.QueryRow(ctx, updateMemberGrade, arg.MemberID, arg.GradeID, arg.UpdatedAt)
	var i Member
	err := row.Scan(
		&i.MMembersPkey,
		&i.MemberID,
		&i.LoginID,
		&i.Password,
		&i.Email,
		&i.Name,
		&i.AttendStatusID,
		&i.ProfileImageID,
		&i.GradeID,
		&i.GroupID,
		&i.PersonalOrganizationID,
		&i.RoleID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateMemberGroup = `-- name: UpdateMemberGroup :one
UPDATE m_members SET group_id = $2, updated_at = $3 WHERE member_id = $1 RETURNING m_members_pkey, member_id, login_id, password, email, name, attend_status_id, profile_image_id, grade_id, group_id, personal_organization_id, role_id, created_at, updated_at
`

type UpdateMemberGroupParams struct {
	MemberID  uuid.UUID `json:"member_id"`
	GroupID   uuid.UUID `json:"group_id"`
	UpdatedAt time.Time `json:"updated_at"`
}

func (q *Queries) UpdateMemberGroup(ctx context.Context, arg UpdateMemberGroupParams) (Member, error) {
	row := q.db.QueryRow(ctx, updateMemberGroup, arg.MemberID, arg.GroupID, arg.UpdatedAt)
	var i Member
	err := row.Scan(
		&i.MMembersPkey,
		&i.MemberID,
		&i.LoginID,
		&i.Password,
		&i.Email,
		&i.Name,
		&i.AttendStatusID,
		&i.ProfileImageID,
		&i.GradeID,
		&i.GroupID,
		&i.PersonalOrganizationID,
		&i.RoleID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateMemberLoginID = `-- name: UpdateMemberLoginID :one
UPDATE m_members SET login_id = $2, updated_at = $3 WHERE member_id = $1 RETURNING m_members_pkey, member_id, login_id, password, email, name, attend_status_id, profile_image_id, grade_id, group_id, personal_organization_id, role_id, created_at, updated_at
`

type UpdateMemberLoginIDParams struct {
	MemberID  uuid.UUID `json:"member_id"`
	LoginID   string    `json:"login_id"`
	UpdatedAt time.Time `json:"updated_at"`
}

func (q *Queries) UpdateMemberLoginID(ctx context.Context, arg UpdateMemberLoginIDParams) (Member, error) {
	row := q.db.QueryRow(ctx, updateMemberLoginID, arg.MemberID, arg.LoginID, arg.UpdatedAt)
	var i Member
	err := row.Scan(
		&i.MMembersPkey,
		&i.MemberID,
		&i.LoginID,
		&i.Password,
		&i.Email,
		&i.Name,
		&i.AttendStatusID,
		&i.ProfileImageID,
		&i.GradeID,
		&i.GroupID,
		&i.PersonalOrganizationID,
		&i.RoleID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateMemberPassword = `-- name: UpdateMemberPassword :one
UPDATE m_members SET password = $2, updated_at = $3 WHERE member_id = $1 RETURNING m_members_pkey, member_id, login_id, password, email, name, attend_status_id, profile_image_id, grade_id, group_id, personal_organization_id, role_id, created_at, updated_at
`

type UpdateMemberPasswordParams struct {
	MemberID  uuid.UUID `json:"member_id"`
	Password  string    `json:"password"`
	UpdatedAt time.Time `json:"updated_at"`
}

func (q *Queries) UpdateMemberPassword(ctx context.Context, arg UpdateMemberPasswordParams) (Member, error) {
	row := q.db.QueryRow(ctx, updateMemberPassword, arg.MemberID, arg.Password, arg.UpdatedAt)
	var i Member
	err := row.Scan(
		&i.MMembersPkey,
		&i.MemberID,
		&i.LoginID,
		&i.Password,
		&i.Email,
		&i.Name,
		&i.AttendStatusID,
		&i.ProfileImageID,
		&i.GradeID,
		&i.GroupID,
		&i.PersonalOrganizationID,
		&i.RoleID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateMemberRole = `-- name: UpdateMemberRole :one
UPDATE m_members SET role_id = $2, updated_at = $3 WHERE member_id = $1 RETURNING m_members_pkey, member_id, login_id, password, email, name, attend_status_id, profile_image_id, grade_id, group_id, personal_organization_id, role_id, created_at, updated_at
`

type UpdateMemberRoleParams struct {
	MemberID  uuid.UUID   `json:"member_id"`
	RoleID    pgtype.UUID `json:"role_id"`
	UpdatedAt time.Time   `json:"updated_at"`
}

func (q *Queries) UpdateMemberRole(ctx context.Context, arg UpdateMemberRoleParams) (Member, error) {
	row := q.db.QueryRow(ctx, updateMemberRole, arg.MemberID, arg.RoleID, arg.UpdatedAt)
	var i Member
	err := row.Scan(
		&i.MMembersPkey,
		&i.MemberID,
		&i.LoginID,
		&i.Password,
		&i.Email,
		&i.Name,
		&i.AttendStatusID,
		&i.ProfileImageID,
		&i.GradeID,
		&i.GroupID,
		&i.PersonalOrganizationID,
		&i.RoleID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
