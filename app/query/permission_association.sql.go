// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: permission_association.sql

package query

import (
	"context"

	"github.com/google/uuid"
)

const countPermissionsOnWorkPosition = `-- name: CountPermissionsOnWorkPosition :one
SELECT COUNT(*) FROM m_permission_associations
LEFT JOIN m_permissions ON m_permission_associations.permission_id = m_permissions.permission_id
WHERE work_position_id = $1
AND
	CASE WHEN $2::boolean = true THEN m_permissions.name LIKE '%' || $3::text || '%' ELSE TRUE END
`

type CountPermissionsOnWorkPositionParams struct {
	WorkPositionID uuid.UUID `json:"work_position_id"`
	WhereLikeName  bool      `json:"where_like_name"`
	SearchName     string    `json:"search_name"`
}

func (q *Queries) CountPermissionsOnWorkPosition(ctx context.Context, arg CountPermissionsOnWorkPositionParams) (int64, error) {
	row := q.db.QueryRow(ctx, countPermissionsOnWorkPosition, arg.WorkPositionID, arg.WhereLikeName, arg.SearchName)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countWorkPositionsOnPermission = `-- name: CountWorkPositionsOnPermission :one
SELECT COUNT(*) FROM m_permission_associations
LEFT JOIN m_work_positions ON m_permission_associations.work_position_id = m_work_positions.work_position_id
WHERE permission_id = $1
AND
	CASE WHEN $2::boolean = true THEN m_work_positions.name LIKE '%' || $3::text || '%' ELSE TRUE END
`

type CountWorkPositionsOnPermissionParams struct {
	PermissionID  uuid.UUID `json:"permission_id"`
	WhereLikeName bool      `json:"where_like_name"`
	SearchName    string    `json:"search_name"`
}

func (q *Queries) CountWorkPositionsOnPermission(ctx context.Context, arg CountWorkPositionsOnPermissionParams) (int64, error) {
	row := q.db.QueryRow(ctx, countWorkPositionsOnPermission, arg.PermissionID, arg.WhereLikeName, arg.SearchName)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createPermissionAssociation = `-- name: CreatePermissionAssociation :one
INSERT INTO m_permission_associations (permission_id, work_position_id) VALUES ($1, $2) RETURNING m_permission_associations_pkey, permission_id, work_position_id
`

type CreatePermissionAssociationParams struct {
	PermissionID   uuid.UUID `json:"permission_id"`
	WorkPositionID uuid.UUID `json:"work_position_id"`
}

func (q *Queries) CreatePermissionAssociation(ctx context.Context, arg CreatePermissionAssociationParams) (PermissionAssociation, error) {
	row := q.db.QueryRow(ctx, createPermissionAssociation, arg.PermissionID, arg.WorkPositionID)
	var i PermissionAssociation
	err := row.Scan(&i.MPermissionAssociationsPkey, &i.PermissionID, &i.WorkPositionID)
	return i, err
}

type CreatePermissionAssociationsParams struct {
	PermissionID   uuid.UUID `json:"permission_id"`
	WorkPositionID uuid.UUID `json:"work_position_id"`
}

const deletePermissionAssociation = `-- name: DeletePermissionAssociation :exec
DELETE FROM m_permission_associations WHERE permission_id = $1 AND work_position_id = $2
`

type DeletePermissionAssociationParams struct {
	PermissionID   uuid.UUID `json:"permission_id"`
	WorkPositionID uuid.UUID `json:"work_position_id"`
}

func (q *Queries) DeletePermissionAssociation(ctx context.Context, arg DeletePermissionAssociationParams) error {
	_, err := q.db.Exec(ctx, deletePermissionAssociation, arg.PermissionID, arg.WorkPositionID)
	return err
}

const getPermissionsOnWorkPosition = `-- name: GetPermissionsOnWorkPosition :many
SELECT m_permission_associations.m_permission_associations_pkey, m_permission_associations.permission_id, m_permission_associations.work_position_id, m_permissions.m_permissions_pkey, m_permissions.permission_id, m_permissions.name, m_permissions.description, m_permissions.key, m_permissions.permission_category_id FROM m_permission_associations
LEFT JOIN m_permissions ON m_permission_associations.permission_id = m_permissions.permission_id
WHERE work_position_id = $1
AND
	CASE WHEN $4::boolean = true THEN m_permissions.name LIKE '%' || $5::text || '%' ELSE TRUE END
ORDER BY
	CASE WHEN $6::text = 'name' THEN m_permissions.name END ASC,
	m_permission_associations_pkey DESC
LIMIT $2 OFFSET $3
`

type GetPermissionsOnWorkPositionParams struct {
	WorkPositionID uuid.UUID `json:"work_position_id"`
	Limit          int32     `json:"limit"`
	Offset         int32     `json:"offset"`
	WhereLikeName  bool      `json:"where_like_name"`
	SearchName     string    `json:"search_name"`
	OrderMethod    string    `json:"order_method"`
}

type GetPermissionsOnWorkPositionRow struct {
	PermissionAssociation PermissionAssociation `json:"permission_association"`
	Permission            Permission            `json:"permission"`
}

func (q *Queries) GetPermissionsOnWorkPosition(ctx context.Context, arg GetPermissionsOnWorkPositionParams) ([]GetPermissionsOnWorkPositionRow, error) {
	rows, err := q.db.Query(ctx, getPermissionsOnWorkPosition,
		arg.WorkPositionID,
		arg.Limit,
		arg.Offset,
		arg.WhereLikeName,
		arg.SearchName,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPermissionsOnWorkPositionRow{}
	for rows.Next() {
		var i GetPermissionsOnWorkPositionRow
		if err := rows.Scan(
			&i.PermissionAssociation.MPermissionAssociationsPkey,
			&i.PermissionAssociation.PermissionID,
			&i.PermissionAssociation.WorkPositionID,
			&i.Permission.MPermissionsPkey,
			&i.Permission.PermissionID,
			&i.Permission.Name,
			&i.Permission.Description,
			&i.Permission.Key,
			&i.Permission.PermissionCategoryID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWorkPositionsOnPermission = `-- name: GetWorkPositionsOnPermission :many
SELECT m_permission_associations.m_permission_associations_pkey, m_permission_associations.permission_id, m_permission_associations.work_position_id, m_work_positions.m_work_positions_pkey, m_work_positions.work_position_id, m_work_positions.name, m_work_positions.description, m_work_positions.created_at, m_work_positions.updated_at FROM m_permission_associations
LEFT JOIN m_work_positions ON m_permission_associations.work_position_id = m_work_positions.work_position_id
WHERE permission_id = $1
AND
	CASE WHEN $4::boolean = true THEN m_work_positions.name LIKE '%' || $5::text || '%' ELSE TRUE END
ORDER BY
	CASE WHEN $6::text = 'name' THEN m_work_positions.name END ASC,
	CASE WHEN $6::text = 'r_name' THEN m_work_positions.name END DESC,
	m_permission_associations_pkey DESC
LIMIT $2 OFFSET $3
`

type GetWorkPositionsOnPermissionParams struct {
	PermissionID  uuid.UUID `json:"permission_id"`
	Limit         int32     `json:"limit"`
	Offset        int32     `json:"offset"`
	WhereLikeName bool      `json:"where_like_name"`
	SearchName    string    `json:"search_name"`
	OrderMethod   string    `json:"order_method"`
}

type GetWorkPositionsOnPermissionRow struct {
	PermissionAssociation PermissionAssociation `json:"permission_association"`
	WorkPosition          WorkPosition          `json:"work_position"`
}

func (q *Queries) GetWorkPositionsOnPermission(ctx context.Context, arg GetWorkPositionsOnPermissionParams) ([]GetWorkPositionsOnPermissionRow, error) {
	rows, err := q.db.Query(ctx, getWorkPositionsOnPermission,
		arg.PermissionID,
		arg.Limit,
		arg.Offset,
		arg.WhereLikeName,
		arg.SearchName,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetWorkPositionsOnPermissionRow{}
	for rows.Next() {
		var i GetWorkPositionsOnPermissionRow
		if err := rows.Scan(
			&i.PermissionAssociation.MPermissionAssociationsPkey,
			&i.PermissionAssociation.PermissionID,
			&i.PermissionAssociation.WorkPositionID,
			&i.WorkPosition.MWorkPositionsPkey,
			&i.WorkPosition.WorkPositionID,
			&i.WorkPosition.Name,
			&i.WorkPosition.Description,
			&i.WorkPosition.CreatedAt,
			&i.WorkPosition.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
