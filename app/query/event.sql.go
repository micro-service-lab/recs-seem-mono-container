// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: event.sql

package query

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countEvents = `-- name: CountEvents :one
SELECT COUNT(*) FROM t_events
WHERE
	CASE WHEN $1::boolean = true THEN title LIKE '%' || $2::text || '%' ELSE TRUE END
AND
	CASE WHEN $3::boolean = true THEN t_events.organization_id = $4 ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN mail_send_flag = $6 ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN send_organization_id = $8 ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN start_time >= $10 ELSE TRUE END
AND
	CASE WHEN $11::boolean = true THEN start_time <= $12 ELSE TRUE END
AND
	CASE WHEN $13::boolean = true THEN end_time >= $14 ELSE TRUE END
AND
	CASE WHEN $15::boolean = true THEN end_time <= $16 ELSE TRUE END
`

type CountEventsParams struct {
	WhereLikeTitle        bool        `json:"where_like_title"`
	SearchTitle           string      `json:"search_title"`
	WhereOrganization     bool        `json:"where_organization"`
	OrganizationID        pgtype.UUID `json:"organization_id"`
	WhereMailSendFlag     bool        `json:"where_mail_send_flag"`
	MailSendFlag          bool        `json:"mail_send_flag"`
	WhereSendOrganization bool        `json:"where_send_organization"`
	SendOrganizationID    pgtype.UUID `json:"send_organization_id"`
	WhereEarlierStartTime bool        `json:"where_earlier_start_time"`
	EarlierStartTime      time.Time   `json:"earlier_start_time"`
	WhereLaterStartTime   bool        `json:"where_later_start_time"`
	LaterStartTime        time.Time   `json:"later_start_time"`
	WhereEarlierEndTime   bool        `json:"where_earlier_end_time"`
	EarlierEndTime        time.Time   `json:"earlier_end_time"`
	WhereLaterEndTime     bool        `json:"where_later_end_time"`
	LaterEndTime          time.Time   `json:"later_end_time"`
}

func (q *Queries) CountEvents(ctx context.Context, arg CountEventsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countEvents,
		arg.WhereLikeTitle,
		arg.SearchTitle,
		arg.WhereOrganization,
		arg.OrganizationID,
		arg.WhereMailSendFlag,
		arg.MailSendFlag,
		arg.WhereSendOrganization,
		arg.SendOrganizationID,
		arg.WhereEarlierStartTime,
		arg.EarlierStartTime,
		arg.WhereLaterStartTime,
		arg.LaterStartTime,
		arg.WhereEarlierEndTime,
		arg.EarlierEndTime,
		arg.WhereLaterEndTime,
		arg.LaterEndTime,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createEvent = `-- name: CreateEvent :one
INSERT INTO t_events (event_type_id, title, description, organization_id, start_time, end_time, mail_send_flag, send_organization_id, posted_by, last_edited_by, posted_at, last_edited_at) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12) RETURNING t_events_pkey, event_id, event_type_id, title, description, organization_id, start_time, end_time, mail_send_flag, send_organization_id, posted_by, last_edited_by, posted_at, last_edited_at
`

type CreateEventParams struct {
	EventTypeID        uuid.UUID   `json:"event_type_id"`
	Title              string      `json:"title"`
	Description        pgtype.Text `json:"description"`
	OrganizationID     pgtype.UUID `json:"organization_id"`
	StartTime          time.Time   `json:"start_time"`
	EndTime            time.Time   `json:"end_time"`
	MailSendFlag       bool        `json:"mail_send_flag"`
	SendOrganizationID pgtype.UUID `json:"send_organization_id"`
	PostedBy           pgtype.UUID `json:"posted_by"`
	LastEditedBy       pgtype.UUID `json:"last_edited_by"`
	PostedAt           time.Time   `json:"posted_at"`
	LastEditedAt       time.Time   `json:"last_edited_at"`
}

func (q *Queries) CreateEvent(ctx context.Context, arg CreateEventParams) (Event, error) {
	row := q.db.QueryRow(ctx, createEvent,
		arg.EventTypeID,
		arg.Title,
		arg.Description,
		arg.OrganizationID,
		arg.StartTime,
		arg.EndTime,
		arg.MailSendFlag,
		arg.SendOrganizationID,
		arg.PostedBy,
		arg.LastEditedBy,
		arg.PostedAt,
		arg.LastEditedAt,
	)
	var i Event
	err := row.Scan(
		&i.TEventsPkey,
		&i.EventID,
		&i.EventTypeID,
		&i.Title,
		&i.Description,
		&i.OrganizationID,
		&i.StartTime,
		&i.EndTime,
		&i.MailSendFlag,
		&i.SendOrganizationID,
		&i.PostedBy,
		&i.LastEditedBy,
		&i.PostedAt,
		&i.LastEditedAt,
	)
	return i, err
}

type CreateEventsParams struct {
	EventTypeID        uuid.UUID   `json:"event_type_id"`
	Title              string      `json:"title"`
	Description        pgtype.Text `json:"description"`
	OrganizationID     pgtype.UUID `json:"organization_id"`
	StartTime          time.Time   `json:"start_time"`
	EndTime            time.Time   `json:"end_time"`
	MailSendFlag       bool        `json:"mail_send_flag"`
	SendOrganizationID pgtype.UUID `json:"send_organization_id"`
	PostedBy           pgtype.UUID `json:"posted_by"`
	LastEditedBy       pgtype.UUID `json:"last_edited_by"`
	PostedAt           time.Time   `json:"posted_at"`
	LastEditedAt       time.Time   `json:"last_edited_at"`
}

const deleteEvent = `-- name: DeleteEvent :exec
DELETE FROM t_events WHERE event_id = $1
`

func (q *Queries) DeleteEvent(ctx context.Context, eventID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteEvent, eventID)
	return err
}

const deleteEventOnOrganization = `-- name: DeleteEventOnOrganization :exec
DELETE FROM t_events WHERE organization_id = $1
`

func (q *Queries) DeleteEventOnOrganization(ctx context.Context, organizationID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteEventOnOrganization, organizationID)
	return err
}

const findEventByID = `-- name: FindEventByID :one
SELECT t_events_pkey, event_id, event_type_id, title, description, organization_id, start_time, end_time, mail_send_flag, send_organization_id, posted_by, last_edited_by, posted_at, last_edited_at FROM t_events WHERE event_id = $1
`

func (q *Queries) FindEventByID(ctx context.Context, eventID uuid.UUID) (Event, error) {
	row := q.db.QueryRow(ctx, findEventByID, eventID)
	var i Event
	err := row.Scan(
		&i.TEventsPkey,
		&i.EventID,
		&i.EventTypeID,
		&i.Title,
		&i.Description,
		&i.OrganizationID,
		&i.StartTime,
		&i.EndTime,
		&i.MailSendFlag,
		&i.SendOrganizationID,
		&i.PostedBy,
		&i.LastEditedBy,
		&i.PostedAt,
		&i.LastEditedAt,
	)
	return i, err
}

const findEventByIDWithAll = `-- name: FindEventByIDWithAll :one
SELECT t_events.t_events_pkey, t_events.event_id, t_events.event_type_id, t_events.title, t_events.description, t_events.organization_id, t_events.start_time, t_events.end_time, t_events.mail_send_flag, t_events.send_organization_id, t_events.posted_by, t_events.last_edited_by, t_events.posted_at, t_events.last_edited_at, o.m_event_types_pkey, o.event_type_id, o.name, o.key, o.color, s.m_organizations_pkey, s.organization_id, s.name, s.description, s.color, s.is_personal, s.is_whole, s.created_at, s.updated_at, s.chat_room_id, send_organizations.m_organizations_pkey, send_organizations.organization_id, send_organizations.name, send_organizations.description, send_organizations.color, send_organizations.is_personal, send_organizations.is_whole, send_organizations.created_at, send_organizations.updated_at, send_organizations.chat_room_id, l.m_members_pkey, l.member_id, l.login_id, l.password, l.email, l.name, l.attend_status_id, l.profile_image_url, l.grade_id, l.group_id, l.personal_organization_id, l.role_id, l.created_at, l.updated_at FROM t_events
LEFT JOIN m_event_types o ON t_events.event_type_id = o.event_type_id
LEFT JOIN m_organizations s ON t_events.organization_id = s.organization_id
LEFT JOIN m_organizations send_organizations ON t_events.send_organization_id = p.organization_id
LEFT JOIN m_members l ON t_events.posted_by = l.member_id
WHERE event_id = $1
`

type FindEventByIDWithAllRow struct {
	Event              Event              `json:"event"`
	EventType          EventType          `json:"event_type"`
	Organization       Organization       `json:"organization"`
	MOrganizationsPkey pgtype.Int8        `json:"m_organizations_pkey"`
	OrganizationID     pgtype.UUID        `json:"organization_id"`
	Name               pgtype.Text        `json:"name"`
	Description        pgtype.Text        `json:"description"`
	Color              pgtype.Text        `json:"color"`
	IsPersonal         pgtype.Bool        `json:"is_personal"`
	IsWhole            pgtype.Bool        `json:"is_whole"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
	ChatRoomID         pgtype.UUID        `json:"chat_room_id"`
	Member             Member             `json:"member"`
}

func (q *Queries) FindEventByIDWithAll(ctx context.Context, eventID uuid.UUID) (FindEventByIDWithAllRow, error) {
	row := q.db.QueryRow(ctx, findEventByIDWithAll, eventID)
	var i FindEventByIDWithAllRow
	err := row.Scan(
		&i.Event.TEventsPkey,
		&i.Event.EventID,
		&i.Event.EventTypeID,
		&i.Event.Title,
		&i.Event.Description,
		&i.Event.OrganizationID,
		&i.Event.StartTime,
		&i.Event.EndTime,
		&i.Event.MailSendFlag,
		&i.Event.SendOrganizationID,
		&i.Event.PostedBy,
		&i.Event.LastEditedBy,
		&i.Event.PostedAt,
		&i.Event.LastEditedAt,
		&i.EventType.MEventTypesPkey,
		&i.EventType.EventTypeID,
		&i.EventType.Name,
		&i.EventType.Key,
		&i.EventType.Color,
		&i.Organization.MOrganizationsPkey,
		&i.Organization.OrganizationID,
		&i.Organization.Name,
		&i.Organization.Description,
		&i.Organization.Color,
		&i.Organization.IsPersonal,
		&i.Organization.IsWhole,
		&i.Organization.CreatedAt,
		&i.Organization.UpdatedAt,
		&i.Organization.ChatRoomID,
		&i.MOrganizationsPkey,
		&i.OrganizationID,
		&i.Name,
		&i.Description,
		&i.Color,
		&i.IsPersonal,
		&i.IsWhole,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ChatRoomID,
		&i.Member.MMembersPkey,
		&i.Member.MemberID,
		&i.Member.LoginID,
		&i.Member.Password,
		&i.Member.Email,
		&i.Member.Name,
		&i.Member.AttendStatusID,
		&i.Member.ProfileImageUrl,
		&i.Member.GradeID,
		&i.Member.GroupID,
		&i.Member.PersonalOrganizationID,
		&i.Member.RoleID,
		&i.Member.CreatedAt,
		&i.Member.UpdatedAt,
	)
	return i, err
}

const findEventByIDWithLastEditUser = `-- name: FindEventByIDWithLastEditUser :one
SELECT t_events.t_events_pkey, t_events.event_id, t_events.event_type_id, t_events.title, t_events.description, t_events.organization_id, t_events.start_time, t_events.end_time, t_events.mail_send_flag, t_events.send_organization_id, t_events.posted_by, t_events.last_edited_by, t_events.posted_at, t_events.last_edited_at, m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_url, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at FROM t_events
LEFT JOIN m_members ON t_events.last_edited_by = m_members.member_id
WHERE event_id = $1
`

type FindEventByIDWithLastEditUserRow struct {
	Event  Event  `json:"event"`
	Member Member `json:"member"`
}

func (q *Queries) FindEventByIDWithLastEditUser(ctx context.Context, eventID uuid.UUID) (FindEventByIDWithLastEditUserRow, error) {
	row := q.db.QueryRow(ctx, findEventByIDWithLastEditUser, eventID)
	var i FindEventByIDWithLastEditUserRow
	err := row.Scan(
		&i.Event.TEventsPkey,
		&i.Event.EventID,
		&i.Event.EventTypeID,
		&i.Event.Title,
		&i.Event.Description,
		&i.Event.OrganizationID,
		&i.Event.StartTime,
		&i.Event.EndTime,
		&i.Event.MailSendFlag,
		&i.Event.SendOrganizationID,
		&i.Event.PostedBy,
		&i.Event.LastEditedBy,
		&i.Event.PostedAt,
		&i.Event.LastEditedAt,
		&i.Member.MMembersPkey,
		&i.Member.MemberID,
		&i.Member.LoginID,
		&i.Member.Password,
		&i.Member.Email,
		&i.Member.Name,
		&i.Member.AttendStatusID,
		&i.Member.ProfileImageUrl,
		&i.Member.GradeID,
		&i.Member.GroupID,
		&i.Member.PersonalOrganizationID,
		&i.Member.RoleID,
		&i.Member.CreatedAt,
		&i.Member.UpdatedAt,
	)
	return i, err
}

const findEventByIDWithOrganization = `-- name: FindEventByIDWithOrganization :one
SELECT t_events.t_events_pkey, t_events.event_id, t_events.event_type_id, t_events.title, t_events.description, t_events.organization_id, t_events.start_time, t_events.end_time, t_events.mail_send_flag, t_events.send_organization_id, t_events.posted_by, t_events.last_edited_by, t_events.posted_at, t_events.last_edited_at, m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.color, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at, m_organizations.chat_room_id FROM t_events
LEFT JOIN m_organizations ON t_events.organization_id = m_organizations.organization_id
WHERE event_id = $1
`

type FindEventByIDWithOrganizationRow struct {
	Event        Event        `json:"event"`
	Organization Organization `json:"organization"`
}

func (q *Queries) FindEventByIDWithOrganization(ctx context.Context, eventID uuid.UUID) (FindEventByIDWithOrganizationRow, error) {
	row := q.db.QueryRow(ctx, findEventByIDWithOrganization, eventID)
	var i FindEventByIDWithOrganizationRow
	err := row.Scan(
		&i.Event.TEventsPkey,
		&i.Event.EventID,
		&i.Event.EventTypeID,
		&i.Event.Title,
		&i.Event.Description,
		&i.Event.OrganizationID,
		&i.Event.StartTime,
		&i.Event.EndTime,
		&i.Event.MailSendFlag,
		&i.Event.SendOrganizationID,
		&i.Event.PostedBy,
		&i.Event.LastEditedBy,
		&i.Event.PostedAt,
		&i.Event.LastEditedAt,
		&i.Organization.MOrganizationsPkey,
		&i.Organization.OrganizationID,
		&i.Organization.Name,
		&i.Organization.Description,
		&i.Organization.Color,
		&i.Organization.IsPersonal,
		&i.Organization.IsWhole,
		&i.Organization.CreatedAt,
		&i.Organization.UpdatedAt,
		&i.Organization.ChatRoomID,
	)
	return i, err
}

const findEventByIDWithPostUser = `-- name: FindEventByIDWithPostUser :one
SELECT t_events.t_events_pkey, t_events.event_id, t_events.event_type_id, t_events.title, t_events.description, t_events.organization_id, t_events.start_time, t_events.end_time, t_events.mail_send_flag, t_events.send_organization_id, t_events.posted_by, t_events.last_edited_by, t_events.posted_at, t_events.last_edited_at, m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_url, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at FROM t_events
LEFT JOIN m_members ON t_events.posted_by = m_members.member_id
WHERE event_id = $1
`

type FindEventByIDWithPostUserRow struct {
	Event  Event  `json:"event"`
	Member Member `json:"member"`
}

func (q *Queries) FindEventByIDWithPostUser(ctx context.Context, eventID uuid.UUID) (FindEventByIDWithPostUserRow, error) {
	row := q.db.QueryRow(ctx, findEventByIDWithPostUser, eventID)
	var i FindEventByIDWithPostUserRow
	err := row.Scan(
		&i.Event.TEventsPkey,
		&i.Event.EventID,
		&i.Event.EventTypeID,
		&i.Event.Title,
		&i.Event.Description,
		&i.Event.OrganizationID,
		&i.Event.StartTime,
		&i.Event.EndTime,
		&i.Event.MailSendFlag,
		&i.Event.SendOrganizationID,
		&i.Event.PostedBy,
		&i.Event.LastEditedBy,
		&i.Event.PostedAt,
		&i.Event.LastEditedAt,
		&i.Member.MMembersPkey,
		&i.Member.MemberID,
		&i.Member.LoginID,
		&i.Member.Password,
		&i.Member.Email,
		&i.Member.Name,
		&i.Member.AttendStatusID,
		&i.Member.ProfileImageUrl,
		&i.Member.GradeID,
		&i.Member.GroupID,
		&i.Member.PersonalOrganizationID,
		&i.Member.RoleID,
		&i.Member.CreatedAt,
		&i.Member.UpdatedAt,
	)
	return i, err
}

const findEventByIDWithSendOrganization = `-- name: FindEventByIDWithSendOrganization :one
SELECT t_events.t_events_pkey, t_events.event_id, t_events.event_type_id, t_events.title, t_events.description, t_events.organization_id, t_events.start_time, t_events.end_time, t_events.mail_send_flag, t_events.send_organization_id, t_events.posted_by, t_events.last_edited_by, t_events.posted_at, t_events.last_edited_at, m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.color, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at, m_organizations.chat_room_id FROM t_events
LEFT JOIN m_organizations ON t_events.send_organization_id = m_organizations.organization_id
WHERE event_id = $1
`

type FindEventByIDWithSendOrganizationRow struct {
	Event        Event        `json:"event"`
	Organization Organization `json:"organization"`
}

func (q *Queries) FindEventByIDWithSendOrganization(ctx context.Context, eventID uuid.UUID) (FindEventByIDWithSendOrganizationRow, error) {
	row := q.db.QueryRow(ctx, findEventByIDWithSendOrganization, eventID)
	var i FindEventByIDWithSendOrganizationRow
	err := row.Scan(
		&i.Event.TEventsPkey,
		&i.Event.EventID,
		&i.Event.EventTypeID,
		&i.Event.Title,
		&i.Event.Description,
		&i.Event.OrganizationID,
		&i.Event.StartTime,
		&i.Event.EndTime,
		&i.Event.MailSendFlag,
		&i.Event.SendOrganizationID,
		&i.Event.PostedBy,
		&i.Event.LastEditedBy,
		&i.Event.PostedAt,
		&i.Event.LastEditedAt,
		&i.Organization.MOrganizationsPkey,
		&i.Organization.OrganizationID,
		&i.Organization.Name,
		&i.Organization.Description,
		&i.Organization.Color,
		&i.Organization.IsPersonal,
		&i.Organization.IsWhole,
		&i.Organization.CreatedAt,
		&i.Organization.UpdatedAt,
		&i.Organization.ChatRoomID,
	)
	return i, err
}

const findEventByIDWithType = `-- name: FindEventByIDWithType :one
SELECT t_events.t_events_pkey, t_events.event_id, t_events.event_type_id, t_events.title, t_events.description, t_events.organization_id, t_events.start_time, t_events.end_time, t_events.mail_send_flag, t_events.send_organization_id, t_events.posted_by, t_events.last_edited_by, t_events.posted_at, t_events.last_edited_at, m_event_types.m_event_types_pkey, m_event_types.event_type_id, m_event_types.name, m_event_types.key, m_event_types.color FROM t_events
LEFT JOIN m_event_types ON t_events.event_type_id = m_event_types.event_type_id
WHERE event_id = $1
`

type FindEventByIDWithTypeRow struct {
	Event     Event     `json:"event"`
	EventType EventType `json:"event_type"`
}

func (q *Queries) FindEventByIDWithType(ctx context.Context, eventID uuid.UUID) (FindEventByIDWithTypeRow, error) {
	row := q.db.QueryRow(ctx, findEventByIDWithType, eventID)
	var i FindEventByIDWithTypeRow
	err := row.Scan(
		&i.Event.TEventsPkey,
		&i.Event.EventID,
		&i.Event.EventTypeID,
		&i.Event.Title,
		&i.Event.Description,
		&i.Event.OrganizationID,
		&i.Event.StartTime,
		&i.Event.EndTime,
		&i.Event.MailSendFlag,
		&i.Event.SendOrganizationID,
		&i.Event.PostedBy,
		&i.Event.LastEditedBy,
		&i.Event.PostedAt,
		&i.Event.LastEditedAt,
		&i.EventType.MEventTypesPkey,
		&i.EventType.EventTypeID,
		&i.EventType.Name,
		&i.EventType.Key,
		&i.EventType.Color,
	)
	return i, err
}

const getEvents = `-- name: GetEvents :many
SELECT t_events_pkey, event_id, event_type_id, title, description, organization_id, start_time, end_time, mail_send_flag, send_organization_id, posted_by, last_edited_by, posted_at, last_edited_at FROM t_events
WHERE
	CASE WHEN $1::boolean = true THEN title LIKE '%' || $2::text || '%' ELSE TRUE END
AND
	CASE WHEN $3::boolean = true THEN organization_id = $4 ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN mail_send_flag = $6 ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN send_organization_id = $8 ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN start_time >= $10 ELSE TRUE END
AND
	CASE WHEN $11::boolean = true THEN start_time <= $12 ELSE TRUE END
AND
	CASE WHEN $13::boolean = true THEN end_time >= $14 ELSE TRUE END
AND
	CASE WHEN $15::boolean = true THEN end_time <= $16 ELSE TRUE END
ORDER BY
	CASE WHEN $17::text = 'start_time' THEN start_time END ASC,
	CASE WHEN $17::text = 'r_start_time' THEN start_time END DESC,
	t_events_pkey ASC
`

type GetEventsParams struct {
	WhereLikeTitle        bool        `json:"where_like_title"`
	SearchTitle           string      `json:"search_title"`
	WhereOrganization     bool        `json:"where_organization"`
	OrganizationID        pgtype.UUID `json:"organization_id"`
	WhereMailSendFlag     bool        `json:"where_mail_send_flag"`
	MailSendFlag          bool        `json:"mail_send_flag"`
	WhereSendOrganization bool        `json:"where_send_organization"`
	SendOrganizationID    pgtype.UUID `json:"send_organization_id"`
	WhereEarlierStartTime bool        `json:"where_earlier_start_time"`
	EarlierStartTime      time.Time   `json:"earlier_start_time"`
	WhereLaterStartTime   bool        `json:"where_later_start_time"`
	LaterStartTime        time.Time   `json:"later_start_time"`
	WhereEarlierEndTime   bool        `json:"where_earlier_end_time"`
	EarlierEndTime        time.Time   `json:"earlier_end_time"`
	WhereLaterEndTime     bool        `json:"where_later_end_time"`
	LaterEndTime          time.Time   `json:"later_end_time"`
	OrderMethod           string      `json:"order_method"`
}

func (q *Queries) GetEvents(ctx context.Context, arg GetEventsParams) ([]Event, error) {
	rows, err := q.db.Query(ctx, getEvents,
		arg.WhereLikeTitle,
		arg.SearchTitle,
		arg.WhereOrganization,
		arg.OrganizationID,
		arg.WhereMailSendFlag,
		arg.MailSendFlag,
		arg.WhereSendOrganization,
		arg.SendOrganizationID,
		arg.WhereEarlierStartTime,
		arg.EarlierStartTime,
		arg.WhereLaterStartTime,
		arg.LaterStartTime,
		arg.WhereEarlierEndTime,
		arg.EarlierEndTime,
		arg.WhereLaterEndTime,
		arg.LaterEndTime,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Event{}
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.TEventsPkey,
			&i.EventID,
			&i.EventTypeID,
			&i.Title,
			&i.Description,
			&i.OrganizationID,
			&i.StartTime,
			&i.EndTime,
			&i.MailSendFlag,
			&i.SendOrganizationID,
			&i.PostedBy,
			&i.LastEditedBy,
			&i.PostedAt,
			&i.LastEditedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsUseKeysetPaginate = `-- name: GetEventsUseKeysetPaginate :many
SELECT t_events_pkey, event_id, event_type_id, title, description, organization_id, start_time, end_time, mail_send_flag, send_organization_id, posted_by, last_edited_by, posted_at, last_edited_at FROM t_events
WHERE
	CASE WHEN $2::boolean = true THEN title LIKE '%' || $3::text || '%' ELSE TRUE END
AND
	CASE WHEN $4::boolean = true THEN organization_id = $5 ELSE TRUE END
AND
	CASE WHEN $6::boolean = true THEN mail_send_flag = $7 ELSE TRUE END
AND
	CASE WHEN $8::boolean = true THEN send_organization_id = $9 ELSE TRUE END
AND
	CASE WHEN $10::boolean = true THEN start_time >= $11 ELSE TRUE END
AND
	CASE WHEN $12::boolean = true THEN start_time <= $13 ELSE TRUE END
AND
	CASE WHEN $14::boolean = true THEN end_time >= $15 ELSE TRUE END
AND
	CASE WHEN $16::boolean = true THEN end_time <= $17 ELSE TRUE END
AND
	CASE $18::text
		WHEN 'next' THEN
			CASE $19
				WHEN 'start_time' THEN start_time > $20 OR (start_time = $20 AND t_events_pkey > $21::int)
				WHEN 'r_start_time' THEN start_time < $20 OR (start_time = $20 AND t_events_pkey > $21::int)
				ELSE t_events_pkey > $21::int
			END
		WHEN 'prev' THEN
			CASE $19
				WHEN 'start_time' THEN start_time < $20 OR (start_time = $20 AND t_events_pkey < $21::int)
				WHEN 'r_start_time' THEN start_time > $20 OR (start_time = $20 AND t_events_pkey < $21::int)
				ELSE t_events_pkey < $21::int
			END
	END
ORDER BY
	CASE WHEN $19::text = 'start_time' AND $18::text = 'next' THEN start_time END ASC,
	CASE WHEN $19::text = 'start_time' AND $18::text = 'prev' THEN start_time END DESC,
	CASE WHEN $19::text = 'r_start_time' AND $18::text = 'next' THEN start_time END ASC,
	CASE WHEN $19::text = 'r_start_time' AND $18::text = 'prev' THEN start_time END DESC,
	CASE WHEN $18::text = 'next' THEN t_events_pkey END ASC,
	CASE WHEN $18::text = 'prev' THEN t_events_pkey END DESC
LIMIT $1
`

type GetEventsUseKeysetPaginateParams struct {
	Limit                 int32       `json:"limit"`
	WhereLikeTitle        bool        `json:"where_like_title"`
	SearchTitle           string      `json:"search_title"`
	WhereOrganization     bool        `json:"where_organization"`
	OrganizationID        pgtype.UUID `json:"organization_id"`
	WhereMailSendFlag     bool        `json:"where_mail_send_flag"`
	MailSendFlag          bool        `json:"mail_send_flag"`
	WhereSendOrganization bool        `json:"where_send_organization"`
	SendOrganizationID    pgtype.UUID `json:"send_organization_id"`
	WhereEarlierStartTime bool        `json:"where_earlier_start_time"`
	EarlierStartTime      time.Time   `json:"earlier_start_time"`
	WhereLaterStartTime   bool        `json:"where_later_start_time"`
	LaterStartTime        time.Time   `json:"later_start_time"`
	WhereEarlierEndTime   bool        `json:"where_earlier_end_time"`
	EarlierEndTime        time.Time   `json:"earlier_end_time"`
	WhereLaterEndTime     bool        `json:"where_later_end_time"`
	LaterEndTime          time.Time   `json:"later_end_time"`
	CursorDirection       string      `json:"cursor_direction"`
	OrderMethod           interface{} `json:"order_method"`
	StartTimeCursor       time.Time   `json:"start_time_cursor"`
	Cursor                int32       `json:"cursor"`
}

func (q *Queries) GetEventsUseKeysetPaginate(ctx context.Context, arg GetEventsUseKeysetPaginateParams) ([]Event, error) {
	rows, err := q.db.Query(ctx, getEventsUseKeysetPaginate,
		arg.Limit,
		arg.WhereLikeTitle,
		arg.SearchTitle,
		arg.WhereOrganization,
		arg.OrganizationID,
		arg.WhereMailSendFlag,
		arg.MailSendFlag,
		arg.WhereSendOrganization,
		arg.SendOrganizationID,
		arg.WhereEarlierStartTime,
		arg.EarlierStartTime,
		arg.WhereLaterStartTime,
		arg.LaterStartTime,
		arg.WhereEarlierEndTime,
		arg.EarlierEndTime,
		arg.WhereLaterEndTime,
		arg.LaterEndTime,
		arg.CursorDirection,
		arg.OrderMethod,
		arg.StartTimeCursor,
		arg.Cursor,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Event{}
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.TEventsPkey,
			&i.EventID,
			&i.EventTypeID,
			&i.Title,
			&i.Description,
			&i.OrganizationID,
			&i.StartTime,
			&i.EndTime,
			&i.MailSendFlag,
			&i.SendOrganizationID,
			&i.PostedBy,
			&i.LastEditedBy,
			&i.PostedAt,
			&i.LastEditedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsUseNumberedPaginate = `-- name: GetEventsUseNumberedPaginate :many
SELECT t_events_pkey, event_id, event_type_id, title, description, organization_id, start_time, end_time, mail_send_flag, send_organization_id, posted_by, last_edited_by, posted_at, last_edited_at FROM t_events
WHERE
	CASE WHEN $3::boolean = true THEN title LIKE '%' || $4::text || '%' ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN organization_id = $6 ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN mail_send_flag = $8 ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN send_organization_id = $10 ELSE TRUE END
AND
	CASE WHEN $11::boolean = true THEN start_time >= $12 ELSE TRUE END
AND
	CASE WHEN $13::boolean = true THEN start_time <= $14 ELSE TRUE END
AND
	CASE WHEN $15::boolean = true THEN end_time >= $16 ELSE TRUE END
AND
	CASE WHEN $17::boolean = true THEN end_time <= $18 ELSE TRUE END
ORDER BY
	CASE WHEN $19::text = 'start_time' THEN start_time END ASC,
	CASE WHEN $19::text = 'r_start_time' THEN start_time END DESC,
	t_events_pkey ASC
LIMIT $1 OFFSET $2
`

type GetEventsUseNumberedPaginateParams struct {
	Limit                 int32       `json:"limit"`
	Offset                int32       `json:"offset"`
	WhereLikeTitle        bool        `json:"where_like_title"`
	SearchTitle           string      `json:"search_title"`
	WhereOrganization     bool        `json:"where_organization"`
	OrganizationID        pgtype.UUID `json:"organization_id"`
	WhereMailSendFlag     bool        `json:"where_mail_send_flag"`
	MailSendFlag          bool        `json:"mail_send_flag"`
	WhereSendOrganization bool        `json:"where_send_organization"`
	SendOrganizationID    pgtype.UUID `json:"send_organization_id"`
	WhereEarlierStartTime bool        `json:"where_earlier_start_time"`
	EarlierStartTime      time.Time   `json:"earlier_start_time"`
	WhereLaterStartTime   bool        `json:"where_later_start_time"`
	LaterStartTime        time.Time   `json:"later_start_time"`
	WhereEarlierEndTime   bool        `json:"where_earlier_end_time"`
	EarlierEndTime        time.Time   `json:"earlier_end_time"`
	WhereLaterEndTime     bool        `json:"where_later_end_time"`
	LaterEndTime          time.Time   `json:"later_end_time"`
	OrderMethod           string      `json:"order_method"`
}

func (q *Queries) GetEventsUseNumberedPaginate(ctx context.Context, arg GetEventsUseNumberedPaginateParams) ([]Event, error) {
	rows, err := q.db.Query(ctx, getEventsUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.WhereLikeTitle,
		arg.SearchTitle,
		arg.WhereOrganization,
		arg.OrganizationID,
		arg.WhereMailSendFlag,
		arg.MailSendFlag,
		arg.WhereSendOrganization,
		arg.SendOrganizationID,
		arg.WhereEarlierStartTime,
		arg.EarlierStartTime,
		arg.WhereLaterStartTime,
		arg.LaterStartTime,
		arg.WhereEarlierEndTime,
		arg.EarlierEndTime,
		arg.WhereLaterEndTime,
		arg.LaterEndTime,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Event{}
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.TEventsPkey,
			&i.EventID,
			&i.EventTypeID,
			&i.Title,
			&i.Description,
			&i.OrganizationID,
			&i.StartTime,
			&i.EndTime,
			&i.MailSendFlag,
			&i.SendOrganizationID,
			&i.PostedBy,
			&i.LastEditedBy,
			&i.PostedAt,
			&i.LastEditedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsWithAll = `-- name: GetEventsWithAll :many
SELECT t_events.t_events_pkey, t_events.event_id, t_events.event_type_id, t_events.title, t_events.description, t_events.organization_id, t_events.start_time, t_events.end_time, t_events.mail_send_flag, t_events.send_organization_id, t_events.posted_by, t_events.last_edited_by, t_events.posted_at, t_events.last_edited_at, o.m_event_types_pkey, o.event_type_id, o.name, o.key, o.color, s.m_organizations_pkey, s.organization_id, s.name, s.description, s.color, s.is_personal, s.is_whole, s.created_at, s.updated_at, s.chat_room_id, p.m_organizations_pkey, p.organization_id, p.name, p.description, p.color, p.is_personal, p.is_whole, p.created_at, p.updated_at, p.chat_room_id, l.m_members_pkey, l.member_id, l.login_id, l.password, l.email, l.name, l.attend_status_id, l.profile_image_url, l.grade_id, l.group_id, l.personal_organization_id, l.role_id, l.created_at, l.updated_at, l.m_members_pkey, l.member_id, l.login_id, l.password, l.email, l.name, l.attend_status_id, l.profile_image_url, l.grade_id, l.group_id, l.personal_organization_id, l.role_id, l.created_at, l.updated_at, l.m_members_pkey, l.member_id, l.login_id, l.password, l.email, l.name, l.attend_status_id, l.profile_image_url, l.grade_id, l.group_id, l.personal_organization_id, l.role_id, l.created_at, l.updated_at, l.m_members_pkey, l.member_id, l.login_id, l.password, l.email, l.name, l.attend_status_id, l.profile_image_url, l.grade_id, l.group_id, l.personal_organization_id, l.role_id, l.created_at, l.updated_at FROM t_events
LEFT JOIN m_event_types o ON t_events.event_type_id = o.event_type_id
LEFT JOIN m_organizations s ON t_events.organization_id = s.organization_id
LEFT JOIN m_organizations p ON t_events.send_organization_id = p.organization_id
LEFT JOIN m_members l ON t_events.posted_by = l.member_id
LEFT JOIN m_members l ON t_events.last_edited_by = l.member_id
WHERE
	CASE WHEN $1::boolean = true THEN title LIKE '%' || $2::text || '%' ELSE TRUE END
AND
	CASE WHEN $3::boolean = true THEN t_events.organization_id = $4 ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN mail_send_flag = $6 ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN send_organization_id = $8 ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN start_time >= $10 ELSE TRUE END
AND
	CASE WHEN $11::boolean = true THEN start_time <= $12 ELSE TRUE END
AND
	CASE WHEN $13::boolean = true THEN end_time >= $14 ELSE TRUE END
AND
	CASE WHEN $15::boolean = true THEN end_time <= $16 ELSE TRUE END
ORDER BY
	CASE WHEN $17::text = 'start_time' THEN start_time END ASC,
	CASE WHEN $17::text = 'r_start_time' THEN start_time END DESC,
	t_events_pkey ASC
`

type GetEventsWithAllParams struct {
	WhereLikeTitle        bool        `json:"where_like_title"`
	SearchTitle           string      `json:"search_title"`
	WhereOrganization     bool        `json:"where_organization"`
	OrganizationID        pgtype.UUID `json:"organization_id"`
	WhereMailSendFlag     bool        `json:"where_mail_send_flag"`
	MailSendFlag          bool        `json:"mail_send_flag"`
	WhereSendOrganization bool        `json:"where_send_organization"`
	SendOrganizationID    pgtype.UUID `json:"send_organization_id"`
	WhereEarlierStartTime bool        `json:"where_earlier_start_time"`
	EarlierStartTime      time.Time   `json:"earlier_start_time"`
	WhereLaterStartTime   bool        `json:"where_later_start_time"`
	LaterStartTime        time.Time   `json:"later_start_time"`
	WhereEarlierEndTime   bool        `json:"where_earlier_end_time"`
	EarlierEndTime        time.Time   `json:"earlier_end_time"`
	WhereLaterEndTime     bool        `json:"where_later_end_time"`
	LaterEndTime          time.Time   `json:"later_end_time"`
	OrderMethod           string      `json:"order_method"`
}

type GetEventsWithAllRow struct {
	Event          Event        `json:"event"`
	EventType      EventType    `json:"event_type"`
	Organization   Organization `json:"organization"`
	Organization_2 Organization `json:"organization_2"`
	Member         Member       `json:"member"`
	Member_2       Member       `json:"member_2"`
}

func (q *Queries) GetEventsWithAll(ctx context.Context, arg GetEventsWithAllParams) ([]GetEventsWithAllRow, error) {
	rows, err := q.db.Query(ctx, getEventsWithAll,
		arg.WhereLikeTitle,
		arg.SearchTitle,
		arg.WhereOrganization,
		arg.OrganizationID,
		arg.WhereMailSendFlag,
		arg.MailSendFlag,
		arg.WhereSendOrganization,
		arg.SendOrganizationID,
		arg.WhereEarlierStartTime,
		arg.EarlierStartTime,
		arg.WhereLaterStartTime,
		arg.LaterStartTime,
		arg.WhereEarlierEndTime,
		arg.EarlierEndTime,
		arg.WhereLaterEndTime,
		arg.LaterEndTime,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEventsWithAllRow{}
	for rows.Next() {
		var i GetEventsWithAllRow
		if err := rows.Scan(
			&i.Event.TEventsPkey,
			&i.Event.EventID,
			&i.Event.EventTypeID,
			&i.Event.Title,
			&i.Event.Description,
			&i.Event.OrganizationID,
			&i.Event.StartTime,
			&i.Event.EndTime,
			&i.Event.MailSendFlag,
			&i.Event.SendOrganizationID,
			&i.Event.PostedBy,
			&i.Event.LastEditedBy,
			&i.Event.PostedAt,
			&i.Event.LastEditedAt,
			&i.EventType.MEventTypesPkey,
			&i.EventType.EventTypeID,
			&i.EventType.Name,
			&i.EventType.Key,
			&i.EventType.Color,
			&i.Organization.MOrganizationsPkey,
			&i.Organization.OrganizationID,
			&i.Organization.Name,
			&i.Organization.Description,
			&i.Organization.Color,
			&i.Organization.IsPersonal,
			&i.Organization.IsWhole,
			&i.Organization.CreatedAt,
			&i.Organization.UpdatedAt,
			&i.Organization.ChatRoomID,
			&i.Organization_2.MOrganizationsPkey,
			&i.Organization_2.OrganizationID,
			&i.Organization_2.Name,
			&i.Organization_2.Description,
			&i.Organization_2.Color,
			&i.Organization_2.IsPersonal,
			&i.Organization_2.IsWhole,
			&i.Organization_2.CreatedAt,
			&i.Organization_2.UpdatedAt,
			&i.Organization_2.ChatRoomID,
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageUrl,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
			&i.Member_2.MMembersPkey,
			&i.Member_2.MemberID,
			&i.Member_2.LoginID,
			&i.Member_2.Password,
			&i.Member_2.Email,
			&i.Member_2.Name,
			&i.Member_2.AttendStatusID,
			&i.Member_2.ProfileImageUrl,
			&i.Member_2.GradeID,
			&i.Member_2.GroupID,
			&i.Member_2.PersonalOrganizationID,
			&i.Member_2.RoleID,
			&i.Member_2.CreatedAt,
			&i.Member_2.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsWithAllUseKeysetPaginate = `-- name: GetEventsWithAllUseKeysetPaginate :many
SELECT t_events.t_events_pkey, t_events.event_id, t_events.event_type_id, t_events.title, t_events.description, t_events.organization_id, t_events.start_time, t_events.end_time, t_events.mail_send_flag, t_events.send_organization_id, t_events.posted_by, t_events.last_edited_by, t_events.posted_at, t_events.last_edited_at, o.m_event_types_pkey, o.event_type_id, o.name, o.key, o.color, s.m_organizations_pkey, s.organization_id, s.name, s.description, s.color, s.is_personal, s.is_whole, s.created_at, s.updated_at, s.chat_room_id, p.m_organizations_pkey, p.organization_id, p.name, p.description, p.color, p.is_personal, p.is_whole, p.created_at, p.updated_at, p.chat_room_id, l.m_members_pkey, l.member_id, l.login_id, l.password, l.email, l.name, l.attend_status_id, l.profile_image_url, l.grade_id, l.group_id, l.personal_organization_id, l.role_id, l.created_at, l.updated_at, l.m_members_pkey, l.member_id, l.login_id, l.password, l.email, l.name, l.attend_status_id, l.profile_image_url, l.grade_id, l.group_id, l.personal_organization_id, l.role_id, l.created_at, l.updated_at, l.m_members_pkey, l.member_id, l.login_id, l.password, l.email, l.name, l.attend_status_id, l.profile_image_url, l.grade_id, l.group_id, l.personal_organization_id, l.role_id, l.created_at, l.updated_at, l.m_members_pkey, l.member_id, l.login_id, l.password, l.email, l.name, l.attend_status_id, l.profile_image_url, l.grade_id, l.group_id, l.personal_organization_id, l.role_id, l.created_at, l.updated_at FROM t_events
LEFT JOIN m_event_types o ON t_events.event_type_id = o.event_type_id
LEFT JOIN m_organizations s ON t_events.organization_id = s.organization_id
LEFT JOIN m_organizations p ON t_events.send_organization_id = p.organization_id
LEFT JOIN m_members l ON t_events.posted_by = l.member_id
LEFT JOIN m_members l ON t_events.last_edited_by = l.member_id
WHERE
	CASE WHEN $2::boolean = true THEN title LIKE '%' || $3::text || '%' ELSE TRUE END
AND
	CASE WHEN $4::boolean = true THEN t_events.organization_id = $5 ELSE TRUE END
AND
	CASE WHEN $6::boolean = true THEN mail_send_flag = $7 ELSE TRUE END
AND
	CASE WHEN $8::boolean = true THEN send_organization_id = $9 ELSE TRUE END
AND
	CASE WHEN $10::boolean = true THEN start_time >= $11 ELSE TRUE END
AND
	CASE WHEN $12::boolean = true THEN start_time <= $13 ELSE TRUE END
AND
	CASE WHEN $14::boolean = true THEN end_time >= $15 ELSE TRUE END
AND
	CASE WHEN $16::boolean = true THEN end_time <= $17 ELSE TRUE END
AND
	CASE $18::text
		WHEN 'next' THEN
			CASE $19
				WHEN 'start_time' THEN start_time > $20 OR (start_time = $20 AND t_events_pkey > $21::int)
				WHEN 'r_start_time' THEN start_time < $20 OR (start_time = $20 AND t_events_pkey > $21::int)
				ELSE t_events_pkey > $21::int
			END
		WHEN 'prev' THEN
			CASE $19
				WHEN 'start_time' THEN start_time < $20 OR (start_time = $20 AND t_events_pkey < $21::int)
				WHEN 'r_start_time' THEN start_time > $20 OR (start_time = $20 AND t_events_pkey < $21::int)
				ELSE t_events_pkey < $21::int
			END
	END
ORDER BY
	CASE WHEN $19::text = 'start_time' AND $18::text = 'next' THEN start_time END ASC,
	CASE WHEN $19::text = 'start_time' AND $18::text = 'prev' THEN start_time END DESC,
	CASE WHEN $19::text = 'r_start_time' AND $18::text = 'next' THEN start_time END ASC,
	CASE WHEN $19::text = 'r_start_time' AND $18::text = 'prev' THEN start_time END DESC,
	CASE WHEN $18::text = 'next' THEN t_events_pkey END ASC,
	CASE WHEN $18::text = 'prev' THEN t_events_pkey END DESC
LIMIT $1
`

type GetEventsWithAllUseKeysetPaginateParams struct {
	Limit                 int32       `json:"limit"`
	WhereLikeTitle        bool        `json:"where_like_title"`
	SearchTitle           string      `json:"search_title"`
	WhereOrganization     bool        `json:"where_organization"`
	OrganizationID        pgtype.UUID `json:"organization_id"`
	WhereMailSendFlag     bool        `json:"where_mail_send_flag"`
	MailSendFlag          bool        `json:"mail_send_flag"`
	WhereSendOrganization bool        `json:"where_send_organization"`
	SendOrganizationID    pgtype.UUID `json:"send_organization_id"`
	WhereEarlierStartTime bool        `json:"where_earlier_start_time"`
	EarlierStartTime      time.Time   `json:"earlier_start_time"`
	WhereLaterStartTime   bool        `json:"where_later_start_time"`
	LaterStartTime        time.Time   `json:"later_start_time"`
	WhereEarlierEndTime   bool        `json:"where_earlier_end_time"`
	EarlierEndTime        time.Time   `json:"earlier_end_time"`
	WhereLaterEndTime     bool        `json:"where_later_end_time"`
	LaterEndTime          time.Time   `json:"later_end_time"`
	CursorDirection       string      `json:"cursor_direction"`
	OrderMethod           interface{} `json:"order_method"`
	StartTimeCursor       time.Time   `json:"start_time_cursor"`
	Cursor                int32       `json:"cursor"`
}

type GetEventsWithAllUseKeysetPaginateRow struct {
	Event          Event        `json:"event"`
	EventType      EventType    `json:"event_type"`
	Organization   Organization `json:"organization"`
	Organization_2 Organization `json:"organization_2"`
	Member         Member       `json:"member"`
	Member_2       Member       `json:"member_2"`
}

func (q *Queries) GetEventsWithAllUseKeysetPaginate(ctx context.Context, arg GetEventsWithAllUseKeysetPaginateParams) ([]GetEventsWithAllUseKeysetPaginateRow, error) {
	rows, err := q.db.Query(ctx, getEventsWithAllUseKeysetPaginate,
		arg.Limit,
		arg.WhereLikeTitle,
		arg.SearchTitle,
		arg.WhereOrganization,
		arg.OrganizationID,
		arg.WhereMailSendFlag,
		arg.MailSendFlag,
		arg.WhereSendOrganization,
		arg.SendOrganizationID,
		arg.WhereEarlierStartTime,
		arg.EarlierStartTime,
		arg.WhereLaterStartTime,
		arg.LaterStartTime,
		arg.WhereEarlierEndTime,
		arg.EarlierEndTime,
		arg.WhereLaterEndTime,
		arg.LaterEndTime,
		arg.CursorDirection,
		arg.OrderMethod,
		arg.StartTimeCursor,
		arg.Cursor,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEventsWithAllUseKeysetPaginateRow{}
	for rows.Next() {
		var i GetEventsWithAllUseKeysetPaginateRow
		if err := rows.Scan(
			&i.Event.TEventsPkey,
			&i.Event.EventID,
			&i.Event.EventTypeID,
			&i.Event.Title,
			&i.Event.Description,
			&i.Event.OrganizationID,
			&i.Event.StartTime,
			&i.Event.EndTime,
			&i.Event.MailSendFlag,
			&i.Event.SendOrganizationID,
			&i.Event.PostedBy,
			&i.Event.LastEditedBy,
			&i.Event.PostedAt,
			&i.Event.LastEditedAt,
			&i.EventType.MEventTypesPkey,
			&i.EventType.EventTypeID,
			&i.EventType.Name,
			&i.EventType.Key,
			&i.EventType.Color,
			&i.Organization.MOrganizationsPkey,
			&i.Organization.OrganizationID,
			&i.Organization.Name,
			&i.Organization.Description,
			&i.Organization.Color,
			&i.Organization.IsPersonal,
			&i.Organization.IsWhole,
			&i.Organization.CreatedAt,
			&i.Organization.UpdatedAt,
			&i.Organization.ChatRoomID,
			&i.Organization_2.MOrganizationsPkey,
			&i.Organization_2.OrganizationID,
			&i.Organization_2.Name,
			&i.Organization_2.Description,
			&i.Organization_2.Color,
			&i.Organization_2.IsPersonal,
			&i.Organization_2.IsWhole,
			&i.Organization_2.CreatedAt,
			&i.Organization_2.UpdatedAt,
			&i.Organization_2.ChatRoomID,
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageUrl,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
			&i.Member_2.MMembersPkey,
			&i.Member_2.MemberID,
			&i.Member_2.LoginID,
			&i.Member_2.Password,
			&i.Member_2.Email,
			&i.Member_2.Name,
			&i.Member_2.AttendStatusID,
			&i.Member_2.ProfileImageUrl,
			&i.Member_2.GradeID,
			&i.Member_2.GroupID,
			&i.Member_2.PersonalOrganizationID,
			&i.Member_2.RoleID,
			&i.Member_2.CreatedAt,
			&i.Member_2.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsWithAllUseNumberedPaginate = `-- name: GetEventsWithAllUseNumberedPaginate :many
SELECT t_events.t_events_pkey, t_events.event_id, t_events.event_type_id, t_events.title, t_events.description, t_events.organization_id, t_events.start_time, t_events.end_time, t_events.mail_send_flag, t_events.send_organization_id, t_events.posted_by, t_events.last_edited_by, t_events.posted_at, t_events.last_edited_at, o.m_event_types_pkey, o.event_type_id, o.name, o.key, o.color, s.m_organizations_pkey, s.organization_id, s.name, s.description, s.color, s.is_personal, s.is_whole, s.created_at, s.updated_at, s.chat_room_id, p.m_organizations_pkey, p.organization_id, p.name, p.description, p.color, p.is_personal, p.is_whole, p.created_at, p.updated_at, p.chat_room_id, l.m_members_pkey, l.member_id, l.login_id, l.password, l.email, l.name, l.attend_status_id, l.profile_image_url, l.grade_id, l.group_id, l.personal_organization_id, l.role_id, l.created_at, l.updated_at, l.m_members_pkey, l.member_id, l.login_id, l.password, l.email, l.name, l.attend_status_id, l.profile_image_url, l.grade_id, l.group_id, l.personal_organization_id, l.role_id, l.created_at, l.updated_at, l.m_members_pkey, l.member_id, l.login_id, l.password, l.email, l.name, l.attend_status_id, l.profile_image_url, l.grade_id, l.group_id, l.personal_organization_id, l.role_id, l.created_at, l.updated_at, l.m_members_pkey, l.member_id, l.login_id, l.password, l.email, l.name, l.attend_status_id, l.profile_image_url, l.grade_id, l.group_id, l.personal_organization_id, l.role_id, l.created_at, l.updated_at FROM t_events
LEFT JOIN m_event_types o ON t_events.event_type_id = o.event_type_id
LEFT JOIN m_organizations s ON t_events.organization_id = s.organization_id
LEFT JOIN m_organizations p ON t_events.send_organization_id = p.organization_id
LEFT JOIN m_members l ON t_events.posted_by = l.member_id
LEFT JOIN m_members l ON t_events.last_edited_by = l.member_id
WHERE
	CASE WHEN $3::boolean = true THEN title LIKE '%' || $4::text || '%' ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN t_events.organization_id = $6 ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN mail_send_flag = $8 ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN send_organization_id = $10 ELSE TRUE END
AND
	CASE WHEN $11::boolean = true THEN start_time >= $12 ELSE TRUE END
AND
	CASE WHEN $13::boolean = true THEN start_time <= $14 ELSE TRUE END
AND
	CASE WHEN $15::boolean = true THEN end_time >= $16 ELSE TRUE END
AND
	CASE WHEN $17::boolean = true THEN end_time <= $18 ELSE TRUE END
ORDER BY
	CASE WHEN $19::text = 'start_time' THEN start_time END ASC,
	CASE WHEN $19::text = 'r_start_time' THEN start_time END DESC,
	t_events_pkey ASC
LIMIT $1 OFFSET $2
`

type GetEventsWithAllUseNumberedPaginateParams struct {
	Limit                 int32       `json:"limit"`
	Offset                int32       `json:"offset"`
	WhereLikeTitle        bool        `json:"where_like_title"`
	SearchTitle           string      `json:"search_title"`
	WhereOrganization     bool        `json:"where_organization"`
	OrganizationID        pgtype.UUID `json:"organization_id"`
	WhereMailSendFlag     bool        `json:"where_mail_send_flag"`
	MailSendFlag          bool        `json:"mail_send_flag"`
	WhereSendOrganization bool        `json:"where_send_organization"`
	SendOrganizationID    pgtype.UUID `json:"send_organization_id"`
	WhereEarlierStartTime bool        `json:"where_earlier_start_time"`
	EarlierStartTime      time.Time   `json:"earlier_start_time"`
	WhereLaterStartTime   bool        `json:"where_later_start_time"`
	LaterStartTime        time.Time   `json:"later_start_time"`
	WhereEarlierEndTime   bool        `json:"where_earlier_end_time"`
	EarlierEndTime        time.Time   `json:"earlier_end_time"`
	WhereLaterEndTime     bool        `json:"where_later_end_time"`
	LaterEndTime          time.Time   `json:"later_end_time"`
	OrderMethod           string      `json:"order_method"`
}

type GetEventsWithAllUseNumberedPaginateRow struct {
	Event          Event        `json:"event"`
	EventType      EventType    `json:"event_type"`
	Organization   Organization `json:"organization"`
	Organization_2 Organization `json:"organization_2"`
	Member         Member       `json:"member"`
	Member_2       Member       `json:"member_2"`
}

func (q *Queries) GetEventsWithAllUseNumberedPaginate(ctx context.Context, arg GetEventsWithAllUseNumberedPaginateParams) ([]GetEventsWithAllUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getEventsWithAllUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.WhereLikeTitle,
		arg.SearchTitle,
		arg.WhereOrganization,
		arg.OrganizationID,
		arg.WhereMailSendFlag,
		arg.MailSendFlag,
		arg.WhereSendOrganization,
		arg.SendOrganizationID,
		arg.WhereEarlierStartTime,
		arg.EarlierStartTime,
		arg.WhereLaterStartTime,
		arg.LaterStartTime,
		arg.WhereEarlierEndTime,
		arg.EarlierEndTime,
		arg.WhereLaterEndTime,
		arg.LaterEndTime,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEventsWithAllUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetEventsWithAllUseNumberedPaginateRow
		if err := rows.Scan(
			&i.Event.TEventsPkey,
			&i.Event.EventID,
			&i.Event.EventTypeID,
			&i.Event.Title,
			&i.Event.Description,
			&i.Event.OrganizationID,
			&i.Event.StartTime,
			&i.Event.EndTime,
			&i.Event.MailSendFlag,
			&i.Event.SendOrganizationID,
			&i.Event.PostedBy,
			&i.Event.LastEditedBy,
			&i.Event.PostedAt,
			&i.Event.LastEditedAt,
			&i.EventType.MEventTypesPkey,
			&i.EventType.EventTypeID,
			&i.EventType.Name,
			&i.EventType.Key,
			&i.EventType.Color,
			&i.Organization.MOrganizationsPkey,
			&i.Organization.OrganizationID,
			&i.Organization.Name,
			&i.Organization.Description,
			&i.Organization.Color,
			&i.Organization.IsPersonal,
			&i.Organization.IsWhole,
			&i.Organization.CreatedAt,
			&i.Organization.UpdatedAt,
			&i.Organization.ChatRoomID,
			&i.Organization_2.MOrganizationsPkey,
			&i.Organization_2.OrganizationID,
			&i.Organization_2.Name,
			&i.Organization_2.Description,
			&i.Organization_2.Color,
			&i.Organization_2.IsPersonal,
			&i.Organization_2.IsWhole,
			&i.Organization_2.CreatedAt,
			&i.Organization_2.UpdatedAt,
			&i.Organization_2.ChatRoomID,
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageUrl,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
			&i.Member_2.MMembersPkey,
			&i.Member_2.MemberID,
			&i.Member_2.LoginID,
			&i.Member_2.Password,
			&i.Member_2.Email,
			&i.Member_2.Name,
			&i.Member_2.AttendStatusID,
			&i.Member_2.ProfileImageUrl,
			&i.Member_2.GradeID,
			&i.Member_2.GroupID,
			&i.Member_2.PersonalOrganizationID,
			&i.Member_2.RoleID,
			&i.Member_2.CreatedAt,
			&i.Member_2.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsWithLastEditUser = `-- name: GetEventsWithLastEditUser :many
SELECT t_events.t_events_pkey, t_events.event_id, t_events.event_type_id, t_events.title, t_events.description, t_events.organization_id, t_events.start_time, t_events.end_time, t_events.mail_send_flag, t_events.send_organization_id, t_events.posted_by, t_events.last_edited_by, t_events.posted_at, t_events.last_edited_at, m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_url, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at FROM t_events
LEFT JOIN m_members ON t_events.last_edited_by = m_members.member_id
WHERE
	CASE WHEN $1::boolean = true THEN title LIKE '%' || $2::text || '%' ELSE TRUE END
AND
	CASE WHEN $3::boolean = true THEN t_events.organization_id = $4 ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN mail_send_flag = $6 ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN send_organization_id = $8 ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN start_time >= $10 ELSE TRUE END
AND
	CASE WHEN $11::boolean = true THEN start_time <= $12 ELSE TRUE END
AND
	CASE WHEN $13::boolean = true THEN end_time >= $14 ELSE TRUE END
AND
	CASE WHEN $15::boolean = true THEN end_time <= $16 ELSE TRUE END
ORDER BY
	CASE WHEN $17::text = 'start_time' THEN start_time END ASC,
	CASE WHEN $17::text = 'r_start_time' THEN start_time END DESC,
	t_events_pkey ASC
`

type GetEventsWithLastEditUserParams struct {
	WhereLikeTitle        bool        `json:"where_like_title"`
	SearchTitle           string      `json:"search_title"`
	WhereOrganization     bool        `json:"where_organization"`
	OrganizationID        pgtype.UUID `json:"organization_id"`
	WhereMailSendFlag     bool        `json:"where_mail_send_flag"`
	MailSendFlag          bool        `json:"mail_send_flag"`
	WhereSendOrganization bool        `json:"where_send_organization"`
	SendOrganizationID    pgtype.UUID `json:"send_organization_id"`
	WhereEarlierStartTime bool        `json:"where_earlier_start_time"`
	EarlierStartTime      time.Time   `json:"earlier_start_time"`
	WhereLaterStartTime   bool        `json:"where_later_start_time"`
	LaterStartTime        time.Time   `json:"later_start_time"`
	WhereEarlierEndTime   bool        `json:"where_earlier_end_time"`
	EarlierEndTime        time.Time   `json:"earlier_end_time"`
	WhereLaterEndTime     bool        `json:"where_later_end_time"`
	LaterEndTime          time.Time   `json:"later_end_time"`
	OrderMethod           string      `json:"order_method"`
}

type GetEventsWithLastEditUserRow struct {
	Event  Event  `json:"event"`
	Member Member `json:"member"`
}

func (q *Queries) GetEventsWithLastEditUser(ctx context.Context, arg GetEventsWithLastEditUserParams) ([]GetEventsWithLastEditUserRow, error) {
	rows, err := q.db.Query(ctx, getEventsWithLastEditUser,
		arg.WhereLikeTitle,
		arg.SearchTitle,
		arg.WhereOrganization,
		arg.OrganizationID,
		arg.WhereMailSendFlag,
		arg.MailSendFlag,
		arg.WhereSendOrganization,
		arg.SendOrganizationID,
		arg.WhereEarlierStartTime,
		arg.EarlierStartTime,
		arg.WhereLaterStartTime,
		arg.LaterStartTime,
		arg.WhereEarlierEndTime,
		arg.EarlierEndTime,
		arg.WhereLaterEndTime,
		arg.LaterEndTime,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEventsWithLastEditUserRow{}
	for rows.Next() {
		var i GetEventsWithLastEditUserRow
		if err := rows.Scan(
			&i.Event.TEventsPkey,
			&i.Event.EventID,
			&i.Event.EventTypeID,
			&i.Event.Title,
			&i.Event.Description,
			&i.Event.OrganizationID,
			&i.Event.StartTime,
			&i.Event.EndTime,
			&i.Event.MailSendFlag,
			&i.Event.SendOrganizationID,
			&i.Event.PostedBy,
			&i.Event.LastEditedBy,
			&i.Event.PostedAt,
			&i.Event.LastEditedAt,
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageUrl,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsWithLastEditUserUseKeysetPaginate = `-- name: GetEventsWithLastEditUserUseKeysetPaginate :many
SELECT t_events.t_events_pkey, t_events.event_id, t_events.event_type_id, t_events.title, t_events.description, t_events.organization_id, t_events.start_time, t_events.end_time, t_events.mail_send_flag, t_events.send_organization_id, t_events.posted_by, t_events.last_edited_by, t_events.posted_at, t_events.last_edited_at, m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_url, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at FROM t_events
LEFT JOIN m_members ON t_events.last_edited_by = m_members.member_id
WHERE
	CASE WHEN $2::boolean = true THEN title LIKE '%' || $3::text || '%' ELSE TRUE END
AND
	CASE WHEN $4::boolean = true THEN t_events.organization_id = $5 ELSE TRUE END
AND
	CASE WHEN $6::boolean = true THEN mail_send_flag = $7 ELSE TRUE END
AND
	CASE WHEN $8::boolean = true THEN send_organization_id = $9 ELSE TRUE END
AND
	CASE WHEN $10::boolean = true THEN start_time >= $11 ELSE TRUE END
AND
	CASE WHEN $12::boolean = true THEN start_time <= $13 ELSE TRUE END
AND
	CASE WHEN $14::boolean = true THEN end_time >= $15 ELSE TRUE END
AND
	CASE WHEN $16::boolean = true THEN end_time <= $17 ELSE TRUE END
AND
	CASE $18::text
		WHEN 'next' THEN
			CASE $19
				WHEN 'start_time' THEN start_time > $20 OR (start_time = $20 AND t_events_pkey > $21::int)
				WHEN 'r_start_time' THEN start_time < $20 OR (start_time = $20 AND t_events_pkey > $21::int)
				ELSE t_events_pkey > $21::int
			END
		WHEN 'prev' THEN
			CASE $19
				WHEN 'start_time' THEN start_time < $20 OR (start_time = $20 AND t_events_pkey < $21::int)
				WHEN 'r_start_time' THEN start_time > $20 OR (start_time = $20 AND t_events_pkey < $21::int)
				ELSE t_events_pkey < $21::int
			END
	END
ORDER BY
	CASE WHEN $19::text = 'start_time' AND $18::text = 'next' THEN start_time END ASC,
	CASE WHEN $19::text = 'start_time' AND $18::text = 'prev' THEN start_time END DESC,
	CASE WHEN $19::text = 'r_start_time' AND $18::text = 'next' THEN start_time END ASC,
	CASE WHEN $19::text = 'r_start_time' AND $18::text = 'prev' THEN start_time END DESC,
	CASE WHEN $18::text = 'next' THEN t_events_pkey END ASC,
	CASE WHEN $18::text = 'prev' THEN t_events_pkey END DESC
LIMIT $1
`

type GetEventsWithLastEditUserUseKeysetPaginateParams struct {
	Limit                 int32       `json:"limit"`
	WhereLikeTitle        bool        `json:"where_like_title"`
	SearchTitle           string      `json:"search_title"`
	WhereOrganization     bool        `json:"where_organization"`
	OrganizationID        pgtype.UUID `json:"organization_id"`
	WhereMailSendFlag     bool        `json:"where_mail_send_flag"`
	MailSendFlag          bool        `json:"mail_send_flag"`
	WhereSendOrganization bool        `json:"where_send_organization"`
	SendOrganizationID    pgtype.UUID `json:"send_organization_id"`
	WhereEarlierStartTime bool        `json:"where_earlier_start_time"`
	EarlierStartTime      time.Time   `json:"earlier_start_time"`
	WhereLaterStartTime   bool        `json:"where_later_start_time"`
	LaterStartTime        time.Time   `json:"later_start_time"`
	WhereEarlierEndTime   bool        `json:"where_earlier_end_time"`
	EarlierEndTime        time.Time   `json:"earlier_end_time"`
	WhereLaterEndTime     bool        `json:"where_later_end_time"`
	LaterEndTime          time.Time   `json:"later_end_time"`
	CursorDirection       string      `json:"cursor_direction"`
	OrderMethod           interface{} `json:"order_method"`
	StartTimeCursor       time.Time   `json:"start_time_cursor"`
	Cursor                int32       `json:"cursor"`
}

type GetEventsWithLastEditUserUseKeysetPaginateRow struct {
	Event  Event  `json:"event"`
	Member Member `json:"member"`
}

func (q *Queries) GetEventsWithLastEditUserUseKeysetPaginate(ctx context.Context, arg GetEventsWithLastEditUserUseKeysetPaginateParams) ([]GetEventsWithLastEditUserUseKeysetPaginateRow, error) {
	rows, err := q.db.Query(ctx, getEventsWithLastEditUserUseKeysetPaginate,
		arg.Limit,
		arg.WhereLikeTitle,
		arg.SearchTitle,
		arg.WhereOrganization,
		arg.OrganizationID,
		arg.WhereMailSendFlag,
		arg.MailSendFlag,
		arg.WhereSendOrganization,
		arg.SendOrganizationID,
		arg.WhereEarlierStartTime,
		arg.EarlierStartTime,
		arg.WhereLaterStartTime,
		arg.LaterStartTime,
		arg.WhereEarlierEndTime,
		arg.EarlierEndTime,
		arg.WhereLaterEndTime,
		arg.LaterEndTime,
		arg.CursorDirection,
		arg.OrderMethod,
		arg.StartTimeCursor,
		arg.Cursor,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEventsWithLastEditUserUseKeysetPaginateRow{}
	for rows.Next() {
		var i GetEventsWithLastEditUserUseKeysetPaginateRow
		if err := rows.Scan(
			&i.Event.TEventsPkey,
			&i.Event.EventID,
			&i.Event.EventTypeID,
			&i.Event.Title,
			&i.Event.Description,
			&i.Event.OrganizationID,
			&i.Event.StartTime,
			&i.Event.EndTime,
			&i.Event.MailSendFlag,
			&i.Event.SendOrganizationID,
			&i.Event.PostedBy,
			&i.Event.LastEditedBy,
			&i.Event.PostedAt,
			&i.Event.LastEditedAt,
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageUrl,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsWithLastEditUserUseNumberedPaginate = `-- name: GetEventsWithLastEditUserUseNumberedPaginate :many
SELECT t_events.t_events_pkey, t_events.event_id, t_events.event_type_id, t_events.title, t_events.description, t_events.organization_id, t_events.start_time, t_events.end_time, t_events.mail_send_flag, t_events.send_organization_id, t_events.posted_by, t_events.last_edited_by, t_events.posted_at, t_events.last_edited_at, m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_url, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at FROM t_events
LEFT JOIN m_members ON t_events.last_edited_by = m_members.member_id
WHERE
	CASE WHEN $3::boolean = true THEN title LIKE '%' || $4::text || '%' ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN t_events.organization_id = $6 ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN mail_send_flag = $8 ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN send_organization_id = $10 ELSE TRUE END
AND
	CASE WHEN $11::boolean = true THEN start_time >= $12 ELSE TRUE END
AND
	CASE WHEN $13::boolean = true THEN start_time <= $14 ELSE TRUE END
AND
	CASE WHEN $15::boolean = true THEN end_time >= $16 ELSE TRUE END
AND
	CASE WHEN $17::boolean = true THEN end_time <= $18 ELSE TRUE END
ORDER BY
	CASE WHEN $19::text = 'start_time' THEN start_time END ASC,
	CASE WHEN $19::text = 'r_start_time' THEN start_time END DESC,
	t_events_pkey ASC
LIMIT $1 OFFSET $2
`

type GetEventsWithLastEditUserUseNumberedPaginateParams struct {
	Limit                 int32       `json:"limit"`
	Offset                int32       `json:"offset"`
	WhereLikeTitle        bool        `json:"where_like_title"`
	SearchTitle           string      `json:"search_title"`
	WhereOrganization     bool        `json:"where_organization"`
	OrganizationID        pgtype.UUID `json:"organization_id"`
	WhereMailSendFlag     bool        `json:"where_mail_send_flag"`
	MailSendFlag          bool        `json:"mail_send_flag"`
	WhereSendOrganization bool        `json:"where_send_organization"`
	SendOrganizationID    pgtype.UUID `json:"send_organization_id"`
	WhereEarlierStartTime bool        `json:"where_earlier_start_time"`
	EarlierStartTime      time.Time   `json:"earlier_start_time"`
	WhereLaterStartTime   bool        `json:"where_later_start_time"`
	LaterStartTime        time.Time   `json:"later_start_time"`
	WhereEarlierEndTime   bool        `json:"where_earlier_end_time"`
	EarlierEndTime        time.Time   `json:"earlier_end_time"`
	WhereLaterEndTime     bool        `json:"where_later_end_time"`
	LaterEndTime          time.Time   `json:"later_end_time"`
	OrderMethod           string      `json:"order_method"`
}

type GetEventsWithLastEditUserUseNumberedPaginateRow struct {
	Event  Event  `json:"event"`
	Member Member `json:"member"`
}

func (q *Queries) GetEventsWithLastEditUserUseNumberedPaginate(ctx context.Context, arg GetEventsWithLastEditUserUseNumberedPaginateParams) ([]GetEventsWithLastEditUserUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getEventsWithLastEditUserUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.WhereLikeTitle,
		arg.SearchTitle,
		arg.WhereOrganization,
		arg.OrganizationID,
		arg.WhereMailSendFlag,
		arg.MailSendFlag,
		arg.WhereSendOrganization,
		arg.SendOrganizationID,
		arg.WhereEarlierStartTime,
		arg.EarlierStartTime,
		arg.WhereLaterStartTime,
		arg.LaterStartTime,
		arg.WhereEarlierEndTime,
		arg.EarlierEndTime,
		arg.WhereLaterEndTime,
		arg.LaterEndTime,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEventsWithLastEditUserUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetEventsWithLastEditUserUseNumberedPaginateRow
		if err := rows.Scan(
			&i.Event.TEventsPkey,
			&i.Event.EventID,
			&i.Event.EventTypeID,
			&i.Event.Title,
			&i.Event.Description,
			&i.Event.OrganizationID,
			&i.Event.StartTime,
			&i.Event.EndTime,
			&i.Event.MailSendFlag,
			&i.Event.SendOrganizationID,
			&i.Event.PostedBy,
			&i.Event.LastEditedBy,
			&i.Event.PostedAt,
			&i.Event.LastEditedAt,
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageUrl,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsWithOrganization = `-- name: GetEventsWithOrganization :many
SELECT t_events.t_events_pkey, t_events.event_id, t_events.event_type_id, t_events.title, t_events.description, t_events.organization_id, t_events.start_time, t_events.end_time, t_events.mail_send_flag, t_events.send_organization_id, t_events.posted_by, t_events.last_edited_by, t_events.posted_at, t_events.last_edited_at, m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.color, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at, m_organizations.chat_room_id FROM t_events
LEFT JOIN m_organizations ON t_events.organization_id = m_organizations.organization_id
WHERE
	CASE WHEN $1::boolean = true THEN title LIKE '%' || $2::text || '%' ELSE TRUE END
AND
	CASE WHEN $3::boolean = true THEN t_events.organization_id = $4 ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN mail_send_flag = $6 ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN send_organization_id = $8 ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN start_time >= $10 ELSE TRUE END
AND
	CASE WHEN $11::boolean = true THEN start_time <= $12 ELSE TRUE END
AND
	CASE WHEN $13::boolean = true THEN end_time >= $14 ELSE TRUE END
AND
	CASE WHEN $15::boolean = true THEN end_time <= $16 ELSE TRUE END
ORDER BY
	CASE WHEN $17::text = 'start_time' THEN start_time END ASC,
	CASE WHEN $17::text = 'r_start_time' THEN start_time END DESC,
	t_events_pkey ASC
`

type GetEventsWithOrganizationParams struct {
	WhereLikeTitle        bool        `json:"where_like_title"`
	SearchTitle           string      `json:"search_title"`
	WhereOrganization     bool        `json:"where_organization"`
	OrganizationID        pgtype.UUID `json:"organization_id"`
	WhereMailSendFlag     bool        `json:"where_mail_send_flag"`
	MailSendFlag          bool        `json:"mail_send_flag"`
	WhereSendOrganization bool        `json:"where_send_organization"`
	SendOrganizationID    pgtype.UUID `json:"send_organization_id"`
	WhereEarlierStartTime bool        `json:"where_earlier_start_time"`
	EarlierStartTime      time.Time   `json:"earlier_start_time"`
	WhereLaterStartTime   bool        `json:"where_later_start_time"`
	LaterStartTime        time.Time   `json:"later_start_time"`
	WhereEarlierEndTime   bool        `json:"where_earlier_end_time"`
	EarlierEndTime        time.Time   `json:"earlier_end_time"`
	WhereLaterEndTime     bool        `json:"where_later_end_time"`
	LaterEndTime          time.Time   `json:"later_end_time"`
	OrderMethod           string      `json:"order_method"`
}

type GetEventsWithOrganizationRow struct {
	Event        Event        `json:"event"`
	Organization Organization `json:"organization"`
}

func (q *Queries) GetEventsWithOrganization(ctx context.Context, arg GetEventsWithOrganizationParams) ([]GetEventsWithOrganizationRow, error) {
	rows, err := q.db.Query(ctx, getEventsWithOrganization,
		arg.WhereLikeTitle,
		arg.SearchTitle,
		arg.WhereOrganization,
		arg.OrganizationID,
		arg.WhereMailSendFlag,
		arg.MailSendFlag,
		arg.WhereSendOrganization,
		arg.SendOrganizationID,
		arg.WhereEarlierStartTime,
		arg.EarlierStartTime,
		arg.WhereLaterStartTime,
		arg.LaterStartTime,
		arg.WhereEarlierEndTime,
		arg.EarlierEndTime,
		arg.WhereLaterEndTime,
		arg.LaterEndTime,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEventsWithOrganizationRow{}
	for rows.Next() {
		var i GetEventsWithOrganizationRow
		if err := rows.Scan(
			&i.Event.TEventsPkey,
			&i.Event.EventID,
			&i.Event.EventTypeID,
			&i.Event.Title,
			&i.Event.Description,
			&i.Event.OrganizationID,
			&i.Event.StartTime,
			&i.Event.EndTime,
			&i.Event.MailSendFlag,
			&i.Event.SendOrganizationID,
			&i.Event.PostedBy,
			&i.Event.LastEditedBy,
			&i.Event.PostedAt,
			&i.Event.LastEditedAt,
			&i.Organization.MOrganizationsPkey,
			&i.Organization.OrganizationID,
			&i.Organization.Name,
			&i.Organization.Description,
			&i.Organization.Color,
			&i.Organization.IsPersonal,
			&i.Organization.IsWhole,
			&i.Organization.CreatedAt,
			&i.Organization.UpdatedAt,
			&i.Organization.ChatRoomID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsWithOrganizationUseKeysetPaginate = `-- name: GetEventsWithOrganizationUseKeysetPaginate :many
SELECT t_events.t_events_pkey, t_events.event_id, t_events.event_type_id, t_events.title, t_events.description, t_events.organization_id, t_events.start_time, t_events.end_time, t_events.mail_send_flag, t_events.send_organization_id, t_events.posted_by, t_events.last_edited_by, t_events.posted_at, t_events.last_edited_at, m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.color, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at, m_organizations.chat_room_id FROM t_events
LEFT JOIN m_organizations ON t_events.organization_id = m_organizations.organization_id
WHERE
	CASE WHEN $2::boolean = true THEN title LIKE '%' || $3::text || '%' ELSE TRUE END
AND
	CASE WHEN $4::boolean = true THEN t_events.organization_id = $5 ELSE TRUE END
AND
	CASE WHEN $6::boolean = true THEN mail_send_flag = $7 ELSE TRUE END
AND
	CASE WHEN $8::boolean = true THEN send_organization_id = $9 ELSE TRUE END
AND
	CASE WHEN $10::boolean = true THEN start_time >= $11 ELSE TRUE END
AND
	CASE WHEN $12::boolean = true THEN start_time <= $13 ELSE TRUE END
AND
	CASE WHEN $14::boolean = true THEN end_time >= $15 ELSE TRUE END
AND
	CASE WHEN $16::boolean = true THEN end_time <= $17 ELSE TRUE END
AND
	CASE $18::text
		WHEN 'next' THEN
			CASE $19
				WHEN 'start_time' THEN start_time > $20 OR (start_time = $20 AND t_events_pkey > $21::int)
				WHEN 'r_start_time' THEN start_time < $20 OR (start_time = $20 AND t_events_pkey > $21::int)
				ELSE t_events_pkey > $21::int
			END
		WHEN 'prev' THEN
			CASE $19
				WHEN 'start_time' THEN start_time < $20 OR (start_time = $20 AND t_events_pkey < $21::int)
				WHEN 'r_start_time' THEN start_time > $20 OR (start_time = $20 AND t_events_pkey < $21::int)
				ELSE t_events_pkey < $21::int
			END
	END
ORDER BY
	CASE WHEN $19::text = 'start_time' AND $18::text = 'next' THEN start_time END ASC,
	CASE WHEN $19::text = 'start_time' AND $18::text = 'prev' THEN start_time END DESC,
	CASE WHEN $19::text = 'r_start_time' AND $18::text = 'next' THEN start_time END ASC,
	CASE WHEN $19::text = 'r_start_time' AND $18::text = 'prev' THEN start_time END DESC,
	CASE WHEN $18::text = 'next' THEN t_events_pkey END ASC,
	CASE WHEN $18::text = 'prev' THEN t_events_pkey END DESC
LIMIT $1
`

type GetEventsWithOrganizationUseKeysetPaginateParams struct {
	Limit                 int32       `json:"limit"`
	WhereLikeTitle        bool        `json:"where_like_title"`
	SearchTitle           string      `json:"search_title"`
	WhereOrganization     bool        `json:"where_organization"`
	OrganizationID        pgtype.UUID `json:"organization_id"`
	WhereMailSendFlag     bool        `json:"where_mail_send_flag"`
	MailSendFlag          bool        `json:"mail_send_flag"`
	WhereSendOrganization bool        `json:"where_send_organization"`
	SendOrganizationID    pgtype.UUID `json:"send_organization_id"`
	WhereEarlierStartTime bool        `json:"where_earlier_start_time"`
	EarlierStartTime      time.Time   `json:"earlier_start_time"`
	WhereLaterStartTime   bool        `json:"where_later_start_time"`
	LaterStartTime        time.Time   `json:"later_start_time"`
	WhereEarlierEndTime   bool        `json:"where_earlier_end_time"`
	EarlierEndTime        time.Time   `json:"earlier_end_time"`
	WhereLaterEndTime     bool        `json:"where_later_end_time"`
	LaterEndTime          time.Time   `json:"later_end_time"`
	CursorDirection       string      `json:"cursor_direction"`
	OrderMethod           interface{} `json:"order_method"`
	StartTimeCursor       time.Time   `json:"start_time_cursor"`
	Cursor                int32       `json:"cursor"`
}

type GetEventsWithOrganizationUseKeysetPaginateRow struct {
	Event        Event        `json:"event"`
	Organization Organization `json:"organization"`
}

func (q *Queries) GetEventsWithOrganizationUseKeysetPaginate(ctx context.Context, arg GetEventsWithOrganizationUseKeysetPaginateParams) ([]GetEventsWithOrganizationUseKeysetPaginateRow, error) {
	rows, err := q.db.Query(ctx, getEventsWithOrganizationUseKeysetPaginate,
		arg.Limit,
		arg.WhereLikeTitle,
		arg.SearchTitle,
		arg.WhereOrganization,
		arg.OrganizationID,
		arg.WhereMailSendFlag,
		arg.MailSendFlag,
		arg.WhereSendOrganization,
		arg.SendOrganizationID,
		arg.WhereEarlierStartTime,
		arg.EarlierStartTime,
		arg.WhereLaterStartTime,
		arg.LaterStartTime,
		arg.WhereEarlierEndTime,
		arg.EarlierEndTime,
		arg.WhereLaterEndTime,
		arg.LaterEndTime,
		arg.CursorDirection,
		arg.OrderMethod,
		arg.StartTimeCursor,
		arg.Cursor,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEventsWithOrganizationUseKeysetPaginateRow{}
	for rows.Next() {
		var i GetEventsWithOrganizationUseKeysetPaginateRow
		if err := rows.Scan(
			&i.Event.TEventsPkey,
			&i.Event.EventID,
			&i.Event.EventTypeID,
			&i.Event.Title,
			&i.Event.Description,
			&i.Event.OrganizationID,
			&i.Event.StartTime,
			&i.Event.EndTime,
			&i.Event.MailSendFlag,
			&i.Event.SendOrganizationID,
			&i.Event.PostedBy,
			&i.Event.LastEditedBy,
			&i.Event.PostedAt,
			&i.Event.LastEditedAt,
			&i.Organization.MOrganizationsPkey,
			&i.Organization.OrganizationID,
			&i.Organization.Name,
			&i.Organization.Description,
			&i.Organization.Color,
			&i.Organization.IsPersonal,
			&i.Organization.IsWhole,
			&i.Organization.CreatedAt,
			&i.Organization.UpdatedAt,
			&i.Organization.ChatRoomID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsWithOrganizationUseNumberedPaginate = `-- name: GetEventsWithOrganizationUseNumberedPaginate :many
SELECT t_events.t_events_pkey, t_events.event_id, t_events.event_type_id, t_events.title, t_events.description, t_events.organization_id, t_events.start_time, t_events.end_time, t_events.mail_send_flag, t_events.send_organization_id, t_events.posted_by, t_events.last_edited_by, t_events.posted_at, t_events.last_edited_at, m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.color, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at, m_organizations.chat_room_id FROM t_events
LEFT JOIN m_organizations ON t_events.organization_id = m_organizations.organization_id
WHERE
	CASE WHEN $3::boolean = true THEN title LIKE '%' || $4::text || '%' ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN t_events.organization_id = $6 ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN mail_send_flag = $8 ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN send_organization_id = $10 ELSE TRUE END
AND
	CASE WHEN $11::boolean = true THEN start_time >= $12 ELSE TRUE END
AND
	CASE WHEN $13::boolean = true THEN start_time <= $14 ELSE TRUE END
AND
	CASE WHEN $15::boolean = true THEN end_time >= $16 ELSE TRUE END
AND
	CASE WHEN $17::boolean = true THEN end_time <= $18 ELSE TRUE END
ORDER BY
	CASE WHEN $19::text = 'start_time' THEN start_time END ASC,
	CASE WHEN $19::text = 'r_start_time' THEN start_time END DESC,
	t_events_pkey ASC
LIMIT $1 OFFSET $2
`

type GetEventsWithOrganizationUseNumberedPaginateParams struct {
	Limit                 int32       `json:"limit"`
	Offset                int32       `json:"offset"`
	WhereLikeTitle        bool        `json:"where_like_title"`
	SearchTitle           string      `json:"search_title"`
	WhereOrganization     bool        `json:"where_organization"`
	OrganizationID        pgtype.UUID `json:"organization_id"`
	WhereMailSendFlag     bool        `json:"where_mail_send_flag"`
	MailSendFlag          bool        `json:"mail_send_flag"`
	WhereSendOrganization bool        `json:"where_send_organization"`
	SendOrganizationID    pgtype.UUID `json:"send_organization_id"`
	WhereEarlierStartTime bool        `json:"where_earlier_start_time"`
	EarlierStartTime      time.Time   `json:"earlier_start_time"`
	WhereLaterStartTime   bool        `json:"where_later_start_time"`
	LaterStartTime        time.Time   `json:"later_start_time"`
	WhereEarlierEndTime   bool        `json:"where_earlier_end_time"`
	EarlierEndTime        time.Time   `json:"earlier_end_time"`
	WhereLaterEndTime     bool        `json:"where_later_end_time"`
	LaterEndTime          time.Time   `json:"later_end_time"`
	OrderMethod           string      `json:"order_method"`
}

type GetEventsWithOrganizationUseNumberedPaginateRow struct {
	Event        Event        `json:"event"`
	Organization Organization `json:"organization"`
}

func (q *Queries) GetEventsWithOrganizationUseNumberedPaginate(ctx context.Context, arg GetEventsWithOrganizationUseNumberedPaginateParams) ([]GetEventsWithOrganizationUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getEventsWithOrganizationUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.WhereLikeTitle,
		arg.SearchTitle,
		arg.WhereOrganization,
		arg.OrganizationID,
		arg.WhereMailSendFlag,
		arg.MailSendFlag,
		arg.WhereSendOrganization,
		arg.SendOrganizationID,
		arg.WhereEarlierStartTime,
		arg.EarlierStartTime,
		arg.WhereLaterStartTime,
		arg.LaterStartTime,
		arg.WhereEarlierEndTime,
		arg.EarlierEndTime,
		arg.WhereLaterEndTime,
		arg.LaterEndTime,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEventsWithOrganizationUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetEventsWithOrganizationUseNumberedPaginateRow
		if err := rows.Scan(
			&i.Event.TEventsPkey,
			&i.Event.EventID,
			&i.Event.EventTypeID,
			&i.Event.Title,
			&i.Event.Description,
			&i.Event.OrganizationID,
			&i.Event.StartTime,
			&i.Event.EndTime,
			&i.Event.MailSendFlag,
			&i.Event.SendOrganizationID,
			&i.Event.PostedBy,
			&i.Event.LastEditedBy,
			&i.Event.PostedAt,
			&i.Event.LastEditedAt,
			&i.Organization.MOrganizationsPkey,
			&i.Organization.OrganizationID,
			&i.Organization.Name,
			&i.Organization.Description,
			&i.Organization.Color,
			&i.Organization.IsPersonal,
			&i.Organization.IsWhole,
			&i.Organization.CreatedAt,
			&i.Organization.UpdatedAt,
			&i.Organization.ChatRoomID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsWithPostUser = `-- name: GetEventsWithPostUser :many
SELECT t_events.t_events_pkey, t_events.event_id, t_events.event_type_id, t_events.title, t_events.description, t_events.organization_id, t_events.start_time, t_events.end_time, t_events.mail_send_flag, t_events.send_organization_id, t_events.posted_by, t_events.last_edited_by, t_events.posted_at, t_events.last_edited_at, m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_url, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at FROM t_events
LEFT JOIN m_members ON t_events.posted_by = m_members.member_id
WHERE
	CASE WHEN $1::boolean = true THEN title LIKE '%' || $2::text || '%' ELSE TRUE END
AND
	CASE WHEN $3::boolean = true THEN t_events.organization_id = $4 ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN mail_send_flag = $6 ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN send_organization_id = $8 ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN start_time >= $10 ELSE TRUE END
AND
	CASE WHEN $11::boolean = true THEN start_time <= $12 ELSE TRUE END
AND
	CASE WHEN $13::boolean = true THEN end_time >= $14 ELSE TRUE END
AND
	CASE WHEN $15::boolean = true THEN end_time <= $16 ELSE TRUE END
ORDER BY
	CASE WHEN $17::text = 'start_time' THEN start_time END ASC,
	CASE WHEN $17::text = 'r_start_time' THEN start_time END DESC,
	t_events_pkey ASC
`

type GetEventsWithPostUserParams struct {
	WhereLikeTitle        bool        `json:"where_like_title"`
	SearchTitle           string      `json:"search_title"`
	WhereOrganization     bool        `json:"where_organization"`
	OrganizationID        pgtype.UUID `json:"organization_id"`
	WhereMailSendFlag     bool        `json:"where_mail_send_flag"`
	MailSendFlag          bool        `json:"mail_send_flag"`
	WhereSendOrganization bool        `json:"where_send_organization"`
	SendOrganizationID    pgtype.UUID `json:"send_organization_id"`
	WhereEarlierStartTime bool        `json:"where_earlier_start_time"`
	EarlierStartTime      time.Time   `json:"earlier_start_time"`
	WhereLaterStartTime   bool        `json:"where_later_start_time"`
	LaterStartTime        time.Time   `json:"later_start_time"`
	WhereEarlierEndTime   bool        `json:"where_earlier_end_time"`
	EarlierEndTime        time.Time   `json:"earlier_end_time"`
	WhereLaterEndTime     bool        `json:"where_later_end_time"`
	LaterEndTime          time.Time   `json:"later_end_time"`
	OrderMethod           string      `json:"order_method"`
}

type GetEventsWithPostUserRow struct {
	Event  Event  `json:"event"`
	Member Member `json:"member"`
}

func (q *Queries) GetEventsWithPostUser(ctx context.Context, arg GetEventsWithPostUserParams) ([]GetEventsWithPostUserRow, error) {
	rows, err := q.db.Query(ctx, getEventsWithPostUser,
		arg.WhereLikeTitle,
		arg.SearchTitle,
		arg.WhereOrganization,
		arg.OrganizationID,
		arg.WhereMailSendFlag,
		arg.MailSendFlag,
		arg.WhereSendOrganization,
		arg.SendOrganizationID,
		arg.WhereEarlierStartTime,
		arg.EarlierStartTime,
		arg.WhereLaterStartTime,
		arg.LaterStartTime,
		arg.WhereEarlierEndTime,
		arg.EarlierEndTime,
		arg.WhereLaterEndTime,
		arg.LaterEndTime,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEventsWithPostUserRow{}
	for rows.Next() {
		var i GetEventsWithPostUserRow
		if err := rows.Scan(
			&i.Event.TEventsPkey,
			&i.Event.EventID,
			&i.Event.EventTypeID,
			&i.Event.Title,
			&i.Event.Description,
			&i.Event.OrganizationID,
			&i.Event.StartTime,
			&i.Event.EndTime,
			&i.Event.MailSendFlag,
			&i.Event.SendOrganizationID,
			&i.Event.PostedBy,
			&i.Event.LastEditedBy,
			&i.Event.PostedAt,
			&i.Event.LastEditedAt,
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageUrl,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsWithPostUserUseKeysetPaginate = `-- name: GetEventsWithPostUserUseKeysetPaginate :many
SELECT t_events.t_events_pkey, t_events.event_id, t_events.event_type_id, t_events.title, t_events.description, t_events.organization_id, t_events.start_time, t_events.end_time, t_events.mail_send_flag, t_events.send_organization_id, t_events.posted_by, t_events.last_edited_by, t_events.posted_at, t_events.last_edited_at, m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_url, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at FROM t_events
LEFT JOIN m_members ON t_events.posted_by = m_members.member_id
WHERE
	CASE WHEN $2::boolean = true THEN title LIKE '%' || $3::text || '%' ELSE TRUE END
AND
	CASE WHEN $4::boolean = true THEN t_events.organization_id = $5 ELSE TRUE END
AND
	CASE WHEN $6::boolean = true THEN mail_send_flag = $7 ELSE TRUE END
AND
	CASE WHEN $8::boolean = true THEN send_organization_id = $9 ELSE TRUE END
AND
	CASE WHEN $10::boolean = true THEN start_time >= $11 ELSE TRUE END
AND
	CASE WHEN $12::boolean = true THEN start_time <= $13 ELSE TRUE END
AND
	CASE WHEN $14::boolean = true THEN end_time >= $15 ELSE TRUE END
AND
	CASE WHEN $16::boolean = true THEN end_time <= $17 ELSE TRUE END
AND
	CASE $18::text
		WHEN 'next' THEN
			CASE $19
				WHEN 'start_time' THEN start_time > $20 OR (start_time = $20 AND t_events_pkey > $21::int)
				WHEN 'r_start_time' THEN start_time < $20 OR (start_time = $20 AND t_events_pkey > $21::int)
				ELSE t_events_pkey > $21::int
			END
		WHEN 'prev' THEN
			CASE $19
				WHEN 'start_time' THEN start_time < $20 OR (start_time = $20 AND t_events_pkey < $21::int)
				WHEN 'r_start_time' THEN start_time > $20 OR (start_time = $20 AND t_events_pkey < $21::int)
				ELSE t_events_pkey < $21::int
			END
	END
ORDER BY
	CASE WHEN $19::text = 'start_time' AND $18::text = 'next' THEN start_time END ASC,
	CASE WHEN $19::text = 'start_time' AND $18::text = 'prev' THEN start_time END DESC,
	CASE WHEN $19::text = 'r_start_time' AND $18::text = 'next' THEN start_time END ASC,
	CASE WHEN $19::text = 'r_start_time' AND $18::text = 'prev' THEN start_time END DESC,
	CASE WHEN $18::text = 'next' THEN t_events_pkey END ASC,
	CASE WHEN $18::text = 'prev' THEN t_events_pkey END DESC
LIMIT $1
`

type GetEventsWithPostUserUseKeysetPaginateParams struct {
	Limit                 int32       `json:"limit"`
	WhereLikeTitle        bool        `json:"where_like_title"`
	SearchTitle           string      `json:"search_title"`
	WhereOrganization     bool        `json:"where_organization"`
	OrganizationID        pgtype.UUID `json:"organization_id"`
	WhereMailSendFlag     bool        `json:"where_mail_send_flag"`
	MailSendFlag          bool        `json:"mail_send_flag"`
	WhereSendOrganization bool        `json:"where_send_organization"`
	SendOrganizationID    pgtype.UUID `json:"send_organization_id"`
	WhereEarlierStartTime bool        `json:"where_earlier_start_time"`
	EarlierStartTime      time.Time   `json:"earlier_start_time"`
	WhereLaterStartTime   bool        `json:"where_later_start_time"`
	LaterStartTime        time.Time   `json:"later_start_time"`
	WhereEarlierEndTime   bool        `json:"where_earlier_end_time"`
	EarlierEndTime        time.Time   `json:"earlier_end_time"`
	WhereLaterEndTime     bool        `json:"where_later_end_time"`
	LaterEndTime          time.Time   `json:"later_end_time"`
	CursorDirection       string      `json:"cursor_direction"`
	OrderMethod           interface{} `json:"order_method"`
	StartTimeCursor       time.Time   `json:"start_time_cursor"`
	Cursor                int32       `json:"cursor"`
}

type GetEventsWithPostUserUseKeysetPaginateRow struct {
	Event  Event  `json:"event"`
	Member Member `json:"member"`
}

func (q *Queries) GetEventsWithPostUserUseKeysetPaginate(ctx context.Context, arg GetEventsWithPostUserUseKeysetPaginateParams) ([]GetEventsWithPostUserUseKeysetPaginateRow, error) {
	rows, err := q.db.Query(ctx, getEventsWithPostUserUseKeysetPaginate,
		arg.Limit,
		arg.WhereLikeTitle,
		arg.SearchTitle,
		arg.WhereOrganization,
		arg.OrganizationID,
		arg.WhereMailSendFlag,
		arg.MailSendFlag,
		arg.WhereSendOrganization,
		arg.SendOrganizationID,
		arg.WhereEarlierStartTime,
		arg.EarlierStartTime,
		arg.WhereLaterStartTime,
		arg.LaterStartTime,
		arg.WhereEarlierEndTime,
		arg.EarlierEndTime,
		arg.WhereLaterEndTime,
		arg.LaterEndTime,
		arg.CursorDirection,
		arg.OrderMethod,
		arg.StartTimeCursor,
		arg.Cursor,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEventsWithPostUserUseKeysetPaginateRow{}
	for rows.Next() {
		var i GetEventsWithPostUserUseKeysetPaginateRow
		if err := rows.Scan(
			&i.Event.TEventsPkey,
			&i.Event.EventID,
			&i.Event.EventTypeID,
			&i.Event.Title,
			&i.Event.Description,
			&i.Event.OrganizationID,
			&i.Event.StartTime,
			&i.Event.EndTime,
			&i.Event.MailSendFlag,
			&i.Event.SendOrganizationID,
			&i.Event.PostedBy,
			&i.Event.LastEditedBy,
			&i.Event.PostedAt,
			&i.Event.LastEditedAt,
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageUrl,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsWithPostUserUseNumberedPaginate = `-- name: GetEventsWithPostUserUseNumberedPaginate :many
SELECT t_events.t_events_pkey, t_events.event_id, t_events.event_type_id, t_events.title, t_events.description, t_events.organization_id, t_events.start_time, t_events.end_time, t_events.mail_send_flag, t_events.send_organization_id, t_events.posted_by, t_events.last_edited_by, t_events.posted_at, t_events.last_edited_at, m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_url, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at FROM t_events
LEFT JOIN m_members ON t_events.posted_by = m_members.member_id
WHERE
	CASE WHEN $3::boolean = true THEN title LIKE '%' || $4::text || '%' ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN t_events.organization_id = $6 ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN mail_send_flag = $8 ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN send_organization_id = $10 ELSE TRUE END
AND
	CASE WHEN $11::boolean = true THEN start_time >= $12 ELSE TRUE END
AND
	CASE WHEN $13::boolean = true THEN start_time <= $14 ELSE TRUE END
AND
	CASE WHEN $15::boolean = true THEN end_time >= $16 ELSE TRUE END
AND
	CASE WHEN $17::boolean = true THEN end_time <= $18 ELSE TRUE END
ORDER BY
	CASE WHEN $19::text = 'start_time' THEN start_time END ASC,
	CASE WHEN $19::text = 'r_start_time' THEN start_time END DESC,
	t_events_pkey ASC
LIMIT $1 OFFSET $2
`

type GetEventsWithPostUserUseNumberedPaginateParams struct {
	Limit                 int32       `json:"limit"`
	Offset                int32       `json:"offset"`
	WhereLikeTitle        bool        `json:"where_like_title"`
	SearchTitle           string      `json:"search_title"`
	WhereOrganization     bool        `json:"where_organization"`
	OrganizationID        pgtype.UUID `json:"organization_id"`
	WhereMailSendFlag     bool        `json:"where_mail_send_flag"`
	MailSendFlag          bool        `json:"mail_send_flag"`
	WhereSendOrganization bool        `json:"where_send_organization"`
	SendOrganizationID    pgtype.UUID `json:"send_organization_id"`
	WhereEarlierStartTime bool        `json:"where_earlier_start_time"`
	EarlierStartTime      time.Time   `json:"earlier_start_time"`
	WhereLaterStartTime   bool        `json:"where_later_start_time"`
	LaterStartTime        time.Time   `json:"later_start_time"`
	WhereEarlierEndTime   bool        `json:"where_earlier_end_time"`
	EarlierEndTime        time.Time   `json:"earlier_end_time"`
	WhereLaterEndTime     bool        `json:"where_later_end_time"`
	LaterEndTime          time.Time   `json:"later_end_time"`
	OrderMethod           string      `json:"order_method"`
}

type GetEventsWithPostUserUseNumberedPaginateRow struct {
	Event  Event  `json:"event"`
	Member Member `json:"member"`
}

func (q *Queries) GetEventsWithPostUserUseNumberedPaginate(ctx context.Context, arg GetEventsWithPostUserUseNumberedPaginateParams) ([]GetEventsWithPostUserUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getEventsWithPostUserUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.WhereLikeTitle,
		arg.SearchTitle,
		arg.WhereOrganization,
		arg.OrganizationID,
		arg.WhereMailSendFlag,
		arg.MailSendFlag,
		arg.WhereSendOrganization,
		arg.SendOrganizationID,
		arg.WhereEarlierStartTime,
		arg.EarlierStartTime,
		arg.WhereLaterStartTime,
		arg.LaterStartTime,
		arg.WhereEarlierEndTime,
		arg.EarlierEndTime,
		arg.WhereLaterEndTime,
		arg.LaterEndTime,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEventsWithPostUserUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetEventsWithPostUserUseNumberedPaginateRow
		if err := rows.Scan(
			&i.Event.TEventsPkey,
			&i.Event.EventID,
			&i.Event.EventTypeID,
			&i.Event.Title,
			&i.Event.Description,
			&i.Event.OrganizationID,
			&i.Event.StartTime,
			&i.Event.EndTime,
			&i.Event.MailSendFlag,
			&i.Event.SendOrganizationID,
			&i.Event.PostedBy,
			&i.Event.LastEditedBy,
			&i.Event.PostedAt,
			&i.Event.LastEditedAt,
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageUrl,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsWithSendOrganization = `-- name: GetEventsWithSendOrganization :many
SELECT t_events.t_events_pkey, t_events.event_id, t_events.event_type_id, t_events.title, t_events.description, t_events.organization_id, t_events.start_time, t_events.end_time, t_events.mail_send_flag, t_events.send_organization_id, t_events.posted_by, t_events.last_edited_by, t_events.posted_at, t_events.last_edited_at, m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.color, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at, m_organizations.chat_room_id FROM t_events
LEFT JOIN m_organizations ON t_events.send_organization_id = m_organizations.organization_id
WHERE
	CASE WHEN $1::boolean = true THEN title LIKE '%' || $2::text || '%' ELSE TRUE END
AND
	CASE WHEN $3::boolean = true THEN t_events.organization_id = $4 ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN mail_send_flag = $6 ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN send_organization_id = $8 ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN start_time >= $10 ELSE TRUE END
AND
	CASE WHEN $11::boolean = true THEN start_time <= $12 ELSE TRUE END
AND
	CASE WHEN $13::boolean = true THEN end_time >= $14 ELSE TRUE END
AND
	CASE WHEN $15::boolean = true THEN end_time <= $16 ELSE TRUE END
ORDER BY
	CASE WHEN $17::text = 'start_time' THEN start_time END ASC,
	CASE WHEN $17::text = 'r_start_time' THEN start_time END DESC,
	t_events_pkey ASC
`

type GetEventsWithSendOrganizationParams struct {
	WhereLikeTitle        bool        `json:"where_like_title"`
	SearchTitle           string      `json:"search_title"`
	WhereOrganization     bool        `json:"where_organization"`
	OrganizationID        pgtype.UUID `json:"organization_id"`
	WhereMailSendFlag     bool        `json:"where_mail_send_flag"`
	MailSendFlag          bool        `json:"mail_send_flag"`
	WhereSendOrganization bool        `json:"where_send_organization"`
	SendOrganizationID    pgtype.UUID `json:"send_organization_id"`
	WhereEarlierStartTime bool        `json:"where_earlier_start_time"`
	EarlierStartTime      time.Time   `json:"earlier_start_time"`
	WhereLaterStartTime   bool        `json:"where_later_start_time"`
	LaterStartTime        time.Time   `json:"later_start_time"`
	WhereEarlierEndTime   bool        `json:"where_earlier_end_time"`
	EarlierEndTime        time.Time   `json:"earlier_end_time"`
	WhereLaterEndTime     bool        `json:"where_later_end_time"`
	LaterEndTime          time.Time   `json:"later_end_time"`
	OrderMethod           string      `json:"order_method"`
}

type GetEventsWithSendOrganizationRow struct {
	Event        Event        `json:"event"`
	Organization Organization `json:"organization"`
}

func (q *Queries) GetEventsWithSendOrganization(ctx context.Context, arg GetEventsWithSendOrganizationParams) ([]GetEventsWithSendOrganizationRow, error) {
	rows, err := q.db.Query(ctx, getEventsWithSendOrganization,
		arg.WhereLikeTitle,
		arg.SearchTitle,
		arg.WhereOrganization,
		arg.OrganizationID,
		arg.WhereMailSendFlag,
		arg.MailSendFlag,
		arg.WhereSendOrganization,
		arg.SendOrganizationID,
		arg.WhereEarlierStartTime,
		arg.EarlierStartTime,
		arg.WhereLaterStartTime,
		arg.LaterStartTime,
		arg.WhereEarlierEndTime,
		arg.EarlierEndTime,
		arg.WhereLaterEndTime,
		arg.LaterEndTime,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEventsWithSendOrganizationRow{}
	for rows.Next() {
		var i GetEventsWithSendOrganizationRow
		if err := rows.Scan(
			&i.Event.TEventsPkey,
			&i.Event.EventID,
			&i.Event.EventTypeID,
			&i.Event.Title,
			&i.Event.Description,
			&i.Event.OrganizationID,
			&i.Event.StartTime,
			&i.Event.EndTime,
			&i.Event.MailSendFlag,
			&i.Event.SendOrganizationID,
			&i.Event.PostedBy,
			&i.Event.LastEditedBy,
			&i.Event.PostedAt,
			&i.Event.LastEditedAt,
			&i.Organization.MOrganizationsPkey,
			&i.Organization.OrganizationID,
			&i.Organization.Name,
			&i.Organization.Description,
			&i.Organization.Color,
			&i.Organization.IsPersonal,
			&i.Organization.IsWhole,
			&i.Organization.CreatedAt,
			&i.Organization.UpdatedAt,
			&i.Organization.ChatRoomID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsWithSendOrganizationUseKeysetPaginate = `-- name: GetEventsWithSendOrganizationUseKeysetPaginate :many
SELECT t_events.t_events_pkey, t_events.event_id, t_events.event_type_id, t_events.title, t_events.description, t_events.organization_id, t_events.start_time, t_events.end_time, t_events.mail_send_flag, t_events.send_organization_id, t_events.posted_by, t_events.last_edited_by, t_events.posted_at, t_events.last_edited_at, m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.color, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at, m_organizations.chat_room_id FROM t_events
LEFT JOIN m_organizations ON t_events.send_organization_id = m_organizations.organization_id
WHERE
	CASE WHEN $2::boolean = true THEN title LIKE '%' || $3::text || '%' ELSE TRUE END
AND
	CASE WHEN $4::boolean = true THEN t_events.organization_id = $5 ELSE TRUE END
AND
	CASE WHEN $6::boolean = true THEN mail_send_flag = $7 ELSE TRUE END
AND
	CASE WHEN $8::boolean = true THEN send_organization_id = $9 ELSE TRUE END
AND
	CASE WHEN $10::boolean = true THEN start_time >= $11 ELSE TRUE END
AND
	CASE WHEN $12::boolean = true THEN start_time <= $13 ELSE TRUE END
AND
	CASE WHEN $14::boolean = true THEN end_time >= $15 ELSE TRUE END
AND
	CASE WHEN $16::boolean = true THEN end_time <= $17 ELSE TRUE END
AND
	CASE $18::text
		WHEN 'next' THEN
			CASE $19
				WHEN 'start_time' THEN start_time > $20 OR (start_time = $20 AND t_events_pkey > $21::int)
				WHEN 'r_start_time' THEN start_time < $20 OR (start_time = $20 AND t_events_pkey > $21::int)
				ELSE t_events_pkey > $21::int
			END
		WHEN 'prev' THEN
			CASE $19
				WHEN 'start_time' THEN start_time < $20 OR (start_time = $20 AND t_events_pkey < $21::int)
				WHEN 'r_start_time' THEN start_time > $20 OR (start_time = $20 AND t_events_pkey < $21::int)
				ELSE t_events_pkey < $21::int
			END
	END
ORDER BY
	CASE WHEN $19::text = 'start_time' AND $18::text = 'next' THEN start_time END ASC,
	CASE WHEN $19::text = 'start_time' AND $18::text = 'prev' THEN start_time END DESC,
	CASE WHEN $19::text = 'r_start_time' AND $18::text = 'next' THEN start_time END ASC,
	CASE WHEN $19::text = 'r_start_time' AND $18::text = 'prev' THEN start_time END DESC,
	CASE WHEN $18::text = 'next' THEN t_events_pkey END ASC,
	CASE WHEN $18::text = 'prev' THEN t_events_pkey END DESC
LIMIT $1
`

type GetEventsWithSendOrganizationUseKeysetPaginateParams struct {
	Limit                 int32       `json:"limit"`
	WhereLikeTitle        bool        `json:"where_like_title"`
	SearchTitle           string      `json:"search_title"`
	WhereOrganization     bool        `json:"where_organization"`
	OrganizationID        pgtype.UUID `json:"organization_id"`
	WhereMailSendFlag     bool        `json:"where_mail_send_flag"`
	MailSendFlag          bool        `json:"mail_send_flag"`
	WhereSendOrganization bool        `json:"where_send_organization"`
	SendOrganizationID    pgtype.UUID `json:"send_organization_id"`
	WhereEarlierStartTime bool        `json:"where_earlier_start_time"`
	EarlierStartTime      time.Time   `json:"earlier_start_time"`
	WhereLaterStartTime   bool        `json:"where_later_start_time"`
	LaterStartTime        time.Time   `json:"later_start_time"`
	WhereEarlierEndTime   bool        `json:"where_earlier_end_time"`
	EarlierEndTime        time.Time   `json:"earlier_end_time"`
	WhereLaterEndTime     bool        `json:"where_later_end_time"`
	LaterEndTime          time.Time   `json:"later_end_time"`
	CursorDirection       string      `json:"cursor_direction"`
	OrderMethod           interface{} `json:"order_method"`
	StartTimeCursor       time.Time   `json:"start_time_cursor"`
	Cursor                int32       `json:"cursor"`
}

type GetEventsWithSendOrganizationUseKeysetPaginateRow struct {
	Event        Event        `json:"event"`
	Organization Organization `json:"organization"`
}

func (q *Queries) GetEventsWithSendOrganizationUseKeysetPaginate(ctx context.Context, arg GetEventsWithSendOrganizationUseKeysetPaginateParams) ([]GetEventsWithSendOrganizationUseKeysetPaginateRow, error) {
	rows, err := q.db.Query(ctx, getEventsWithSendOrganizationUseKeysetPaginate,
		arg.Limit,
		arg.WhereLikeTitle,
		arg.SearchTitle,
		arg.WhereOrganization,
		arg.OrganizationID,
		arg.WhereMailSendFlag,
		arg.MailSendFlag,
		arg.WhereSendOrganization,
		arg.SendOrganizationID,
		arg.WhereEarlierStartTime,
		arg.EarlierStartTime,
		arg.WhereLaterStartTime,
		arg.LaterStartTime,
		arg.WhereEarlierEndTime,
		arg.EarlierEndTime,
		arg.WhereLaterEndTime,
		arg.LaterEndTime,
		arg.CursorDirection,
		arg.OrderMethod,
		arg.StartTimeCursor,
		arg.Cursor,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEventsWithSendOrganizationUseKeysetPaginateRow{}
	for rows.Next() {
		var i GetEventsWithSendOrganizationUseKeysetPaginateRow
		if err := rows.Scan(
			&i.Event.TEventsPkey,
			&i.Event.EventID,
			&i.Event.EventTypeID,
			&i.Event.Title,
			&i.Event.Description,
			&i.Event.OrganizationID,
			&i.Event.StartTime,
			&i.Event.EndTime,
			&i.Event.MailSendFlag,
			&i.Event.SendOrganizationID,
			&i.Event.PostedBy,
			&i.Event.LastEditedBy,
			&i.Event.PostedAt,
			&i.Event.LastEditedAt,
			&i.Organization.MOrganizationsPkey,
			&i.Organization.OrganizationID,
			&i.Organization.Name,
			&i.Organization.Description,
			&i.Organization.Color,
			&i.Organization.IsPersonal,
			&i.Organization.IsWhole,
			&i.Organization.CreatedAt,
			&i.Organization.UpdatedAt,
			&i.Organization.ChatRoomID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsWithSendOrganizationUseNumberedPaginate = `-- name: GetEventsWithSendOrganizationUseNumberedPaginate :many
SELECT t_events.t_events_pkey, t_events.event_id, t_events.event_type_id, t_events.title, t_events.description, t_events.organization_id, t_events.start_time, t_events.end_time, t_events.mail_send_flag, t_events.send_organization_id, t_events.posted_by, t_events.last_edited_by, t_events.posted_at, t_events.last_edited_at, m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.color, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at, m_organizations.chat_room_id FROM t_events
LEFT JOIN m_organizations ON t_events.send_organization_id = m_organizations.organization_id
WHERE
	CASE WHEN $3::boolean = true THEN title LIKE '%' || $4::text || '%' ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN t_events.organization_id = $6 ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN mail_send_flag = $8 ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN send_organization_id = $10 ELSE TRUE END
AND
	CASE WHEN $11::boolean = true THEN start_time >= $12 ELSE TRUE END
AND
	CASE WHEN $13::boolean = true THEN start_time <= $14 ELSE TRUE END
AND
	CASE WHEN $15::boolean = true THEN end_time >= $16 ELSE TRUE END
AND
	CASE WHEN $17::boolean = true THEN end_time <= $18 ELSE TRUE END
ORDER BY
	CASE WHEN $19::text = 'start_time' THEN start_time END ASC,
	CASE WHEN $19::text = 'r_start_time' THEN start_time END DESC,
	t_events_pkey ASC
LIMIT $1 OFFSET $2
`

type GetEventsWithSendOrganizationUseNumberedPaginateParams struct {
	Limit                 int32       `json:"limit"`
	Offset                int32       `json:"offset"`
	WhereLikeTitle        bool        `json:"where_like_title"`
	SearchTitle           string      `json:"search_title"`
	WhereOrganization     bool        `json:"where_organization"`
	OrganizationID        pgtype.UUID `json:"organization_id"`
	WhereMailSendFlag     bool        `json:"where_mail_send_flag"`
	MailSendFlag          bool        `json:"mail_send_flag"`
	WhereSendOrganization bool        `json:"where_send_organization"`
	SendOrganizationID    pgtype.UUID `json:"send_organization_id"`
	WhereEarlierStartTime bool        `json:"where_earlier_start_time"`
	EarlierStartTime      time.Time   `json:"earlier_start_time"`
	WhereLaterStartTime   bool        `json:"where_later_start_time"`
	LaterStartTime        time.Time   `json:"later_start_time"`
	WhereEarlierEndTime   bool        `json:"where_earlier_end_time"`
	EarlierEndTime        time.Time   `json:"earlier_end_time"`
	WhereLaterEndTime     bool        `json:"where_later_end_time"`
	LaterEndTime          time.Time   `json:"later_end_time"`
	OrderMethod           string      `json:"order_method"`
}

type GetEventsWithSendOrganizationUseNumberedPaginateRow struct {
	Event        Event        `json:"event"`
	Organization Organization `json:"organization"`
}

func (q *Queries) GetEventsWithSendOrganizationUseNumberedPaginate(ctx context.Context, arg GetEventsWithSendOrganizationUseNumberedPaginateParams) ([]GetEventsWithSendOrganizationUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getEventsWithSendOrganizationUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.WhereLikeTitle,
		arg.SearchTitle,
		arg.WhereOrganization,
		arg.OrganizationID,
		arg.WhereMailSendFlag,
		arg.MailSendFlag,
		arg.WhereSendOrganization,
		arg.SendOrganizationID,
		arg.WhereEarlierStartTime,
		arg.EarlierStartTime,
		arg.WhereLaterStartTime,
		arg.LaterStartTime,
		arg.WhereEarlierEndTime,
		arg.EarlierEndTime,
		arg.WhereLaterEndTime,
		arg.LaterEndTime,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEventsWithSendOrganizationUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetEventsWithSendOrganizationUseNumberedPaginateRow
		if err := rows.Scan(
			&i.Event.TEventsPkey,
			&i.Event.EventID,
			&i.Event.EventTypeID,
			&i.Event.Title,
			&i.Event.Description,
			&i.Event.OrganizationID,
			&i.Event.StartTime,
			&i.Event.EndTime,
			&i.Event.MailSendFlag,
			&i.Event.SendOrganizationID,
			&i.Event.PostedBy,
			&i.Event.LastEditedBy,
			&i.Event.PostedAt,
			&i.Event.LastEditedAt,
			&i.Organization.MOrganizationsPkey,
			&i.Organization.OrganizationID,
			&i.Organization.Name,
			&i.Organization.Description,
			&i.Organization.Color,
			&i.Organization.IsPersonal,
			&i.Organization.IsWhole,
			&i.Organization.CreatedAt,
			&i.Organization.UpdatedAt,
			&i.Organization.ChatRoomID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsWithType = `-- name: GetEventsWithType :many
SELECT t_events.t_events_pkey, t_events.event_id, t_events.event_type_id, t_events.title, t_events.description, t_events.organization_id, t_events.start_time, t_events.end_time, t_events.mail_send_flag, t_events.send_organization_id, t_events.posted_by, t_events.last_edited_by, t_events.posted_at, t_events.last_edited_at, m_event_types.m_event_types_pkey, m_event_types.event_type_id, m_event_types.name, m_event_types.key, m_event_types.color FROM t_events
LEFT JOIN m_event_types ON t_events.event_type_id = m_event_types.event_type_id
WHERE
	CASE WHEN $1::boolean = true THEN title LIKE '%' || $2::text || '%' ELSE TRUE END
AND
	CASE WHEN $3::boolean = true THEN t_events.organization_id = $4 ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN mail_send_flag = $6 ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN send_organization_id = $8 ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN start_time >= $10 ELSE TRUE END
AND
	CASE WHEN $11::boolean = true THEN start_time <= $12 ELSE TRUE END
AND
	CASE WHEN $13::boolean = true THEN end_time >= $14 ELSE TRUE END
AND
	CASE WHEN $15::boolean = true THEN end_time <= $16 ELSE TRUE END
ORDER BY
	CASE WHEN $17::text = 'start_time' THEN start_time END ASC,
	CASE WHEN $17::text = 'r_start_time' THEN start_time END DESC,
	t_events_pkey ASC
`

type GetEventsWithTypeParams struct {
	WhereLikeTitle        bool        `json:"where_like_title"`
	SearchTitle           string      `json:"search_title"`
	WhereOrganization     bool        `json:"where_organization"`
	OrganizationID        pgtype.UUID `json:"organization_id"`
	WhereMailSendFlag     bool        `json:"where_mail_send_flag"`
	MailSendFlag          bool        `json:"mail_send_flag"`
	WhereSendOrganization bool        `json:"where_send_organization"`
	SendOrganizationID    pgtype.UUID `json:"send_organization_id"`
	WhereEarlierStartTime bool        `json:"where_earlier_start_time"`
	EarlierStartTime      time.Time   `json:"earlier_start_time"`
	WhereLaterStartTime   bool        `json:"where_later_start_time"`
	LaterStartTime        time.Time   `json:"later_start_time"`
	WhereEarlierEndTime   bool        `json:"where_earlier_end_time"`
	EarlierEndTime        time.Time   `json:"earlier_end_time"`
	WhereLaterEndTime     bool        `json:"where_later_end_time"`
	LaterEndTime          time.Time   `json:"later_end_time"`
	OrderMethod           string      `json:"order_method"`
}

type GetEventsWithTypeRow struct {
	Event     Event     `json:"event"`
	EventType EventType `json:"event_type"`
}

func (q *Queries) GetEventsWithType(ctx context.Context, arg GetEventsWithTypeParams) ([]GetEventsWithTypeRow, error) {
	rows, err := q.db.Query(ctx, getEventsWithType,
		arg.WhereLikeTitle,
		arg.SearchTitle,
		arg.WhereOrganization,
		arg.OrganizationID,
		arg.WhereMailSendFlag,
		arg.MailSendFlag,
		arg.WhereSendOrganization,
		arg.SendOrganizationID,
		arg.WhereEarlierStartTime,
		arg.EarlierStartTime,
		arg.WhereLaterStartTime,
		arg.LaterStartTime,
		arg.WhereEarlierEndTime,
		arg.EarlierEndTime,
		arg.WhereLaterEndTime,
		arg.LaterEndTime,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEventsWithTypeRow{}
	for rows.Next() {
		var i GetEventsWithTypeRow
		if err := rows.Scan(
			&i.Event.TEventsPkey,
			&i.Event.EventID,
			&i.Event.EventTypeID,
			&i.Event.Title,
			&i.Event.Description,
			&i.Event.OrganizationID,
			&i.Event.StartTime,
			&i.Event.EndTime,
			&i.Event.MailSendFlag,
			&i.Event.SendOrganizationID,
			&i.Event.PostedBy,
			&i.Event.LastEditedBy,
			&i.Event.PostedAt,
			&i.Event.LastEditedAt,
			&i.EventType.MEventTypesPkey,
			&i.EventType.EventTypeID,
			&i.EventType.Name,
			&i.EventType.Key,
			&i.EventType.Color,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsWithTypeUseKeysetPaginate = `-- name: GetEventsWithTypeUseKeysetPaginate :many
SELECT t_events.t_events_pkey, t_events.event_id, t_events.event_type_id, t_events.title, t_events.description, t_events.organization_id, t_events.start_time, t_events.end_time, t_events.mail_send_flag, t_events.send_organization_id, t_events.posted_by, t_events.last_edited_by, t_events.posted_at, t_events.last_edited_at, m_event_types.m_event_types_pkey, m_event_types.event_type_id, m_event_types.name, m_event_types.key, m_event_types.color FROM t_events
LEFT JOIN m_event_types ON t_events.event_type_id = m_event_types.event_type_id
WHERE
	CASE WHEN $2::boolean = true THEN title LIKE '%' || $3::text || '%' ELSE TRUE END
AND
	CASE WHEN $4::boolean = true THEN t_events.organization_id = $5 ELSE TRUE END
AND
	CASE WHEN $6::boolean = true THEN mail_send_flag = $7 ELSE TRUE END
AND
	CASE WHEN $8::boolean = true THEN send_organization_id = $9 ELSE TRUE END
AND
	CASE WHEN $10::boolean = true THEN start_time >= $11 ELSE TRUE END
AND
	CASE WHEN $12::boolean = true THEN start_time <= $13 ELSE TRUE END
AND
	CASE WHEN $14::boolean = true THEN end_time >= $15 ELSE TRUE END
AND
	CASE WHEN $16::boolean = true THEN end_time <= $17 ELSE TRUE END
AND
	CASE $18::text
		WHEN 'next' THEN
			CASE $19
				WHEN 'start_time' THEN start_time > $20 OR (start_time = $20 AND t_events_pkey > $21::int)
				WHEN 'r_start_time' THEN start_time < $20 OR (start_time = $20 AND t_events_pkey > $21::int)
				ELSE t_events_pkey > $21::int
			END
		WHEN 'prev' THEN
			CASE $19
				WHEN 'start_time' THEN start_time < $20 OR (start_time = $20 AND t_events_pkey < $21::int)
				WHEN 'r_start_time' THEN start_time > $20 OR (start_time = $20 AND t_events_pkey < $21::int)
				ELSE t_events_pkey < $21::int
			END
	END
ORDER BY
	CASE WHEN $19::text = 'start_time' AND $18::text = 'next' THEN start_time END ASC,
	CASE WHEN $19::text = 'start_time' AND $18::text = 'prev' THEN start_time END DESC,
	CASE WHEN $19::text = 'r_start_time' AND $18::text = 'next' THEN start_time END ASC,
	CASE WHEN $19::text = 'r_start_time' AND $18::text = 'prev' THEN start_time END DESC,
	CASE WHEN $18::text = 'next' THEN t_events_pkey END ASC,
	CASE WHEN $18::text = 'prev' THEN t_events_pkey END DESC
LIMIT $1
`

type GetEventsWithTypeUseKeysetPaginateParams struct {
	Limit                 int32       `json:"limit"`
	WhereLikeTitle        bool        `json:"where_like_title"`
	SearchTitle           string      `json:"search_title"`
	WhereOrganization     bool        `json:"where_organization"`
	OrganizationID        pgtype.UUID `json:"organization_id"`
	WhereMailSendFlag     bool        `json:"where_mail_send_flag"`
	MailSendFlag          bool        `json:"mail_send_flag"`
	WhereSendOrganization bool        `json:"where_send_organization"`
	SendOrganizationID    pgtype.UUID `json:"send_organization_id"`
	WhereEarlierStartTime bool        `json:"where_earlier_start_time"`
	EarlierStartTime      time.Time   `json:"earlier_start_time"`
	WhereLaterStartTime   bool        `json:"where_later_start_time"`
	LaterStartTime        time.Time   `json:"later_start_time"`
	WhereEarlierEndTime   bool        `json:"where_earlier_end_time"`
	EarlierEndTime        time.Time   `json:"earlier_end_time"`
	WhereLaterEndTime     bool        `json:"where_later_end_time"`
	LaterEndTime          time.Time   `json:"later_end_time"`
	CursorDirection       string      `json:"cursor_direction"`
	OrderMethod           interface{} `json:"order_method"`
	StartTimeCursor       time.Time   `json:"start_time_cursor"`
	Cursor                int32       `json:"cursor"`
}

type GetEventsWithTypeUseKeysetPaginateRow struct {
	Event     Event     `json:"event"`
	EventType EventType `json:"event_type"`
}

func (q *Queries) GetEventsWithTypeUseKeysetPaginate(ctx context.Context, arg GetEventsWithTypeUseKeysetPaginateParams) ([]GetEventsWithTypeUseKeysetPaginateRow, error) {
	rows, err := q.db.Query(ctx, getEventsWithTypeUseKeysetPaginate,
		arg.Limit,
		arg.WhereLikeTitle,
		arg.SearchTitle,
		arg.WhereOrganization,
		arg.OrganizationID,
		arg.WhereMailSendFlag,
		arg.MailSendFlag,
		arg.WhereSendOrganization,
		arg.SendOrganizationID,
		arg.WhereEarlierStartTime,
		arg.EarlierStartTime,
		arg.WhereLaterStartTime,
		arg.LaterStartTime,
		arg.WhereEarlierEndTime,
		arg.EarlierEndTime,
		arg.WhereLaterEndTime,
		arg.LaterEndTime,
		arg.CursorDirection,
		arg.OrderMethod,
		arg.StartTimeCursor,
		arg.Cursor,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEventsWithTypeUseKeysetPaginateRow{}
	for rows.Next() {
		var i GetEventsWithTypeUseKeysetPaginateRow
		if err := rows.Scan(
			&i.Event.TEventsPkey,
			&i.Event.EventID,
			&i.Event.EventTypeID,
			&i.Event.Title,
			&i.Event.Description,
			&i.Event.OrganizationID,
			&i.Event.StartTime,
			&i.Event.EndTime,
			&i.Event.MailSendFlag,
			&i.Event.SendOrganizationID,
			&i.Event.PostedBy,
			&i.Event.LastEditedBy,
			&i.Event.PostedAt,
			&i.Event.LastEditedAt,
			&i.EventType.MEventTypesPkey,
			&i.EventType.EventTypeID,
			&i.EventType.Name,
			&i.EventType.Key,
			&i.EventType.Color,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsWithTypeUseNumberedPaginate = `-- name: GetEventsWithTypeUseNumberedPaginate :many
SELECT t_events.t_events_pkey, t_events.event_id, t_events.event_type_id, t_events.title, t_events.description, t_events.organization_id, t_events.start_time, t_events.end_time, t_events.mail_send_flag, t_events.send_organization_id, t_events.posted_by, t_events.last_edited_by, t_events.posted_at, t_events.last_edited_at, m_event_types.m_event_types_pkey, m_event_types.event_type_id, m_event_types.name, m_event_types.key, m_event_types.color FROM t_events
LEFT JOIN m_event_types ON t_events.event_type_id = m_event_types.event_type_id
WHERE
	CASE WHEN $3::boolean = true THEN title LIKE '%' || $4::text || '%' ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN t_events.organization_id = $6 ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN mail_send_flag = $8 ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN send_organization_id = $10 ELSE TRUE END
AND
	CASE WHEN $11::boolean = true THEN start_time >= $12 ELSE TRUE END
AND
	CASE WHEN $13::boolean = true THEN start_time <= $14 ELSE TRUE END
AND
	CASE WHEN $15::boolean = true THEN end_time >= $16 ELSE TRUE END
AND
	CASE WHEN $17::boolean = true THEN end_time <= $18 ELSE TRUE END
ORDER BY
	CASE WHEN $19::text = 'start_time' THEN start_time END ASC,
	CASE WHEN $19::text = 'r_start_time' THEN start_time END DESC,
	t_events_pkey ASC
LIMIT $1 OFFSET $2
`

type GetEventsWithTypeUseNumberedPaginateParams struct {
	Limit                 int32       `json:"limit"`
	Offset                int32       `json:"offset"`
	WhereLikeTitle        bool        `json:"where_like_title"`
	SearchTitle           string      `json:"search_title"`
	WhereOrganization     bool        `json:"where_organization"`
	OrganizationID        pgtype.UUID `json:"organization_id"`
	WhereMailSendFlag     bool        `json:"where_mail_send_flag"`
	MailSendFlag          bool        `json:"mail_send_flag"`
	WhereSendOrganization bool        `json:"where_send_organization"`
	SendOrganizationID    pgtype.UUID `json:"send_organization_id"`
	WhereEarlierStartTime bool        `json:"where_earlier_start_time"`
	EarlierStartTime      time.Time   `json:"earlier_start_time"`
	WhereLaterStartTime   bool        `json:"where_later_start_time"`
	LaterStartTime        time.Time   `json:"later_start_time"`
	WhereEarlierEndTime   bool        `json:"where_earlier_end_time"`
	EarlierEndTime        time.Time   `json:"earlier_end_time"`
	WhereLaterEndTime     bool        `json:"where_later_end_time"`
	LaterEndTime          time.Time   `json:"later_end_time"`
	OrderMethod           string      `json:"order_method"`
}

type GetEventsWithTypeUseNumberedPaginateRow struct {
	Event     Event     `json:"event"`
	EventType EventType `json:"event_type"`
}

func (q *Queries) GetEventsWithTypeUseNumberedPaginate(ctx context.Context, arg GetEventsWithTypeUseNumberedPaginateParams) ([]GetEventsWithTypeUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getEventsWithTypeUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.WhereLikeTitle,
		arg.SearchTitle,
		arg.WhereOrganization,
		arg.OrganizationID,
		arg.WhereMailSendFlag,
		arg.MailSendFlag,
		arg.WhereSendOrganization,
		arg.SendOrganizationID,
		arg.WhereEarlierStartTime,
		arg.EarlierStartTime,
		arg.WhereLaterStartTime,
		arg.LaterStartTime,
		arg.WhereEarlierEndTime,
		arg.EarlierEndTime,
		arg.WhereLaterEndTime,
		arg.LaterEndTime,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEventsWithTypeUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetEventsWithTypeUseNumberedPaginateRow
		if err := rows.Scan(
			&i.Event.TEventsPkey,
			&i.Event.EventID,
			&i.Event.EventTypeID,
			&i.Event.Title,
			&i.Event.Description,
			&i.Event.OrganizationID,
			&i.Event.StartTime,
			&i.Event.EndTime,
			&i.Event.MailSendFlag,
			&i.Event.SendOrganizationID,
			&i.Event.PostedBy,
			&i.Event.LastEditedBy,
			&i.Event.PostedAt,
			&i.Event.LastEditedAt,
			&i.EventType.MEventTypesPkey,
			&i.EventType.EventTypeID,
			&i.EventType.Name,
			&i.EventType.Key,
			&i.EventType.Color,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralEvents = `-- name: GetPluralEvents :many
SELECT t_events_pkey, event_id, event_type_id, title, description, organization_id, start_time, end_time, mail_send_flag, send_organization_id, posted_by, last_edited_by, posted_at, last_edited_at FROM t_events WHERE event_id = ANY($3::uuid[])
ORDER BY
	t_events_pkey ASC
LIMIT $1 OFFSET $2
`

type GetPluralEventsParams struct {
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
	EventIds []uuid.UUID `json:"event_ids"`
}

func (q *Queries) GetPluralEvents(ctx context.Context, arg GetPluralEventsParams) ([]Event, error) {
	rows, err := q.db.Query(ctx, getPluralEvents, arg.Limit, arg.Offset, arg.EventIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Event{}
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.TEventsPkey,
			&i.EventID,
			&i.EventTypeID,
			&i.Title,
			&i.Description,
			&i.OrganizationID,
			&i.StartTime,
			&i.EndTime,
			&i.MailSendFlag,
			&i.SendOrganizationID,
			&i.PostedBy,
			&i.LastEditedBy,
			&i.PostedAt,
			&i.LastEditedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralEventsWithAll = `-- name: GetPluralEventsWithAll :many
SELECT t_events.t_events_pkey, t_events.event_id, t_events.event_type_id, t_events.title, t_events.description, t_events.organization_id, t_events.start_time, t_events.end_time, t_events.mail_send_flag, t_events.send_organization_id, t_events.posted_by, t_events.last_edited_by, t_events.posted_at, t_events.last_edited_at, o.m_event_types_pkey, o.event_type_id, o.name, o.key, o.color, s.m_organizations_pkey, s.organization_id, s.name, s.description, s.color, s.is_personal, s.is_whole, s.created_at, s.updated_at, s.chat_room_id, p.m_organizations_pkey, p.organization_id, p.name, p.description, p.color, p.is_personal, p.is_whole, p.created_at, p.updated_at, p.chat_room_id, l.m_members_pkey, l.member_id, l.login_id, l.password, l.email, l.name, l.attend_status_id, l.profile_image_url, l.grade_id, l.group_id, l.personal_organization_id, l.role_id, l.created_at, l.updated_at, l.m_members_pkey, l.member_id, l.login_id, l.password, l.email, l.name, l.attend_status_id, l.profile_image_url, l.grade_id, l.group_id, l.personal_organization_id, l.role_id, l.created_at, l.updated_at, l.m_members_pkey, l.member_id, l.login_id, l.password, l.email, l.name, l.attend_status_id, l.profile_image_url, l.grade_id, l.group_id, l.personal_organization_id, l.role_id, l.created_at, l.updated_at, l.m_members_pkey, l.member_id, l.login_id, l.password, l.email, l.name, l.attend_status_id, l.profile_image_url, l.grade_id, l.group_id, l.personal_organization_id, l.role_id, l.created_at, l.updated_at FROM t_events
LEFT JOIN m_event_types o ON t_events.event_type_id = o.event_type_id
LEFT JOIN m_organizations s ON t_events.organization_id = s.organization_id
LEFT JOIN m_organizations p ON t_events.send_organization_id = p.organization_id
LEFT JOIN m_members l ON t_events.posted_by = l.member_id
LEFT JOIN m_members l ON t_events.last_edited_by = l.member_id
WHERE event_id = ANY($3::uuid[])
ORDER BY
	t_events_pkey ASC
LIMIT $1 OFFSET $2
`

type GetPluralEventsWithAllParams struct {
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
	EventIds []uuid.UUID `json:"event_ids"`
}

type GetPluralEventsWithAllRow struct {
	Event          Event        `json:"event"`
	EventType      EventType    `json:"event_type"`
	Organization   Organization `json:"organization"`
	Organization_2 Organization `json:"organization_2"`
	Member         Member       `json:"member"`
	Member_2       Member       `json:"member_2"`
}

func (q *Queries) GetPluralEventsWithAll(ctx context.Context, arg GetPluralEventsWithAllParams) ([]GetPluralEventsWithAllRow, error) {
	rows, err := q.db.Query(ctx, getPluralEventsWithAll, arg.Limit, arg.Offset, arg.EventIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralEventsWithAllRow{}
	for rows.Next() {
		var i GetPluralEventsWithAllRow
		if err := rows.Scan(
			&i.Event.TEventsPkey,
			&i.Event.EventID,
			&i.Event.EventTypeID,
			&i.Event.Title,
			&i.Event.Description,
			&i.Event.OrganizationID,
			&i.Event.StartTime,
			&i.Event.EndTime,
			&i.Event.MailSendFlag,
			&i.Event.SendOrganizationID,
			&i.Event.PostedBy,
			&i.Event.LastEditedBy,
			&i.Event.PostedAt,
			&i.Event.LastEditedAt,
			&i.EventType.MEventTypesPkey,
			&i.EventType.EventTypeID,
			&i.EventType.Name,
			&i.EventType.Key,
			&i.EventType.Color,
			&i.Organization.MOrganizationsPkey,
			&i.Organization.OrganizationID,
			&i.Organization.Name,
			&i.Organization.Description,
			&i.Organization.Color,
			&i.Organization.IsPersonal,
			&i.Organization.IsWhole,
			&i.Organization.CreatedAt,
			&i.Organization.UpdatedAt,
			&i.Organization.ChatRoomID,
			&i.Organization_2.MOrganizationsPkey,
			&i.Organization_2.OrganizationID,
			&i.Organization_2.Name,
			&i.Organization_2.Description,
			&i.Organization_2.Color,
			&i.Organization_2.IsPersonal,
			&i.Organization_2.IsWhole,
			&i.Organization_2.CreatedAt,
			&i.Organization_2.UpdatedAt,
			&i.Organization_2.ChatRoomID,
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageUrl,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
			&i.Member_2.MMembersPkey,
			&i.Member_2.MemberID,
			&i.Member_2.LoginID,
			&i.Member_2.Password,
			&i.Member_2.Email,
			&i.Member_2.Name,
			&i.Member_2.AttendStatusID,
			&i.Member_2.ProfileImageUrl,
			&i.Member_2.GradeID,
			&i.Member_2.GroupID,
			&i.Member_2.PersonalOrganizationID,
			&i.Member_2.RoleID,
			&i.Member_2.CreatedAt,
			&i.Member_2.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralEventsWithLastEditUser = `-- name: GetPluralEventsWithLastEditUser :many
SELECT t_events.t_events_pkey, t_events.event_id, t_events.event_type_id, t_events.title, t_events.description, t_events.organization_id, t_events.start_time, t_events.end_time, t_events.mail_send_flag, t_events.send_organization_id, t_events.posted_by, t_events.last_edited_by, t_events.posted_at, t_events.last_edited_at, m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_url, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at FROM t_events
LEFT JOIN m_members ON t_events.last_edited_by = m_members.member_id
WHERE event_id = ANY($3::uuid[])
ORDER BY
	t_events_pkey ASC
LIMIT $1 OFFSET $2
`

type GetPluralEventsWithLastEditUserParams struct {
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
	EventIds []uuid.UUID `json:"event_ids"`
}

type GetPluralEventsWithLastEditUserRow struct {
	Event  Event  `json:"event"`
	Member Member `json:"member"`
}

func (q *Queries) GetPluralEventsWithLastEditUser(ctx context.Context, arg GetPluralEventsWithLastEditUserParams) ([]GetPluralEventsWithLastEditUserRow, error) {
	rows, err := q.db.Query(ctx, getPluralEventsWithLastEditUser, arg.Limit, arg.Offset, arg.EventIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralEventsWithLastEditUserRow{}
	for rows.Next() {
		var i GetPluralEventsWithLastEditUserRow
		if err := rows.Scan(
			&i.Event.TEventsPkey,
			&i.Event.EventID,
			&i.Event.EventTypeID,
			&i.Event.Title,
			&i.Event.Description,
			&i.Event.OrganizationID,
			&i.Event.StartTime,
			&i.Event.EndTime,
			&i.Event.MailSendFlag,
			&i.Event.SendOrganizationID,
			&i.Event.PostedBy,
			&i.Event.LastEditedBy,
			&i.Event.PostedAt,
			&i.Event.LastEditedAt,
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageUrl,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralEventsWithOrganization = `-- name: GetPluralEventsWithOrganization :many
SELECT t_events.t_events_pkey, t_events.event_id, t_events.event_type_id, t_events.title, t_events.description, t_events.organization_id, t_events.start_time, t_events.end_time, t_events.mail_send_flag, t_events.send_organization_id, t_events.posted_by, t_events.last_edited_by, t_events.posted_at, t_events.last_edited_at, m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.color, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at, m_organizations.chat_room_id FROM t_events
LEFT JOIN m_organizations ON t_events.organization_id = m_organizations.organization_id
WHERE event_id = ANY($3::uuid[])
ORDER BY
	t_events_pkey ASC
LIMIT $1 OFFSET $2
`

type GetPluralEventsWithOrganizationParams struct {
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
	EventIds []uuid.UUID `json:"event_ids"`
}

type GetPluralEventsWithOrganizationRow struct {
	Event        Event        `json:"event"`
	Organization Organization `json:"organization"`
}

func (q *Queries) GetPluralEventsWithOrganization(ctx context.Context, arg GetPluralEventsWithOrganizationParams) ([]GetPluralEventsWithOrganizationRow, error) {
	rows, err := q.db.Query(ctx, getPluralEventsWithOrganization, arg.Limit, arg.Offset, arg.EventIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralEventsWithOrganizationRow{}
	for rows.Next() {
		var i GetPluralEventsWithOrganizationRow
		if err := rows.Scan(
			&i.Event.TEventsPkey,
			&i.Event.EventID,
			&i.Event.EventTypeID,
			&i.Event.Title,
			&i.Event.Description,
			&i.Event.OrganizationID,
			&i.Event.StartTime,
			&i.Event.EndTime,
			&i.Event.MailSendFlag,
			&i.Event.SendOrganizationID,
			&i.Event.PostedBy,
			&i.Event.LastEditedBy,
			&i.Event.PostedAt,
			&i.Event.LastEditedAt,
			&i.Organization.MOrganizationsPkey,
			&i.Organization.OrganizationID,
			&i.Organization.Name,
			&i.Organization.Description,
			&i.Organization.Color,
			&i.Organization.IsPersonal,
			&i.Organization.IsWhole,
			&i.Organization.CreatedAt,
			&i.Organization.UpdatedAt,
			&i.Organization.ChatRoomID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralEventsWithPostUser = `-- name: GetPluralEventsWithPostUser :many
SELECT t_events.t_events_pkey, t_events.event_id, t_events.event_type_id, t_events.title, t_events.description, t_events.organization_id, t_events.start_time, t_events.end_time, t_events.mail_send_flag, t_events.send_organization_id, t_events.posted_by, t_events.last_edited_by, t_events.posted_at, t_events.last_edited_at, m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_url, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at FROM t_events
LEFT JOIN m_members ON t_events.posted_by = m_members.member_id
WHERE event_id = ANY($3::uuid[])
ORDER BY
	t_events_pkey ASC
LIMIT $1 OFFSET $2
`

type GetPluralEventsWithPostUserParams struct {
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
	EventIds []uuid.UUID `json:"event_ids"`
}

type GetPluralEventsWithPostUserRow struct {
	Event  Event  `json:"event"`
	Member Member `json:"member"`
}

func (q *Queries) GetPluralEventsWithPostUser(ctx context.Context, arg GetPluralEventsWithPostUserParams) ([]GetPluralEventsWithPostUserRow, error) {
	rows, err := q.db.Query(ctx, getPluralEventsWithPostUser, arg.Limit, arg.Offset, arg.EventIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralEventsWithPostUserRow{}
	for rows.Next() {
		var i GetPluralEventsWithPostUserRow
		if err := rows.Scan(
			&i.Event.TEventsPkey,
			&i.Event.EventID,
			&i.Event.EventTypeID,
			&i.Event.Title,
			&i.Event.Description,
			&i.Event.OrganizationID,
			&i.Event.StartTime,
			&i.Event.EndTime,
			&i.Event.MailSendFlag,
			&i.Event.SendOrganizationID,
			&i.Event.PostedBy,
			&i.Event.LastEditedBy,
			&i.Event.PostedAt,
			&i.Event.LastEditedAt,
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageUrl,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralEventsWithSendOrganization = `-- name: GetPluralEventsWithSendOrganization :many
SELECT t_events.t_events_pkey, t_events.event_id, t_events.event_type_id, t_events.title, t_events.description, t_events.organization_id, t_events.start_time, t_events.end_time, t_events.mail_send_flag, t_events.send_organization_id, t_events.posted_by, t_events.last_edited_by, t_events.posted_at, t_events.last_edited_at, m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.color, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at, m_organizations.chat_room_id FROM t_events
LEFT JOIN m_organizations ON t_events.send_organization_id = m_organizations.organization_id
WHERE event_id = ANY($3::uuid[])
ORDER BY
	t_events_pkey ASC
LIMIT $1 OFFSET $2
`

type GetPluralEventsWithSendOrganizationParams struct {
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
	EventIds []uuid.UUID `json:"event_ids"`
}

type GetPluralEventsWithSendOrganizationRow struct {
	Event        Event        `json:"event"`
	Organization Organization `json:"organization"`
}

func (q *Queries) GetPluralEventsWithSendOrganization(ctx context.Context, arg GetPluralEventsWithSendOrganizationParams) ([]GetPluralEventsWithSendOrganizationRow, error) {
	rows, err := q.db.Query(ctx, getPluralEventsWithSendOrganization, arg.Limit, arg.Offset, arg.EventIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralEventsWithSendOrganizationRow{}
	for rows.Next() {
		var i GetPluralEventsWithSendOrganizationRow
		if err := rows.Scan(
			&i.Event.TEventsPkey,
			&i.Event.EventID,
			&i.Event.EventTypeID,
			&i.Event.Title,
			&i.Event.Description,
			&i.Event.OrganizationID,
			&i.Event.StartTime,
			&i.Event.EndTime,
			&i.Event.MailSendFlag,
			&i.Event.SendOrganizationID,
			&i.Event.PostedBy,
			&i.Event.LastEditedBy,
			&i.Event.PostedAt,
			&i.Event.LastEditedAt,
			&i.Organization.MOrganizationsPkey,
			&i.Organization.OrganizationID,
			&i.Organization.Name,
			&i.Organization.Description,
			&i.Organization.Color,
			&i.Organization.IsPersonal,
			&i.Organization.IsWhole,
			&i.Organization.CreatedAt,
			&i.Organization.UpdatedAt,
			&i.Organization.ChatRoomID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralEventsWithType = `-- name: GetPluralEventsWithType :many
SELECT t_events.t_events_pkey, t_events.event_id, t_events.event_type_id, t_events.title, t_events.description, t_events.organization_id, t_events.start_time, t_events.end_time, t_events.mail_send_flag, t_events.send_organization_id, t_events.posted_by, t_events.last_edited_by, t_events.posted_at, t_events.last_edited_at, m_event_types.m_event_types_pkey, m_event_types.event_type_id, m_event_types.name, m_event_types.key, m_event_types.color FROM t_events
LEFT JOIN m_event_types ON t_events.event_type_id = m_event_types.event_type_id
WHERE event_id = ANY($3::uuid[])
ORDER BY
	t_events_pkey ASC
LIMIT $1 OFFSET $2
`

type GetPluralEventsWithTypeParams struct {
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
	EventIds []uuid.UUID `json:"event_ids"`
}

type GetPluralEventsWithTypeRow struct {
	Event     Event     `json:"event"`
	EventType EventType `json:"event_type"`
}

func (q *Queries) GetPluralEventsWithType(ctx context.Context, arg GetPluralEventsWithTypeParams) ([]GetPluralEventsWithTypeRow, error) {
	rows, err := q.db.Query(ctx, getPluralEventsWithType, arg.Limit, arg.Offset, arg.EventIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralEventsWithTypeRow{}
	for rows.Next() {
		var i GetPluralEventsWithTypeRow
		if err := rows.Scan(
			&i.Event.TEventsPkey,
			&i.Event.EventID,
			&i.Event.EventTypeID,
			&i.Event.Title,
			&i.Event.Description,
			&i.Event.OrganizationID,
			&i.Event.StartTime,
			&i.Event.EndTime,
			&i.Event.MailSendFlag,
			&i.Event.SendOrganizationID,
			&i.Event.PostedBy,
			&i.Event.LastEditedBy,
			&i.Event.PostedAt,
			&i.Event.LastEditedAt,
			&i.EventType.MEventTypesPkey,
			&i.EventType.EventTypeID,
			&i.EventType.Name,
			&i.EventType.Key,
			&i.EventType.Color,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const pluralDeleteEvents = `-- name: PluralDeleteEvents :exec
DELETE FROM t_events WHERE event_id = ANY($1::uuid[])
`

func (q *Queries) PluralDeleteEvents(ctx context.Context, dollar_1 []uuid.UUID) error {
	_, err := q.db.Exec(ctx, pluralDeleteEvents, dollar_1)
	return err
}

const updateEvent = `-- name: UpdateEvent :one
UPDATE t_events SET event_type_id = $2, title = $3, description = $4, organization_id = $5, start_time = $6, end_time = $7, send_organization_id = $8, last_edited_by = $9, last_edited_at = $10 WHERE event_id = $1 RETURNING t_events_pkey, event_id, event_type_id, title, description, organization_id, start_time, end_time, mail_send_flag, send_organization_id, posted_by, last_edited_by, posted_at, last_edited_at
`

type UpdateEventParams struct {
	EventID            uuid.UUID   `json:"event_id"`
	EventTypeID        uuid.UUID   `json:"event_type_id"`
	Title              string      `json:"title"`
	Description        pgtype.Text `json:"description"`
	OrganizationID     pgtype.UUID `json:"organization_id"`
	StartTime          time.Time   `json:"start_time"`
	EndTime            time.Time   `json:"end_time"`
	SendOrganizationID pgtype.UUID `json:"send_organization_id"`
	LastEditedBy       pgtype.UUID `json:"last_edited_by"`
	LastEditedAt       time.Time   `json:"last_edited_at"`
}

func (q *Queries) UpdateEvent(ctx context.Context, arg UpdateEventParams) (Event, error) {
	row := q.db.QueryRow(ctx, updateEvent,
		arg.EventID,
		arg.EventTypeID,
		arg.Title,
		arg.Description,
		arg.OrganizationID,
		arg.StartTime,
		arg.EndTime,
		arg.SendOrganizationID,
		arg.LastEditedBy,
		arg.LastEditedAt,
	)
	var i Event
	err := row.Scan(
		&i.TEventsPkey,
		&i.EventID,
		&i.EventTypeID,
		&i.Title,
		&i.Description,
		&i.OrganizationID,
		&i.StartTime,
		&i.EndTime,
		&i.MailSendFlag,
		&i.SendOrganizationID,
		&i.PostedBy,
		&i.LastEditedBy,
		&i.PostedAt,
		&i.LastEditedAt,
	)
	return i, err
}
