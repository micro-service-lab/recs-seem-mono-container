// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: lab_io_history.sql

package query

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countLabIoHistories = `-- name: CountLabIoHistories :one
SELECT COUNT(*) FROM t_lab_io_histories
WHERE
	CASE WHEN $1::boolean = true THEN member_id = $2 ELSE TRUE END
AND
	CASE WHEN $3::boolean = true THEN entered_at >= $4 ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN entered_at <= $6 ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN exited_at >= $8 ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN exited_at <= $10 ELSE TRUE END
`

type CountLabIoHistoriesParams struct {
	WhereMember           bool               `json:"where_member"`
	MemberID              uuid.UUID          `json:"member_id"`
	WhereEarlierEnteredAt bool               `json:"where_earlier_entered_at"`
	EarlierEnteredAt      time.Time          `json:"earlier_entered_at"`
	WhereLaterEnteredAt   bool               `json:"where_later_entered_at"`
	LaterEnteredAt        time.Time          `json:"later_entered_at"`
	WhereEarlierExitedAt  bool               `json:"where_earlier_exited_at"`
	EarlierExitedAt       pgtype.Timestamptz `json:"earlier_exited_at"`
	WhereLaterExitedAt    bool               `json:"where_later_exited_at"`
	LaterExitedAt         pgtype.Timestamptz `json:"later_exited_at"`
}

func (q *Queries) CountLabIoHistories(ctx context.Context, arg CountLabIoHistoriesParams) (int64, error) {
	row := q.db.QueryRow(ctx, countLabIoHistories,
		arg.WhereMember,
		arg.MemberID,
		arg.WhereEarlierEnteredAt,
		arg.EarlierEnteredAt,
		arg.WhereLaterEnteredAt,
		arg.LaterEnteredAt,
		arg.WhereEarlierExitedAt,
		arg.EarlierExitedAt,
		arg.WhereLaterExitedAt,
		arg.LaterExitedAt,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

type CreateLabIoHistoriesParams struct {
	MemberID  uuid.UUID          `json:"member_id"`
	EnteredAt time.Time          `json:"entered_at"`
	ExitedAt  pgtype.Timestamptz `json:"exited_at"`
}

const createLabIoHistory = `-- name: CreateLabIoHistory :one
INSERT INTO t_lab_io_histories (member_id, entered_at, exited_at) VALUES ($1, $2, $3) RETURNING t_lab_io_histories_pkey, lab_io_history_id, member_id, entered_at, exited_at
`

type CreateLabIoHistoryParams struct {
	MemberID  uuid.UUID          `json:"member_id"`
	EnteredAt time.Time          `json:"entered_at"`
	ExitedAt  pgtype.Timestamptz `json:"exited_at"`
}

func (q *Queries) CreateLabIoHistory(ctx context.Context, arg CreateLabIoHistoryParams) (LabIOHistory, error) {
	row := q.db.QueryRow(ctx, createLabIoHistory, arg.MemberID, arg.EnteredAt, arg.ExitedAt)
	var i LabIOHistory
	err := row.Scan(
		&i.TLabIoHistoriesPkey,
		&i.LabIoHistoryID,
		&i.MemberID,
		&i.EnteredAt,
		&i.ExitedAt,
	)
	return i, err
}

const deleteLabIoHistory = `-- name: DeleteLabIoHistory :exec
DELETE FROM t_lab_io_histories WHERE lab_io_history_id = $1
`

func (q *Queries) DeleteLabIoHistory(ctx context.Context, labIoHistoryID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteLabIoHistory, labIoHistoryID)
	return err
}

const findLabIoHistoryByID = `-- name: FindLabIoHistoryByID :one
SELECT t_lab_io_histories_pkey, lab_io_history_id, member_id, entered_at, exited_at FROM t_lab_io_histories WHERE lab_io_history_id = $1
`

func (q *Queries) FindLabIoHistoryByID(ctx context.Context, labIoHistoryID uuid.UUID) (LabIOHistory, error) {
	row := q.db.QueryRow(ctx, findLabIoHistoryByID, labIoHistoryID)
	var i LabIOHistory
	err := row.Scan(
		&i.TLabIoHistoriesPkey,
		&i.LabIoHistoryID,
		&i.MemberID,
		&i.EnteredAt,
		&i.ExitedAt,
	)
	return i, err
}

const getLabIoHistories = `-- name: GetLabIoHistories :many
SELECT t_lab_io_histories_pkey, lab_io_history_id, member_id, entered_at, exited_at FROM t_lab_io_histories
WHERE
	CASE WHEN $3::boolean = true THEN member_id = $4 ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN entered_at >= $6 ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN entered_at <= $8 ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN exited_at >= $10 ELSE TRUE END
AND
	CASE WHEN $11::boolean = true THEN exited_at <= $12 ELSE TRUE END
ORDER BY
	CASE WHEN $13::text = 'entered_at' THEN entered_at END ASC,
	CASE WHEN $13::text = 'exited_at' THEN exited_at END ASC,
	t_lab_io_histories_pkey DESC
LIMIT $1 OFFSET $2
`

type GetLabIoHistoriesParams struct {
	Limit                 int32              `json:"limit"`
	Offset                int32              `json:"offset"`
	WhereMember           bool               `json:"where_member"`
	MemberID              uuid.UUID          `json:"member_id"`
	WhereEarlierEnteredAt bool               `json:"where_earlier_entered_at"`
	EarlierEnteredAt      time.Time          `json:"earlier_entered_at"`
	WhereLaterEnteredAt   bool               `json:"where_later_entered_at"`
	LaterEnteredAt        time.Time          `json:"later_entered_at"`
	WhereEarlierExitedAt  bool               `json:"where_earlier_exited_at"`
	EarlierExitedAt       pgtype.Timestamptz `json:"earlier_exited_at"`
	WhereLaterExitedAt    bool               `json:"where_later_exited_at"`
	LaterExitedAt         pgtype.Timestamptz `json:"later_exited_at"`
	OrderMethod           string             `json:"order_method"`
}

func (q *Queries) GetLabIoHistories(ctx context.Context, arg GetLabIoHistoriesParams) ([]LabIOHistory, error) {
	rows, err := q.db.Query(ctx, getLabIoHistories,
		arg.Limit,
		arg.Offset,
		arg.WhereMember,
		arg.MemberID,
		arg.WhereEarlierEnteredAt,
		arg.EarlierEnteredAt,
		arg.WhereLaterEnteredAt,
		arg.LaterEnteredAt,
		arg.WhereEarlierExitedAt,
		arg.EarlierExitedAt,
		arg.WhereLaterExitedAt,
		arg.LaterExitedAt,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LabIOHistory{}
	for rows.Next() {
		var i LabIOHistory
		if err := rows.Scan(
			&i.TLabIoHistoriesPkey,
			&i.LabIoHistoryID,
			&i.MemberID,
			&i.EnteredAt,
			&i.ExitedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateLabIoHistory = `-- name: UpdateLabIoHistory :one
UPDATE t_lab_io_histories SET member_id = $2, entered_at = $3, exited_at = $4 WHERE lab_io_history_id = $1 RETURNING t_lab_io_histories_pkey, lab_io_history_id, member_id, entered_at, exited_at
`

type UpdateLabIoHistoryParams struct {
	LabIoHistoryID uuid.UUID          `json:"lab_io_history_id"`
	MemberID       uuid.UUID          `json:"member_id"`
	EnteredAt      time.Time          `json:"entered_at"`
	ExitedAt       pgtype.Timestamptz `json:"exited_at"`
}

func (q *Queries) UpdateLabIoHistory(ctx context.Context, arg UpdateLabIoHistoryParams) (LabIOHistory, error) {
	row := q.db.QueryRow(ctx, updateLabIoHistory,
		arg.LabIoHistoryID,
		arg.MemberID,
		arg.EnteredAt,
		arg.ExitedAt,
	)
	var i LabIOHistory
	err := row.Scan(
		&i.TLabIoHistoriesPkey,
		&i.LabIoHistoryID,
		&i.MemberID,
		&i.EnteredAt,
		&i.ExitedAt,
	)
	return i, err
}
