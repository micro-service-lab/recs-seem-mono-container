// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: record.sql

package query

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countRecords = `-- name: CountRecords :one
SELECT COUNT(*) FROM t_records
WHERE
	CASE WHEN $1::boolean = true THEN record_type_id = ANY($2) ELSE TRUE END
AND
	CASE WHEN $3::boolean = true THEN organization_id = ANY($4) ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN posted_by = ANY($6) ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN last_edited_by = ANY($8) ELSE TRUE END
`

type CountRecordsParams struct {
	WhereInRecordType   bool        `json:"where_in_record_type"`
	InRecordType        uuid.UUID   `json:"in_record_type"`
	WhereInOrganization bool        `json:"where_in_organization"`
	InOrganization      pgtype.UUID `json:"in_organization"`
	WhereInPostedBy     bool        `json:"where_in_posted_by"`
	InPostedBy          pgtype.UUID `json:"in_posted_by"`
	WhereInLastEditedBy bool        `json:"where_in_last_edited_by"`
	InLastEditedBy      pgtype.UUID `json:"in_last_edited_by"`
}

func (q *Queries) CountRecords(ctx context.Context, arg CountRecordsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countRecords,
		arg.WhereInRecordType,
		arg.InRecordType,
		arg.WhereInOrganization,
		arg.InOrganization,
		arg.WhereInPostedBy,
		arg.InPostedBy,
		arg.WhereInLastEditedBy,
		arg.InLastEditedBy,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createRecord = `-- name: CreateRecord :one
INSERT INTO t_records (record_type_id, title, body, organization_id, posted_by, last_edited_by, posted_at, last_edited_at) VALUES ($1, $2, $3, $4, $5, $6, $7, $8) RETURNING t_records_pkey, record_id, record_type_id, title, body, organization_id, posted_by, last_edited_by, posted_at, last_edited_at
`

type CreateRecordParams struct {
	RecordTypeID   uuid.UUID   `json:"record_type_id"`
	Title          string      `json:"title"`
	Body           pgtype.Text `json:"body"`
	OrganizationID pgtype.UUID `json:"organization_id"`
	PostedBy       pgtype.UUID `json:"posted_by"`
	LastEditedBy   pgtype.UUID `json:"last_edited_by"`
	PostedAt       time.Time   `json:"posted_at"`
	LastEditedAt   time.Time   `json:"last_edited_at"`
}

func (q *Queries) CreateRecord(ctx context.Context, arg CreateRecordParams) (Record, error) {
	row := q.db.QueryRow(ctx, createRecord,
		arg.RecordTypeID,
		arg.Title,
		arg.Body,
		arg.OrganizationID,
		arg.PostedBy,
		arg.LastEditedBy,
		arg.PostedAt,
		arg.LastEditedAt,
	)
	var i Record
	err := row.Scan(
		&i.TRecordsPkey,
		&i.RecordID,
		&i.RecordTypeID,
		&i.Title,
		&i.Body,
		&i.OrganizationID,
		&i.PostedBy,
		&i.LastEditedBy,
		&i.PostedAt,
		&i.LastEditedAt,
	)
	return i, err
}

type CreateRecordsParams struct {
	RecordTypeID   uuid.UUID   `json:"record_type_id"`
	Title          string      `json:"title"`
	Body           pgtype.Text `json:"body"`
	OrganizationID pgtype.UUID `json:"organization_id"`
	PostedBy       pgtype.UUID `json:"posted_by"`
	LastEditedBy   pgtype.UUID `json:"last_edited_by"`
	PostedAt       time.Time   `json:"posted_at"`
	LastEditedAt   time.Time   `json:"last_edited_at"`
}

const deleteRecord = `-- name: DeleteRecord :exec
DELETE FROM t_records WHERE record_id = $1
`

func (q *Queries) DeleteRecord(ctx context.Context, recordID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteRecord, recordID)
	return err
}

const findRecordByID = `-- name: FindRecordByID :one
SELECT t_records_pkey, record_id, record_type_id, title, body, organization_id, posted_by, last_edited_by, posted_at, last_edited_at FROM t_records WHERE record_id = $1
`

func (q *Queries) FindRecordByID(ctx context.Context, recordID uuid.UUID) (Record, error) {
	row := q.db.QueryRow(ctx, findRecordByID, recordID)
	var i Record
	err := row.Scan(
		&i.TRecordsPkey,
		&i.RecordID,
		&i.RecordTypeID,
		&i.Title,
		&i.Body,
		&i.OrganizationID,
		&i.PostedBy,
		&i.LastEditedBy,
		&i.PostedAt,
		&i.LastEditedAt,
	)
	return i, err
}

const findRecordByIDWithAll = `-- name: FindRecordByIDWithAll :one
SELECT t_records.t_records_pkey, t_records.record_id, t_records.record_type_id, t_records.title, t_records.body, t_records.organization_id, t_records.posted_by, t_records.last_edited_by, t_records.posted_at, t_records.last_edited_at, m_record_types.m_record_types_pkey, m_record_types.record_type_id, m_record_types.name, m_record_types.key, m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at, m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at FROM t_records
INNER JOIN m_record_types ON t_records.record_type_id = m_record_types.record_type_id
LEFT JOIN m_organizations ON t_records.organization_id = m_organizations.organization_id
INNER JOIN m_members ON t_records.posted_by = m_members.member_id
INNER JOIN m_members AS m_members_2 ON t_records.last_edited_by = m_members_2.member_id
WHERE record_id = $1
`

type FindRecordByIDWithAllRow struct {
	Record       Record       `json:"record"`
	RecordType   RecordType   `json:"record_type"`
	Organization Organization `json:"organization"`
	Member       Member       `json:"member"`
}

func (q *Queries) FindRecordByIDWithAll(ctx context.Context, recordID uuid.UUID) (FindRecordByIDWithAllRow, error) {
	row := q.db.QueryRow(ctx, findRecordByIDWithAll, recordID)
	var i FindRecordByIDWithAllRow
	err := row.Scan(
		&i.Record.TRecordsPkey,
		&i.Record.RecordID,
		&i.Record.RecordTypeID,
		&i.Record.Title,
		&i.Record.Body,
		&i.Record.OrganizationID,
		&i.Record.PostedBy,
		&i.Record.LastEditedBy,
		&i.Record.PostedAt,
		&i.Record.LastEditedAt,
		&i.RecordType.MRecordTypesPkey,
		&i.RecordType.RecordTypeID,
		&i.RecordType.Name,
		&i.RecordType.Key,
		&i.Organization.MOrganizationsPkey,
		&i.Organization.OrganizationID,
		&i.Organization.Name,
		&i.Organization.Description,
		&i.Organization.IsPersonal,
		&i.Organization.IsWhole,
		&i.Organization.CreatedAt,
		&i.Organization.UpdatedAt,
		&i.Member.MMembersPkey,
		&i.Member.MemberID,
		&i.Member.LoginID,
		&i.Member.Password,
		&i.Member.Email,
		&i.Member.Name,
		&i.Member.AttendStatusID,
		&i.Member.ProfileImageID,
		&i.Member.GradeID,
		&i.Member.GroupID,
		&i.Member.PersonalOrganizationID,
		&i.Member.RoleID,
		&i.Member.CreatedAt,
		&i.Member.UpdatedAt,
	)
	return i, err
}

const findRecordByIDWithLastEditedBy = `-- name: FindRecordByIDWithLastEditedBy :one
SELECT t_records.t_records_pkey, t_records.record_id, t_records.record_type_id, t_records.title, t_records.body, t_records.organization_id, t_records.posted_by, t_records.last_edited_by, t_records.posted_at, t_records.last_edited_at, m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at FROM t_records
INNER JOIN m_members ON t_records.last_edited_by = m_members.member_id
WHERE record_id = $1
`

type FindRecordByIDWithLastEditedByRow struct {
	Record Record `json:"record"`
	Member Member `json:"member"`
}

func (q *Queries) FindRecordByIDWithLastEditedBy(ctx context.Context, recordID uuid.UUID) (FindRecordByIDWithLastEditedByRow, error) {
	row := q.db.QueryRow(ctx, findRecordByIDWithLastEditedBy, recordID)
	var i FindRecordByIDWithLastEditedByRow
	err := row.Scan(
		&i.Record.TRecordsPkey,
		&i.Record.RecordID,
		&i.Record.RecordTypeID,
		&i.Record.Title,
		&i.Record.Body,
		&i.Record.OrganizationID,
		&i.Record.PostedBy,
		&i.Record.LastEditedBy,
		&i.Record.PostedAt,
		&i.Record.LastEditedAt,
		&i.Member.MMembersPkey,
		&i.Member.MemberID,
		&i.Member.LoginID,
		&i.Member.Password,
		&i.Member.Email,
		&i.Member.Name,
		&i.Member.AttendStatusID,
		&i.Member.ProfileImageID,
		&i.Member.GradeID,
		&i.Member.GroupID,
		&i.Member.PersonalOrganizationID,
		&i.Member.RoleID,
		&i.Member.CreatedAt,
		&i.Member.UpdatedAt,
	)
	return i, err
}

const findRecordByIDWithOrganization = `-- name: FindRecordByIDWithOrganization :one
SELECT t_records.t_records_pkey, t_records.record_id, t_records.record_type_id, t_records.title, t_records.body, t_records.organization_id, t_records.posted_by, t_records.last_edited_by, t_records.posted_at, t_records.last_edited_at, m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at FROM t_records
LEFT JOIN m_organizations ON t_records.organization_id = m_organizations.organization_id
WHERE record_id = $1
`

type FindRecordByIDWithOrganizationRow struct {
	Record       Record       `json:"record"`
	Organization Organization `json:"organization"`
}

func (q *Queries) FindRecordByIDWithOrganization(ctx context.Context, recordID uuid.UUID) (FindRecordByIDWithOrganizationRow, error) {
	row := q.db.QueryRow(ctx, findRecordByIDWithOrganization, recordID)
	var i FindRecordByIDWithOrganizationRow
	err := row.Scan(
		&i.Record.TRecordsPkey,
		&i.Record.RecordID,
		&i.Record.RecordTypeID,
		&i.Record.Title,
		&i.Record.Body,
		&i.Record.OrganizationID,
		&i.Record.PostedBy,
		&i.Record.LastEditedBy,
		&i.Record.PostedAt,
		&i.Record.LastEditedAt,
		&i.Organization.MOrganizationsPkey,
		&i.Organization.OrganizationID,
		&i.Organization.Name,
		&i.Organization.Description,
		&i.Organization.IsPersonal,
		&i.Organization.IsWhole,
		&i.Organization.CreatedAt,
		&i.Organization.UpdatedAt,
	)
	return i, err
}

const findRecordByIDWithPostedBy = `-- name: FindRecordByIDWithPostedBy :one
SELECT t_records.t_records_pkey, t_records.record_id, t_records.record_type_id, t_records.title, t_records.body, t_records.organization_id, t_records.posted_by, t_records.last_edited_by, t_records.posted_at, t_records.last_edited_at, m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at FROM t_records
INNER JOIN m_members ON t_records.posted_by = m_members.member_id
WHERE record_id = $1
`

type FindRecordByIDWithPostedByRow struct {
	Record Record `json:"record"`
	Member Member `json:"member"`
}

func (q *Queries) FindRecordByIDWithPostedBy(ctx context.Context, recordID uuid.UUID) (FindRecordByIDWithPostedByRow, error) {
	row := q.db.QueryRow(ctx, findRecordByIDWithPostedBy, recordID)
	var i FindRecordByIDWithPostedByRow
	err := row.Scan(
		&i.Record.TRecordsPkey,
		&i.Record.RecordID,
		&i.Record.RecordTypeID,
		&i.Record.Title,
		&i.Record.Body,
		&i.Record.OrganizationID,
		&i.Record.PostedBy,
		&i.Record.LastEditedBy,
		&i.Record.PostedAt,
		&i.Record.LastEditedAt,
		&i.Member.MMembersPkey,
		&i.Member.MemberID,
		&i.Member.LoginID,
		&i.Member.Password,
		&i.Member.Email,
		&i.Member.Name,
		&i.Member.AttendStatusID,
		&i.Member.ProfileImageID,
		&i.Member.GradeID,
		&i.Member.GroupID,
		&i.Member.PersonalOrganizationID,
		&i.Member.RoleID,
		&i.Member.CreatedAt,
		&i.Member.UpdatedAt,
	)
	return i, err
}

const findRecordByIDWithRecordType = `-- name: FindRecordByIDWithRecordType :one
SELECT t_records.t_records_pkey, t_records.record_id, t_records.record_type_id, t_records.title, t_records.body, t_records.organization_id, t_records.posted_by, t_records.last_edited_by, t_records.posted_at, t_records.last_edited_at, m_record_types.m_record_types_pkey, m_record_types.record_type_id, m_record_types.name, m_record_types.key FROM t_records
INNER JOIN m_record_types ON t_records.record_type_id = m_record_types.record_type_id
WHERE record_id = $1
`

type FindRecordByIDWithRecordTypeRow struct {
	Record     Record     `json:"record"`
	RecordType RecordType `json:"record_type"`
}

func (q *Queries) FindRecordByIDWithRecordType(ctx context.Context, recordID uuid.UUID) (FindRecordByIDWithRecordTypeRow, error) {
	row := q.db.QueryRow(ctx, findRecordByIDWithRecordType, recordID)
	var i FindRecordByIDWithRecordTypeRow
	err := row.Scan(
		&i.Record.TRecordsPkey,
		&i.Record.RecordID,
		&i.Record.RecordTypeID,
		&i.Record.Title,
		&i.Record.Body,
		&i.Record.OrganizationID,
		&i.Record.PostedBy,
		&i.Record.LastEditedBy,
		&i.Record.PostedAt,
		&i.Record.LastEditedAt,
		&i.RecordType.MRecordTypesPkey,
		&i.RecordType.RecordTypeID,
		&i.RecordType.Name,
		&i.RecordType.Key,
	)
	return i, err
}

const getRecords = `-- name: GetRecords :many
SELECT t_records_pkey, record_id, record_type_id, title, body, organization_id, posted_by, last_edited_by, posted_at, last_edited_at FROM t_records
WHERE
	CASE WHEN $3::boolean = true THEN record_type_id = ANY($4) ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN organization_id = ANY($6) ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN posted_by = ANY($8) ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN last_edited_by = ANY($10) ELSE TRUE END
ORDER BY
	CASE WHEN $11::text = 'posted_at' THEN posted_at END ASC,
	CASE WHEN $11::text = 'r_posted_at' THEN posted_at END DESC,
	CASE WHEN $11::text = 'last_edited_at' THEN last_edited_at END ASC,
	CASE WHEN $11::text = 'r_last_edited_at' THEN last_edited_at END DESC,
	t_records_pkey DESC
LIMIT $1 OFFSET $2
`

type GetRecordsParams struct {
	Limit               int32       `json:"limit"`
	Offset              int32       `json:"offset"`
	WhereInRecordType   bool        `json:"where_in_record_type"`
	InRecordType        uuid.UUID   `json:"in_record_type"`
	WhereInOrganization bool        `json:"where_in_organization"`
	InOrganization      pgtype.UUID `json:"in_organization"`
	WhereInPostedBy     bool        `json:"where_in_posted_by"`
	InPostedBy          pgtype.UUID `json:"in_posted_by"`
	WhereInLastEditedBy bool        `json:"where_in_last_edited_by"`
	InLastEditedBy      pgtype.UUID `json:"in_last_edited_by"`
	OrderMethod         string      `json:"order_method"`
}

func (q *Queries) GetRecords(ctx context.Context, arg GetRecordsParams) ([]Record, error) {
	rows, err := q.db.Query(ctx, getRecords,
		arg.Limit,
		arg.Offset,
		arg.WhereInRecordType,
		arg.InRecordType,
		arg.WhereInOrganization,
		arg.InOrganization,
		arg.WhereInPostedBy,
		arg.InPostedBy,
		arg.WhereInLastEditedBy,
		arg.InLastEditedBy,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Record{}
	for rows.Next() {
		var i Record
		if err := rows.Scan(
			&i.TRecordsPkey,
			&i.RecordID,
			&i.RecordTypeID,
			&i.Title,
			&i.Body,
			&i.OrganizationID,
			&i.PostedBy,
			&i.LastEditedBy,
			&i.PostedAt,
			&i.LastEditedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecordsWithAll = `-- name: GetRecordsWithAll :many
SELECT t_records.t_records_pkey, t_records.record_id, t_records.record_type_id, t_records.title, t_records.body, t_records.organization_id, t_records.posted_by, t_records.last_edited_by, t_records.posted_at, t_records.last_edited_at, m_record_types.m_record_types_pkey, m_record_types.record_type_id, m_record_types.name, m_record_types.key, m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at, m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at FROM t_records
INNER JOIN m_record_types ON t_records.record_type_id = m_record_types.record_type_id
LEFT JOIN m_organizations ON t_records.organization_id = m_organizations.organization_id
INNER JOIN m_members ON t_records.posted_by = m_members.member_id
INNER JOIN m_members AS m_members_2 ON t_records.last_edited_by = m_members_2.member_id
WHERE
	CASE WHEN $3::boolean = true THEN t_records.record_type_id = ANY($4) ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN t_records.organization_id = ANY($6) ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN t_records.posted_by = ANY($8) ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN t_records.last_edited_by = ANY($10) ELSE TRUE END
ORDER BY
	CASE WHEN $11::text = 'posted_at' THEN posted_at END ASC,
	CASE WHEN $11::text = 'r_posted_at' THEN posted_at END DESC,
	CASE WHEN $11::text = 'last_edited_at' THEN last_edited_at END ASC,
	CASE WHEN $11::text = 'r_last_edited_at' THEN last_edited_at END DESC,
	t_records_pkey DESC
LIMIT $1 OFFSET $2
`

type GetRecordsWithAllParams struct {
	Limit               int32       `json:"limit"`
	Offset              int32       `json:"offset"`
	WhereInRecordType   bool        `json:"where_in_record_type"`
	InRecordType        uuid.UUID   `json:"in_record_type"`
	WhereInOrganization bool        `json:"where_in_organization"`
	InOrganization      pgtype.UUID `json:"in_organization"`
	WhereInPostedBy     bool        `json:"where_in_posted_by"`
	InPostedBy          pgtype.UUID `json:"in_posted_by"`
	WhereInLastEditedBy bool        `json:"where_in_last_edited_by"`
	InLastEditedBy      pgtype.UUID `json:"in_last_edited_by"`
	OrderMethod         string      `json:"order_method"`
}

type GetRecordsWithAllRow struct {
	Record       Record       `json:"record"`
	RecordType   RecordType   `json:"record_type"`
	Organization Organization `json:"organization"`
	Member       Member       `json:"member"`
	Member_2     Member       `json:"member_2"`
}

func (q *Queries) GetRecordsWithAll(ctx context.Context, arg GetRecordsWithAllParams) ([]GetRecordsWithAllRow, error) {
	rows, err := q.db.Query(ctx, getRecordsWithAll,
		arg.Limit,
		arg.Offset,
		arg.WhereInRecordType,
		arg.InRecordType,
		arg.WhereInOrganization,
		arg.InOrganization,
		arg.WhereInPostedBy,
		arg.InPostedBy,
		arg.WhereInLastEditedBy,
		arg.InLastEditedBy,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecordsWithAllRow{}
	for rows.Next() {
		var i GetRecordsWithAllRow
		if err := rows.Scan(
			&i.Record.TRecordsPkey,
			&i.Record.RecordID,
			&i.Record.RecordTypeID,
			&i.Record.Title,
			&i.Record.Body,
			&i.Record.OrganizationID,
			&i.Record.PostedBy,
			&i.Record.LastEditedBy,
			&i.Record.PostedAt,
			&i.Record.LastEditedAt,
			&i.RecordType.MRecordTypesPkey,
			&i.RecordType.RecordTypeID,
			&i.RecordType.Name,
			&i.RecordType.Key,
			&i.Organization.MOrganizationsPkey,
			&i.Organization.OrganizationID,
			&i.Organization.Name,
			&i.Organization.Description,
			&i.Organization.IsPersonal,
			&i.Organization.IsWhole,
			&i.Organization.CreatedAt,
			&i.Organization.UpdatedAt,
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageID,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
			&i.Member_2.MMembersPkey,
			&i.Member_2.MemberID,
			&i.Member_2.LoginID,
			&i.Member_2.Password,
			&i.Member_2.Email,
			&i.Member_2.Name,
			&i.Member_2.AttendStatusID,
			&i.Member_2.ProfileImageID,
			&i.Member_2.GradeID,
			&i.Member_2.GroupID,
			&i.Member_2.PersonalOrganizationID,
			&i.Member_2.RoleID,
			&i.Member_2.CreatedAt,
			&i.Member_2.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecordsWithLastEditedBy = `-- name: GetRecordsWithLastEditedBy :many
SELECT t_records.t_records_pkey, t_records.record_id, t_records.record_type_id, t_records.title, t_records.body, t_records.organization_id, t_records.posted_by, t_records.last_edited_by, t_records.posted_at, t_records.last_edited_at, m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at FROM t_records
INNER JOIN m_members ON t_records.last_edited_by = m_members.member_id
WHERE
	CASE WHEN $3::boolean = true THEN record_type_id = ANY($4) ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN organization_id = ANY($6) ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN posted_by = ANY($8) ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN t_records.last_edited_by = ANY($10) ELSE TRUE END
ORDER BY
	CASE WHEN $11::text = 'posted_at' THEN posted_at END ASC,
	CASE WHEN $11::text = 'r_posted_at' THEN posted_at END DESC,
	CASE WHEN $11::text = 'last_edited_at' THEN last_edited_at END ASC,
	CASE WHEN $11::text = 'r_last_edited_at' THEN last_edited_at END DESC,
	t_records_pkey DESC
LIMIT $1 OFFSET $2
`

type GetRecordsWithLastEditedByParams struct {
	Limit               int32       `json:"limit"`
	Offset              int32       `json:"offset"`
	WhereInRecordType   bool        `json:"where_in_record_type"`
	InRecordType        uuid.UUID   `json:"in_record_type"`
	WhereInOrganization bool        `json:"where_in_organization"`
	InOrganization      pgtype.UUID `json:"in_organization"`
	WhereInPostedBy     bool        `json:"where_in_posted_by"`
	InPostedBy          pgtype.UUID `json:"in_posted_by"`
	WhereInLastEditedBy bool        `json:"where_in_last_edited_by"`
	InLastEditedBy      pgtype.UUID `json:"in_last_edited_by"`
	OrderMethod         string      `json:"order_method"`
}

type GetRecordsWithLastEditedByRow struct {
	Record Record `json:"record"`
	Member Member `json:"member"`
}

func (q *Queries) GetRecordsWithLastEditedBy(ctx context.Context, arg GetRecordsWithLastEditedByParams) ([]GetRecordsWithLastEditedByRow, error) {
	rows, err := q.db.Query(ctx, getRecordsWithLastEditedBy,
		arg.Limit,
		arg.Offset,
		arg.WhereInRecordType,
		arg.InRecordType,
		arg.WhereInOrganization,
		arg.InOrganization,
		arg.WhereInPostedBy,
		arg.InPostedBy,
		arg.WhereInLastEditedBy,
		arg.InLastEditedBy,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecordsWithLastEditedByRow{}
	for rows.Next() {
		var i GetRecordsWithLastEditedByRow
		if err := rows.Scan(
			&i.Record.TRecordsPkey,
			&i.Record.RecordID,
			&i.Record.RecordTypeID,
			&i.Record.Title,
			&i.Record.Body,
			&i.Record.OrganizationID,
			&i.Record.PostedBy,
			&i.Record.LastEditedBy,
			&i.Record.PostedAt,
			&i.Record.LastEditedAt,
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageID,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecordsWithOrganization = `-- name: GetRecordsWithOrganization :many
SELECT t_records.t_records_pkey, t_records.record_id, t_records.record_type_id, t_records.title, t_records.body, t_records.organization_id, t_records.posted_by, t_records.last_edited_by, t_records.posted_at, t_records.last_edited_at, m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at FROM t_records
LEFT JOIN m_organizations ON t_records.organization_id = m_organizations.organization_id
WHERE
	CASE WHEN $3::boolean = true THEN record_type_id = ANY($4) ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN t_records.organization_id = ANY($6) ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN posted_by = ANY($8) ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN last_edited_by = ANY($10) ELSE TRUE END
ORDER BY
	CASE WHEN $11::text = 'posted_at' THEN posted_at END ASC,
	CASE WHEN $11::text = 'r_posted_at' THEN posted_at END DESC,
	CASE WHEN $11::text = 'last_edited_at' THEN last_edited_at END ASC,
	CASE WHEN $11::text = 'r_last_edited_at' THEN last_edited_at END DESC,
	t_records_pkey DESC
LIMIT $1 OFFSET $2
`

type GetRecordsWithOrganizationParams struct {
	Limit               int32       `json:"limit"`
	Offset              int32       `json:"offset"`
	WhereInRecordType   bool        `json:"where_in_record_type"`
	InRecordType        uuid.UUID   `json:"in_record_type"`
	WhereInOrganization bool        `json:"where_in_organization"`
	InOrganization      pgtype.UUID `json:"in_organization"`
	WhereInPostedBy     bool        `json:"where_in_posted_by"`
	InPostedBy          pgtype.UUID `json:"in_posted_by"`
	WhereInLastEditedBy bool        `json:"where_in_last_edited_by"`
	InLastEditedBy      pgtype.UUID `json:"in_last_edited_by"`
	OrderMethod         string      `json:"order_method"`
}

type GetRecordsWithOrganizationRow struct {
	Record       Record       `json:"record"`
	Organization Organization `json:"organization"`
}

func (q *Queries) GetRecordsWithOrganization(ctx context.Context, arg GetRecordsWithOrganizationParams) ([]GetRecordsWithOrganizationRow, error) {
	rows, err := q.db.Query(ctx, getRecordsWithOrganization,
		arg.Limit,
		arg.Offset,
		arg.WhereInRecordType,
		arg.InRecordType,
		arg.WhereInOrganization,
		arg.InOrganization,
		arg.WhereInPostedBy,
		arg.InPostedBy,
		arg.WhereInLastEditedBy,
		arg.InLastEditedBy,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecordsWithOrganizationRow{}
	for rows.Next() {
		var i GetRecordsWithOrganizationRow
		if err := rows.Scan(
			&i.Record.TRecordsPkey,
			&i.Record.RecordID,
			&i.Record.RecordTypeID,
			&i.Record.Title,
			&i.Record.Body,
			&i.Record.OrganizationID,
			&i.Record.PostedBy,
			&i.Record.LastEditedBy,
			&i.Record.PostedAt,
			&i.Record.LastEditedAt,
			&i.Organization.MOrganizationsPkey,
			&i.Organization.OrganizationID,
			&i.Organization.Name,
			&i.Organization.Description,
			&i.Organization.IsPersonal,
			&i.Organization.IsWhole,
			&i.Organization.CreatedAt,
			&i.Organization.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecordsWithPostedBy = `-- name: GetRecordsWithPostedBy :many
SELECT t_records.t_records_pkey, t_records.record_id, t_records.record_type_id, t_records.title, t_records.body, t_records.organization_id, t_records.posted_by, t_records.last_edited_by, t_records.posted_at, t_records.last_edited_at, m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at FROM t_records
INNER JOIN m_members ON t_records.posted_by = m_members.member_id
WHERE
	CASE WHEN $3::boolean = true THEN record_type_id = ANY($4) ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN organization_id = ANY($6) ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN t_records.posted_by = ANY($8) ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN last_edited_by = ANY($10) ELSE TRUE END
ORDER BY
	CASE WHEN $11::text = 'posted_at' THEN posted_at END ASC,
	CASE WHEN $11::text = 'r_posted_at' THEN posted_at END DESC,
	CASE WHEN $11::text = 'last_edited_at' THEN last_edited_at END ASC,
	CASE WHEN $11::text = 'r_last_edited_at' THEN last_edited_at END DESC,
	t_records_pkey DESC
LIMIT $1 OFFSET $2
`

type GetRecordsWithPostedByParams struct {
	Limit               int32       `json:"limit"`
	Offset              int32       `json:"offset"`
	WhereInRecordType   bool        `json:"where_in_record_type"`
	InRecordType        uuid.UUID   `json:"in_record_type"`
	WhereInOrganization bool        `json:"where_in_organization"`
	InOrganization      pgtype.UUID `json:"in_organization"`
	WhereInPostedBy     bool        `json:"where_in_posted_by"`
	InPostedBy          pgtype.UUID `json:"in_posted_by"`
	WhereInLastEditedBy bool        `json:"where_in_last_edited_by"`
	InLastEditedBy      pgtype.UUID `json:"in_last_edited_by"`
	OrderMethod         string      `json:"order_method"`
}

type GetRecordsWithPostedByRow struct {
	Record Record `json:"record"`
	Member Member `json:"member"`
}

func (q *Queries) GetRecordsWithPostedBy(ctx context.Context, arg GetRecordsWithPostedByParams) ([]GetRecordsWithPostedByRow, error) {
	rows, err := q.db.Query(ctx, getRecordsWithPostedBy,
		arg.Limit,
		arg.Offset,
		arg.WhereInRecordType,
		arg.InRecordType,
		arg.WhereInOrganization,
		arg.InOrganization,
		arg.WhereInPostedBy,
		arg.InPostedBy,
		arg.WhereInLastEditedBy,
		arg.InLastEditedBy,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecordsWithPostedByRow{}
	for rows.Next() {
		var i GetRecordsWithPostedByRow
		if err := rows.Scan(
			&i.Record.TRecordsPkey,
			&i.Record.RecordID,
			&i.Record.RecordTypeID,
			&i.Record.Title,
			&i.Record.Body,
			&i.Record.OrganizationID,
			&i.Record.PostedBy,
			&i.Record.LastEditedBy,
			&i.Record.PostedAt,
			&i.Record.LastEditedAt,
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageID,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecordsWithRecordType = `-- name: GetRecordsWithRecordType :many
SELECT t_records.t_records_pkey, t_records.record_id, t_records.record_type_id, t_records.title, t_records.body, t_records.organization_id, t_records.posted_by, t_records.last_edited_by, t_records.posted_at, t_records.last_edited_at, m_record_types.m_record_types_pkey, m_record_types.record_type_id, m_record_types.name, m_record_types.key FROM t_records
INNER JOIN m_record_types ON t_records.record_type_id = m_record_types.record_type_id
WHERE
	CASE WHEN $3::boolean = true THEN t_records.record_type_id = ANY($4) ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN organization_id = ANY($6) ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN posted_by = ANY($8) ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN last_edited_by = ANY($10) ELSE TRUE END
ORDER BY
	CASE WHEN $11::text = 'posted_at' THEN posted_at END ASC,
	CASE WHEN $11::text = 'r_posted_at' THEN posted_at END DESC,
	CASE WHEN $11::text = 'last_edited_at' THEN last_edited_at END ASC,
	CASE WHEN $11::text = 'r_last_edited_at' THEN last_edited_at END DESC,
	t_records_pkey DESC
LIMIT $1 OFFSET $2
`

type GetRecordsWithRecordTypeParams struct {
	Limit               int32       `json:"limit"`
	Offset              int32       `json:"offset"`
	WhereInRecordType   bool        `json:"where_in_record_type"`
	InRecordType        uuid.UUID   `json:"in_record_type"`
	WhereInOrganization bool        `json:"where_in_organization"`
	InOrganization      pgtype.UUID `json:"in_organization"`
	WhereInPostedBy     bool        `json:"where_in_posted_by"`
	InPostedBy          pgtype.UUID `json:"in_posted_by"`
	WhereInLastEditedBy bool        `json:"where_in_last_edited_by"`
	InLastEditedBy      pgtype.UUID `json:"in_last_edited_by"`
	OrderMethod         string      `json:"order_method"`
}

type GetRecordsWithRecordTypeRow struct {
	Record     Record     `json:"record"`
	RecordType RecordType `json:"record_type"`
}

func (q *Queries) GetRecordsWithRecordType(ctx context.Context, arg GetRecordsWithRecordTypeParams) ([]GetRecordsWithRecordTypeRow, error) {
	rows, err := q.db.Query(ctx, getRecordsWithRecordType,
		arg.Limit,
		arg.Offset,
		arg.WhereInRecordType,
		arg.InRecordType,
		arg.WhereInOrganization,
		arg.InOrganization,
		arg.WhereInPostedBy,
		arg.InPostedBy,
		arg.WhereInLastEditedBy,
		arg.InLastEditedBy,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecordsWithRecordTypeRow{}
	for rows.Next() {
		var i GetRecordsWithRecordTypeRow
		if err := rows.Scan(
			&i.Record.TRecordsPkey,
			&i.Record.RecordID,
			&i.Record.RecordTypeID,
			&i.Record.Title,
			&i.Record.Body,
			&i.Record.OrganizationID,
			&i.Record.PostedBy,
			&i.Record.LastEditedBy,
			&i.Record.PostedAt,
			&i.Record.LastEditedAt,
			&i.RecordType.MRecordTypesPkey,
			&i.RecordType.RecordTypeID,
			&i.RecordType.Name,
			&i.RecordType.Key,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRecord = `-- name: UpdateRecord :one
UPDATE t_records SET record_type_id = $2, title = $3, body = $4, organization_id = $5, posted_by = $6, last_edited_by = $7, posted_at = $8, last_edited_at = $9 WHERE record_id = $1 RETURNING t_records_pkey, record_id, record_type_id, title, body, organization_id, posted_by, last_edited_by, posted_at, last_edited_at
`

type UpdateRecordParams struct {
	RecordID       uuid.UUID   `json:"record_id"`
	RecordTypeID   uuid.UUID   `json:"record_type_id"`
	Title          string      `json:"title"`
	Body           pgtype.Text `json:"body"`
	OrganizationID pgtype.UUID `json:"organization_id"`
	PostedBy       pgtype.UUID `json:"posted_by"`
	LastEditedBy   pgtype.UUID `json:"last_edited_by"`
	PostedAt       time.Time   `json:"posted_at"`
	LastEditedAt   time.Time   `json:"last_edited_at"`
}

func (q *Queries) UpdateRecord(ctx context.Context, arg UpdateRecordParams) (Record, error) {
	row := q.db.QueryRow(ctx, updateRecord,
		arg.RecordID,
		arg.RecordTypeID,
		arg.Title,
		arg.Body,
		arg.OrganizationID,
		arg.PostedBy,
		arg.LastEditedBy,
		arg.PostedAt,
		arg.LastEditedAt,
	)
	var i Record
	err := row.Scan(
		&i.TRecordsPkey,
		&i.RecordID,
		&i.RecordTypeID,
		&i.Title,
		&i.Body,
		&i.OrganizationID,
		&i.PostedBy,
		&i.LastEditedBy,
		&i.PostedAt,
		&i.LastEditedAt,
	)
	return i, err
}
