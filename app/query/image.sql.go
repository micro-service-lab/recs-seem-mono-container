// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: image.sql

package query

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countImages = `-- name: CountImages :one
SELECT COUNT(*) FROM t_images
`

func (q *Queries) CountImages(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countImages)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createImage = `-- name: CreateImage :one
INSERT INTO t_images (height, width, attachable_item_id) VALUES ($1, $2, $3) RETURNING t_images_pkey, image_id, height, width, attachable_item_id
`

type CreateImageParams struct {
	Height           pgtype.Float8 `json:"height"`
	Width            pgtype.Float8 `json:"width"`
	AttachableItemID uuid.UUID     `json:"attachable_item_id"`
}

func (q *Queries) CreateImage(ctx context.Context, arg CreateImageParams) (Image, error) {
	row := q.db.QueryRow(ctx, createImage, arg.Height, arg.Width, arg.AttachableItemID)
	var i Image
	err := row.Scan(
		&i.TImagesPkey,
		&i.ImageID,
		&i.Height,
		&i.Width,
		&i.AttachableItemID,
	)
	return i, err
}

type CreateImagesParams struct {
	Height           pgtype.Float8 `json:"height"`
	Width            pgtype.Float8 `json:"width"`
	AttachableItemID uuid.UUID     `json:"attachable_item_id"`
}

const deleteImage = `-- name: DeleteImage :exec
DELETE FROM t_images WHERE image_id = $1
`

func (q *Queries) DeleteImage(ctx context.Context, imageID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteImage, imageID)
	return err
}

const findImageByID = `-- name: FindImageByID :one
SELECT t_images_pkey, image_id, height, width, attachable_item_id FROM t_images WHERE image_id = $1
`

func (q *Queries) FindImageByID(ctx context.Context, imageID uuid.UUID) (Image, error) {
	row := q.db.QueryRow(ctx, findImageByID, imageID)
	var i Image
	err := row.Scan(
		&i.TImagesPkey,
		&i.ImageID,
		&i.Height,
		&i.Width,
		&i.AttachableItemID,
	)
	return i, err
}

const findImageByIDWithAttachableItem = `-- name: FindImageByIDWithAttachableItem :one
SELECT t_images.t_images_pkey, t_images.image_id, t_images.height, t_images.width, t_images.attachable_item_id, t_attachable_items.t_attachable_items_pkey, t_attachable_items.attachable_item_id, t_attachable_items.size, t_attachable_items.mime_type_id FROM t_images
INNER JOIN t_attachable_items ON t_images.attachable_item_id = t_attachable_items.attachable_item_id
WHERE image_id = $1
`

type FindImageByIDWithAttachableItemRow struct {
	Image          Image          `json:"image"`
	AttachableItem AttachableItem `json:"attachable_item"`
}

func (q *Queries) FindImageByIDWithAttachableItem(ctx context.Context, imageID uuid.UUID) (FindImageByIDWithAttachableItemRow, error) {
	row := q.db.QueryRow(ctx, findImageByIDWithAttachableItem, imageID)
	var i FindImageByIDWithAttachableItemRow
	err := row.Scan(
		&i.Image.TImagesPkey,
		&i.Image.ImageID,
		&i.Image.Height,
		&i.Image.Width,
		&i.Image.AttachableItemID,
		&i.AttachableItem.TAttachableItemsPkey,
		&i.AttachableItem.AttachableItemID,
		&i.AttachableItem.Size,
		&i.AttachableItem.MimeTypeID,
	)
	return i, err
}

const getImages = `-- name: GetImages :many
SELECT t_images_pkey, image_id, height, width, attachable_item_id FROM t_images
ORDER BY
	t_images_pkey DESC
LIMIT $1 OFFSET $2
`

type GetImagesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetImages(ctx context.Context, arg GetImagesParams) ([]Image, error) {
	rows, err := q.db.Query(ctx, getImages, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Image{}
	for rows.Next() {
		var i Image
		if err := rows.Scan(
			&i.TImagesPkey,
			&i.ImageID,
			&i.Height,
			&i.Width,
			&i.AttachableItemID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getImagesWithAttachableItem = `-- name: GetImagesWithAttachableItem :many
SELECT t_images.t_images_pkey, t_images.image_id, t_images.height, t_images.width, t_images.attachable_item_id, t_attachable_items.t_attachable_items_pkey, t_attachable_items.attachable_item_id, t_attachable_items.size, t_attachable_items.mime_type_id FROM t_images
INNER JOIN t_attachable_items ON t_images.attachable_item_id = t_attachable_items.attachable_item_id
ORDER BY
	t_images_pkey DESC
LIMIT $1 OFFSET $2
`

type GetImagesWithAttachableItemParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetImagesWithAttachableItemRow struct {
	Image          Image          `json:"image"`
	AttachableItem AttachableItem `json:"attachable_item"`
}

func (q *Queries) GetImagesWithAttachableItem(ctx context.Context, arg GetImagesWithAttachableItemParams) ([]GetImagesWithAttachableItemRow, error) {
	rows, err := q.db.Query(ctx, getImagesWithAttachableItem, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetImagesWithAttachableItemRow{}
	for rows.Next() {
		var i GetImagesWithAttachableItemRow
		if err := rows.Scan(
			&i.Image.TImagesPkey,
			&i.Image.ImageID,
			&i.Image.Height,
			&i.Image.Width,
			&i.Image.AttachableItemID,
			&i.AttachableItem.TAttachableItemsPkey,
			&i.AttachableItem.AttachableItemID,
			&i.AttachableItem.Size,
			&i.AttachableItem.MimeTypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
