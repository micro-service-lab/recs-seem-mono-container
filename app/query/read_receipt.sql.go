// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: read_receipt.sql

package query

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countReadableMembersOnMessage = `-- name: CountReadableMembersOnMessage :one
SELECT COUNT(*) FROM t_read_receipts
LEFT JOIN m_members ON t_read_receipts.member_id = m_members.member_id
WHERE message_id = $1
AND
	CASE WHEN $2::boolean = true THEN member_id IN (SELECT member_id FROM m_members WHERE name LIKE '%' || $3::text || '%') ELSE TRUE END
AND
	CASE WHEN $4::boolean = true THEN read_at IS NOT NULL ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN read_at IS NULL ELSE TRUE END
`

type CountReadableMembersOnMessageParams struct {
	MessageID      uuid.UUID `json:"message_id"`
	WhereLikeName  bool      `json:"where_like_name"`
	SearchName     string    `json:"search_name"`
	WhereIsRead    bool      `json:"where_is_read"`
	WhereIsNotRead bool      `json:"where_is_not_read"`
}

func (q *Queries) CountReadableMembersOnMessage(ctx context.Context, arg CountReadableMembersOnMessageParams) (int64, error) {
	row := q.db.QueryRow(ctx, countReadableMembersOnMessage,
		arg.MessageID,
		arg.WhereLikeName,
		arg.SearchName,
		arg.WhereIsRead,
		arg.WhereIsNotRead,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countReadableMessageOnChatRoomAndMember = `-- name: CountReadableMessageOnChatRoomAndMember :one
SELECT COUNT(*) FROM t_read_receipts
LEFT JOIN t_messages ON t_read_receipts.message_id = t_messages.message_id
WHERE t_messages.chat_room_id = $1
AND t_read_receipts.member_id = $2
AND
	CASE WHEN $3::boolean = true THEN t_read_receipts.read_at IS NOT NULL ELSE TRUE END
AND
	CASE WHEN $4::boolean = true THEN t_read_receipts.read_at IS NULL ELSE TRUE END
`

type CountReadableMessageOnChatRoomAndMemberParams struct {
	ChatRoomID     uuid.UUID `json:"chat_room_id"`
	MemberID       uuid.UUID `json:"member_id"`
	WhereIsRead    bool      `json:"where_is_read"`
	WhereIsNotRead bool      `json:"where_is_not_read"`
}

func (q *Queries) CountReadableMessageOnChatRoomAndMember(ctx context.Context, arg CountReadableMessageOnChatRoomAndMemberParams) (int64, error) {
	row := q.db.QueryRow(ctx, countReadableMessageOnChatRoomAndMember,
		arg.ChatRoomID,
		arg.MemberID,
		arg.WhereIsRead,
		arg.WhereIsNotRead,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countReadableMessagesOnChatRoomAndMember = `-- name: CountReadableMessagesOnChatRoomAndMember :many
SELECT t_messages.chat_room_id, COUNT(*) FROM t_read_receipts
LEFT JOIN t_messages ON t_read_receipts.message_id = t_messages.message_id
WHERE t_messages.chat_room_id = ANY($2::uuid[])
AND t_read_receipts.member_id = $1
AND
	CASE WHEN $3::boolean = true THEN t_read_receipts.read_at IS NOT NULL ELSE TRUE END
AND
	CASE WHEN $4::boolean = true THEN t_read_receipts.read_at IS NULL ELSE TRUE END
GROUP BY t_messages.chat_room_id
`

type CountReadableMessagesOnChatRoomAndMemberParams struct {
	MemberID       uuid.UUID   `json:"member_id"`
	ChatRoomIds    []uuid.UUID `json:"chat_room_ids"`
	WhereIsRead    bool        `json:"where_is_read"`
	WhereIsNotRead bool        `json:"where_is_not_read"`
}

type CountReadableMessagesOnChatRoomAndMemberRow struct {
	ChatRoomID pgtype.UUID `json:"chat_room_id"`
	Count      int64       `json:"count"`
}

func (q *Queries) CountReadableMessagesOnChatRoomAndMember(ctx context.Context, arg CountReadableMessagesOnChatRoomAndMemberParams) ([]CountReadableMessagesOnChatRoomAndMemberRow, error) {
	rows, err := q.db.Query(ctx, countReadableMessagesOnChatRoomAndMember,
		arg.MemberID,
		arg.ChatRoomIds,
		arg.WhereIsRead,
		arg.WhereIsNotRead,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CountReadableMessagesOnChatRoomAndMemberRow{}
	for rows.Next() {
		var i CountReadableMessagesOnChatRoomAndMemberRow
		if err := rows.Scan(&i.ChatRoomID, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const countReadableMessagesOnMember = `-- name: CountReadableMessagesOnMember :one
SELECT COUNT(*) FROM t_read_receipts
WHERE member_id = $1
AND
	CASE WHEN $2::boolean = true THEN read_at IS NOT NULL ELSE TRUE END
AND
	CASE WHEN $3::boolean = true THEN read_at IS NULL ELSE TRUE END
`

type CountReadableMessagesOnMemberParams struct {
	MemberID       uuid.UUID `json:"member_id"`
	WhereIsRead    bool      `json:"where_is_read"`
	WhereIsNotRead bool      `json:"where_is_not_read"`
}

func (q *Queries) CountReadableMessagesOnMember(ctx context.Context, arg CountReadableMessagesOnMemberParams) (int64, error) {
	row := q.db.QueryRow(ctx, countReadableMessagesOnMember, arg.MemberID, arg.WhereIsRead, arg.WhereIsNotRead)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createReadReceipt = `-- name: CreateReadReceipt :one
INSERT INTO t_read_receipts (member_id, message_id, read_at) VALUES ($1, $2, $3) RETURNING t_read_receipts_pkey, member_id, message_id, read_at
`

type CreateReadReceiptParams struct {
	MemberID  uuid.UUID          `json:"member_id"`
	MessageID uuid.UUID          `json:"message_id"`
	ReadAt    pgtype.Timestamptz `json:"read_at"`
}

func (q *Queries) CreateReadReceipt(ctx context.Context, arg CreateReadReceiptParams) (TReadReceipt, error) {
	row := q.db.QueryRow(ctx, createReadReceipt, arg.MemberID, arg.MessageID, arg.ReadAt)
	var i TReadReceipt
	err := row.Scan(
		&i.TReadReceiptsPkey,
		&i.MemberID,
		&i.MessageID,
		&i.ReadAt,
	)
	return i, err
}

type CreateReadReceiptsParams struct {
	MemberID  uuid.UUID          `json:"member_id"`
	MessageID uuid.UUID          `json:"message_id"`
	ReadAt    pgtype.Timestamptz `json:"read_at"`
}

const getPluralReadableMembersOnMessage = `-- name: GetPluralReadableMembersOnMessage :many
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.first_name, m_members.last_name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, t_read_receipts.read_at read_at, t_images.height profile_image_height,
t_images.width profile_image_width, t_images.attachable_item_id profile_image_attachable_item_id,
t_attachable_items.owner_id profile_image_owner_id, t_attachable_items.from_outer profile_image_from_outer,
t_attachable_items.url profile_image_url, t_attachable_items.size profile_image_size, t_attachable_items.mime_type_id profile_image_mime_type_id
FROM m_members
LEFT JOIN t_read_receipts ON m_members.member_id = t_read_receipts.member_id
LEFT JOIN t_images ON m_members.profile_image_id = t_images.image_id
LEFT JOIN t_attachable_items ON t_images.attachable_item_id = t_attachable_items.attachable_item_id
WHERE message_id = ANY($1::uuid[])
ORDER BY
	CASE WHEN $2::text = 'name' THEN m_members.name END ASC,
	CASE WHEN $2::text = 'r_name' THEN m_members.name END DESC,
	CASE WHEN $2::text = 'read_at' THEN t_read_receipts.read_at END ASC,
	CASE WHEN $2::text = 'r_read_at' THEN t_read_receipts.read_at END DESC,
	m_members_pkey ASC
`

type GetPluralReadableMembersOnMessageParams struct {
	MessageIds  []uuid.UUID `json:"message_ids"`
	OrderMethod string      `json:"order_method"`
}

type GetPluralReadableMembersOnMessageRow struct {
	MMembersPkey                 pgtype.Int8        `json:"m_members_pkey"`
	MemberID                     uuid.UUID          `json:"member_id"`
	LoginID                      string             `json:"login_id"`
	Password                     string             `json:"password"`
	Email                        string             `json:"email"`
	Name                         string             `json:"name"`
	FirstName                    string             `json:"first_name"`
	LastName                     string             `json:"last_name"`
	AttendStatusID               uuid.UUID          `json:"attend_status_id"`
	ProfileImageID               pgtype.UUID        `json:"profile_image_id"`
	GradeID                      uuid.UUID          `json:"grade_id"`
	GroupID                      uuid.UUID          `json:"group_id"`
	PersonalOrganizationID       uuid.UUID          `json:"personal_organization_id"`
	RoleID                       pgtype.UUID        `json:"role_id"`
	CreatedAt                    time.Time          `json:"created_at"`
	UpdatedAt                    time.Time          `json:"updated_at"`
	ReadAt                       pgtype.Timestamptz `json:"read_at"`
	ProfileImageHeight           pgtype.Float8      `json:"profile_image_height"`
	ProfileImageWidth            pgtype.Float8      `json:"profile_image_width"`
	ProfileImageAttachableItemID pgtype.UUID        `json:"profile_image_attachable_item_id"`
	ProfileImageOwnerID          pgtype.UUID        `json:"profile_image_owner_id"`
	ProfileImageFromOuter        pgtype.Bool        `json:"profile_image_from_outer"`
	ProfileImageUrl              pgtype.Text        `json:"profile_image_url"`
	ProfileImageSize             pgtype.Float8      `json:"profile_image_size"`
	ProfileImageMimeTypeID       pgtype.UUID        `json:"profile_image_mime_type_id"`
}

func (q *Queries) GetPluralReadableMembersOnMessage(ctx context.Context, arg GetPluralReadableMembersOnMessageParams) ([]GetPluralReadableMembersOnMessageRow, error) {
	rows, err := q.db.Query(ctx, getPluralReadableMembersOnMessage, arg.MessageIds, arg.OrderMethod)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralReadableMembersOnMessageRow{}
	for rows.Next() {
		var i GetPluralReadableMembersOnMessageRow
		if err := rows.Scan(
			&i.MMembersPkey,
			&i.MemberID,
			&i.LoginID,
			&i.Password,
			&i.Email,
			&i.Name,
			&i.FirstName,
			&i.LastName,
			&i.AttendStatusID,
			&i.ProfileImageID,
			&i.GradeID,
			&i.GroupID,
			&i.PersonalOrganizationID,
			&i.RoleID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ReadAt,
			&i.ProfileImageHeight,
			&i.ProfileImageWidth,
			&i.ProfileImageAttachableItemID,
			&i.ProfileImageOwnerID,
			&i.ProfileImageFromOuter,
			&i.ProfileImageUrl,
			&i.ProfileImageSize,
			&i.ProfileImageMimeTypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralReadableMembersOnMessageUseNumberedPaginate = `-- name: GetPluralReadableMembersOnMessageUseNumberedPaginate :many
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.first_name, m_members.last_name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, t_read_receipts.read_at read_at, t_images.height profile_image_height,
t_images.width profile_image_width, t_images.attachable_item_id profile_image_attachable_item_id,
t_attachable_items.owner_id profile_image_owner_id, t_attachable_items.from_outer profile_image_from_outer,
t_attachable_items.url profile_image_url, t_attachable_items.size profile_image_size, t_attachable_items.mime_type_id profile_image_mime_type_id
FROM m_members
LEFT JOIN t_read_receipts ON m_members.member_id = t_read_receipts.member_id
LEFT JOIN t_images ON m_members.profile_image_id = t_images.image_id
LEFT JOIN t_attachable_items ON t_images.attachable_item_id = t_attachable_items.attachable_item_id
WHERE message_id = ANY($3::uuid[])
ORDER BY
	CASE WHEN $4::text = 'name' THEN m_members.name END ASC,
	CASE WHEN $4::text = 'r_name' THEN m_members.name END DESC,
	CASE WHEN $4::text = 'read_at' THEN t_read_receipts.read_at END ASC,
	CASE WHEN $4::text = 'r_read_at' THEN t_read_receipts.read_at END DESC,
	m_members_pkey ASC
LIMIT $1 OFFSET $2
`

type GetPluralReadableMembersOnMessageUseNumberedPaginateParams struct {
	Limit       int32       `json:"limit"`
	Offset      int32       `json:"offset"`
	MessageIds  []uuid.UUID `json:"message_ids"`
	OrderMethod string      `json:"order_method"`
}

type GetPluralReadableMembersOnMessageUseNumberedPaginateRow struct {
	MMembersPkey                 pgtype.Int8        `json:"m_members_pkey"`
	MemberID                     uuid.UUID          `json:"member_id"`
	LoginID                      string             `json:"login_id"`
	Password                     string             `json:"password"`
	Email                        string             `json:"email"`
	Name                         string             `json:"name"`
	FirstName                    string             `json:"first_name"`
	LastName                     string             `json:"last_name"`
	AttendStatusID               uuid.UUID          `json:"attend_status_id"`
	ProfileImageID               pgtype.UUID        `json:"profile_image_id"`
	GradeID                      uuid.UUID          `json:"grade_id"`
	GroupID                      uuid.UUID          `json:"group_id"`
	PersonalOrganizationID       uuid.UUID          `json:"personal_organization_id"`
	RoleID                       pgtype.UUID        `json:"role_id"`
	CreatedAt                    time.Time          `json:"created_at"`
	UpdatedAt                    time.Time          `json:"updated_at"`
	ReadAt                       pgtype.Timestamptz `json:"read_at"`
	ProfileImageHeight           pgtype.Float8      `json:"profile_image_height"`
	ProfileImageWidth            pgtype.Float8      `json:"profile_image_width"`
	ProfileImageAttachableItemID pgtype.UUID        `json:"profile_image_attachable_item_id"`
	ProfileImageOwnerID          pgtype.UUID        `json:"profile_image_owner_id"`
	ProfileImageFromOuter        pgtype.Bool        `json:"profile_image_from_outer"`
	ProfileImageUrl              pgtype.Text        `json:"profile_image_url"`
	ProfileImageSize             pgtype.Float8      `json:"profile_image_size"`
	ProfileImageMimeTypeID       pgtype.UUID        `json:"profile_image_mime_type_id"`
}

func (q *Queries) GetPluralReadableMembersOnMessageUseNumberedPaginate(ctx context.Context, arg GetPluralReadableMembersOnMessageUseNumberedPaginateParams) ([]GetPluralReadableMembersOnMessageUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getPluralReadableMembersOnMessageUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.MessageIds,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralReadableMembersOnMessageUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetPluralReadableMembersOnMessageUseNumberedPaginateRow
		if err := rows.Scan(
			&i.MMembersPkey,
			&i.MemberID,
			&i.LoginID,
			&i.Password,
			&i.Email,
			&i.Name,
			&i.FirstName,
			&i.LastName,
			&i.AttendStatusID,
			&i.ProfileImageID,
			&i.GradeID,
			&i.GroupID,
			&i.PersonalOrganizationID,
			&i.RoleID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ReadAt,
			&i.ProfileImageHeight,
			&i.ProfileImageWidth,
			&i.ProfileImageAttachableItemID,
			&i.ProfileImageOwnerID,
			&i.ProfileImageFromOuter,
			&i.ProfileImageUrl,
			&i.ProfileImageSize,
			&i.ProfileImageMimeTypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralReadableMessagesOnMember = `-- name: GetPluralReadableMessagesOnMember :many
SELECT t_messages.t_messages_pkey, t_messages.message_id, t_messages.chat_room_id, t_messages.sender_id, t_messages.body, t_messages.posted_at, t_messages.last_edited_at, t_read_receipts.read_at read_at FROM t_messages
LEFT JOIN t_read_receipts ON t_messages.message_id = t_read_receipts.message_id
WHERE message_id = ANY($1::uuid[])
ORDER BY
	CASE WHEN $2::text = 'read_at' THEN t_read_receipts.read_at END ASC,
	CASE WHEN $2::text = 'r_read_at' THEN t_read_receipts.read_at END DESC,
	t_messages_pkey ASC
`

type GetPluralReadableMessagesOnMemberParams struct {
	MessageIds  []uuid.UUID `json:"message_ids"`
	OrderMethod string      `json:"order_method"`
}

type GetPluralReadableMessagesOnMemberRow struct {
	TMessagesPkey pgtype.Int8        `json:"t_messages_pkey"`
	MessageID     uuid.UUID          `json:"message_id"`
	ChatRoomID    uuid.UUID          `json:"chat_room_id"`
	SenderID      pgtype.UUID        `json:"sender_id"`
	Body          string             `json:"body"`
	PostedAt      time.Time          `json:"posted_at"`
	LastEditedAt  time.Time          `json:"last_edited_at"`
	ReadAt        pgtype.Timestamptz `json:"read_at"`
}

func (q *Queries) GetPluralReadableMessagesOnMember(ctx context.Context, arg GetPluralReadableMessagesOnMemberParams) ([]GetPluralReadableMessagesOnMemberRow, error) {
	rows, err := q.db.Query(ctx, getPluralReadableMessagesOnMember, arg.MessageIds, arg.OrderMethod)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralReadableMessagesOnMemberRow{}
	for rows.Next() {
		var i GetPluralReadableMessagesOnMemberRow
		if err := rows.Scan(
			&i.TMessagesPkey,
			&i.MessageID,
			&i.ChatRoomID,
			&i.SenderID,
			&i.Body,
			&i.PostedAt,
			&i.LastEditedAt,
			&i.ReadAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralReadableMessagesOnMemberUseNumberedPaginate = `-- name: GetPluralReadableMessagesOnMemberUseNumberedPaginate :many
SELECT t_messages.t_messages_pkey, t_messages.message_id, t_messages.chat_room_id, t_messages.sender_id, t_messages.body, t_messages.posted_at, t_messages.last_edited_at, t_read_receipts.read_at read_at FROM t_messages
LEFT JOIN t_read_receipts ON t_messages.message_id = t_read_receipts.message_id
WHERE message_id = ANY($3::uuid[])
ORDER BY
	CASE WHEN $4::text = 'read_at' THEN t_read_receipts.read_at END ASC,
	CASE WHEN $4::text = 'r_read_at' THEN t_read_receipts.read_at END DESC,
	t_messages_pkey ASC
LIMIT $1 OFFSET $2
`

type GetPluralReadableMessagesOnMemberUseNumberedPaginateParams struct {
	Limit       int32       `json:"limit"`
	Offset      int32       `json:"offset"`
	MessageIds  []uuid.UUID `json:"message_ids"`
	OrderMethod string      `json:"order_method"`
}

type GetPluralReadableMessagesOnMemberUseNumberedPaginateRow struct {
	TMessagesPkey pgtype.Int8        `json:"t_messages_pkey"`
	MessageID     uuid.UUID          `json:"message_id"`
	ChatRoomID    uuid.UUID          `json:"chat_room_id"`
	SenderID      pgtype.UUID        `json:"sender_id"`
	Body          string             `json:"body"`
	PostedAt      time.Time          `json:"posted_at"`
	LastEditedAt  time.Time          `json:"last_edited_at"`
	ReadAt        pgtype.Timestamptz `json:"read_at"`
}

func (q *Queries) GetPluralReadableMessagesOnMemberUseNumberedPaginate(ctx context.Context, arg GetPluralReadableMessagesOnMemberUseNumberedPaginateParams) ([]GetPluralReadableMessagesOnMemberUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getPluralReadableMessagesOnMemberUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.MessageIds,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralReadableMessagesOnMemberUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetPluralReadableMessagesOnMemberUseNumberedPaginateRow
		if err := rows.Scan(
			&i.TMessagesPkey,
			&i.MessageID,
			&i.ChatRoomID,
			&i.SenderID,
			&i.Body,
			&i.PostedAt,
			&i.LastEditedAt,
			&i.ReadAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReadableMembersOnMessage = `-- name: GetReadableMembersOnMessage :many
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.first_name, m_members.last_name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, t_read_receipts.read_at read_at, t_images.height profile_image_height,
t_images.width profile_image_width, t_images.attachable_item_id profile_image_attachable_item_id,
t_attachable_items.owner_id profile_image_owner_id, t_attachable_items.from_outer profile_image_from_outer,
t_attachable_items.url profile_image_url, t_attachable_items.size profile_image_size, t_attachable_items.mime_type_id profile_image_mime_type_id
FROM m_members
LEFT JOIN t_read_receipts ON m_members.member_id = t_read_receipts.member_id
LEFT JOIN t_images ON m_members.profile_image_id = t_images.image_id
LEFT JOIN t_attachable_items ON t_images.attachable_item_id = t_attachable_items.attachable_item_id
WHERE message_id = $1
AND
	CASE WHEN $2::boolean = true THEN m_members.name LIKE '%' || $3::text || '%' ELSE TRUE END
AND
	CASE WHEN $4::boolean = true THEN t_read_receipts.read_at IS NOT NULL ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN t_read_receipts.read_at IS NULL ELSE TRUE END
ORDER BY
	CASE WHEN $6::text = 'name' THEN m_members.name END ASC,
	CASE WHEN $6::text = 'r_name' THEN m_members.name END DESC,
	CASE WHEN $6::text = 'read_at' THEN t_read_receipts.read_at END ASC,
	CASE WHEN $6::text = 'r_read_at' THEN t_read_receipts.read_at END DESC,
	m_members_pkey ASC
`

type GetReadableMembersOnMessageParams struct {
	MessageID      uuid.UUID `json:"message_id"`
	WhereLikeName  bool      `json:"where_like_name"`
	SearchName     string    `json:"search_name"`
	WhereIsRead    bool      `json:"where_is_read"`
	WhereIsNotRead bool      `json:"where_is_not_read"`
	OrderMethod    string    `json:"order_method"`
}

type GetReadableMembersOnMessageRow struct {
	MMembersPkey                 pgtype.Int8        `json:"m_members_pkey"`
	MemberID                     uuid.UUID          `json:"member_id"`
	LoginID                      string             `json:"login_id"`
	Password                     string             `json:"password"`
	Email                        string             `json:"email"`
	Name                         string             `json:"name"`
	FirstName                    string             `json:"first_name"`
	LastName                     string             `json:"last_name"`
	AttendStatusID               uuid.UUID          `json:"attend_status_id"`
	ProfileImageID               pgtype.UUID        `json:"profile_image_id"`
	GradeID                      uuid.UUID          `json:"grade_id"`
	GroupID                      uuid.UUID          `json:"group_id"`
	PersonalOrganizationID       uuid.UUID          `json:"personal_organization_id"`
	RoleID                       pgtype.UUID        `json:"role_id"`
	CreatedAt                    time.Time          `json:"created_at"`
	UpdatedAt                    time.Time          `json:"updated_at"`
	ReadAt                       pgtype.Timestamptz `json:"read_at"`
	ProfileImageHeight           pgtype.Float8      `json:"profile_image_height"`
	ProfileImageWidth            pgtype.Float8      `json:"profile_image_width"`
	ProfileImageAttachableItemID pgtype.UUID        `json:"profile_image_attachable_item_id"`
	ProfileImageOwnerID          pgtype.UUID        `json:"profile_image_owner_id"`
	ProfileImageFromOuter        pgtype.Bool        `json:"profile_image_from_outer"`
	ProfileImageUrl              pgtype.Text        `json:"profile_image_url"`
	ProfileImageSize             pgtype.Float8      `json:"profile_image_size"`
	ProfileImageMimeTypeID       pgtype.UUID        `json:"profile_image_mime_type_id"`
}

func (q *Queries) GetReadableMembersOnMessage(ctx context.Context, arg GetReadableMembersOnMessageParams) ([]GetReadableMembersOnMessageRow, error) {
	rows, err := q.db.Query(ctx, getReadableMembersOnMessage,
		arg.MessageID,
		arg.WhereLikeName,
		arg.SearchName,
		arg.WhereIsRead,
		arg.WhereIsNotRead,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetReadableMembersOnMessageRow{}
	for rows.Next() {
		var i GetReadableMembersOnMessageRow
		if err := rows.Scan(
			&i.MMembersPkey,
			&i.MemberID,
			&i.LoginID,
			&i.Password,
			&i.Email,
			&i.Name,
			&i.FirstName,
			&i.LastName,
			&i.AttendStatusID,
			&i.ProfileImageID,
			&i.GradeID,
			&i.GroupID,
			&i.PersonalOrganizationID,
			&i.RoleID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ReadAt,
			&i.ProfileImageHeight,
			&i.ProfileImageWidth,
			&i.ProfileImageAttachableItemID,
			&i.ProfileImageOwnerID,
			&i.ProfileImageFromOuter,
			&i.ProfileImageUrl,
			&i.ProfileImageSize,
			&i.ProfileImageMimeTypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReadableMembersOnMessageUseKeysetPaginate = `-- name: GetReadableMembersOnMessageUseKeysetPaginate :many
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.first_name, m_members.last_name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, t_read_receipts.read_at read_at, t_images.height profile_image_height,
t_images.width profile_image_width, t_images.attachable_item_id profile_image_attachable_item_id,
t_attachable_items.owner_id profile_image_owner_id, t_attachable_items.from_outer profile_image_from_outer,
t_attachable_items.url profile_image_url, t_attachable_items.size profile_image_size, t_attachable_items.mime_type_id profile_image_mime_type_id
FROM m_members
LEFT JOIN t_read_receipts ON m_members.member_id = t_read_receipts.member_id
LEFT JOIN t_images ON m_members.profile_image_id = t_images.image_id
LEFT JOIN t_attachable_items ON t_images.attachable_item_id = t_attachable_items.attachable_item_id
WHERE message_id = $1
AND
	CASE WHEN $3::boolean = true THEN m_members.name LIKE '%' || $4::text || '%' ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN t_read_receipts.read_at IS NOT NULL ELSE TRUE END
AND
	CASE WHEN $6::boolean = true THEN t_read_receipts.read_at IS NULL ELSE TRUE END
AND
	CASE $7::text
		WHEN 'next' THEN
			CASE $8::text
				WHEN 'name' THEN m_members.name > $9 OR (m_members.name = $9 AND m_members_pkey > $10::int)
				WHEN 'r_name' THEN m_members.name < $9 OR (m_members.name = $9 AND m_members_pkey > $10::int)
				WHEN 'read_at' THEN t_read_receipts.read_at > $11 OR (t_read_receipts.read_at = $11 AND m_members_pkey > $10::int)
				WHEN 'r_read_at' THEN t_read_receipts.read_at < $11 OR (t_read_receipts.read_at = $11 AND m_members_pkey > $10::int)
				ELSE m_members_pkey > $10::int
			END
		WHEN 'prev' THEN
			CASE $8::text
				WHEN 'name' THEN m_members.name < $9 OR (m_members.name = $9 AND m_members_pkey < $10::int)
				WHEN 'r_name' THEN m_members.name > $9 OR (m_members.name = $9 AND m_members_pkey < $10::int)
				WHEN 'read_at' THEN t_read_receipts.read_at < $11 OR (t_read_receipts.read_at = $11 AND m_members_pkey < $10::int)
				WHEN 'r_read_at' THEN t_read_receipts.read_at > $11 OR (t_read_receipts.read_at = $11 AND m_members_pkey < $10::int)
				ELSE m_members_pkey < $10::int
			END
	END
ORDER BY
	CASE WHEN $8::text = 'name' AND $7::text = 'next' THEN m_members.name END ASC,
	CASE WHEN $8::text = 'name' AND $7::text = 'prev' THEN m_members.name END DESC,
	CASE WHEN $8::text = 'r_name' AND $7::text = 'next' THEN m_members.name END DESC,
	CASE WHEN $8::text = 'r_name' AND $7::text = 'prev' THEN m_members.name END ASC,
	CASE WHEN $8::text = 'read_at' AND $7::text = 'next' THEN t_read_receipts.read_at END ASC,
	CASE WHEN $8::text = 'read_at' AND $7::text = 'prev' THEN t_read_receipts.read_at END DESC,
	CASE WHEN $8::text = 'r_read_at' AND $7::text = 'next' THEN t_read_receipts.read_at END DESC,
	CASE WHEN $8::text = 'r_read_at' AND $7::text = 'prev' THEN t_read_receipts.read_at END ASC,
	CASE WHEN $7::text = 'next' THEN m_members_pkey END ASC,
	CASE WHEN $7::text = 'prev' THEN m_members_pkey END DESC
LIMIT $2
`

type GetReadableMembersOnMessageUseKeysetPaginateParams struct {
	MessageID       uuid.UUID          `json:"message_id"`
	Limit           int32              `json:"limit"`
	WhereLikeName   bool               `json:"where_like_name"`
	SearchName      string             `json:"search_name"`
	WhereIsRead     bool               `json:"where_is_read"`
	WhereIsNotRead  bool               `json:"where_is_not_read"`
	CursorDirection string             `json:"cursor_direction"`
	OrderMethod     string             `json:"order_method"`
	NameCursor      string             `json:"name_cursor"`
	Cursor          int32              `json:"cursor"`
	ReadAtCursor    pgtype.Timestamptz `json:"read_at_cursor"`
}

type GetReadableMembersOnMessageUseKeysetPaginateRow struct {
	MMembersPkey                 pgtype.Int8        `json:"m_members_pkey"`
	MemberID                     uuid.UUID          `json:"member_id"`
	LoginID                      string             `json:"login_id"`
	Password                     string             `json:"password"`
	Email                        string             `json:"email"`
	Name                         string             `json:"name"`
	FirstName                    string             `json:"first_name"`
	LastName                     string             `json:"last_name"`
	AttendStatusID               uuid.UUID          `json:"attend_status_id"`
	ProfileImageID               pgtype.UUID        `json:"profile_image_id"`
	GradeID                      uuid.UUID          `json:"grade_id"`
	GroupID                      uuid.UUID          `json:"group_id"`
	PersonalOrganizationID       uuid.UUID          `json:"personal_organization_id"`
	RoleID                       pgtype.UUID        `json:"role_id"`
	CreatedAt                    time.Time          `json:"created_at"`
	UpdatedAt                    time.Time          `json:"updated_at"`
	ReadAt                       pgtype.Timestamptz `json:"read_at"`
	ProfileImageHeight           pgtype.Float8      `json:"profile_image_height"`
	ProfileImageWidth            pgtype.Float8      `json:"profile_image_width"`
	ProfileImageAttachableItemID pgtype.UUID        `json:"profile_image_attachable_item_id"`
	ProfileImageOwnerID          pgtype.UUID        `json:"profile_image_owner_id"`
	ProfileImageFromOuter        pgtype.Bool        `json:"profile_image_from_outer"`
	ProfileImageUrl              pgtype.Text        `json:"profile_image_url"`
	ProfileImageSize             pgtype.Float8      `json:"profile_image_size"`
	ProfileImageMimeTypeID       pgtype.UUID        `json:"profile_image_mime_type_id"`
}

func (q *Queries) GetReadableMembersOnMessageUseKeysetPaginate(ctx context.Context, arg GetReadableMembersOnMessageUseKeysetPaginateParams) ([]GetReadableMembersOnMessageUseKeysetPaginateRow, error) {
	rows, err := q.db.Query(ctx, getReadableMembersOnMessageUseKeysetPaginate,
		arg.MessageID,
		arg.Limit,
		arg.WhereLikeName,
		arg.SearchName,
		arg.WhereIsRead,
		arg.WhereIsNotRead,
		arg.CursorDirection,
		arg.OrderMethod,
		arg.NameCursor,
		arg.Cursor,
		arg.ReadAtCursor,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetReadableMembersOnMessageUseKeysetPaginateRow{}
	for rows.Next() {
		var i GetReadableMembersOnMessageUseKeysetPaginateRow
		if err := rows.Scan(
			&i.MMembersPkey,
			&i.MemberID,
			&i.LoginID,
			&i.Password,
			&i.Email,
			&i.Name,
			&i.FirstName,
			&i.LastName,
			&i.AttendStatusID,
			&i.ProfileImageID,
			&i.GradeID,
			&i.GroupID,
			&i.PersonalOrganizationID,
			&i.RoleID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ReadAt,
			&i.ProfileImageHeight,
			&i.ProfileImageWidth,
			&i.ProfileImageAttachableItemID,
			&i.ProfileImageOwnerID,
			&i.ProfileImageFromOuter,
			&i.ProfileImageUrl,
			&i.ProfileImageSize,
			&i.ProfileImageMimeTypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReadableMembersOnMessageUseNumberedPaginate = `-- name: GetReadableMembersOnMessageUseNumberedPaginate :many
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.first_name, m_members.last_name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, t_read_receipts.read_at read_at, t_images.height profile_image_height,
t_images.width profile_image_width, t_images.attachable_item_id profile_image_attachable_item_id,
t_attachable_items.owner_id profile_image_owner_id, t_attachable_items.from_outer profile_image_from_outer,
t_attachable_items.url profile_image_url, t_attachable_items.size profile_image_size, t_attachable_items.mime_type_id profile_image_mime_type_id
FROM m_members
LEFT JOIN t_read_receipts ON m_members.member_id = t_read_receipts.member_id
LEFT JOIN t_images ON m_members.profile_image_id = t_images.image_id
LEFT JOIN t_attachable_items ON t_images.attachable_item_id = t_attachable_items.attachable_item_id
WHERE message_id = $1
AND
	CASE WHEN $4::boolean = true THEN m_members.name LIKE '%' || $5::text || '%' ELSE TRUE END
AND
	CASE WHEN $6::boolean = true THEN t_read_receipts.read_at IS NOT NULL ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN t_read_receipts.read_at IS NULL ELSE TRUE END
ORDER BY
	CASE WHEN $8::text = 'name' THEN m_members.name END ASC,
	CASE WHEN $8::text = 'r_name' THEN m_members.name END DESC,
	CASE WHEN $8::text = 'read_at' THEN t_read_receipts.read_at END ASC,
	CASE WHEN $8::text = 'r_read_at' THEN t_read_receipts.read_at END DESC,
	m_members_pkey ASC
LIMIT $2 OFFSET $3
`

type GetReadableMembersOnMessageUseNumberedPaginateParams struct {
	MessageID      uuid.UUID `json:"message_id"`
	Limit          int32     `json:"limit"`
	Offset         int32     `json:"offset"`
	WhereLikeName  bool      `json:"where_like_name"`
	SearchName     string    `json:"search_name"`
	WhereIsRead    bool      `json:"where_is_read"`
	WhereIsNotRead bool      `json:"where_is_not_read"`
	OrderMethod    string    `json:"order_method"`
}

type GetReadableMembersOnMessageUseNumberedPaginateRow struct {
	MMembersPkey                 pgtype.Int8        `json:"m_members_pkey"`
	MemberID                     uuid.UUID          `json:"member_id"`
	LoginID                      string             `json:"login_id"`
	Password                     string             `json:"password"`
	Email                        string             `json:"email"`
	Name                         string             `json:"name"`
	FirstName                    string             `json:"first_name"`
	LastName                     string             `json:"last_name"`
	AttendStatusID               uuid.UUID          `json:"attend_status_id"`
	ProfileImageID               pgtype.UUID        `json:"profile_image_id"`
	GradeID                      uuid.UUID          `json:"grade_id"`
	GroupID                      uuid.UUID          `json:"group_id"`
	PersonalOrganizationID       uuid.UUID          `json:"personal_organization_id"`
	RoleID                       pgtype.UUID        `json:"role_id"`
	CreatedAt                    time.Time          `json:"created_at"`
	UpdatedAt                    time.Time          `json:"updated_at"`
	ReadAt                       pgtype.Timestamptz `json:"read_at"`
	ProfileImageHeight           pgtype.Float8      `json:"profile_image_height"`
	ProfileImageWidth            pgtype.Float8      `json:"profile_image_width"`
	ProfileImageAttachableItemID pgtype.UUID        `json:"profile_image_attachable_item_id"`
	ProfileImageOwnerID          pgtype.UUID        `json:"profile_image_owner_id"`
	ProfileImageFromOuter        pgtype.Bool        `json:"profile_image_from_outer"`
	ProfileImageUrl              pgtype.Text        `json:"profile_image_url"`
	ProfileImageSize             pgtype.Float8      `json:"profile_image_size"`
	ProfileImageMimeTypeID       pgtype.UUID        `json:"profile_image_mime_type_id"`
}

func (q *Queries) GetReadableMembersOnMessageUseNumberedPaginate(ctx context.Context, arg GetReadableMembersOnMessageUseNumberedPaginateParams) ([]GetReadableMembersOnMessageUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getReadableMembersOnMessageUseNumberedPaginate,
		arg.MessageID,
		arg.Limit,
		arg.Offset,
		arg.WhereLikeName,
		arg.SearchName,
		arg.WhereIsRead,
		arg.WhereIsNotRead,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetReadableMembersOnMessageUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetReadableMembersOnMessageUseNumberedPaginateRow
		if err := rows.Scan(
			&i.MMembersPkey,
			&i.MemberID,
			&i.LoginID,
			&i.Password,
			&i.Email,
			&i.Name,
			&i.FirstName,
			&i.LastName,
			&i.AttendStatusID,
			&i.ProfileImageID,
			&i.GradeID,
			&i.GroupID,
			&i.PersonalOrganizationID,
			&i.RoleID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ReadAt,
			&i.ProfileImageHeight,
			&i.ProfileImageWidth,
			&i.ProfileImageAttachableItemID,
			&i.ProfileImageOwnerID,
			&i.ProfileImageFromOuter,
			&i.ProfileImageUrl,
			&i.ProfileImageSize,
			&i.ProfileImageMimeTypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReadableMessagesOnMember = `-- name: GetReadableMessagesOnMember :many
SELECT t_messages.t_messages_pkey, t_messages.message_id, t_messages.chat_room_id, t_messages.sender_id, t_messages.body, t_messages.posted_at, t_messages.last_edited_at, t_read_receipts.read_at read_at FROM t_messages
LEFT JOIN t_read_receipts ON t_messages.message_id = t_read_receipts.message_id
WHERE member_id = $1
AND
	CASE WHEN $2::boolean = true THEN t_read_receipts.read_at IS NOT NULL ELSE TRUE END
AND
	CASE WHEN $3::boolean = true THEN t_read_receipts.read_at IS NULL ELSE TRUE END
ORDER BY
	CASE WHEN $4::text = 'read_at' THEN t_read_receipts.read_at END ASC,
	CASE WHEN $4::text = 'r_read_at' THEN t_read_receipts.read_at END DESC,
	t_messages_pkey ASC
`

type GetReadableMessagesOnMemberParams struct {
	MemberID       uuid.UUID `json:"member_id"`
	WhereIsRead    bool      `json:"where_is_read"`
	WhereIsNotRead bool      `json:"where_is_not_read"`
	OrderMethod    string    `json:"order_method"`
}

type GetReadableMessagesOnMemberRow struct {
	TMessagesPkey pgtype.Int8        `json:"t_messages_pkey"`
	MessageID     uuid.UUID          `json:"message_id"`
	ChatRoomID    uuid.UUID          `json:"chat_room_id"`
	SenderID      pgtype.UUID        `json:"sender_id"`
	Body          string             `json:"body"`
	PostedAt      time.Time          `json:"posted_at"`
	LastEditedAt  time.Time          `json:"last_edited_at"`
	ReadAt        pgtype.Timestamptz `json:"read_at"`
}

func (q *Queries) GetReadableMessagesOnMember(ctx context.Context, arg GetReadableMessagesOnMemberParams) ([]GetReadableMessagesOnMemberRow, error) {
	rows, err := q.db.Query(ctx, getReadableMessagesOnMember,
		arg.MemberID,
		arg.WhereIsRead,
		arg.WhereIsNotRead,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetReadableMessagesOnMemberRow{}
	for rows.Next() {
		var i GetReadableMessagesOnMemberRow
		if err := rows.Scan(
			&i.TMessagesPkey,
			&i.MessageID,
			&i.ChatRoomID,
			&i.SenderID,
			&i.Body,
			&i.PostedAt,
			&i.LastEditedAt,
			&i.ReadAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReadableMessagesOnMemberUseKeysetPaginate = `-- name: GetReadableMessagesOnMemberUseKeysetPaginate :many
SELECT t_messages.t_messages_pkey, t_messages.message_id, t_messages.chat_room_id, t_messages.sender_id, t_messages.body, t_messages.posted_at, t_messages.last_edited_at, t_read_receipts.read_at read_at FROM t_messages
LEFT JOIN t_read_receipts ON t_messages.message_id = t_read_receipts.message_id
WHERE member_id = $1
AND
	CASE WHEN $3::boolean = true THEN t_read_receipts.read_at IS NOT NULL ELSE TRUE END
AND
	CASE WHEN $4::boolean = true THEN t_read_receipts.read_at IS NULL ELSE TRUE END
AND
	CASE $5::text
		WHEN 'next' THEN
			CASE $6::text
				WHEN 'read_at' THEN t_read_receipts.read_at > $7 OR (t_read_receipts.read_at = $7 AND t_messages_pkey > $8::int)
				WHEN 'r_read_at' THEN t_read_receipts.read_at < $7 OR (t_read_receipts.read_at = $7 AND t_messages_pkey > $8::int)
				ELSE t_messages_pkey > $8::int
			END
		WHEN 'prev' THEN
			CASE $6::text
				WHEN 'read_at' THEN t_read_receipts.read_at < $7 OR (t_read_receipts.read_at = $7 AND t_messages_pkey < $8::int)
				WHEN 'r_read_at' THEN t_read_receipts.read_at > $7 OR (t_read_receipts.read_at = $7 AND t_messages_pkey < $8::int)
				ELSE t_messages_pkey < $8::int
			END
	END
ORDER BY
	CASE WHEN $6::text = 'read_at' AND $5::text = 'next' THEN t_read_receipts.read_at END ASC,
	CASE WHEN $6::text = 'read_at' AND $5::text = 'prev' THEN t_read_receipts.read_at END DESC,
	CASE WHEN $6::text = 'r_read_at' AND $5::text = 'next' THEN t_read_receipts.read_at END DESC,
	CASE WHEN $6::text = 'r_read_at' AND $5::text = 'prev' THEN t_read_receipts.read_at END ASC,
	CASE WHEN $5::text = 'next' THEN t_messages_pkey END ASC,
	CASE WHEN $5::text = 'prev' THEN t_messages_pkey END DESC
LIMIT $2
`

type GetReadableMessagesOnMemberUseKeysetPaginateParams struct {
	MemberID        uuid.UUID          `json:"member_id"`
	Limit           int32              `json:"limit"`
	WhereIsRead     bool               `json:"where_is_read"`
	WhereIsNotRead  bool               `json:"where_is_not_read"`
	CursorDirection string             `json:"cursor_direction"`
	OrderMethod     string             `json:"order_method"`
	ReadAtCursor    pgtype.Timestamptz `json:"read_at_cursor"`
	Cursor          int32              `json:"cursor"`
}

type GetReadableMessagesOnMemberUseKeysetPaginateRow struct {
	TMessagesPkey pgtype.Int8        `json:"t_messages_pkey"`
	MessageID     uuid.UUID          `json:"message_id"`
	ChatRoomID    uuid.UUID          `json:"chat_room_id"`
	SenderID      pgtype.UUID        `json:"sender_id"`
	Body          string             `json:"body"`
	PostedAt      time.Time          `json:"posted_at"`
	LastEditedAt  time.Time          `json:"last_edited_at"`
	ReadAt        pgtype.Timestamptz `json:"read_at"`
}

func (q *Queries) GetReadableMessagesOnMemberUseKeysetPaginate(ctx context.Context, arg GetReadableMessagesOnMemberUseKeysetPaginateParams) ([]GetReadableMessagesOnMemberUseKeysetPaginateRow, error) {
	rows, err := q.db.Query(ctx, getReadableMessagesOnMemberUseKeysetPaginate,
		arg.MemberID,
		arg.Limit,
		arg.WhereIsRead,
		arg.WhereIsNotRead,
		arg.CursorDirection,
		arg.OrderMethod,
		arg.ReadAtCursor,
		arg.Cursor,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetReadableMessagesOnMemberUseKeysetPaginateRow{}
	for rows.Next() {
		var i GetReadableMessagesOnMemberUseKeysetPaginateRow
		if err := rows.Scan(
			&i.TMessagesPkey,
			&i.MessageID,
			&i.ChatRoomID,
			&i.SenderID,
			&i.Body,
			&i.PostedAt,
			&i.LastEditedAt,
			&i.ReadAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReadableMessagesOnMemberUseNumberedPaginate = `-- name: GetReadableMessagesOnMemberUseNumberedPaginate :many
SELECT t_messages.t_messages_pkey, t_messages.message_id, t_messages.chat_room_id, t_messages.sender_id, t_messages.body, t_messages.posted_at, t_messages.last_edited_at, t_read_receipts.read_at read_at FROM t_messages
LEFT JOIN t_read_receipts ON t_messages.message_id = t_read_receipts.message_id
WHERE member_id = $1
AND
	CASE WHEN $4::boolean = true THEN t_read_receipts.read_at IS NOT NULL ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN t_read_receipts.read_at IS NULL ELSE TRUE END
ORDER BY
	CASE WHEN $6::text = 'read_at' THEN t_read_receipts.read_at END ASC,
	CASE WHEN $6::text = 'r_read_at' THEN t_read_receipts.read_at END DESC,
	t_messages_pkey ASC
LIMIT $2 OFFSET $3
`

type GetReadableMessagesOnMemberUseNumberedPaginateParams struct {
	MemberID       uuid.UUID `json:"member_id"`
	Limit          int32     `json:"limit"`
	Offset         int32     `json:"offset"`
	WhereIsRead    bool      `json:"where_is_read"`
	WhereIsNotRead bool      `json:"where_is_not_read"`
	OrderMethod    string    `json:"order_method"`
}

type GetReadableMessagesOnMemberUseNumberedPaginateRow struct {
	TMessagesPkey pgtype.Int8        `json:"t_messages_pkey"`
	MessageID     uuid.UUID          `json:"message_id"`
	ChatRoomID    uuid.UUID          `json:"chat_room_id"`
	SenderID      pgtype.UUID        `json:"sender_id"`
	Body          string             `json:"body"`
	PostedAt      time.Time          `json:"posted_at"`
	LastEditedAt  time.Time          `json:"last_edited_at"`
	ReadAt        pgtype.Timestamptz `json:"read_at"`
}

func (q *Queries) GetReadableMessagesOnMemberUseNumberedPaginate(ctx context.Context, arg GetReadableMessagesOnMemberUseNumberedPaginateParams) ([]GetReadableMessagesOnMemberUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getReadableMessagesOnMemberUseNumberedPaginate,
		arg.MemberID,
		arg.Limit,
		arg.Offset,
		arg.WhereIsRead,
		arg.WhereIsNotRead,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetReadableMessagesOnMemberUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetReadableMessagesOnMemberUseNumberedPaginateRow
		if err := rows.Scan(
			&i.TMessagesPkey,
			&i.MessageID,
			&i.ChatRoomID,
			&i.SenderID,
			&i.Body,
			&i.PostedAt,
			&i.LastEditedAt,
			&i.ReadAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readReceipt = `-- name: ReadReceipt :one
UPDATE t_read_receipts SET read_at = $3 WHERE member_id = $1 AND message_id = $2 RETURNING t_read_receipts_pkey, member_id, message_id, read_at
`

type ReadReceiptParams struct {
	MemberID  uuid.UUID          `json:"member_id"`
	MessageID uuid.UUID          `json:"message_id"`
	ReadAt    pgtype.Timestamptz `json:"read_at"`
}

func (q *Queries) ReadReceipt(ctx context.Context, arg ReadReceiptParams) (TReadReceipt, error) {
	row := q.db.QueryRow(ctx, readReceipt, arg.MemberID, arg.MessageID, arg.ReadAt)
	var i TReadReceipt
	err := row.Scan(
		&i.TReadReceiptsPkey,
		&i.MemberID,
		&i.MessageID,
		&i.ReadAt,
	)
	return i, err
}

const readReceipts = `-- name: ReadReceipts :many
SELECT t_read_receipts_pkey, member_id, message_id, read_at FROM t_read_receipts WHERE member_id = $1 AND message_id = ANY($2::uuid[])
`

type ReadReceiptsParams struct {
	MemberID   uuid.UUID   `json:"member_id"`
	MessageIds []uuid.UUID `json:"message_ids"`
}

func (q *Queries) ReadReceipts(ctx context.Context, arg ReadReceiptsParams) ([]TReadReceipt, error) {
	rows, err := q.db.Query(ctx, readReceipts, arg.MemberID, arg.MessageIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TReadReceipt{}
	for rows.Next() {
		var i TReadReceipt
		if err := rows.Scan(
			&i.TReadReceiptsPkey,
			&i.MemberID,
			&i.MessageID,
			&i.ReadAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
