// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: chat_room.sql

package query

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countChatRooms = `-- name: CountChatRooms :one
SELECT COUNT(*) FROM m_chat_rooms
WHERE
	CASE WHEN $1::boolean = true THEN owner_id = ANY($2::uuid[]) ELSE TRUE END
AND
	CASE WHEN $3::boolean = true THEN is_private = $4 ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN from_organization = $6 ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN (SELECT chat_room_id FROM m_organizations WHERE organization_id = ANY($8::uuid[])) = chat_room_id ELSE TRUE END
`

type CountChatRoomsParams struct {
	WhereInOwner            bool        `json:"where_in_owner"`
	InOwner                 []uuid.UUID `json:"in_owner"`
	WhereIsPrivate          bool        `json:"where_is_private"`
	IsPrivate               bool        `json:"is_private"`
	WhereIsFromOrganization bool        `json:"where_is_from_organization"`
	IsFromOrganization      bool        `json:"is_from_organization"`
	WhereFromOrganizations  bool        `json:"where_from_organizations"`
	FromOrganizations       []uuid.UUID `json:"from_organizations"`
}

func (q *Queries) CountChatRooms(ctx context.Context, arg CountChatRoomsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countChatRooms,
		arg.WhereInOwner,
		arg.InOwner,
		arg.WhereIsPrivate,
		arg.IsPrivate,
		arg.WhereIsFromOrganization,
		arg.IsFromOrganization,
		arg.WhereFromOrganizations,
		arg.FromOrganizations,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createChatRoom = `-- name: CreateChatRoom :one
INSERT INTO m_chat_rooms (name, is_private, cover_image_id, owner_id, from_organization, created_at, updated_at) VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING m_chat_rooms_pkey, chat_room_id, name, is_private, cover_image_id, owner_id, from_organization, created_at, updated_at
`

type CreateChatRoomParams struct {
	Name             string      `json:"name"`
	IsPrivate        bool        `json:"is_private"`
	CoverImageID     pgtype.UUID `json:"cover_image_id"`
	OwnerID          pgtype.UUID `json:"owner_id"`
	FromOrganization bool        `json:"from_organization"`
	CreatedAt        time.Time   `json:"created_at"`
	UpdatedAt        time.Time   `json:"updated_at"`
}

func (q *Queries) CreateChatRoom(ctx context.Context, arg CreateChatRoomParams) (ChatRoom, error) {
	row := q.db.QueryRow(ctx, createChatRoom,
		arg.Name,
		arg.IsPrivate,
		arg.CoverImageID,
		arg.OwnerID,
		arg.FromOrganization,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i ChatRoom
	err := row.Scan(
		&i.MChatRoomsPkey,
		&i.ChatRoomID,
		&i.Name,
		&i.IsPrivate,
		&i.CoverImageID,
		&i.OwnerID,
		&i.FromOrganization,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

type CreateChatRoomsParams struct {
	Name             string      `json:"name"`
	IsPrivate        bool        `json:"is_private"`
	CoverImageID     pgtype.UUID `json:"cover_image_id"`
	OwnerID          pgtype.UUID `json:"owner_id"`
	FromOrganization bool        `json:"from_organization"`
	CreatedAt        time.Time   `json:"created_at"`
	UpdatedAt        time.Time   `json:"updated_at"`
}

const deleteChatRoom = `-- name: DeleteChatRoom :execrows
DELETE FROM m_chat_rooms WHERE chat_room_id = $1
`

func (q *Queries) DeleteChatRoom(ctx context.Context, chatRoomID uuid.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, deleteChatRoom, chatRoomID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const findChatRoomByID = `-- name: FindChatRoomByID :one
SELECT m_chat_rooms_pkey, chat_room_id, name, is_private, cover_image_id, owner_id, from_organization, created_at, updated_at FROM m_chat_rooms WHERE chat_room_id = $1
`

func (q *Queries) FindChatRoomByID(ctx context.Context, chatRoomID uuid.UUID) (ChatRoom, error) {
	row := q.db.QueryRow(ctx, findChatRoomByID, chatRoomID)
	var i ChatRoom
	err := row.Scan(
		&i.MChatRoomsPkey,
		&i.ChatRoomID,
		&i.Name,
		&i.IsPrivate,
		&i.CoverImageID,
		&i.OwnerID,
		&i.FromOrganization,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findChatRoomByIDWithCoverImage = `-- name: FindChatRoomByIDWithCoverImage :one
SELECT m_chat_rooms.m_chat_rooms_pkey, m_chat_rooms.chat_room_id, m_chat_rooms.name, m_chat_rooms.is_private, m_chat_rooms.cover_image_id, m_chat_rooms.owner_id, m_chat_rooms.from_organization, m_chat_rooms.created_at, m_chat_rooms.updated_at, t_images.height cover_image_height, t_images.width cover_image_width, t_images.attachable_item_id cover_image_attachable_item_id,
t_attachable_items.owner_id cover_image_owner_id, t_attachable_items.from_outer cover_image_from_outer, t_attachable_items.alias cover_image_alias,
t_attachable_items.url cover_image_url, t_attachable_items.size cover_image_size, t_attachable_items.mime_type_id cover_image_mime_type_id
FROM m_chat_rooms
LEFT JOIN t_images ON m_chat_rooms.cover_image_id = t_images.image_id
LEFT JOIN t_attachable_items ON t_images.attachable_item_id = t_attachable_items.attachable_item_id
WHERE chat_room_id = $1
`

type FindChatRoomByIDWithCoverImageRow struct {
	MChatRoomsPkey             pgtype.Int8   `json:"m_chat_rooms_pkey"`
	ChatRoomID                 uuid.UUID     `json:"chat_room_id"`
	Name                       string        `json:"name"`
	IsPrivate                  bool          `json:"is_private"`
	CoverImageID               pgtype.UUID   `json:"cover_image_id"`
	OwnerID                    pgtype.UUID   `json:"owner_id"`
	FromOrganization           bool          `json:"from_organization"`
	CreatedAt                  time.Time     `json:"created_at"`
	UpdatedAt                  time.Time     `json:"updated_at"`
	CoverImageHeight           pgtype.Float8 `json:"cover_image_height"`
	CoverImageWidth            pgtype.Float8 `json:"cover_image_width"`
	CoverImageAttachableItemID pgtype.UUID   `json:"cover_image_attachable_item_id"`
	CoverImageOwnerID          pgtype.UUID   `json:"cover_image_owner_id"`
	CoverImageFromOuter        pgtype.Bool   `json:"cover_image_from_outer"`
	CoverImageAlias            pgtype.Text   `json:"cover_image_alias"`
	CoverImageUrl              pgtype.Text   `json:"cover_image_url"`
	CoverImageSize             pgtype.Float8 `json:"cover_image_size"`
	CoverImageMimeTypeID       pgtype.UUID   `json:"cover_image_mime_type_id"`
}

func (q *Queries) FindChatRoomByIDWithCoverImage(ctx context.Context, chatRoomID uuid.UUID) (FindChatRoomByIDWithCoverImageRow, error) {
	row := q.db.QueryRow(ctx, findChatRoomByIDWithCoverImage, chatRoomID)
	var i FindChatRoomByIDWithCoverImageRow
	err := row.Scan(
		&i.MChatRoomsPkey,
		&i.ChatRoomID,
		&i.Name,
		&i.IsPrivate,
		&i.CoverImageID,
		&i.OwnerID,
		&i.FromOrganization,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CoverImageHeight,
		&i.CoverImageWidth,
		&i.CoverImageAttachableItemID,
		&i.CoverImageOwnerID,
		&i.CoverImageFromOuter,
		&i.CoverImageAlias,
		&i.CoverImageUrl,
		&i.CoverImageSize,
		&i.CoverImageMimeTypeID,
	)
	return i, err
}

const findChatRoomByIDWithOwner = `-- name: FindChatRoomByIDWithOwner :one
SELECT m_chat_rooms.m_chat_rooms_pkey, m_chat_rooms.chat_room_id, m_chat_rooms.name, m_chat_rooms.is_private, m_chat_rooms.cover_image_id, m_chat_rooms.owner_id, m_chat_rooms.from_organization, m_chat_rooms.created_at, m_chat_rooms.updated_at, m_members.name owner_name, m_members.first_name owner_first_name, m_members.last_name owner_last_name, m_members.email owner_email,
m_members.profile_image_id owner_profile_image_id, m_members.grade_id owner_grade_id, m_members.group_id owner_group_id
FROM m_chat_rooms
LEFT JOIN m_members ON m_chat_rooms.owner_id = m_members.member_id
WHERE chat_room_id = $1
`

type FindChatRoomByIDWithOwnerRow struct {
	MChatRoomsPkey      pgtype.Int8 `json:"m_chat_rooms_pkey"`
	ChatRoomID          uuid.UUID   `json:"chat_room_id"`
	Name                string      `json:"name"`
	IsPrivate           bool        `json:"is_private"`
	CoverImageID        pgtype.UUID `json:"cover_image_id"`
	OwnerID             pgtype.UUID `json:"owner_id"`
	FromOrganization    bool        `json:"from_organization"`
	CreatedAt           time.Time   `json:"created_at"`
	UpdatedAt           time.Time   `json:"updated_at"`
	OwnerName           pgtype.Text `json:"owner_name"`
	OwnerFirstName      pgtype.Text `json:"owner_first_name"`
	OwnerLastName       pgtype.Text `json:"owner_last_name"`
	OwnerEmail          pgtype.Text `json:"owner_email"`
	OwnerProfileImageID pgtype.UUID `json:"owner_profile_image_id"`
	OwnerGradeID        pgtype.UUID `json:"owner_grade_id"`
	OwnerGroupID        pgtype.UUID `json:"owner_group_id"`
}

func (q *Queries) FindChatRoomByIDWithOwner(ctx context.Context, chatRoomID uuid.UUID) (FindChatRoomByIDWithOwnerRow, error) {
	row := q.db.QueryRow(ctx, findChatRoomByIDWithOwner, chatRoomID)
	var i FindChatRoomByIDWithOwnerRow
	err := row.Scan(
		&i.MChatRoomsPkey,
		&i.ChatRoomID,
		&i.Name,
		&i.IsPrivate,
		&i.CoverImageID,
		&i.OwnerID,
		&i.FromOrganization,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.OwnerName,
		&i.OwnerFirstName,
		&i.OwnerLastName,
		&i.OwnerEmail,
		&i.OwnerProfileImageID,
		&i.OwnerGradeID,
		&i.OwnerGroupID,
	)
	return i, err
}

const findChatRoomOnPrivate = `-- name: FindChatRoomOnPrivate :one
SELECT m_chat_rooms_pkey, chat_room_id, name, is_private, cover_image_id, owner_id, from_organization, created_at, updated_at FROM m_chat_rooms
WHERE (SELECT COUNT(chat_room_id) FROM m_chat_room_belongings WHERE chat_room_id = m_chat_rooms.chat_room_id AND
(m_chat_room_belongings.member_id = $1 OR m_chat_room_belongings.member_id = $2)) = 2
AND is_private = true
AND m_chat_rooms_belongs.member_id <> $1
`

type FindChatRoomOnPrivateParams struct {
	OwnerID  uuid.UUID `json:"owner_id"`
	MemberID uuid.UUID `json:"member_id"`
}

func (q *Queries) FindChatRoomOnPrivate(ctx context.Context, arg FindChatRoomOnPrivateParams) (ChatRoom, error) {
	row := q.db.QueryRow(ctx, findChatRoomOnPrivate, arg.OwnerID, arg.MemberID)
	var i ChatRoom
	err := row.Scan(
		&i.MChatRoomsPkey,
		&i.ChatRoomID,
		&i.Name,
		&i.IsPrivate,
		&i.CoverImageID,
		&i.OwnerID,
		&i.FromOrganization,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findChatRoomOnPrivateWithMember = `-- name: FindChatRoomOnPrivateWithMember :one
SELECT m_chat_rooms.m_chat_rooms_pkey, m_chat_rooms.chat_room_id, m_chat_rooms.name, m_chat_rooms.is_private, m_chat_rooms.cover_image_id, m_chat_rooms.owner_id, m_chat_rooms.from_organization, m_chat_rooms.created_at, m_chat_rooms.updated_at, m_chat_room_belongings.added_at member_added_at, m_members.member_id, m_members.name member_name, m_members.first_name member_first_name, m_members.last_name member_last_name, m_members.email member_email,
m_members.profile_image_id member_profile_image_id, m_members.grade_id member_grade_id, m_members.group_id member_group_id
FROM m_chat_rooms
LEFT JOIN m_chat_room_belongings ON m_chat_rooms.chat_room_id = m_chat_room_belongings.chat_room_id
LEFT JOIN m_members ON m_chat_room_belongings.member_id = m_members.member_id
WHERE (SELECT COUNT(chat_room_id) FROM m_chat_room_belongings WHERE chat_room_id = m_chat_rooms.chat_room_id AND
(m_chat_room_belongings.member_id = $1 OR m_chat_room_belongings.member_id = $2)) = 2
AND is_private = true
AND m_chat_rooms_belongs.member_id <> $1
`

type FindChatRoomOnPrivateWithMemberParams struct {
	OwnerID  uuid.UUID `json:"owner_id"`
	MemberID uuid.UUID `json:"member_id"`
}

type FindChatRoomOnPrivateWithMemberRow struct {
	MChatRoomsPkey       pgtype.Int8        `json:"m_chat_rooms_pkey"`
	ChatRoomID           uuid.UUID          `json:"chat_room_id"`
	Name                 string             `json:"name"`
	IsPrivate            bool               `json:"is_private"`
	CoverImageID         pgtype.UUID        `json:"cover_image_id"`
	OwnerID              pgtype.UUID        `json:"owner_id"`
	FromOrganization     bool               `json:"from_organization"`
	CreatedAt            time.Time          `json:"created_at"`
	UpdatedAt            time.Time          `json:"updated_at"`
	MemberAddedAt        pgtype.Timestamptz `json:"member_added_at"`
	MemberID             pgtype.UUID        `json:"member_id"`
	MemberName           pgtype.Text        `json:"member_name"`
	MemberFirstName      pgtype.Text        `json:"member_first_name"`
	MemberLastName       pgtype.Text        `json:"member_last_name"`
	MemberEmail          pgtype.Text        `json:"member_email"`
	MemberProfileImageID pgtype.UUID        `json:"member_profile_image_id"`
	MemberGradeID        pgtype.UUID        `json:"member_grade_id"`
	MemberGroupID        pgtype.UUID        `json:"member_group_id"`
}

func (q *Queries) FindChatRoomOnPrivateWithMember(ctx context.Context, arg FindChatRoomOnPrivateWithMemberParams) (FindChatRoomOnPrivateWithMemberRow, error) {
	row := q.db.QueryRow(ctx, findChatRoomOnPrivateWithMember, arg.OwnerID, arg.MemberID)
	var i FindChatRoomOnPrivateWithMemberRow
	err := row.Scan(
		&i.MChatRoomsPkey,
		&i.ChatRoomID,
		&i.Name,
		&i.IsPrivate,
		&i.CoverImageID,
		&i.OwnerID,
		&i.FromOrganization,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MemberAddedAt,
		&i.MemberID,
		&i.MemberName,
		&i.MemberFirstName,
		&i.MemberLastName,
		&i.MemberEmail,
		&i.MemberProfileImageID,
		&i.MemberGradeID,
		&i.MemberGroupID,
	)
	return i, err
}

const getChatRooms = `-- name: GetChatRooms :many
SELECT m_chat_rooms_pkey, chat_room_id, name, is_private, cover_image_id, owner_id, from_organization, created_at, updated_at FROM m_chat_rooms
WHERE
	CASE WHEN $1::boolean = true THEN owner_id = ANY($2::uuid[]) ELSE TRUE END
AND
	CASE WHEN $3::boolean = true THEN is_private = $4 ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN from_organization = $6 ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN (SELECT chat_room_id FROM m_organizations WHERE organization_id = ANY($8::uuid[])) = chat_room_id ELSE TRUE END
ORDER BY
	m_chat_rooms_pkey ASC
`

type GetChatRoomsParams struct {
	WhereInOwner            bool        `json:"where_in_owner"`
	InOwner                 []uuid.UUID `json:"in_owner"`
	WhereIsPrivate          bool        `json:"where_is_private"`
	IsPrivate               bool        `json:"is_private"`
	WhereIsFromOrganization bool        `json:"where_is_from_organization"`
	IsFromOrganization      bool        `json:"is_from_organization"`
	WhereFromOrganizations  bool        `json:"where_from_organizations"`
	FromOrganizations       []uuid.UUID `json:"from_organizations"`
}

func (q *Queries) GetChatRooms(ctx context.Context, arg GetChatRoomsParams) ([]ChatRoom, error) {
	rows, err := q.db.Query(ctx, getChatRooms,
		arg.WhereInOwner,
		arg.InOwner,
		arg.WhereIsPrivate,
		arg.IsPrivate,
		arg.WhereIsFromOrganization,
		arg.IsFromOrganization,
		arg.WhereFromOrganizations,
		arg.FromOrganizations,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ChatRoom{}
	for rows.Next() {
		var i ChatRoom
		if err := rows.Scan(
			&i.MChatRoomsPkey,
			&i.ChatRoomID,
			&i.Name,
			&i.IsPrivate,
			&i.CoverImageID,
			&i.OwnerID,
			&i.FromOrganization,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChatRoomsUseKeysetPaginate = `-- name: GetChatRoomsUseKeysetPaginate :many
SELECT m_chat_rooms_pkey, chat_room_id, name, is_private, cover_image_id, owner_id, from_organization, created_at, updated_at FROM m_chat_rooms
WHERE
	CASE WHEN $2::boolean = true THEN owner_id = ANY($3::uuid[]) ELSE TRUE END
AND
	CASE WHEN $4::boolean = true THEN is_private = $5 ELSE TRUE END
AND
	CASE WHEN $6::boolean = true THEN from_organization = $7 ELSE TRUE END
AND
	CASE WHEN $8::boolean = true THEN (SELECT chat_room_id FROM m_organizations WHERE organization_id = ANY($9::uuid[])) = chat_room_id ELSE TRUE END
AND
	CASE $10::text
		WHEN 'next' THEN
			m_chat_rooms_pkey > $11::int
		WHEN 'prev' THEN
			m_chat_rooms_pkey < $11::int
	END
ORDER BY
	CASE WHEN $10::text = 'next' THEN m_chat_rooms_pkey END ASC,
	CASE WHEN $10::text = 'prev' THEN m_chat_rooms_pkey END DESC
LIMIT $1
`

type GetChatRoomsUseKeysetPaginateParams struct {
	Limit                   int32       `json:"limit"`
	WhereInOwner            bool        `json:"where_in_owner"`
	InOwner                 []uuid.UUID `json:"in_owner"`
	WhereIsPrivate          bool        `json:"where_is_private"`
	IsPrivate               bool        `json:"is_private"`
	WhereIsFromOrganization bool        `json:"where_is_from_organization"`
	IsFromOrganization      bool        `json:"is_from_organization"`
	WhereFromOrganizations  bool        `json:"where_from_organizations"`
	FromOrganizations       []uuid.UUID `json:"from_organizations"`
	CursorDirection         string      `json:"cursor_direction"`
	Cursor                  int32       `json:"cursor"`
}

func (q *Queries) GetChatRoomsUseKeysetPaginate(ctx context.Context, arg GetChatRoomsUseKeysetPaginateParams) ([]ChatRoom, error) {
	rows, err := q.db.Query(ctx, getChatRoomsUseKeysetPaginate,
		arg.Limit,
		arg.WhereInOwner,
		arg.InOwner,
		arg.WhereIsPrivate,
		arg.IsPrivate,
		arg.WhereIsFromOrganization,
		arg.IsFromOrganization,
		arg.WhereFromOrganizations,
		arg.FromOrganizations,
		arg.CursorDirection,
		arg.Cursor,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ChatRoom{}
	for rows.Next() {
		var i ChatRoom
		if err := rows.Scan(
			&i.MChatRoomsPkey,
			&i.ChatRoomID,
			&i.Name,
			&i.IsPrivate,
			&i.CoverImageID,
			&i.OwnerID,
			&i.FromOrganization,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChatRoomsUseNumberedPaginate = `-- name: GetChatRoomsUseNumberedPaginate :many
SELECT m_chat_rooms_pkey, chat_room_id, name, is_private, cover_image_id, owner_id, from_organization, created_at, updated_at FROM m_chat_rooms
WHERE
	CASE WHEN $3::boolean = true THEN owner_id = ANY($4::uuid[]) ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN is_private = $6 ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN from_organization = $8 ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN (SELECT chat_room_id FROM m_organizations WHERE organization_id = ANY($10::uuid[])) = chat_room_id ELSE TRUE END
ORDER BY
	m_chat_rooms_pkey ASC
LIMIT $1 OFFSET $2
`

type GetChatRoomsUseNumberedPaginateParams struct {
	Limit                   int32       `json:"limit"`
	Offset                  int32       `json:"offset"`
	WhereInOwner            bool        `json:"where_in_owner"`
	InOwner                 []uuid.UUID `json:"in_owner"`
	WhereIsPrivate          bool        `json:"where_is_private"`
	IsPrivate               bool        `json:"is_private"`
	WhereIsFromOrganization bool        `json:"where_is_from_organization"`
	IsFromOrganization      bool        `json:"is_from_organization"`
	WhereFromOrganizations  bool        `json:"where_from_organizations"`
	FromOrganizations       []uuid.UUID `json:"from_organizations"`
}

func (q *Queries) GetChatRoomsUseNumberedPaginate(ctx context.Context, arg GetChatRoomsUseNumberedPaginateParams) ([]ChatRoom, error) {
	rows, err := q.db.Query(ctx, getChatRoomsUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.WhereInOwner,
		arg.InOwner,
		arg.WhereIsPrivate,
		arg.IsPrivate,
		arg.WhereIsFromOrganization,
		arg.IsFromOrganization,
		arg.WhereFromOrganizations,
		arg.FromOrganizations,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ChatRoom{}
	for rows.Next() {
		var i ChatRoom
		if err := rows.Scan(
			&i.MChatRoomsPkey,
			&i.ChatRoomID,
			&i.Name,
			&i.IsPrivate,
			&i.CoverImageID,
			&i.OwnerID,
			&i.FromOrganization,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChatRoomsWithCoverImage = `-- name: GetChatRoomsWithCoverImage :many
SELECT m_chat_rooms.m_chat_rooms_pkey, m_chat_rooms.chat_room_id, m_chat_rooms.name, m_chat_rooms.is_private, m_chat_rooms.cover_image_id, m_chat_rooms.owner_id, m_chat_rooms.from_organization, m_chat_rooms.created_at, m_chat_rooms.updated_at, t_images.height cover_image_height, t_images.width cover_image_width, t_images.attachable_item_id cover_image_attachable_item_id,
t_attachable_items.owner_id cover_image_owner_id, t_attachable_items.from_outer cover_image_from_outer, t_attachable_items.alias cover_image_alias,
t_attachable_items.url cover_image_url, t_attachable_items.size cover_image_size, t_attachable_items.mime_type_id cover_image_mime_type_id
FROM m_chat_rooms
LEFT JOIN t_images ON m_chat_rooms.cover_image_id = t_images.image_id
LEFT JOIN t_attachable_items ON t_images.attachable_item_id = t_attachable_items.attachable_item_id
WHERE
	CASE WHEN $1::boolean = true THEN owner_id = ANY($2::uuid[]) ELSE TRUE END
AND
	CASE WHEN $3::boolean = true THEN is_private = $4 ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN from_organization = $6 ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN (SELECT chat_room_id FROM m_organizations WHERE organization_id = ANY($8::uuid[])) = chat_room_id ELSE TRUE END
ORDER BY
	m_chat_rooms_pkey ASC
`

type GetChatRoomsWithCoverImageParams struct {
	WhereInOwner            bool        `json:"where_in_owner"`
	InOwner                 []uuid.UUID `json:"in_owner"`
	WhereIsPrivate          bool        `json:"where_is_private"`
	IsPrivate               bool        `json:"is_private"`
	WhereIsFromOrganization bool        `json:"where_is_from_organization"`
	IsFromOrganization      bool        `json:"is_from_organization"`
	WhereFromOrganizations  bool        `json:"where_from_organizations"`
	FromOrganizations       []uuid.UUID `json:"from_organizations"`
}

type GetChatRoomsWithCoverImageRow struct {
	MChatRoomsPkey             pgtype.Int8   `json:"m_chat_rooms_pkey"`
	ChatRoomID                 uuid.UUID     `json:"chat_room_id"`
	Name                       string        `json:"name"`
	IsPrivate                  bool          `json:"is_private"`
	CoverImageID               pgtype.UUID   `json:"cover_image_id"`
	OwnerID                    pgtype.UUID   `json:"owner_id"`
	FromOrganization           bool          `json:"from_organization"`
	CreatedAt                  time.Time     `json:"created_at"`
	UpdatedAt                  time.Time     `json:"updated_at"`
	CoverImageHeight           pgtype.Float8 `json:"cover_image_height"`
	CoverImageWidth            pgtype.Float8 `json:"cover_image_width"`
	CoverImageAttachableItemID pgtype.UUID   `json:"cover_image_attachable_item_id"`
	CoverImageOwnerID          pgtype.UUID   `json:"cover_image_owner_id"`
	CoverImageFromOuter        pgtype.Bool   `json:"cover_image_from_outer"`
	CoverImageAlias            pgtype.Text   `json:"cover_image_alias"`
	CoverImageUrl              pgtype.Text   `json:"cover_image_url"`
	CoverImageSize             pgtype.Float8 `json:"cover_image_size"`
	CoverImageMimeTypeID       pgtype.UUID   `json:"cover_image_mime_type_id"`
}

func (q *Queries) GetChatRoomsWithCoverImage(ctx context.Context, arg GetChatRoomsWithCoverImageParams) ([]GetChatRoomsWithCoverImageRow, error) {
	rows, err := q.db.Query(ctx, getChatRoomsWithCoverImage,
		arg.WhereInOwner,
		arg.InOwner,
		arg.WhereIsPrivate,
		arg.IsPrivate,
		arg.WhereIsFromOrganization,
		arg.IsFromOrganization,
		arg.WhereFromOrganizations,
		arg.FromOrganizations,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetChatRoomsWithCoverImageRow{}
	for rows.Next() {
		var i GetChatRoomsWithCoverImageRow
		if err := rows.Scan(
			&i.MChatRoomsPkey,
			&i.ChatRoomID,
			&i.Name,
			&i.IsPrivate,
			&i.CoverImageID,
			&i.OwnerID,
			&i.FromOrganization,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CoverImageHeight,
			&i.CoverImageWidth,
			&i.CoverImageAttachableItemID,
			&i.CoverImageOwnerID,
			&i.CoverImageFromOuter,
			&i.CoverImageAlias,
			&i.CoverImageUrl,
			&i.CoverImageSize,
			&i.CoverImageMimeTypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChatRoomsWithCoverImageUseKeysetPaginate = `-- name: GetChatRoomsWithCoverImageUseKeysetPaginate :many
SELECT m_chat_rooms.m_chat_rooms_pkey, m_chat_rooms.chat_room_id, m_chat_rooms.name, m_chat_rooms.is_private, m_chat_rooms.cover_image_id, m_chat_rooms.owner_id, m_chat_rooms.from_organization, m_chat_rooms.created_at, m_chat_rooms.updated_at, t_images.height cover_image_height, t_images.width cover_image_width, t_images.attachable_item_id cover_image_attachable_item_id,
t_attachable_items.owner_id cover_image_owner_id, t_attachable_items.from_outer cover_image_from_outer, t_attachable_items.alias cover_image_alias,
t_attachable_items.url cover_image_url, t_attachable_items.size cover_image_size, t_attachable_items.mime_type_id cover_image_mime_type_id
FROM m_chat_rooms
LEFT JOIN t_images ON m_chat_rooms.cover_image_id = t_images.image_id
LEFT JOIN t_attachable_items ON t_images.attachable_item_id = t_attachable_items.attachable_item_id
WHERE
	CASE WHEN $2::boolean = true THEN owner_id = ANY($3::uuid[]) ELSE TRUE END
AND
	CASE WHEN $4::boolean = true THEN is_private = $5 ELSE TRUE END
AND
	CASE WHEN $6::boolean = true THEN from_organization = $7 ELSE TRUE END
AND
	CASE WHEN $8::boolean = true THEN (SELECT chat_room_id FROM m_organizations WHERE organization_id = ANY($9::uuid[])) = chat_room_id ELSE TRUE END
AND
	CASE $10::text
		WHEN 'next' THEN
			m_chat_rooms_pkey > $11::int
		WHEN 'prev' THEN
			m_chat_rooms_pkey < $11::int
	END
ORDER BY
	CASE WHEN $10::text = 'next' THEN m_chat_rooms_pkey END ASC,
	CASE WHEN $10::text = 'prev' THEN m_chat_rooms_pkey END DESC
LIMIT $1
`

type GetChatRoomsWithCoverImageUseKeysetPaginateParams struct {
	Limit                   int32       `json:"limit"`
	WhereInOwner            bool        `json:"where_in_owner"`
	InOwner                 []uuid.UUID `json:"in_owner"`
	WhereIsPrivate          bool        `json:"where_is_private"`
	IsPrivate               bool        `json:"is_private"`
	WhereIsFromOrganization bool        `json:"where_is_from_organization"`
	IsFromOrganization      bool        `json:"is_from_organization"`
	WhereFromOrganizations  bool        `json:"where_from_organizations"`
	FromOrganizations       []uuid.UUID `json:"from_organizations"`
	CursorDirection         string      `json:"cursor_direction"`
	Cursor                  int32       `json:"cursor"`
}

type GetChatRoomsWithCoverImageUseKeysetPaginateRow struct {
	MChatRoomsPkey             pgtype.Int8   `json:"m_chat_rooms_pkey"`
	ChatRoomID                 uuid.UUID     `json:"chat_room_id"`
	Name                       string        `json:"name"`
	IsPrivate                  bool          `json:"is_private"`
	CoverImageID               pgtype.UUID   `json:"cover_image_id"`
	OwnerID                    pgtype.UUID   `json:"owner_id"`
	FromOrganization           bool          `json:"from_organization"`
	CreatedAt                  time.Time     `json:"created_at"`
	UpdatedAt                  time.Time     `json:"updated_at"`
	CoverImageHeight           pgtype.Float8 `json:"cover_image_height"`
	CoverImageWidth            pgtype.Float8 `json:"cover_image_width"`
	CoverImageAttachableItemID pgtype.UUID   `json:"cover_image_attachable_item_id"`
	CoverImageOwnerID          pgtype.UUID   `json:"cover_image_owner_id"`
	CoverImageFromOuter        pgtype.Bool   `json:"cover_image_from_outer"`
	CoverImageAlias            pgtype.Text   `json:"cover_image_alias"`
	CoverImageUrl              pgtype.Text   `json:"cover_image_url"`
	CoverImageSize             pgtype.Float8 `json:"cover_image_size"`
	CoverImageMimeTypeID       pgtype.UUID   `json:"cover_image_mime_type_id"`
}

func (q *Queries) GetChatRoomsWithCoverImageUseKeysetPaginate(ctx context.Context, arg GetChatRoomsWithCoverImageUseKeysetPaginateParams) ([]GetChatRoomsWithCoverImageUseKeysetPaginateRow, error) {
	rows, err := q.db.Query(ctx, getChatRoomsWithCoverImageUseKeysetPaginate,
		arg.Limit,
		arg.WhereInOwner,
		arg.InOwner,
		arg.WhereIsPrivate,
		arg.IsPrivate,
		arg.WhereIsFromOrganization,
		arg.IsFromOrganization,
		arg.WhereFromOrganizations,
		arg.FromOrganizations,
		arg.CursorDirection,
		arg.Cursor,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetChatRoomsWithCoverImageUseKeysetPaginateRow{}
	for rows.Next() {
		var i GetChatRoomsWithCoverImageUseKeysetPaginateRow
		if err := rows.Scan(
			&i.MChatRoomsPkey,
			&i.ChatRoomID,
			&i.Name,
			&i.IsPrivate,
			&i.CoverImageID,
			&i.OwnerID,
			&i.FromOrganization,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CoverImageHeight,
			&i.CoverImageWidth,
			&i.CoverImageAttachableItemID,
			&i.CoverImageOwnerID,
			&i.CoverImageFromOuter,
			&i.CoverImageAlias,
			&i.CoverImageUrl,
			&i.CoverImageSize,
			&i.CoverImageMimeTypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChatRoomsWithCoverImageUseNumberedPaginate = `-- name: GetChatRoomsWithCoverImageUseNumberedPaginate :many
SELECT m_chat_rooms.m_chat_rooms_pkey, m_chat_rooms.chat_room_id, m_chat_rooms.name, m_chat_rooms.is_private, m_chat_rooms.cover_image_id, m_chat_rooms.owner_id, m_chat_rooms.from_organization, m_chat_rooms.created_at, m_chat_rooms.updated_at, t_images.height cover_image_height, t_images.width cover_image_width, t_images.attachable_item_id cover_image_attachable_item_id,
t_attachable_items.owner_id cover_image_owner_id, t_attachable_items.from_outer cover_image_from_outer, t_attachable_items.alias cover_image_alias,
t_attachable_items.url cover_image_url, t_attachable_items.size cover_image_size, t_attachable_items.mime_type_id cover_image_mime_type_id
FROM m_chat_rooms
LEFT JOIN t_images ON m_chat_rooms.cover_image_id = t_images.image_id
LEFT JOIN t_attachable_items ON t_images.attachable_item_id = t_attachable_items.attachable_item_id
WHERE
	CASE WHEN $3::boolean = true THEN owner_id = ANY($4::uuid[]) ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN is_private = $6 ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN from_organization = $8 ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN (SELECT chat_room_id FROM m_organizations WHERE organization_id = ANY($10::uuid[])) = chat_room_id ELSE TRUE END
ORDER BY
	m_chat_rooms_pkey ASC
LIMIT $1 OFFSET $2
`

type GetChatRoomsWithCoverImageUseNumberedPaginateParams struct {
	Limit                   int32       `json:"limit"`
	Offset                  int32       `json:"offset"`
	WhereInOwner            bool        `json:"where_in_owner"`
	InOwner                 []uuid.UUID `json:"in_owner"`
	WhereIsPrivate          bool        `json:"where_is_private"`
	IsPrivate               bool        `json:"is_private"`
	WhereIsFromOrganization bool        `json:"where_is_from_organization"`
	IsFromOrganization      bool        `json:"is_from_organization"`
	WhereFromOrganizations  bool        `json:"where_from_organizations"`
	FromOrganizations       []uuid.UUID `json:"from_organizations"`
}

type GetChatRoomsWithCoverImageUseNumberedPaginateRow struct {
	MChatRoomsPkey             pgtype.Int8   `json:"m_chat_rooms_pkey"`
	ChatRoomID                 uuid.UUID     `json:"chat_room_id"`
	Name                       string        `json:"name"`
	IsPrivate                  bool          `json:"is_private"`
	CoverImageID               pgtype.UUID   `json:"cover_image_id"`
	OwnerID                    pgtype.UUID   `json:"owner_id"`
	FromOrganization           bool          `json:"from_organization"`
	CreatedAt                  time.Time     `json:"created_at"`
	UpdatedAt                  time.Time     `json:"updated_at"`
	CoverImageHeight           pgtype.Float8 `json:"cover_image_height"`
	CoverImageWidth            pgtype.Float8 `json:"cover_image_width"`
	CoverImageAttachableItemID pgtype.UUID   `json:"cover_image_attachable_item_id"`
	CoverImageOwnerID          pgtype.UUID   `json:"cover_image_owner_id"`
	CoverImageFromOuter        pgtype.Bool   `json:"cover_image_from_outer"`
	CoverImageAlias            pgtype.Text   `json:"cover_image_alias"`
	CoverImageUrl              pgtype.Text   `json:"cover_image_url"`
	CoverImageSize             pgtype.Float8 `json:"cover_image_size"`
	CoverImageMimeTypeID       pgtype.UUID   `json:"cover_image_mime_type_id"`
}

func (q *Queries) GetChatRoomsWithCoverImageUseNumberedPaginate(ctx context.Context, arg GetChatRoomsWithCoverImageUseNumberedPaginateParams) ([]GetChatRoomsWithCoverImageUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getChatRoomsWithCoverImageUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.WhereInOwner,
		arg.InOwner,
		arg.WhereIsPrivate,
		arg.IsPrivate,
		arg.WhereIsFromOrganization,
		arg.IsFromOrganization,
		arg.WhereFromOrganizations,
		arg.FromOrganizations,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetChatRoomsWithCoverImageUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetChatRoomsWithCoverImageUseNumberedPaginateRow
		if err := rows.Scan(
			&i.MChatRoomsPkey,
			&i.ChatRoomID,
			&i.Name,
			&i.IsPrivate,
			&i.CoverImageID,
			&i.OwnerID,
			&i.FromOrganization,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CoverImageHeight,
			&i.CoverImageWidth,
			&i.CoverImageAttachableItemID,
			&i.CoverImageOwnerID,
			&i.CoverImageFromOuter,
			&i.CoverImageAlias,
			&i.CoverImageUrl,
			&i.CoverImageSize,
			&i.CoverImageMimeTypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChatRoomsWithOwner = `-- name: GetChatRoomsWithOwner :many
SELECT m_chat_rooms.m_chat_rooms_pkey, m_chat_rooms.chat_room_id, m_chat_rooms.name, m_chat_rooms.is_private, m_chat_rooms.cover_image_id, m_chat_rooms.owner_id, m_chat_rooms.from_organization, m_chat_rooms.created_at, m_chat_rooms.updated_at, m_members.name owner_name, m_members.first_name owner_first_name, m_members.last_name owner_last_name, m_members.email owner_email,
m_members.profile_image_id owner_profile_image_id, m_members.grade_id owner_grade_id, m_members.group_id owner_group_id
FROM m_chat_rooms
LEFT JOIN m_members ON m_chat_rooms.owner_id = m_members.member_id
WHERE
	CASE WHEN $1::boolean THEN owner_id = ANY($2::uuid[]) ELSE TRUE END
AND
	CASE WHEN $3::boolean THEN is_private = $4 ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN from_organization = $6 ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN (SELECT chat_room_id FROM m_organizations WHERE organization_id = ANY($8::uuid[])) = chat_room_id ELSE TRUE END
ORDER BY
	m_chat_rooms_pkey ASC
`

type GetChatRoomsWithOwnerParams struct {
	WhereInOwner            bool        `json:"where_in_owner"`
	InOwner                 []uuid.UUID `json:"in_owner"`
	WhereIsPrivate          bool        `json:"where_is_private"`
	IsPrivate               bool        `json:"is_private"`
	WhereIsFromOrganization bool        `json:"where_is_from_organization"`
	IsFromOrganization      bool        `json:"is_from_organization"`
	WhereFromOrganizations  bool        `json:"where_from_organizations"`
	FromOrganizations       []uuid.UUID `json:"from_organizations"`
}

type GetChatRoomsWithOwnerRow struct {
	MChatRoomsPkey      pgtype.Int8 `json:"m_chat_rooms_pkey"`
	ChatRoomID          uuid.UUID   `json:"chat_room_id"`
	Name                string      `json:"name"`
	IsPrivate           bool        `json:"is_private"`
	CoverImageID        pgtype.UUID `json:"cover_image_id"`
	OwnerID             pgtype.UUID `json:"owner_id"`
	FromOrganization    bool        `json:"from_organization"`
	CreatedAt           time.Time   `json:"created_at"`
	UpdatedAt           time.Time   `json:"updated_at"`
	OwnerName           pgtype.Text `json:"owner_name"`
	OwnerFirstName      pgtype.Text `json:"owner_first_name"`
	OwnerLastName       pgtype.Text `json:"owner_last_name"`
	OwnerEmail          pgtype.Text `json:"owner_email"`
	OwnerProfileImageID pgtype.UUID `json:"owner_profile_image_id"`
	OwnerGradeID        pgtype.UUID `json:"owner_grade_id"`
	OwnerGroupID        pgtype.UUID `json:"owner_group_id"`
}

func (q *Queries) GetChatRoomsWithOwner(ctx context.Context, arg GetChatRoomsWithOwnerParams) ([]GetChatRoomsWithOwnerRow, error) {
	rows, err := q.db.Query(ctx, getChatRoomsWithOwner,
		arg.WhereInOwner,
		arg.InOwner,
		arg.WhereIsPrivate,
		arg.IsPrivate,
		arg.WhereIsFromOrganization,
		arg.IsFromOrganization,
		arg.WhereFromOrganizations,
		arg.FromOrganizations,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetChatRoomsWithOwnerRow{}
	for rows.Next() {
		var i GetChatRoomsWithOwnerRow
		if err := rows.Scan(
			&i.MChatRoomsPkey,
			&i.ChatRoomID,
			&i.Name,
			&i.IsPrivate,
			&i.CoverImageID,
			&i.OwnerID,
			&i.FromOrganization,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.OwnerName,
			&i.OwnerFirstName,
			&i.OwnerLastName,
			&i.OwnerEmail,
			&i.OwnerProfileImageID,
			&i.OwnerGradeID,
			&i.OwnerGroupID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChatRoomsWithOwnerUseKeysetPaginate = `-- name: GetChatRoomsWithOwnerUseKeysetPaginate :many
SELECT m_chat_rooms.m_chat_rooms_pkey, m_chat_rooms.chat_room_id, m_chat_rooms.name, m_chat_rooms.is_private, m_chat_rooms.cover_image_id, m_chat_rooms.owner_id, m_chat_rooms.from_organization, m_chat_rooms.created_at, m_chat_rooms.updated_at, m_members.name owner_name, m_members.first_name owner_first_name, m_members.last_name owner_last_name, m_members.email owner_email,
m_members.profile_image_id owner_profile_image_id, m_members.grade_id owner_grade_id, m_members.group_id owner_group_id
FROM m_chat_rooms
LEFT JOIN m_members ON m_chat_rooms.owner_id = m_members.member_id
WHERE
	CASE WHEN $2::boolean = true THEN owner_id = ANY($3::uuid[]) ELSE TRUE END
AND
	CASE WHEN $4::boolean = true THEN is_private = $5 ELSE TRUE END
AND
	CASE WHEN $6::boolean = true THEN from_organization = $7 ELSE TRUE END
AND
	CASE WHEN $8::boolean = true THEN (SELECT chat_room_id FROM m_organizations WHERE organization_id = ANY($9::uuid[])) = chat_room_id ELSE TRUE END
AND
	CASE $10::text
		WHEN 'next' THEN
			m_chat_rooms_pkey > $11::int
		WHEN 'prev' THEN
			m_chat_rooms_pkey < $11::int
	END
ORDER BY
	CASE WHEN $10::text = 'next' THEN m_chat_rooms_pkey END ASC,
	CASE WHEN $10::text = 'prev' THEN m_chat_rooms_pkey END DESC
LIMIT $1
`

type GetChatRoomsWithOwnerUseKeysetPaginateParams struct {
	Limit                   int32       `json:"limit"`
	WhereInOwner            bool        `json:"where_in_owner"`
	InOwner                 []uuid.UUID `json:"in_owner"`
	WhereIsPrivate          bool        `json:"where_is_private"`
	IsPrivate               bool        `json:"is_private"`
	WhereIsFromOrganization bool        `json:"where_is_from_organization"`
	IsFromOrganization      bool        `json:"is_from_organization"`
	WhereFromOrganizations  bool        `json:"where_from_organizations"`
	FromOrganizations       []uuid.UUID `json:"from_organizations"`
	CursorDirection         string      `json:"cursor_direction"`
	Cursor                  int32       `json:"cursor"`
}

type GetChatRoomsWithOwnerUseKeysetPaginateRow struct {
	MChatRoomsPkey      pgtype.Int8 `json:"m_chat_rooms_pkey"`
	ChatRoomID          uuid.UUID   `json:"chat_room_id"`
	Name                string      `json:"name"`
	IsPrivate           bool        `json:"is_private"`
	CoverImageID        pgtype.UUID `json:"cover_image_id"`
	OwnerID             pgtype.UUID `json:"owner_id"`
	FromOrganization    bool        `json:"from_organization"`
	CreatedAt           time.Time   `json:"created_at"`
	UpdatedAt           time.Time   `json:"updated_at"`
	OwnerName           pgtype.Text `json:"owner_name"`
	OwnerFirstName      pgtype.Text `json:"owner_first_name"`
	OwnerLastName       pgtype.Text `json:"owner_last_name"`
	OwnerEmail          pgtype.Text `json:"owner_email"`
	OwnerProfileImageID pgtype.UUID `json:"owner_profile_image_id"`
	OwnerGradeID        pgtype.UUID `json:"owner_grade_id"`
	OwnerGroupID        pgtype.UUID `json:"owner_group_id"`
}

func (q *Queries) GetChatRoomsWithOwnerUseKeysetPaginate(ctx context.Context, arg GetChatRoomsWithOwnerUseKeysetPaginateParams) ([]GetChatRoomsWithOwnerUseKeysetPaginateRow, error) {
	rows, err := q.db.Query(ctx, getChatRoomsWithOwnerUseKeysetPaginate,
		arg.Limit,
		arg.WhereInOwner,
		arg.InOwner,
		arg.WhereIsPrivate,
		arg.IsPrivate,
		arg.WhereIsFromOrganization,
		arg.IsFromOrganization,
		arg.WhereFromOrganizations,
		arg.FromOrganizations,
		arg.CursorDirection,
		arg.Cursor,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetChatRoomsWithOwnerUseKeysetPaginateRow{}
	for rows.Next() {
		var i GetChatRoomsWithOwnerUseKeysetPaginateRow
		if err := rows.Scan(
			&i.MChatRoomsPkey,
			&i.ChatRoomID,
			&i.Name,
			&i.IsPrivate,
			&i.CoverImageID,
			&i.OwnerID,
			&i.FromOrganization,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.OwnerName,
			&i.OwnerFirstName,
			&i.OwnerLastName,
			&i.OwnerEmail,
			&i.OwnerProfileImageID,
			&i.OwnerGradeID,
			&i.OwnerGroupID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChatRoomsWithOwnerUseNumberedPaginate = `-- name: GetChatRoomsWithOwnerUseNumberedPaginate :many
SELECT m_chat_rooms.m_chat_rooms_pkey, m_chat_rooms.chat_room_id, m_chat_rooms.name, m_chat_rooms.is_private, m_chat_rooms.cover_image_id, m_chat_rooms.owner_id, m_chat_rooms.from_organization, m_chat_rooms.created_at, m_chat_rooms.updated_at, m_members.name owner_name, m_members.first_name owner_first_name, m_members.last_name owner_last_name, m_members.email owner_email,
m_members.profile_image_id owner_profile_image_id, m_members.grade_id owner_grade_id, m_members.group_id owner_group_id
FROM m_chat_rooms
LEFT JOIN m_members ON m_chat_rooms.owner_id = m_members.member_id
WHERE
	CASE WHEN $3::boolean THEN owner_id = ANY($4::uuid[]) ELSE TRUE END
AND
	CASE WHEN $5::boolean THEN is_private = $6 ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN from_organization = $8 ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN (SELECT chat_room_id FROM m_organizations WHERE organization_id = ANY($10::uuid[])) = chat_room_id ELSE TRUE END
ORDER BY
	m_chat_rooms_pkey ASC
LIMIT $1 OFFSET $2
`

type GetChatRoomsWithOwnerUseNumberedPaginateParams struct {
	Limit                   int32       `json:"limit"`
	Offset                  int32       `json:"offset"`
	WhereInOwner            bool        `json:"where_in_owner"`
	InOwner                 []uuid.UUID `json:"in_owner"`
	WhereIsPrivate          bool        `json:"where_is_private"`
	IsPrivate               bool        `json:"is_private"`
	WhereIsFromOrganization bool        `json:"where_is_from_organization"`
	IsFromOrganization      bool        `json:"is_from_organization"`
	WhereFromOrganizations  bool        `json:"where_from_organizations"`
	FromOrganizations       []uuid.UUID `json:"from_organizations"`
}

type GetChatRoomsWithOwnerUseNumberedPaginateRow struct {
	MChatRoomsPkey      pgtype.Int8 `json:"m_chat_rooms_pkey"`
	ChatRoomID          uuid.UUID   `json:"chat_room_id"`
	Name                string      `json:"name"`
	IsPrivate           bool        `json:"is_private"`
	CoverImageID        pgtype.UUID `json:"cover_image_id"`
	OwnerID             pgtype.UUID `json:"owner_id"`
	FromOrganization    bool        `json:"from_organization"`
	CreatedAt           time.Time   `json:"created_at"`
	UpdatedAt           time.Time   `json:"updated_at"`
	OwnerName           pgtype.Text `json:"owner_name"`
	OwnerFirstName      pgtype.Text `json:"owner_first_name"`
	OwnerLastName       pgtype.Text `json:"owner_last_name"`
	OwnerEmail          pgtype.Text `json:"owner_email"`
	OwnerProfileImageID pgtype.UUID `json:"owner_profile_image_id"`
	OwnerGradeID        pgtype.UUID `json:"owner_grade_id"`
	OwnerGroupID        pgtype.UUID `json:"owner_group_id"`
}

func (q *Queries) GetChatRoomsWithOwnerUseNumberedPaginate(ctx context.Context, arg GetChatRoomsWithOwnerUseNumberedPaginateParams) ([]GetChatRoomsWithOwnerUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getChatRoomsWithOwnerUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.WhereInOwner,
		arg.InOwner,
		arg.WhereIsPrivate,
		arg.IsPrivate,
		arg.WhereIsFromOrganization,
		arg.IsFromOrganization,
		arg.WhereFromOrganizations,
		arg.FromOrganizations,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetChatRoomsWithOwnerUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetChatRoomsWithOwnerUseNumberedPaginateRow
		if err := rows.Scan(
			&i.MChatRoomsPkey,
			&i.ChatRoomID,
			&i.Name,
			&i.IsPrivate,
			&i.CoverImageID,
			&i.OwnerID,
			&i.FromOrganization,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.OwnerName,
			&i.OwnerFirstName,
			&i.OwnerLastName,
			&i.OwnerEmail,
			&i.OwnerProfileImageID,
			&i.OwnerGradeID,
			&i.OwnerGroupID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralChatRooms = `-- name: GetPluralChatRooms :many
SELECT m_chat_rooms_pkey, chat_room_id, name, is_private, cover_image_id, owner_id, from_organization, created_at, updated_at FROM m_chat_rooms
WHERE chat_room_id = ANY($1::uuid[])
ORDER BY
	m_chat_rooms_pkey ASC
`

func (q *Queries) GetPluralChatRooms(ctx context.Context, chatRoomIds []uuid.UUID) ([]ChatRoom, error) {
	rows, err := q.db.Query(ctx, getPluralChatRooms, chatRoomIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ChatRoom{}
	for rows.Next() {
		var i ChatRoom
		if err := rows.Scan(
			&i.MChatRoomsPkey,
			&i.ChatRoomID,
			&i.Name,
			&i.IsPrivate,
			&i.CoverImageID,
			&i.OwnerID,
			&i.FromOrganization,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralChatRoomsUseNumberedPaginate = `-- name: GetPluralChatRoomsUseNumberedPaginate :many
SELECT m_chat_rooms_pkey, chat_room_id, name, is_private, cover_image_id, owner_id, from_organization, created_at, updated_at FROM m_chat_rooms
WHERE chat_room_id = ANY($3::uuid[])
ORDER BY
	m_chat_rooms_pkey ASC
LIMIT $1 OFFSET $2
`

type GetPluralChatRoomsUseNumberedPaginateParams struct {
	Limit       int32       `json:"limit"`
	Offset      int32       `json:"offset"`
	ChatRoomIds []uuid.UUID `json:"chat_room_ids"`
}

func (q *Queries) GetPluralChatRoomsUseNumberedPaginate(ctx context.Context, arg GetPluralChatRoomsUseNumberedPaginateParams) ([]ChatRoom, error) {
	rows, err := q.db.Query(ctx, getPluralChatRoomsUseNumberedPaginate, arg.Limit, arg.Offset, arg.ChatRoomIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ChatRoom{}
	for rows.Next() {
		var i ChatRoom
		if err := rows.Scan(
			&i.MChatRoomsPkey,
			&i.ChatRoomID,
			&i.Name,
			&i.IsPrivate,
			&i.CoverImageID,
			&i.OwnerID,
			&i.FromOrganization,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralChatRoomsWithCoverImage = `-- name: GetPluralChatRoomsWithCoverImage :many
SELECT m_chat_rooms.m_chat_rooms_pkey, m_chat_rooms.chat_room_id, m_chat_rooms.name, m_chat_rooms.is_private, m_chat_rooms.cover_image_id, m_chat_rooms.owner_id, m_chat_rooms.from_organization, m_chat_rooms.created_at, m_chat_rooms.updated_at, t_images.height cover_image_height, t_images.width cover_image_width, t_images.attachable_item_id cover_image_attachable_item_id,
t_attachable_items.owner_id cover_image_owner_id, t_attachable_items.from_outer cover_image_from_outer, t_attachable_items.alias cover_image_alias,
t_attachable_items.url cover_image_url, t_attachable_items.size cover_image_size, t_attachable_items.mime_type_id cover_image_mime_type_id
FROM m_chat_rooms
LEFT JOIN t_images ON m_chat_rooms.cover_image_id = t_images.image_id
LEFT JOIN t_attachable_items ON t_images.attachable_item_id = t_attachable_items.attachable_item_id
WHERE chat_room_id = ANY($1::uuid[])
ORDER BY
	m_chat_rooms_pkey ASC
`

type GetPluralChatRoomsWithCoverImageRow struct {
	MChatRoomsPkey             pgtype.Int8   `json:"m_chat_rooms_pkey"`
	ChatRoomID                 uuid.UUID     `json:"chat_room_id"`
	Name                       string        `json:"name"`
	IsPrivate                  bool          `json:"is_private"`
	CoverImageID               pgtype.UUID   `json:"cover_image_id"`
	OwnerID                    pgtype.UUID   `json:"owner_id"`
	FromOrganization           bool          `json:"from_organization"`
	CreatedAt                  time.Time     `json:"created_at"`
	UpdatedAt                  time.Time     `json:"updated_at"`
	CoverImageHeight           pgtype.Float8 `json:"cover_image_height"`
	CoverImageWidth            pgtype.Float8 `json:"cover_image_width"`
	CoverImageAttachableItemID pgtype.UUID   `json:"cover_image_attachable_item_id"`
	CoverImageOwnerID          pgtype.UUID   `json:"cover_image_owner_id"`
	CoverImageFromOuter        pgtype.Bool   `json:"cover_image_from_outer"`
	CoverImageAlias            pgtype.Text   `json:"cover_image_alias"`
	CoverImageUrl              pgtype.Text   `json:"cover_image_url"`
	CoverImageSize             pgtype.Float8 `json:"cover_image_size"`
	CoverImageMimeTypeID       pgtype.UUID   `json:"cover_image_mime_type_id"`
}

func (q *Queries) GetPluralChatRoomsWithCoverImage(ctx context.Context, chatRoomIds []uuid.UUID) ([]GetPluralChatRoomsWithCoverImageRow, error) {
	rows, err := q.db.Query(ctx, getPluralChatRoomsWithCoverImage, chatRoomIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralChatRoomsWithCoverImageRow{}
	for rows.Next() {
		var i GetPluralChatRoomsWithCoverImageRow
		if err := rows.Scan(
			&i.MChatRoomsPkey,
			&i.ChatRoomID,
			&i.Name,
			&i.IsPrivate,
			&i.CoverImageID,
			&i.OwnerID,
			&i.FromOrganization,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CoverImageHeight,
			&i.CoverImageWidth,
			&i.CoverImageAttachableItemID,
			&i.CoverImageOwnerID,
			&i.CoverImageFromOuter,
			&i.CoverImageAlias,
			&i.CoverImageUrl,
			&i.CoverImageSize,
			&i.CoverImageMimeTypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralChatRoomsWithCoverImageUseNumberedPaginate = `-- name: GetPluralChatRoomsWithCoverImageUseNumberedPaginate :many
SELECT m_chat_rooms.m_chat_rooms_pkey, m_chat_rooms.chat_room_id, m_chat_rooms.name, m_chat_rooms.is_private, m_chat_rooms.cover_image_id, m_chat_rooms.owner_id, m_chat_rooms.from_organization, m_chat_rooms.created_at, m_chat_rooms.updated_at, t_images.height cover_image_height, t_images.width cover_image_width, t_images.attachable_item_id cover_image_attachable_item_id,
t_attachable_items.owner_id cover_image_owner_id, t_attachable_items.from_outer cover_image_from_outer, t_attachable_items.alias cover_image_alias,
t_attachable_items.url cover_image_url, t_attachable_items.size cover_image_size, t_attachable_items.mime_type_id cover_image_mime_type_id
FROM m_chat_rooms
LEFT JOIN t_images ON m_chat_rooms.cover_image_id = t_images.image_id
LEFT JOIN t_attachable_items ON t_images.attachable_item_id = t_attachable_items.attachable_item_id
WHERE chat_room_id = ANY($3::uuid[])
ORDER BY
	m_chat_rooms_pkey ASC
LIMIT $1 OFFSET $2
`

type GetPluralChatRoomsWithCoverImageUseNumberedPaginateParams struct {
	Limit       int32       `json:"limit"`
	Offset      int32       `json:"offset"`
	ChatRoomIds []uuid.UUID `json:"chat_room_ids"`
}

type GetPluralChatRoomsWithCoverImageUseNumberedPaginateRow struct {
	MChatRoomsPkey             pgtype.Int8   `json:"m_chat_rooms_pkey"`
	ChatRoomID                 uuid.UUID     `json:"chat_room_id"`
	Name                       string        `json:"name"`
	IsPrivate                  bool          `json:"is_private"`
	CoverImageID               pgtype.UUID   `json:"cover_image_id"`
	OwnerID                    pgtype.UUID   `json:"owner_id"`
	FromOrganization           bool          `json:"from_organization"`
	CreatedAt                  time.Time     `json:"created_at"`
	UpdatedAt                  time.Time     `json:"updated_at"`
	CoverImageHeight           pgtype.Float8 `json:"cover_image_height"`
	CoverImageWidth            pgtype.Float8 `json:"cover_image_width"`
	CoverImageAttachableItemID pgtype.UUID   `json:"cover_image_attachable_item_id"`
	CoverImageOwnerID          pgtype.UUID   `json:"cover_image_owner_id"`
	CoverImageFromOuter        pgtype.Bool   `json:"cover_image_from_outer"`
	CoverImageAlias            pgtype.Text   `json:"cover_image_alias"`
	CoverImageUrl              pgtype.Text   `json:"cover_image_url"`
	CoverImageSize             pgtype.Float8 `json:"cover_image_size"`
	CoverImageMimeTypeID       pgtype.UUID   `json:"cover_image_mime_type_id"`
}

func (q *Queries) GetPluralChatRoomsWithCoverImageUseNumberedPaginate(ctx context.Context, arg GetPluralChatRoomsWithCoverImageUseNumberedPaginateParams) ([]GetPluralChatRoomsWithCoverImageUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getPluralChatRoomsWithCoverImageUseNumberedPaginate, arg.Limit, arg.Offset, arg.ChatRoomIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralChatRoomsWithCoverImageUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetPluralChatRoomsWithCoverImageUseNumberedPaginateRow
		if err := rows.Scan(
			&i.MChatRoomsPkey,
			&i.ChatRoomID,
			&i.Name,
			&i.IsPrivate,
			&i.CoverImageID,
			&i.OwnerID,
			&i.FromOrganization,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CoverImageHeight,
			&i.CoverImageWidth,
			&i.CoverImageAttachableItemID,
			&i.CoverImageOwnerID,
			&i.CoverImageFromOuter,
			&i.CoverImageAlias,
			&i.CoverImageUrl,
			&i.CoverImageSize,
			&i.CoverImageMimeTypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralChatRoomsWithOwner = `-- name: GetPluralChatRoomsWithOwner :many
SELECT m_chat_rooms.m_chat_rooms_pkey, m_chat_rooms.chat_room_id, m_chat_rooms.name, m_chat_rooms.is_private, m_chat_rooms.cover_image_id, m_chat_rooms.owner_id, m_chat_rooms.from_organization, m_chat_rooms.created_at, m_chat_rooms.updated_at, m_members.name owner_name, m_members.first_name owner_first_name, m_members.last_name owner_last_name, m_members.email owner_email,
m_members.profile_image_id owner_profile_image_id, m_members.grade_id owner_grade_id, m_members.group_id owner_group_id
FROM m_chat_rooms
LEFT JOIN m_members ON m_chat_rooms.owner_id = m_members.member_id
WHERE chat_room_id = ANY($1::uuid[])
ORDER BY
	m_chat_rooms_pkey ASC
`

type GetPluralChatRoomsWithOwnerRow struct {
	MChatRoomsPkey      pgtype.Int8 `json:"m_chat_rooms_pkey"`
	ChatRoomID          uuid.UUID   `json:"chat_room_id"`
	Name                string      `json:"name"`
	IsPrivate           bool        `json:"is_private"`
	CoverImageID        pgtype.UUID `json:"cover_image_id"`
	OwnerID             pgtype.UUID `json:"owner_id"`
	FromOrganization    bool        `json:"from_organization"`
	CreatedAt           time.Time   `json:"created_at"`
	UpdatedAt           time.Time   `json:"updated_at"`
	OwnerName           pgtype.Text `json:"owner_name"`
	OwnerFirstName      pgtype.Text `json:"owner_first_name"`
	OwnerLastName       pgtype.Text `json:"owner_last_name"`
	OwnerEmail          pgtype.Text `json:"owner_email"`
	OwnerProfileImageID pgtype.UUID `json:"owner_profile_image_id"`
	OwnerGradeID        pgtype.UUID `json:"owner_grade_id"`
	OwnerGroupID        pgtype.UUID `json:"owner_group_id"`
}

func (q *Queries) GetPluralChatRoomsWithOwner(ctx context.Context, chatRoomIds []uuid.UUID) ([]GetPluralChatRoomsWithOwnerRow, error) {
	rows, err := q.db.Query(ctx, getPluralChatRoomsWithOwner, chatRoomIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralChatRoomsWithOwnerRow{}
	for rows.Next() {
		var i GetPluralChatRoomsWithOwnerRow
		if err := rows.Scan(
			&i.MChatRoomsPkey,
			&i.ChatRoomID,
			&i.Name,
			&i.IsPrivate,
			&i.CoverImageID,
			&i.OwnerID,
			&i.FromOrganization,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.OwnerName,
			&i.OwnerFirstName,
			&i.OwnerLastName,
			&i.OwnerEmail,
			&i.OwnerProfileImageID,
			&i.OwnerGradeID,
			&i.OwnerGroupID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralChatRoomsWithOwnerUseNumberedPaginate = `-- name: GetPluralChatRoomsWithOwnerUseNumberedPaginate :many
SELECT m_chat_rooms.m_chat_rooms_pkey, m_chat_rooms.chat_room_id, m_chat_rooms.name, m_chat_rooms.is_private, m_chat_rooms.cover_image_id, m_chat_rooms.owner_id, m_chat_rooms.from_organization, m_chat_rooms.created_at, m_chat_rooms.updated_at, m_members.name owner_name, m_members.first_name owner_first_name, m_members.last_name owner_last_name, m_members.email owner_email,
m_members.profile_image_id owner_profile_image_id, m_members.grade_id owner_grade_id, m_members.group_id owner_group_id
FROM m_chat_rooms
LEFT JOIN m_members ON m_chat_rooms.owner_id = m_members.member_id
WHERE chat_room_id = ANY($3::uuid[])
ORDER BY
	m_chat_rooms_pkey ASC
LIMIT $1 OFFSET $2
`

type GetPluralChatRoomsWithOwnerUseNumberedPaginateParams struct {
	Limit       int32       `json:"limit"`
	Offset      int32       `json:"offset"`
	ChatRoomIds []uuid.UUID `json:"chat_room_ids"`
}

type GetPluralChatRoomsWithOwnerUseNumberedPaginateRow struct {
	MChatRoomsPkey      pgtype.Int8 `json:"m_chat_rooms_pkey"`
	ChatRoomID          uuid.UUID   `json:"chat_room_id"`
	Name                string      `json:"name"`
	IsPrivate           bool        `json:"is_private"`
	CoverImageID        pgtype.UUID `json:"cover_image_id"`
	OwnerID             pgtype.UUID `json:"owner_id"`
	FromOrganization    bool        `json:"from_organization"`
	CreatedAt           time.Time   `json:"created_at"`
	UpdatedAt           time.Time   `json:"updated_at"`
	OwnerName           pgtype.Text `json:"owner_name"`
	OwnerFirstName      pgtype.Text `json:"owner_first_name"`
	OwnerLastName       pgtype.Text `json:"owner_last_name"`
	OwnerEmail          pgtype.Text `json:"owner_email"`
	OwnerProfileImageID pgtype.UUID `json:"owner_profile_image_id"`
	OwnerGradeID        pgtype.UUID `json:"owner_grade_id"`
	OwnerGroupID        pgtype.UUID `json:"owner_group_id"`
}

func (q *Queries) GetPluralChatRoomsWithOwnerUseNumberedPaginate(ctx context.Context, arg GetPluralChatRoomsWithOwnerUseNumberedPaginateParams) ([]GetPluralChatRoomsWithOwnerUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getPluralChatRoomsWithOwnerUseNumberedPaginate, arg.Limit, arg.Offset, arg.ChatRoomIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralChatRoomsWithOwnerUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetPluralChatRoomsWithOwnerUseNumberedPaginateRow
		if err := rows.Scan(
			&i.MChatRoomsPkey,
			&i.ChatRoomID,
			&i.Name,
			&i.IsPrivate,
			&i.CoverImageID,
			&i.OwnerID,
			&i.FromOrganization,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.OwnerName,
			&i.OwnerFirstName,
			&i.OwnerLastName,
			&i.OwnerEmail,
			&i.OwnerProfileImageID,
			&i.OwnerGradeID,
			&i.OwnerGroupID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const pluralDeleteChatRooms = `-- name: PluralDeleteChatRooms :execrows
DELETE FROM m_chat_rooms WHERE chat_room_id = ANY($1::uuid[])
`

func (q *Queries) PluralDeleteChatRooms(ctx context.Context, chatRoomIds []uuid.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, pluralDeleteChatRooms, chatRoomIds)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateChatRoom = `-- name: UpdateChatRoom :one
UPDATE m_chat_rooms SET name = $2, cover_image_id = $3, updated_at = $4 WHERE chat_room_id = $1 RETURNING m_chat_rooms_pkey, chat_room_id, name, is_private, cover_image_id, owner_id, from_organization, created_at, updated_at
`

type UpdateChatRoomParams struct {
	ChatRoomID   uuid.UUID   `json:"chat_room_id"`
	Name         string      `json:"name"`
	CoverImageID pgtype.UUID `json:"cover_image_id"`
	UpdatedAt    time.Time   `json:"updated_at"`
}

func (q *Queries) UpdateChatRoom(ctx context.Context, arg UpdateChatRoomParams) (ChatRoom, error) {
	row := q.db.QueryRow(ctx, updateChatRoom,
		arg.ChatRoomID,
		arg.Name,
		arg.CoverImageID,
		arg.UpdatedAt,
	)
	var i ChatRoom
	err := row.Scan(
		&i.MChatRoomsPkey,
		&i.ChatRoomID,
		&i.Name,
		&i.IsPrivate,
		&i.CoverImageID,
		&i.OwnerID,
		&i.FromOrganization,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateChatRoomOwner = `-- name: UpdateChatRoomOwner :one
UPDATE m_chat_rooms SET owner_id = $2, updated_at = $3 WHERE chat_room_id = $1 RETURNING m_chat_rooms_pkey, chat_room_id, name, is_private, cover_image_id, owner_id, from_organization, created_at, updated_at
`

type UpdateChatRoomOwnerParams struct {
	ChatRoomID uuid.UUID   `json:"chat_room_id"`
	OwnerID    pgtype.UUID `json:"owner_id"`
	UpdatedAt  time.Time   `json:"updated_at"`
}

func (q *Queries) UpdateChatRoomOwner(ctx context.Context, arg UpdateChatRoomOwnerParams) (ChatRoom, error) {
	row := q.db.QueryRow(ctx, updateChatRoomOwner, arg.ChatRoomID, arg.OwnerID, arg.UpdatedAt)
	var i ChatRoom
	err := row.Scan(
		&i.MChatRoomsPkey,
		&i.ChatRoomID,
		&i.Name,
		&i.IsPrivate,
		&i.CoverImageID,
		&i.OwnerID,
		&i.FromOrganization,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
