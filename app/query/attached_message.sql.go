// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: attached_message.sql

package query

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countAttachedItemsOnChatRoom = `-- name: CountAttachedItemsOnChatRoom :one
SELECT COUNT(*) FROM t_attached_messages
WHERE message_id IN (
	SELECT message_id FROM t_messages WHERE chat_room_id = $1
)
`

func (q *Queries) CountAttachedItemsOnChatRoom(ctx context.Context, chatRoomID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countAttachedItemsOnChatRoom, chatRoomID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAttachedItemsOnMessage = `-- name: CountAttachedItemsOnMessage :one
SELECT COUNT(*) FROM t_attached_messages WHERE message_id = $1
`

func (q *Queries) CountAttachedItemsOnMessage(ctx context.Context, messageID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countAttachedItemsOnMessage, messageID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAttachedMessage = `-- name: CreateAttachedMessage :one
INSERT INTO t_attached_messages (message_id, attachable_item_id) VALUES ($1, $2) RETURNING t_attached_messages_pkey, attached_message_id, message_id, attachable_item_id
`

type CreateAttachedMessageParams struct {
	MessageID        uuid.UUID   `json:"message_id"`
	AttachableItemID pgtype.UUID `json:"attachable_item_id"`
}

func (q *Queries) CreateAttachedMessage(ctx context.Context, arg CreateAttachedMessageParams) (AttachedMessage, error) {
	row := q.db.QueryRow(ctx, createAttachedMessage, arg.MessageID, arg.AttachableItemID)
	var i AttachedMessage
	err := row.Scan(
		&i.TAttachedMessagesPkey,
		&i.AttachedMessageID,
		&i.MessageID,
		&i.AttachableItemID,
	)
	return i, err
}

type CreateAttachedMessagesParams struct {
	MessageID        uuid.UUID   `json:"message_id"`
	AttachableItemID pgtype.UUID `json:"attachable_item_id"`
}

const deleteAttachedMessage = `-- name: DeleteAttachedMessage :execrows
DELETE FROM t_attached_messages WHERE attached_message_id = $1
`

func (q *Queries) DeleteAttachedMessage(ctx context.Context, attachedMessageID uuid.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, deleteAttachedMessage, attachedMessageID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteAttachedMessagesOnMessage = `-- name: DeleteAttachedMessagesOnMessage :execrows
DELETE FROM t_attached_messages WHERE message_id = $1
`

func (q *Queries) DeleteAttachedMessagesOnMessage(ctx context.Context, messageID uuid.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, deleteAttachedMessagesOnMessage, messageID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteAttachedMessagesOnMessages = `-- name: DeleteAttachedMessagesOnMessages :execrows
DELETE FROM t_attached_messages WHERE message_id = ANY($1::uuid[])
`

func (q *Queries) DeleteAttachedMessagesOnMessages(ctx context.Context, dollar_1 []uuid.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, deleteAttachedMessagesOnMessages, dollar_1)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getAttachedItemsOnChatRoom = `-- name: GetAttachedItemsOnChatRoom :many
SELECT t_attached_messages.t_attached_messages_pkey, t_attached_messages.attached_message_id, t_attached_messages.message_id, t_attached_messages.attachable_item_id, t_attachable_items.url attached_item_url,
t_attachable_items.size attached_item_size, t_attachable_items.mime_type_id attached_item_mime_type_id,
t_attachable_items.owner_id attached_item_owner_id, t_attachable_items.from_outer attached_item_from_outer
FROM t_attached_messages
LEFT JOIN t_attachable_items ON t_attached_messages.attachable_item_id = t_attachable_items.attachable_item_id
WHERE message_id IN (
	SELECT message_id FROM t_messages WHERE chat_room_id = $1
)
ORDER BY
	t_attached_messages_pkey ASC
`

type GetAttachedItemsOnChatRoomRow struct {
	TAttachedMessagesPkey  pgtype.Int8   `json:"t_attached_messages_pkey"`
	AttachedMessageID      uuid.UUID     `json:"attached_message_id"`
	MessageID              uuid.UUID     `json:"message_id"`
	AttachableItemID       pgtype.UUID   `json:"attachable_item_id"`
	AttachedItemUrl        pgtype.Text   `json:"attached_item_url"`
	AttachedItemSize       pgtype.Float8 `json:"attached_item_size"`
	AttachedItemMimeTypeID pgtype.UUID   `json:"attached_item_mime_type_id"`
	AttachedItemOwnerID    pgtype.UUID   `json:"attached_item_owner_id"`
	AttachedItemFromOuter  pgtype.Bool   `json:"attached_item_from_outer"`
}

func (q *Queries) GetAttachedItemsOnChatRoom(ctx context.Context, chatRoomID uuid.UUID) ([]GetAttachedItemsOnChatRoomRow, error) {
	rows, err := q.db.Query(ctx, getAttachedItemsOnChatRoom, chatRoomID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAttachedItemsOnChatRoomRow{}
	for rows.Next() {
		var i GetAttachedItemsOnChatRoomRow
		if err := rows.Scan(
			&i.TAttachedMessagesPkey,
			&i.AttachedMessageID,
			&i.MessageID,
			&i.AttachableItemID,
			&i.AttachedItemUrl,
			&i.AttachedItemSize,
			&i.AttachedItemMimeTypeID,
			&i.AttachedItemOwnerID,
			&i.AttachedItemFromOuter,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAttachedItemsOnChatRoomUseKeysetPaginate = `-- name: GetAttachedItemsOnChatRoomUseKeysetPaginate :many
SELECT t_attached_messages.t_attached_messages_pkey, t_attached_messages.attached_message_id, t_attached_messages.message_id, t_attached_messages.attachable_item_id, t_attachable_items.url attached_item_url,
t_attachable_items.size attached_item_size, t_attachable_items.mime_type_id attached_item_mime_type_id,
t_attachable_items.owner_id attached_item_owner_id, t_attachable_items.from_outer attached_item_from_outer
FROM t_attached_messages
LEFT JOIN t_attachable_items ON t_attached_messages.attachable_item_id = t_attachable_items.attachable_item_id
WHERE message_id IN (
	SELECT message_id FROM t_messages WHERE chat_room_id = $1
)
AND
	CASE $3::text
		WHEN 'next' THEN
			t_attached_messages_pkey > $4::int
		WHEN 'prev' THEN
			t_attached_messages_pkey < $4::int
	END
ORDER BY
	CASE WHEN $3::text = 'next' THEN t_attached_messages_pkey END ASC,
	CASE WHEN $3::text = 'prev' THEN t_attached_messages_pkey END DESC
LIMIT $2
`

type GetAttachedItemsOnChatRoomUseKeysetPaginateParams struct {
	ChatRoomID      uuid.UUID `json:"chat_room_id"`
	Limit           int32     `json:"limit"`
	CursorDirection string    `json:"cursor_direction"`
	Cursor          int32     `json:"cursor"`
}

type GetAttachedItemsOnChatRoomUseKeysetPaginateRow struct {
	TAttachedMessagesPkey  pgtype.Int8   `json:"t_attached_messages_pkey"`
	AttachedMessageID      uuid.UUID     `json:"attached_message_id"`
	MessageID              uuid.UUID     `json:"message_id"`
	AttachableItemID       pgtype.UUID   `json:"attachable_item_id"`
	AttachedItemUrl        pgtype.Text   `json:"attached_item_url"`
	AttachedItemSize       pgtype.Float8 `json:"attached_item_size"`
	AttachedItemMimeTypeID pgtype.UUID   `json:"attached_item_mime_type_id"`
	AttachedItemOwnerID    pgtype.UUID   `json:"attached_item_owner_id"`
	AttachedItemFromOuter  pgtype.Bool   `json:"attached_item_from_outer"`
}

func (q *Queries) GetAttachedItemsOnChatRoomUseKeysetPaginate(ctx context.Context, arg GetAttachedItemsOnChatRoomUseKeysetPaginateParams) ([]GetAttachedItemsOnChatRoomUseKeysetPaginateRow, error) {
	rows, err := q.db.Query(ctx, getAttachedItemsOnChatRoomUseKeysetPaginate,
		arg.ChatRoomID,
		arg.Limit,
		arg.CursorDirection,
		arg.Cursor,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAttachedItemsOnChatRoomUseKeysetPaginateRow{}
	for rows.Next() {
		var i GetAttachedItemsOnChatRoomUseKeysetPaginateRow
		if err := rows.Scan(
			&i.TAttachedMessagesPkey,
			&i.AttachedMessageID,
			&i.MessageID,
			&i.AttachableItemID,
			&i.AttachedItemUrl,
			&i.AttachedItemSize,
			&i.AttachedItemMimeTypeID,
			&i.AttachedItemOwnerID,
			&i.AttachedItemFromOuter,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAttachedItemsOnChatRoomUseNumberedPaginate = `-- name: GetAttachedItemsOnChatRoomUseNumberedPaginate :many
SELECT t_attached_messages.t_attached_messages_pkey, t_attached_messages.attached_message_id, t_attached_messages.message_id, t_attached_messages.attachable_item_id, t_attachable_items.url attached_item_url,
t_attachable_items.size attached_item_size, t_attachable_items.mime_type_id attached_item_mime_type_id,
t_attachable_items.owner_id attached_item_owner_id, t_attachable_items.from_outer attached_item_from_outer
FROM t_attached_messages
LEFT JOIN t_attachable_items ON t_attached_messages.attachable_item_id = t_attachable_items.attachable_item_id
WHERE message_id IN (
	SELECT message_id FROM t_messages WHERE chat_room_id = $1
)
ORDER BY
	t_attached_messages_pkey ASC
LIMIT $2 OFFSET $3
`

type GetAttachedItemsOnChatRoomUseNumberedPaginateParams struct {
	ChatRoomID uuid.UUID `json:"chat_room_id"`
	Limit      int32     `json:"limit"`
	Offset     int32     `json:"offset"`
}

type GetAttachedItemsOnChatRoomUseNumberedPaginateRow struct {
	TAttachedMessagesPkey  pgtype.Int8   `json:"t_attached_messages_pkey"`
	AttachedMessageID      uuid.UUID     `json:"attached_message_id"`
	MessageID              uuid.UUID     `json:"message_id"`
	AttachableItemID       pgtype.UUID   `json:"attachable_item_id"`
	AttachedItemUrl        pgtype.Text   `json:"attached_item_url"`
	AttachedItemSize       pgtype.Float8 `json:"attached_item_size"`
	AttachedItemMimeTypeID pgtype.UUID   `json:"attached_item_mime_type_id"`
	AttachedItemOwnerID    pgtype.UUID   `json:"attached_item_owner_id"`
	AttachedItemFromOuter  pgtype.Bool   `json:"attached_item_from_outer"`
}

func (q *Queries) GetAttachedItemsOnChatRoomUseNumberedPaginate(ctx context.Context, arg GetAttachedItemsOnChatRoomUseNumberedPaginateParams) ([]GetAttachedItemsOnChatRoomUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getAttachedItemsOnChatRoomUseNumberedPaginate, arg.ChatRoomID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAttachedItemsOnChatRoomUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetAttachedItemsOnChatRoomUseNumberedPaginateRow
		if err := rows.Scan(
			&i.TAttachedMessagesPkey,
			&i.AttachedMessageID,
			&i.MessageID,
			&i.AttachableItemID,
			&i.AttachedItemUrl,
			&i.AttachedItemSize,
			&i.AttachedItemMimeTypeID,
			&i.AttachedItemOwnerID,
			&i.AttachedItemFromOuter,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAttachedItemsOnMessage = `-- name: GetAttachedItemsOnMessage :many
SELECT t_attached_messages.t_attached_messages_pkey, t_attached_messages.attached_message_id, t_attached_messages.message_id, t_attached_messages.attachable_item_id, t_attachable_items.url attached_item_url,
t_attachable_items.size attached_item_size, t_attachable_items.mime_type_id attached_item_mime_type_id,
t_attachable_items.owner_id attached_item_owner_id, t_attachable_items.from_outer attached_item_from_outer
FROM t_attached_messages
LEFT JOIN t_attachable_items ON t_attached_messages.attachable_item_id = t_attachable_items.attachable_item_id
WHERE message_id = $1
ORDER BY
	t_attached_messages_pkey ASC
`

type GetAttachedItemsOnMessageRow struct {
	TAttachedMessagesPkey  pgtype.Int8   `json:"t_attached_messages_pkey"`
	AttachedMessageID      uuid.UUID     `json:"attached_message_id"`
	MessageID              uuid.UUID     `json:"message_id"`
	AttachableItemID       pgtype.UUID   `json:"attachable_item_id"`
	AttachedItemUrl        pgtype.Text   `json:"attached_item_url"`
	AttachedItemSize       pgtype.Float8 `json:"attached_item_size"`
	AttachedItemMimeTypeID pgtype.UUID   `json:"attached_item_mime_type_id"`
	AttachedItemOwnerID    pgtype.UUID   `json:"attached_item_owner_id"`
	AttachedItemFromOuter  pgtype.Bool   `json:"attached_item_from_outer"`
}

func (q *Queries) GetAttachedItemsOnMessage(ctx context.Context, messageID uuid.UUID) ([]GetAttachedItemsOnMessageRow, error) {
	rows, err := q.db.Query(ctx, getAttachedItemsOnMessage, messageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAttachedItemsOnMessageRow{}
	for rows.Next() {
		var i GetAttachedItemsOnMessageRow
		if err := rows.Scan(
			&i.TAttachedMessagesPkey,
			&i.AttachedMessageID,
			&i.MessageID,
			&i.AttachableItemID,
			&i.AttachedItemUrl,
			&i.AttachedItemSize,
			&i.AttachedItemMimeTypeID,
			&i.AttachedItemOwnerID,
			&i.AttachedItemFromOuter,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAttachedItemsOnMessageUseKeysetPaginate = `-- name: GetAttachedItemsOnMessageUseKeysetPaginate :many
SELECT t_attached_messages.t_attached_messages_pkey, t_attached_messages.attached_message_id, t_attached_messages.message_id, t_attached_messages.attachable_item_id, t_attachable_items.url attached_item_url,
t_attachable_items.size attached_item_size, t_attachable_items.mime_type_id attached_item_mime_type_id,
t_attachable_items.owner_id attached_item_owner_id, t_attachable_items.from_outer attached_item_from_outer
FROM t_attached_messages
LEFT JOIN t_attachable_items ON t_attached_messages.attachable_item_id = t_attachable_items.attachable_item_id
WHERE message_id = $1
AND
	CASE $3::text
		WHEN 'next' THEN
			t_attached_messages_pkey > $4::int
		WHEN 'prev' THEN
			t_attached_messages_pkey < $4::int
	END
ORDER BY
	CASE WHEN $3::text = 'next' THEN t_attached_messages_pkey END ASC,
	CASE WHEN $3::text = 'prev' THEN t_attached_messages_pkey END DESC
LIMIT $2
`

type GetAttachedItemsOnMessageUseKeysetPaginateParams struct {
	MessageID       uuid.UUID `json:"message_id"`
	Limit           int32     `json:"limit"`
	CursorDirection string    `json:"cursor_direction"`
	Cursor          int32     `json:"cursor"`
}

type GetAttachedItemsOnMessageUseKeysetPaginateRow struct {
	TAttachedMessagesPkey  pgtype.Int8   `json:"t_attached_messages_pkey"`
	AttachedMessageID      uuid.UUID     `json:"attached_message_id"`
	MessageID              uuid.UUID     `json:"message_id"`
	AttachableItemID       pgtype.UUID   `json:"attachable_item_id"`
	AttachedItemUrl        pgtype.Text   `json:"attached_item_url"`
	AttachedItemSize       pgtype.Float8 `json:"attached_item_size"`
	AttachedItemMimeTypeID pgtype.UUID   `json:"attached_item_mime_type_id"`
	AttachedItemOwnerID    pgtype.UUID   `json:"attached_item_owner_id"`
	AttachedItemFromOuter  pgtype.Bool   `json:"attached_item_from_outer"`
}

func (q *Queries) GetAttachedItemsOnMessageUseKeysetPaginate(ctx context.Context, arg GetAttachedItemsOnMessageUseKeysetPaginateParams) ([]GetAttachedItemsOnMessageUseKeysetPaginateRow, error) {
	rows, err := q.db.Query(ctx, getAttachedItemsOnMessageUseKeysetPaginate,
		arg.MessageID,
		arg.Limit,
		arg.CursorDirection,
		arg.Cursor,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAttachedItemsOnMessageUseKeysetPaginateRow{}
	for rows.Next() {
		var i GetAttachedItemsOnMessageUseKeysetPaginateRow
		if err := rows.Scan(
			&i.TAttachedMessagesPkey,
			&i.AttachedMessageID,
			&i.MessageID,
			&i.AttachableItemID,
			&i.AttachedItemUrl,
			&i.AttachedItemSize,
			&i.AttachedItemMimeTypeID,
			&i.AttachedItemOwnerID,
			&i.AttachedItemFromOuter,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAttachedItemsOnMessageUseNumberedPaginate = `-- name: GetAttachedItemsOnMessageUseNumberedPaginate :many
SELECT t_attached_messages.t_attached_messages_pkey, t_attached_messages.attached_message_id, t_attached_messages.message_id, t_attached_messages.attachable_item_id, t_attachable_items.url attached_item_url,
t_attachable_items.size attached_item_size, t_attachable_items.mime_type_id attached_item_mime_type_id,
t_attachable_items.owner_id attached_item_owner_id, t_attachable_items.from_outer attached_item_from_outer
FROM t_attached_messages
LEFT JOIN t_attachable_items ON t_attached_messages.attachable_item_id = t_attachable_items.attachable_item_id
WHERE message_id = $1
ORDER BY
	t_attached_messages_pkey ASC
LIMIT $2 OFFSET $3
`

type GetAttachedItemsOnMessageUseNumberedPaginateParams struct {
	MessageID uuid.UUID `json:"message_id"`
	Limit     int32     `json:"limit"`
	Offset    int32     `json:"offset"`
}

type GetAttachedItemsOnMessageUseNumberedPaginateRow struct {
	TAttachedMessagesPkey  pgtype.Int8   `json:"t_attached_messages_pkey"`
	AttachedMessageID      uuid.UUID     `json:"attached_message_id"`
	MessageID              uuid.UUID     `json:"message_id"`
	AttachableItemID       pgtype.UUID   `json:"attachable_item_id"`
	AttachedItemUrl        pgtype.Text   `json:"attached_item_url"`
	AttachedItemSize       pgtype.Float8 `json:"attached_item_size"`
	AttachedItemMimeTypeID pgtype.UUID   `json:"attached_item_mime_type_id"`
	AttachedItemOwnerID    pgtype.UUID   `json:"attached_item_owner_id"`
	AttachedItemFromOuter  pgtype.Bool   `json:"attached_item_from_outer"`
}

func (q *Queries) GetAttachedItemsOnMessageUseNumberedPaginate(ctx context.Context, arg GetAttachedItemsOnMessageUseNumberedPaginateParams) ([]GetAttachedItemsOnMessageUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getAttachedItemsOnMessageUseNumberedPaginate, arg.MessageID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAttachedItemsOnMessageUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetAttachedItemsOnMessageUseNumberedPaginateRow
		if err := rows.Scan(
			&i.TAttachedMessagesPkey,
			&i.AttachedMessageID,
			&i.MessageID,
			&i.AttachableItemID,
			&i.AttachedItemUrl,
			&i.AttachedItemSize,
			&i.AttachedItemMimeTypeID,
			&i.AttachedItemOwnerID,
			&i.AttachedItemFromOuter,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAttachedItemsOnMessageWithMimeType = `-- name: GetAttachedItemsOnMessageWithMimeType :many
SELECT t_attached_messages.t_attached_messages_pkey, t_attached_messages.attached_message_id, t_attached_messages.message_id, t_attached_messages.attachable_item_id, t_attachable_items.url attached_item_url,
t_attachable_items.size attached_item_size, t_attachable_items.mime_type_id attached_item_mime_type_id,
t_attachable_items.owner_id attached_item_owner_id, t_attachable_items.from_outer attached_item_from_outer,
m_mime_types.name mime_type_name, m_mime_types.key mime_type_key, m_mime_types.kind mime_type_kind
FROM t_attached_messages
LEFT JOIN t_attachable_items ON t_attached_messages.attachable_item_id = t_attachable_items.attachable_item_id
LEFT JOIN m_mime_types ON t_attachable_items.mime_type_id = m_mime_types.mime_type_id
WHERE message_id = $1
ORDER BY
	t_attached_messages_pkey ASC
`

type GetAttachedItemsOnMessageWithMimeTypeRow struct {
	TAttachedMessagesPkey  pgtype.Int8   `json:"t_attached_messages_pkey"`
	AttachedMessageID      uuid.UUID     `json:"attached_message_id"`
	MessageID              uuid.UUID     `json:"message_id"`
	AttachableItemID       pgtype.UUID   `json:"attachable_item_id"`
	AttachedItemUrl        pgtype.Text   `json:"attached_item_url"`
	AttachedItemSize       pgtype.Float8 `json:"attached_item_size"`
	AttachedItemMimeTypeID pgtype.UUID   `json:"attached_item_mime_type_id"`
	AttachedItemOwnerID    pgtype.UUID   `json:"attached_item_owner_id"`
	AttachedItemFromOuter  pgtype.Bool   `json:"attached_item_from_outer"`
	MimeTypeName           pgtype.Text   `json:"mime_type_name"`
	MimeTypeKey            pgtype.Text   `json:"mime_type_key"`
	MimeTypeKind           pgtype.Text   `json:"mime_type_kind"`
}

func (q *Queries) GetAttachedItemsOnMessageWithMimeType(ctx context.Context, messageID uuid.UUID) ([]GetAttachedItemsOnMessageWithMimeTypeRow, error) {
	rows, err := q.db.Query(ctx, getAttachedItemsOnMessageWithMimeType, messageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAttachedItemsOnMessageWithMimeTypeRow{}
	for rows.Next() {
		var i GetAttachedItemsOnMessageWithMimeTypeRow
		if err := rows.Scan(
			&i.TAttachedMessagesPkey,
			&i.AttachedMessageID,
			&i.MessageID,
			&i.AttachableItemID,
			&i.AttachedItemUrl,
			&i.AttachedItemSize,
			&i.AttachedItemMimeTypeID,
			&i.AttachedItemOwnerID,
			&i.AttachedItemFromOuter,
			&i.MimeTypeName,
			&i.MimeTypeKey,
			&i.MimeTypeKind,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAttachedItemsOnMessageWithMimeTypeUseKeysetPaginate = `-- name: GetAttachedItemsOnMessageWithMimeTypeUseKeysetPaginate :many
SELECT t_attached_messages.t_attached_messages_pkey, t_attached_messages.attached_message_id, t_attached_messages.message_id, t_attached_messages.attachable_item_id, t_attachable_items.url attached_item_url,
t_attachable_items.size attached_item_size, t_attachable_items.mime_type_id attached_item_mime_type_id,
t_attachable_items.owner_id attached_item_owner_id, t_attachable_items.from_outer attached_item_from_outer,
m_mime_types.name mime_type_name, m_mime_types.key mime_type_key, m_mime_types.kind mime_type_kind
FROM t_attached_messages
LEFT JOIN t_attachable_items ON t_attached_messages.attachable_item_id = t_attachable_items.attachable_item_id
LEFT JOIN m_mime_types ON t_attachable_items.mime_type_id = m_mime_types.mime_type_id
WHERE message_id = $1
AND
	CASE $3::text
		WHEN 'next' THEN
			t_attached_messages_pkey > $4::int
		WHEN 'prev' THEN
			t_attached_messages_pkey < $4::int
	END
ORDER BY
	CASE WHEN $3::text = 'next' THEN t_attached_messages_pkey END ASC,
	CASE WHEN $3::text = 'prev' THEN t_attached_messages_pkey END DESC
LIMIT $2
`

type GetAttachedItemsOnMessageWithMimeTypeUseKeysetPaginateParams struct {
	MessageID       uuid.UUID `json:"message_id"`
	Limit           int32     `json:"limit"`
	CursorDirection string    `json:"cursor_direction"`
	Cursor          int32     `json:"cursor"`
}

type GetAttachedItemsOnMessageWithMimeTypeUseKeysetPaginateRow struct {
	TAttachedMessagesPkey  pgtype.Int8   `json:"t_attached_messages_pkey"`
	AttachedMessageID      uuid.UUID     `json:"attached_message_id"`
	MessageID              uuid.UUID     `json:"message_id"`
	AttachableItemID       pgtype.UUID   `json:"attachable_item_id"`
	AttachedItemUrl        pgtype.Text   `json:"attached_item_url"`
	AttachedItemSize       pgtype.Float8 `json:"attached_item_size"`
	AttachedItemMimeTypeID pgtype.UUID   `json:"attached_item_mime_type_id"`
	AttachedItemOwnerID    pgtype.UUID   `json:"attached_item_owner_id"`
	AttachedItemFromOuter  pgtype.Bool   `json:"attached_item_from_outer"`
	MimeTypeName           pgtype.Text   `json:"mime_type_name"`
	MimeTypeKey            pgtype.Text   `json:"mime_type_key"`
	MimeTypeKind           pgtype.Text   `json:"mime_type_kind"`
}

func (q *Queries) GetAttachedItemsOnMessageWithMimeTypeUseKeysetPaginate(ctx context.Context, arg GetAttachedItemsOnMessageWithMimeTypeUseKeysetPaginateParams) ([]GetAttachedItemsOnMessageWithMimeTypeUseKeysetPaginateRow, error) {
	rows, err := q.db.Query(ctx, getAttachedItemsOnMessageWithMimeTypeUseKeysetPaginate,
		arg.MessageID,
		arg.Limit,
		arg.CursorDirection,
		arg.Cursor,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAttachedItemsOnMessageWithMimeTypeUseKeysetPaginateRow{}
	for rows.Next() {
		var i GetAttachedItemsOnMessageWithMimeTypeUseKeysetPaginateRow
		if err := rows.Scan(
			&i.TAttachedMessagesPkey,
			&i.AttachedMessageID,
			&i.MessageID,
			&i.AttachableItemID,
			&i.AttachedItemUrl,
			&i.AttachedItemSize,
			&i.AttachedItemMimeTypeID,
			&i.AttachedItemOwnerID,
			&i.AttachedItemFromOuter,
			&i.MimeTypeName,
			&i.MimeTypeKey,
			&i.MimeTypeKind,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAttachedItemsOnMessageWithMimeTypeUseNumberedPaginate = `-- name: GetAttachedItemsOnMessageWithMimeTypeUseNumberedPaginate :many
SELECT t_attached_messages.t_attached_messages_pkey, t_attached_messages.attached_message_id, t_attached_messages.message_id, t_attached_messages.attachable_item_id, t_attachable_items.url attached_item_url,
t_attachable_items.size attached_item_size, t_attachable_items.mime_type_id attached_item_mime_type_id,
t_attachable_items.owner_id attached_item_owner_id, t_attachable_items.from_outer attached_item_from_outer,
m_mime_types.name mime_type_name, m_mime_types.key mime_type_key, m_mime_types.kind mime_type_kind
FROM t_attached_messages
LEFT JOIN t_attachable_items ON t_attached_messages.attachable_item_id = t_attachable_items.attachable_item_id
LEFT JOIN m_mime_types ON t_attachable_items.mime_type_id = m_mime_types.mime_type_id
WHERE message_id = $1
ORDER BY
	t_attached_messages_pkey ASC
LIMIT $2 OFFSET $3
`

type GetAttachedItemsOnMessageWithMimeTypeUseNumberedPaginateParams struct {
	MessageID uuid.UUID `json:"message_id"`
	Limit     int32     `json:"limit"`
	Offset    int32     `json:"offset"`
}

type GetAttachedItemsOnMessageWithMimeTypeUseNumberedPaginateRow struct {
	TAttachedMessagesPkey  pgtype.Int8   `json:"t_attached_messages_pkey"`
	AttachedMessageID      uuid.UUID     `json:"attached_message_id"`
	MessageID              uuid.UUID     `json:"message_id"`
	AttachableItemID       pgtype.UUID   `json:"attachable_item_id"`
	AttachedItemUrl        pgtype.Text   `json:"attached_item_url"`
	AttachedItemSize       pgtype.Float8 `json:"attached_item_size"`
	AttachedItemMimeTypeID pgtype.UUID   `json:"attached_item_mime_type_id"`
	AttachedItemOwnerID    pgtype.UUID   `json:"attached_item_owner_id"`
	AttachedItemFromOuter  pgtype.Bool   `json:"attached_item_from_outer"`
	MimeTypeName           pgtype.Text   `json:"mime_type_name"`
	MimeTypeKey            pgtype.Text   `json:"mime_type_key"`
	MimeTypeKind           pgtype.Text   `json:"mime_type_kind"`
}

func (q *Queries) GetAttachedItemsOnMessageWithMimeTypeUseNumberedPaginate(ctx context.Context, arg GetAttachedItemsOnMessageWithMimeTypeUseNumberedPaginateParams) ([]GetAttachedItemsOnMessageWithMimeTypeUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getAttachedItemsOnMessageWithMimeTypeUseNumberedPaginate, arg.MessageID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAttachedItemsOnMessageWithMimeTypeUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetAttachedItemsOnMessageWithMimeTypeUseNumberedPaginateRow
		if err := rows.Scan(
			&i.TAttachedMessagesPkey,
			&i.AttachedMessageID,
			&i.MessageID,
			&i.AttachableItemID,
			&i.AttachedItemUrl,
			&i.AttachedItemSize,
			&i.AttachedItemMimeTypeID,
			&i.AttachedItemOwnerID,
			&i.AttachedItemFromOuter,
			&i.MimeTypeName,
			&i.MimeTypeKey,
			&i.MimeTypeKind,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralAttachedItemsOnChatRoom = `-- name: GetPluralAttachedItemsOnChatRoom :many
SELECT t_attached_messages.t_attached_messages_pkey, t_attached_messages.attached_message_id, t_attached_messages.message_id, t_attached_messages.attachable_item_id, t_attachable_items.url attached_item_url,
t_attachable_items.size attached_item_size, t_attachable_items.mime_type_id attached_item_mime_type_id,
t_attachable_items.owner_id attached_item_owner_id, t_attachable_items.from_outer attached_item_from_outer
FROM t_attached_messages
LEFT JOIN t_attachable_items ON t_attached_messages.attachable_item_id = t_attachable_items.attachable_item_id
WHERE message_id IN (
	SELECT message_id FROM t_messages WHERE chat_room_id = ANY($1::uuid[])
)
ORDER BY
	t_attached_messages_pkey ASC
`

type GetPluralAttachedItemsOnChatRoomRow struct {
	TAttachedMessagesPkey  pgtype.Int8   `json:"t_attached_messages_pkey"`
	AttachedMessageID      uuid.UUID     `json:"attached_message_id"`
	MessageID              uuid.UUID     `json:"message_id"`
	AttachableItemID       pgtype.UUID   `json:"attachable_item_id"`
	AttachedItemUrl        pgtype.Text   `json:"attached_item_url"`
	AttachedItemSize       pgtype.Float8 `json:"attached_item_size"`
	AttachedItemMimeTypeID pgtype.UUID   `json:"attached_item_mime_type_id"`
	AttachedItemOwnerID    pgtype.UUID   `json:"attached_item_owner_id"`
	AttachedItemFromOuter  pgtype.Bool   `json:"attached_item_from_outer"`
}

func (q *Queries) GetPluralAttachedItemsOnChatRoom(ctx context.Context, chatRoomIds []uuid.UUID) ([]GetPluralAttachedItemsOnChatRoomRow, error) {
	rows, err := q.db.Query(ctx, getPluralAttachedItemsOnChatRoom, chatRoomIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralAttachedItemsOnChatRoomRow{}
	for rows.Next() {
		var i GetPluralAttachedItemsOnChatRoomRow
		if err := rows.Scan(
			&i.TAttachedMessagesPkey,
			&i.AttachedMessageID,
			&i.MessageID,
			&i.AttachableItemID,
			&i.AttachedItemUrl,
			&i.AttachedItemSize,
			&i.AttachedItemMimeTypeID,
			&i.AttachedItemOwnerID,
			&i.AttachedItemFromOuter,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralAttachedItemsOnChatRoomUseNumberedPaginate = `-- name: GetPluralAttachedItemsOnChatRoomUseNumberedPaginate :many
SELECT t_attached_messages.t_attached_messages_pkey, t_attached_messages.attached_message_id, t_attached_messages.message_id, t_attached_messages.attachable_item_id, t_attachable_items.url attached_item_url,
t_attachable_items.size attached_item_size, t_attachable_items.mime_type_id attached_item_mime_type_id,
t_attachable_items.owner_id attached_item_owner_id, t_attachable_items.from_outer attached_item_from_outer
FROM t_attached_messages
LEFT JOIN t_attachable_items ON t_attached_messages.attachable_item_id = t_attachable_items.attachable_item_id
WHERE message_id IN (
	SELECT message_id FROM t_messages WHERE chat_room_id = ANY($3::uuid[])
)
ORDER BY
	t_attached_messages_pkey ASC
LIMIT $1 OFFSET $2
`

type GetPluralAttachedItemsOnChatRoomUseNumberedPaginateParams struct {
	Limit       int32       `json:"limit"`
	Offset      int32       `json:"offset"`
	ChatRoomIds []uuid.UUID `json:"chat_room_ids"`
}

type GetPluralAttachedItemsOnChatRoomUseNumberedPaginateRow struct {
	TAttachedMessagesPkey  pgtype.Int8   `json:"t_attached_messages_pkey"`
	AttachedMessageID      uuid.UUID     `json:"attached_message_id"`
	MessageID              uuid.UUID     `json:"message_id"`
	AttachableItemID       pgtype.UUID   `json:"attachable_item_id"`
	AttachedItemUrl        pgtype.Text   `json:"attached_item_url"`
	AttachedItemSize       pgtype.Float8 `json:"attached_item_size"`
	AttachedItemMimeTypeID pgtype.UUID   `json:"attached_item_mime_type_id"`
	AttachedItemOwnerID    pgtype.UUID   `json:"attached_item_owner_id"`
	AttachedItemFromOuter  pgtype.Bool   `json:"attached_item_from_outer"`
}

func (q *Queries) GetPluralAttachedItemsOnChatRoomUseNumberedPaginate(ctx context.Context, arg GetPluralAttachedItemsOnChatRoomUseNumberedPaginateParams) ([]GetPluralAttachedItemsOnChatRoomUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getPluralAttachedItemsOnChatRoomUseNumberedPaginate, arg.Limit, arg.Offset, arg.ChatRoomIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralAttachedItemsOnChatRoomUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetPluralAttachedItemsOnChatRoomUseNumberedPaginateRow
		if err := rows.Scan(
			&i.TAttachedMessagesPkey,
			&i.AttachedMessageID,
			&i.MessageID,
			&i.AttachableItemID,
			&i.AttachedItemUrl,
			&i.AttachedItemSize,
			&i.AttachedItemMimeTypeID,
			&i.AttachedItemOwnerID,
			&i.AttachedItemFromOuter,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralAttachedItemsOnMessage = `-- name: GetPluralAttachedItemsOnMessage :many
SELECT t_attached_messages.t_attached_messages_pkey, t_attached_messages.attached_message_id, t_attached_messages.message_id, t_attached_messages.attachable_item_id, t_attachable_items.url attached_item_url,
t_attachable_items.size attached_item_size, t_attachable_items.mime_type_id attached_item_mime_type_id,
t_attachable_items.owner_id attached_item_owner_id, t_attachable_items.from_outer attached_item_from_outer
FROM t_attached_messages
LEFT JOIN t_attachable_items ON t_attached_messages.attachable_item_id = t_attachable_items.attachable_item_id
WHERE message_id = ANY($1::uuid[])
ORDER BY
	t_attached_messages_pkey ASC
`

type GetPluralAttachedItemsOnMessageRow struct {
	TAttachedMessagesPkey  pgtype.Int8   `json:"t_attached_messages_pkey"`
	AttachedMessageID      uuid.UUID     `json:"attached_message_id"`
	MessageID              uuid.UUID     `json:"message_id"`
	AttachableItemID       pgtype.UUID   `json:"attachable_item_id"`
	AttachedItemUrl        pgtype.Text   `json:"attached_item_url"`
	AttachedItemSize       pgtype.Float8 `json:"attached_item_size"`
	AttachedItemMimeTypeID pgtype.UUID   `json:"attached_item_mime_type_id"`
	AttachedItemOwnerID    pgtype.UUID   `json:"attached_item_owner_id"`
	AttachedItemFromOuter  pgtype.Bool   `json:"attached_item_from_outer"`
}

func (q *Queries) GetPluralAttachedItemsOnMessage(ctx context.Context, messageIds []uuid.UUID) ([]GetPluralAttachedItemsOnMessageRow, error) {
	rows, err := q.db.Query(ctx, getPluralAttachedItemsOnMessage, messageIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralAttachedItemsOnMessageRow{}
	for rows.Next() {
		var i GetPluralAttachedItemsOnMessageRow
		if err := rows.Scan(
			&i.TAttachedMessagesPkey,
			&i.AttachedMessageID,
			&i.MessageID,
			&i.AttachableItemID,
			&i.AttachedItemUrl,
			&i.AttachedItemSize,
			&i.AttachedItemMimeTypeID,
			&i.AttachedItemOwnerID,
			&i.AttachedItemFromOuter,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralAttachedItemsOnMessageUseNumberedPaginate = `-- name: GetPluralAttachedItemsOnMessageUseNumberedPaginate :many
SELECT t_attached_messages.t_attached_messages_pkey, t_attached_messages.attached_message_id, t_attached_messages.message_id, t_attached_messages.attachable_item_id, t_attachable_items.url attached_item_url,
t_attachable_items.size attached_item_size, t_attachable_items.mime_type_id attached_item_mime_type_id,
t_attachable_items.owner_id attached_item_owner_id, t_attachable_items.from_outer attached_item_from_outer
FROM t_attached_messages
LEFT JOIN t_attachable_items ON t_attached_messages.attachable_item_id = t_attachable_items.attachable_item_id
WHERE message_id = ANY($3::uuid[])
ORDER BY
	t_attached_messages_pkey ASC
LIMIT $1 OFFSET $2
`

type GetPluralAttachedItemsOnMessageUseNumberedPaginateParams struct {
	Limit      int32       `json:"limit"`
	Offset     int32       `json:"offset"`
	MessageIds []uuid.UUID `json:"message_ids"`
}

type GetPluralAttachedItemsOnMessageUseNumberedPaginateRow struct {
	TAttachedMessagesPkey  pgtype.Int8   `json:"t_attached_messages_pkey"`
	AttachedMessageID      uuid.UUID     `json:"attached_message_id"`
	MessageID              uuid.UUID     `json:"message_id"`
	AttachableItemID       pgtype.UUID   `json:"attachable_item_id"`
	AttachedItemUrl        pgtype.Text   `json:"attached_item_url"`
	AttachedItemSize       pgtype.Float8 `json:"attached_item_size"`
	AttachedItemMimeTypeID pgtype.UUID   `json:"attached_item_mime_type_id"`
	AttachedItemOwnerID    pgtype.UUID   `json:"attached_item_owner_id"`
	AttachedItemFromOuter  pgtype.Bool   `json:"attached_item_from_outer"`
}

func (q *Queries) GetPluralAttachedItemsOnMessageUseNumberedPaginate(ctx context.Context, arg GetPluralAttachedItemsOnMessageUseNumberedPaginateParams) ([]GetPluralAttachedItemsOnMessageUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getPluralAttachedItemsOnMessageUseNumberedPaginate, arg.Limit, arg.Offset, arg.MessageIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralAttachedItemsOnMessageUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetPluralAttachedItemsOnMessageUseNumberedPaginateRow
		if err := rows.Scan(
			&i.TAttachedMessagesPkey,
			&i.AttachedMessageID,
			&i.MessageID,
			&i.AttachableItemID,
			&i.AttachedItemUrl,
			&i.AttachedItemSize,
			&i.AttachedItemMimeTypeID,
			&i.AttachedItemOwnerID,
			&i.AttachedItemFromOuter,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralAttachedItemsOnMessageWithMimeType = `-- name: GetPluralAttachedItemsOnMessageWithMimeType :many
SELECT t_attached_messages.t_attached_messages_pkey, t_attached_messages.attached_message_id, t_attached_messages.message_id, t_attached_messages.attachable_item_id, t_attachable_items.url attached_item_url,
t_attachable_items.size attached_item_size, t_attachable_items.mime_type_id attached_item_mime_type_id,
t_attachable_items.owner_id attached_item_owner_id, t_attachable_items.from_outer attached_item_from_outer,
m_mime_types.name mime_type_name, m_mime_types.key mime_type_key, m_mime_types.kind mime_type_kind
FROM t_attached_messages
LEFT JOIN t_attachable_items ON t_attached_messages.attachable_item_id = t_attachable_items.attachable_item_id
LEFT JOIN m_mime_types ON t_attachable_items.mime_type_id = m_mime_types.mime_type_id
WHERE message_id = ANY($1::uuid[])
ORDER BY
	t_attached_messages_pkey ASC
`

type GetPluralAttachedItemsOnMessageWithMimeTypeRow struct {
	TAttachedMessagesPkey  pgtype.Int8   `json:"t_attached_messages_pkey"`
	AttachedMessageID      uuid.UUID     `json:"attached_message_id"`
	MessageID              uuid.UUID     `json:"message_id"`
	AttachableItemID       pgtype.UUID   `json:"attachable_item_id"`
	AttachedItemUrl        pgtype.Text   `json:"attached_item_url"`
	AttachedItemSize       pgtype.Float8 `json:"attached_item_size"`
	AttachedItemMimeTypeID pgtype.UUID   `json:"attached_item_mime_type_id"`
	AttachedItemOwnerID    pgtype.UUID   `json:"attached_item_owner_id"`
	AttachedItemFromOuter  pgtype.Bool   `json:"attached_item_from_outer"`
	MimeTypeName           pgtype.Text   `json:"mime_type_name"`
	MimeTypeKey            pgtype.Text   `json:"mime_type_key"`
	MimeTypeKind           pgtype.Text   `json:"mime_type_kind"`
}

func (q *Queries) GetPluralAttachedItemsOnMessageWithMimeType(ctx context.Context, messageIds []uuid.UUID) ([]GetPluralAttachedItemsOnMessageWithMimeTypeRow, error) {
	rows, err := q.db.Query(ctx, getPluralAttachedItemsOnMessageWithMimeType, messageIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralAttachedItemsOnMessageWithMimeTypeRow{}
	for rows.Next() {
		var i GetPluralAttachedItemsOnMessageWithMimeTypeRow
		if err := rows.Scan(
			&i.TAttachedMessagesPkey,
			&i.AttachedMessageID,
			&i.MessageID,
			&i.AttachableItemID,
			&i.AttachedItemUrl,
			&i.AttachedItemSize,
			&i.AttachedItemMimeTypeID,
			&i.AttachedItemOwnerID,
			&i.AttachedItemFromOuter,
			&i.MimeTypeName,
			&i.MimeTypeKey,
			&i.MimeTypeKind,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralAttachedItemsOnMessageWithMimeTypeUseNumberedPaginate = `-- name: GetPluralAttachedItemsOnMessageWithMimeTypeUseNumberedPaginate :many
SELECT t_attached_messages.t_attached_messages_pkey, t_attached_messages.attached_message_id, t_attached_messages.message_id, t_attached_messages.attachable_item_id, t_attachable_items.url attached_item_url,
t_attachable_items.size attached_item_size, t_attachable_items.mime_type_id attached_item_mime_type_id,
t_attachable_items.owner_id attached_item_owner_id, t_attachable_items.from_outer attached_item_from_outer,
m_mime_types.name mime_type_name, m_mime_types.key mime_type_key, m_mime_types.kind mime_type_kind
FROM t_attached_messages
LEFT JOIN t_attachable_items ON t_attached_messages.attachable_item_id = t_attachable_items.attachable_item_id
LEFT JOIN m_mime_types ON t_attachable_items.mime_type_id = m_mime_types.mime_type_id
WHERE message_id = ANY($3::uuid[])
ORDER BY
	t_attached_messages_pkey ASC
LIMIT $1 OFFSET $2
`

type GetPluralAttachedItemsOnMessageWithMimeTypeUseNumberedPaginateParams struct {
	Limit      int32       `json:"limit"`
	Offset     int32       `json:"offset"`
	MessageIds []uuid.UUID `json:"message_ids"`
}

type GetPluralAttachedItemsOnMessageWithMimeTypeUseNumberedPaginateRow struct {
	TAttachedMessagesPkey  pgtype.Int8   `json:"t_attached_messages_pkey"`
	AttachedMessageID      uuid.UUID     `json:"attached_message_id"`
	MessageID              uuid.UUID     `json:"message_id"`
	AttachableItemID       pgtype.UUID   `json:"attachable_item_id"`
	AttachedItemUrl        pgtype.Text   `json:"attached_item_url"`
	AttachedItemSize       pgtype.Float8 `json:"attached_item_size"`
	AttachedItemMimeTypeID pgtype.UUID   `json:"attached_item_mime_type_id"`
	AttachedItemOwnerID    pgtype.UUID   `json:"attached_item_owner_id"`
	AttachedItemFromOuter  pgtype.Bool   `json:"attached_item_from_outer"`
	MimeTypeName           pgtype.Text   `json:"mime_type_name"`
	MimeTypeKey            pgtype.Text   `json:"mime_type_key"`
	MimeTypeKind           pgtype.Text   `json:"mime_type_kind"`
}

func (q *Queries) GetPluralAttachedItemsOnMessageWithMimeTypeUseNumberedPaginate(ctx context.Context, arg GetPluralAttachedItemsOnMessageWithMimeTypeUseNumberedPaginateParams) ([]GetPluralAttachedItemsOnMessageWithMimeTypeUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getPluralAttachedItemsOnMessageWithMimeTypeUseNumberedPaginate, arg.Limit, arg.Offset, arg.MessageIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralAttachedItemsOnMessageWithMimeTypeUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetPluralAttachedItemsOnMessageWithMimeTypeUseNumberedPaginateRow
		if err := rows.Scan(
			&i.TAttachedMessagesPkey,
			&i.AttachedMessageID,
			&i.MessageID,
			&i.AttachableItemID,
			&i.AttachedItemUrl,
			&i.AttachedItemSize,
			&i.AttachedItemMimeTypeID,
			&i.AttachedItemOwnerID,
			&i.AttachedItemFromOuter,
			&i.MimeTypeName,
			&i.MimeTypeKey,
			&i.MimeTypeKind,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
