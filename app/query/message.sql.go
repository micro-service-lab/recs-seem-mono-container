// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: message.sql

package query

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countMessages = `-- name: CountMessages :one
SELECT COUNT(*) FROM t_messages
WHERE
	CASE WHEN $1::boolean = true THEN chat_room_id = ANY($2) ELSE TRUE END
AND
	CASE WHEN $3::boolean = true THEN sender_id = ANY($4) ELSE TRUE END
`

type CountMessagesParams struct {
	WhereInChatRoom bool        `json:"where_in_chat_room"`
	InChatRoom      uuid.UUID   `json:"in_chat_room"`
	WhereInSender   bool        `json:"where_in_sender"`
	InSender        pgtype.UUID `json:"in_sender"`
}

func (q *Queries) CountMessages(ctx context.Context, arg CountMessagesParams) (int64, error) {
	row := q.db.QueryRow(ctx, countMessages,
		arg.WhereInChatRoom,
		arg.InChatRoom,
		arg.WhereInSender,
		arg.InSender,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createMessage = `-- name: CreateMessage :one
INSERT INTO t_messages (chat_room_id, sender_id, body, posted_at, last_edited_at) VALUES ($1, $2, $3, $4, $5) RETURNING t_messages_pkey, message_id, chat_room_id, sender_id, body, posted_at, last_edited_at
`

type CreateMessageParams struct {
	ChatRoomID   uuid.UUID   `json:"chat_room_id"`
	SenderID     pgtype.UUID `json:"sender_id"`
	Body         string      `json:"body"`
	PostedAt     time.Time   `json:"posted_at"`
	LastEditedAt time.Time   `json:"last_edited_at"`
}

func (q *Queries) CreateMessage(ctx context.Context, arg CreateMessageParams) (Message, error) {
	row := q.db.QueryRow(ctx, createMessage,
		arg.ChatRoomID,
		arg.SenderID,
		arg.Body,
		arg.PostedAt,
		arg.LastEditedAt,
	)
	var i Message
	err := row.Scan(
		&i.TMessagesPkey,
		&i.MessageID,
		&i.ChatRoomID,
		&i.SenderID,
		&i.Body,
		&i.PostedAt,
		&i.LastEditedAt,
	)
	return i, err
}

type CreateMessagesParams struct {
	ChatRoomID   uuid.UUID   `json:"chat_room_id"`
	SenderID     pgtype.UUID `json:"sender_id"`
	Body         string      `json:"body"`
	PostedAt     time.Time   `json:"posted_at"`
	LastEditedAt time.Time   `json:"last_edited_at"`
}

const deleteMessage = `-- name: DeleteMessage :exec
DELETE FROM t_messages WHERE message_id = $1
`

func (q *Queries) DeleteMessage(ctx context.Context, messageID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteMessage, messageID)
	return err
}

const findMessageByID = `-- name: FindMessageByID :one
SELECT t_messages_pkey, message_id, chat_room_id, sender_id, body, posted_at, last_edited_at FROM t_messages WHERE message_id = $1
`

func (q *Queries) FindMessageByID(ctx context.Context, messageID uuid.UUID) (Message, error) {
	row := q.db.QueryRow(ctx, findMessageByID, messageID)
	var i Message
	err := row.Scan(
		&i.TMessagesPkey,
		&i.MessageID,
		&i.ChatRoomID,
		&i.SenderID,
		&i.Body,
		&i.PostedAt,
		&i.LastEditedAt,
	)
	return i, err
}

const findMessageByIDWithSender = `-- name: FindMessageByIDWithSender :one
SELECT t_messages.t_messages_pkey, t_messages.message_id, t_messages.chat_room_id, t_messages.sender_id, t_messages.body, t_messages.posted_at, t_messages.last_edited_at, m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at FROM t_messages
INNER JOIN m_members ON t_messages.sender_id = m_members.member_id
WHERE message_id = $1
`

type FindMessageByIDWithSenderRow struct {
	Message Message `json:"message"`
	Member  Member  `json:"member"`
}

func (q *Queries) FindMessageByIDWithSender(ctx context.Context, messageID uuid.UUID) (FindMessageByIDWithSenderRow, error) {
	row := q.db.QueryRow(ctx, findMessageByIDWithSender, messageID)
	var i FindMessageByIDWithSenderRow
	err := row.Scan(
		&i.Message.TMessagesPkey,
		&i.Message.MessageID,
		&i.Message.ChatRoomID,
		&i.Message.SenderID,
		&i.Message.Body,
		&i.Message.PostedAt,
		&i.Message.LastEditedAt,
		&i.Member.MMembersPkey,
		&i.Member.MemberID,
		&i.Member.LoginID,
		&i.Member.Password,
		&i.Member.Email,
		&i.Member.Name,
		&i.Member.AttendStatusID,
		&i.Member.ProfileImageID,
		&i.Member.GradeID,
		&i.Member.GroupID,
		&i.Member.PersonalOrganizationID,
		&i.Member.RoleID,
		&i.Member.CreatedAt,
		&i.Member.UpdatedAt,
	)
	return i, err
}

const getMessages = `-- name: GetMessages :many
SELECT t_messages_pkey, message_id, chat_room_id, sender_id, body, posted_at, last_edited_at FROM t_messages
WHERE
	CASE WHEN $3::boolean = true THEN chat_room_id = ANY($4) ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN sender_id = ANY($6) ELSE TRUE END
ORDER BY
	CASE WHEN $7::text = 'posted_at' THEN posted_at END ASC,
	CASE WHEN $7::text = 'r_posted_at' THEN posted_at END DESC,
	CASE WHEN $7::text = 'last_edited_at' THEN last_edited_at END ASC,
	CASE WHEN $7::text = 'r_last_edited_at' THEN last_edited_at END DESC,
	t_messages_pkey DESC
LIMIT $1 OFFSET $2
`

type GetMessagesParams struct {
	Limit           int32       `json:"limit"`
	Offset          int32       `json:"offset"`
	WhereInChatRoom bool        `json:"where_in_chat_room"`
	InChatRoom      uuid.UUID   `json:"in_chat_room"`
	WhereInSender   bool        `json:"where_in_sender"`
	InSender        pgtype.UUID `json:"in_sender"`
	OrderMethod     string      `json:"order_method"`
}

func (q *Queries) GetMessages(ctx context.Context, arg GetMessagesParams) ([]Message, error) {
	rows, err := q.db.Query(ctx, getMessages,
		arg.Limit,
		arg.Offset,
		arg.WhereInChatRoom,
		arg.InChatRoom,
		arg.WhereInSender,
		arg.InSender,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Message{}
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.TMessagesPkey,
			&i.MessageID,
			&i.ChatRoomID,
			&i.SenderID,
			&i.Body,
			&i.PostedAt,
			&i.LastEditedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMessage = `-- name: UpdateMessage :one
UPDATE t_messages SET chat_room_id = $2, sender_id = $3, body = $4, posted_at = $5, last_edited_at = $6 WHERE message_id = $1 RETURNING t_messages_pkey, message_id, chat_room_id, sender_id, body, posted_at, last_edited_at
`

type UpdateMessageParams struct {
	MessageID    uuid.UUID   `json:"message_id"`
	ChatRoomID   uuid.UUID   `json:"chat_room_id"`
	SenderID     pgtype.UUID `json:"sender_id"`
	Body         string      `json:"body"`
	PostedAt     time.Time   `json:"posted_at"`
	LastEditedAt time.Time   `json:"last_edited_at"`
}

func (q *Queries) UpdateMessage(ctx context.Context, arg UpdateMessageParams) (Message, error) {
	row := q.db.QueryRow(ctx, updateMessage,
		arg.MessageID,
		arg.ChatRoomID,
		arg.SenderID,
		arg.Body,
		arg.PostedAt,
		arg.LastEditedAt,
	)
	var i Message
	err := row.Scan(
		&i.TMessagesPkey,
		&i.MessageID,
		&i.ChatRoomID,
		&i.SenderID,
		&i.Body,
		&i.PostedAt,
		&i.LastEditedAt,
	)
	return i, err
}
