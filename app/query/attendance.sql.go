// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: attendance.sql

package query

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countAttendances = `-- name: CountAttendances :one
SELECT COUNT(*) FROM t_attendances
WHERE
	CASE WHEN $1::boolean = true THEN t_attendances.attendance_type_id = ANY($2) ELSE TRUE END
AND
	CASE WHEN $3::boolean = true THEN t_attendances.member_id = ANY($4) ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN t_attendances.date >= $6 ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN t_attendances.date <= $8 ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN t_attendances.mail_send_flag = $10 ELSE TRUE END
AND
	CASE WHEN $11::boolean = true THEN t_attendances.send_organization_id = ANY($12) ELSE TRUE END
`

type CountAttendancesParams struct {
	WhereInAttendanceType   bool        `json:"where_in_attendance_type"`
	InAttendanceType        uuid.UUID   `json:"in_attendance_type"`
	WhereInMember           bool        `json:"where_in_member"`
	InMember                uuid.UUID   `json:"in_member"`
	WhereEarlierDate        bool        `json:"where_earlier_date"`
	EarlierDate             pgtype.Date `json:"earlier_date"`
	WhereLaterDate          bool        `json:"where_later_date"`
	LaterDate               pgtype.Date `json:"later_date"`
	WhereMailSendFlag       bool        `json:"where_mail_send_flag"`
	MailSendFlag            bool        `json:"mail_send_flag"`
	WhereInSendOrganization bool        `json:"where_in_send_organization"`
	InSendOrganization      pgtype.UUID `json:"in_send_organization"`
}

func (q *Queries) CountAttendances(ctx context.Context, arg CountAttendancesParams) (int64, error) {
	row := q.db.QueryRow(ctx, countAttendances,
		arg.WhereInAttendanceType,
		arg.InAttendanceType,
		arg.WhereInMember,
		arg.InMember,
		arg.WhereEarlierDate,
		arg.EarlierDate,
		arg.WhereLaterDate,
		arg.LaterDate,
		arg.WhereMailSendFlag,
		arg.MailSendFlag,
		arg.WhereInSendOrganization,
		arg.InSendOrganization,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAttendance = `-- name: CreateAttendance :one
INSERT INTO t_attendances (attendance_type_id, member_id, description, date, mail_send_flag, send_organization_id, posted_at, last_edited_at) VALUES ($1, $2, $3, $4, $5, $6, $7, $8) RETURNING t_attendances_pkey, attendance_id, attendance_type_id, member_id, description, date, mail_send_flag, send_organization_id, posted_at, last_edited_at
`

type CreateAttendanceParams struct {
	AttendanceTypeID   uuid.UUID   `json:"attendance_type_id"`
	MemberID           uuid.UUID   `json:"member_id"`
	Description        string      `json:"description"`
	Date               pgtype.Date `json:"date"`
	MailSendFlag       bool        `json:"mail_send_flag"`
	SendOrganizationID pgtype.UUID `json:"send_organization_id"`
	PostedAt           time.Time   `json:"posted_at"`
	LastEditedAt       time.Time   `json:"last_edited_at"`
}

func (q *Queries) CreateAttendance(ctx context.Context, arg CreateAttendanceParams) (Attendance, error) {
	row := q.db.QueryRow(ctx, createAttendance,
		arg.AttendanceTypeID,
		arg.MemberID,
		arg.Description,
		arg.Date,
		arg.MailSendFlag,
		arg.SendOrganizationID,
		arg.PostedAt,
		arg.LastEditedAt,
	)
	var i Attendance
	err := row.Scan(
		&i.TAttendancesPkey,
		&i.AttendanceID,
		&i.AttendanceTypeID,
		&i.MemberID,
		&i.Description,
		&i.Date,
		&i.MailSendFlag,
		&i.SendOrganizationID,
		&i.PostedAt,
		&i.LastEditedAt,
	)
	return i, err
}

type CreateAttendancesParams struct {
	AttendanceTypeID   uuid.UUID   `json:"attendance_type_id"`
	MemberID           uuid.UUID   `json:"member_id"`
	Description        string      `json:"description"`
	Date               pgtype.Date `json:"date"`
	MailSendFlag       bool        `json:"mail_send_flag"`
	SendOrganizationID pgtype.UUID `json:"send_organization_id"`
	PostedAt           time.Time   `json:"posted_at"`
	LastEditedAt       time.Time   `json:"last_edited_at"`
}

const deleteAttendance = `-- name: DeleteAttendance :exec
DELETE FROM t_attendances WHERE attendance_id = $1
`

func (q *Queries) DeleteAttendance(ctx context.Context, attendanceID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteAttendance, attendanceID)
	return err
}

const deleteAttendancesOnMember = `-- name: DeleteAttendancesOnMember :exec
DELETE FROM t_attendances WHERE member_id = $1
`

func (q *Queries) DeleteAttendancesOnMember(ctx context.Context, memberID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteAttendancesOnMember, memberID)
	return err
}

const deleteAttendancesOnMembers = `-- name: DeleteAttendancesOnMembers :exec
DELETE FROM t_attendances WHERE member_id = ANY($1::uuid[])
`

func (q *Queries) DeleteAttendancesOnMembers(ctx context.Context, dollar_1 []uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteAttendancesOnMembers, dollar_1)
	return err
}

const findAttendanceByID = `-- name: FindAttendanceByID :one
SELECT t_attendances_pkey, attendance_id, attendance_type_id, member_id, description, date, mail_send_flag, send_organization_id, posted_at, last_edited_at FROM t_attendances WHERE attendance_id = $1
`

func (q *Queries) FindAttendanceByID(ctx context.Context, attendanceID uuid.UUID) (Attendance, error) {
	row := q.db.QueryRow(ctx, findAttendanceByID, attendanceID)
	var i Attendance
	err := row.Scan(
		&i.TAttendancesPkey,
		&i.AttendanceID,
		&i.AttendanceTypeID,
		&i.MemberID,
		&i.Description,
		&i.Date,
		&i.MailSendFlag,
		&i.SendOrganizationID,
		&i.PostedAt,
		&i.LastEditedAt,
	)
	return i, err
}

const findAttendanceByIDWithAll = `-- name: FindAttendanceByIDWithAll :one
SELECT t_attendances.t_attendances_pkey, t_attendances.attendance_id, t_attendances.attendance_type_id, t_attendances.member_id, t_attendances.description, t_attendances.date, t_attendances.mail_send_flag, t_attendances.send_organization_id, t_attendances.posted_at, t_attendances.last_edited_at, m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_url, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_attendance_types.attendance_type_id, m_attendance_types.name as attendance_type_name, m_attendance_types.key as attendance_type_key, m_attendance_types.color as attendance_type_color, m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.color, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at, m_organizations.chat_room_id, t_early_leavings.t_early_leavings_pkey, t_early_leavings.early_leaving_id, t_early_leavings.attendance_id, t_early_leavings.leave_time, t_late_arrivals.t_late_arrivals_pkey, t_late_arrivals.late_arrival_id, t_late_arrivals.attendance_id, t_late_arrivals.arrive_time, t_absences.t_absences_pkey, t_absences.absence_id, t_absences.attendance_id FROM t_attendances
LEFT JOIN m_members ON t_attendances.member_id = m_members.member_id
LEFT JOIN m_attend_statuses ON m_members.attend_status_id = m_attend_statuses.attend_status_id
LEFT JOIN m_grades ON m_members.grade_id = m_grades.grade_id
LEFT JOIN m_groups ON m_members.group_id = m_groups.group_id
LEFT JOIN m_attendance_types ON t_attendances.attendance_type_id = m_attendance_types.attendance_type_id
LEFT JOIN m_organizations ON t_attendances.send_organization_id = m_organizations.organization_id
LEFT JOIN t_early_leavings ON t_attendances.attendance_id = t_early_leavings.attendance_id
LEFT JOIN t_late_arrivals ON t_attendances.attendance_id = t_late_arrivals.attendance_id
LEFT JOIN t_absences ON t_attendances.attendance_id = t_absences.attendance_id
WHERE t_attendances.attendance_id = $1
`

type FindAttendanceByIDWithAllRow struct {
	TAttendancesPkey    pgtype.Int8  `json:"t_attendances_pkey"`
	AttendanceID        uuid.UUID    `json:"attendance_id"`
	AttendanceTypeID    uuid.UUID    `json:"attendance_type_id"`
	MemberID            uuid.UUID    `json:"member_id"`
	Description         string       `json:"description"`
	Date                pgtype.Date  `json:"date"`
	MailSendFlag        bool         `json:"mail_send_flag"`
	SendOrganizationID  pgtype.UUID  `json:"send_organization_id"`
	PostedAt            time.Time    `json:"posted_at"`
	LastEditedAt        time.Time    `json:"last_edited_at"`
	Member              Member       `json:"member"`
	AttendanceTypeID_2  pgtype.UUID  `json:"attendance_type_id_2"`
	AttendanceTypeName  pgtype.Text  `json:"attendance_type_name"`
	AttendanceTypeKey   pgtype.Text  `json:"attendance_type_key"`
	AttendanceTypeColor pgtype.Text  `json:"attendance_type_color"`
	Organization        Organization `json:"organization"`
	EarlyLeaving        EarlyLeaving `json:"early_leaving"`
	LateArrival         LateArrival  `json:"late_arrival"`
	Absence             Absence      `json:"absence"`
}

func (q *Queries) FindAttendanceByIDWithAll(ctx context.Context, attendanceID uuid.UUID) (FindAttendanceByIDWithAllRow, error) {
	row := q.db.QueryRow(ctx, findAttendanceByIDWithAll, attendanceID)
	var i FindAttendanceByIDWithAllRow
	err := row.Scan(
		&i.TAttendancesPkey,
		&i.AttendanceID,
		&i.AttendanceTypeID,
		&i.MemberID,
		&i.Description,
		&i.Date,
		&i.MailSendFlag,
		&i.SendOrganizationID,
		&i.PostedAt,
		&i.LastEditedAt,
		&i.Member.MMembersPkey,
		&i.Member.MemberID,
		&i.Member.LoginID,
		&i.Member.Password,
		&i.Member.Email,
		&i.Member.Name,
		&i.Member.AttendStatusID,
		&i.Member.ProfileImageUrl,
		&i.Member.GradeID,
		&i.Member.GroupID,
		&i.Member.PersonalOrganizationID,
		&i.Member.RoleID,
		&i.Member.CreatedAt,
		&i.Member.UpdatedAt,
		&i.AttendanceTypeID_2,
		&i.AttendanceTypeName,
		&i.AttendanceTypeKey,
		&i.AttendanceTypeColor,
		&i.Organization.MOrganizationsPkey,
		&i.Organization.OrganizationID,
		&i.Organization.Name,
		&i.Organization.Description,
		&i.Organization.Color,
		&i.Organization.IsPersonal,
		&i.Organization.IsWhole,
		&i.Organization.CreatedAt,
		&i.Organization.UpdatedAt,
		&i.Organization.ChatRoomID,
		&i.EarlyLeaving.TEarlyLeavingsPkey,
		&i.EarlyLeaving.EarlyLeavingID,
		&i.EarlyLeaving.AttendanceID,
		&i.EarlyLeaving.LeaveTime,
		&i.LateArrival.TLateArrivalsPkey,
		&i.LateArrival.LateArrivalID,
		&i.LateArrival.AttendanceID,
		&i.LateArrival.ArriveTime,
		&i.Absence.TAbsencesPkey,
		&i.Absence.AbsenceID,
		&i.Absence.AttendanceID,
	)
	return i, err
}

const findAttendanceByIDWithAttendanceType = `-- name: FindAttendanceByIDWithAttendanceType :one
SELECT t_attendances.t_attendances_pkey, t_attendances.attendance_id, t_attendances.attendance_type_id, t_attendances.member_id, t_attendances.description, t_attendances.date, t_attendances.mail_send_flag, t_attendances.send_organization_id, t_attendances.posted_at, t_attendances.last_edited_at, m_attendance_types.attendance_type_id, m_attendance_types.name as attendance_type_name, m_attendance_types.key as attendance_type_key, m_attendance_types.color as attendance_type_color FROM t_attendances
LEFT JOIN m_attendance_types ON t_attendances.attendance_type_id = m_attendance_types.attendance_type_id
WHERE attendance_id = $1
`

type FindAttendanceByIDWithAttendanceTypeRow struct {
	TAttendancesPkey    pgtype.Int8 `json:"t_attendances_pkey"`
	AttendanceID        uuid.UUID   `json:"attendance_id"`
	AttendanceTypeID    uuid.UUID   `json:"attendance_type_id"`
	MemberID            uuid.UUID   `json:"member_id"`
	Description         string      `json:"description"`
	Date                pgtype.Date `json:"date"`
	MailSendFlag        bool        `json:"mail_send_flag"`
	SendOrganizationID  pgtype.UUID `json:"send_organization_id"`
	PostedAt            time.Time   `json:"posted_at"`
	LastEditedAt        time.Time   `json:"last_edited_at"`
	AttendanceTypeID_2  pgtype.UUID `json:"attendance_type_id_2"`
	AttendanceTypeName  pgtype.Text `json:"attendance_type_name"`
	AttendanceTypeKey   pgtype.Text `json:"attendance_type_key"`
	AttendanceTypeColor pgtype.Text `json:"attendance_type_color"`
}

func (q *Queries) FindAttendanceByIDWithAttendanceType(ctx context.Context, attendanceID uuid.UUID) (FindAttendanceByIDWithAttendanceTypeRow, error) {
	row := q.db.QueryRow(ctx, findAttendanceByIDWithAttendanceType, attendanceID)
	var i FindAttendanceByIDWithAttendanceTypeRow
	err := row.Scan(
		&i.TAttendancesPkey,
		&i.AttendanceID,
		&i.AttendanceTypeID,
		&i.MemberID,
		&i.Description,
		&i.Date,
		&i.MailSendFlag,
		&i.SendOrganizationID,
		&i.PostedAt,
		&i.LastEditedAt,
		&i.AttendanceTypeID_2,
		&i.AttendanceTypeName,
		&i.AttendanceTypeKey,
		&i.AttendanceTypeColor,
	)
	return i, err
}

const findAttendanceByIDWithDetails = `-- name: FindAttendanceByIDWithDetails :one
SELECT t_attendances.t_attendances_pkey, t_attendances.attendance_id, t_attendances.attendance_type_id, t_attendances.member_id, t_attendances.description, t_attendances.date, t_attendances.mail_send_flag, t_attendances.send_organization_id, t_attendances.posted_at, t_attendances.last_edited_at, t_early_leavings.t_early_leavings_pkey, t_early_leavings.early_leaving_id, t_early_leavings.attendance_id, t_early_leavings.leave_time, t_late_arrivals.t_late_arrivals_pkey, t_late_arrivals.late_arrival_id, t_late_arrivals.attendance_id, t_late_arrivals.arrive_time, t_absences.t_absences_pkey, t_absences.absence_id, t_absences.attendance_id FROM t_attendances
LEFT JOIN t_early_leavings ON t_attendances.attendance_id = t_early_leavings.attendance_id
LEFT JOIN t_late_arrivals ON t_attendances.attendance_id = t_late_arrivals.attendance_id
LEFT JOIN t_absences ON t_attendances.attendance_id = t_absences.attendance_id
WHERE t_attendances.attendance_id = $1
`

type FindAttendanceByIDWithDetailsRow struct {
	TAttendancesPkey   pgtype.Int8  `json:"t_attendances_pkey"`
	AttendanceID       uuid.UUID    `json:"attendance_id"`
	AttendanceTypeID   uuid.UUID    `json:"attendance_type_id"`
	MemberID           uuid.UUID    `json:"member_id"`
	Description        string       `json:"description"`
	Date               pgtype.Date  `json:"date"`
	MailSendFlag       bool         `json:"mail_send_flag"`
	SendOrganizationID pgtype.UUID  `json:"send_organization_id"`
	PostedAt           time.Time    `json:"posted_at"`
	LastEditedAt       time.Time    `json:"last_edited_at"`
	EarlyLeaving       EarlyLeaving `json:"early_leaving"`
	LateArrival        LateArrival  `json:"late_arrival"`
	Absence            Absence      `json:"absence"`
}

func (q *Queries) FindAttendanceByIDWithDetails(ctx context.Context, attendanceID uuid.UUID) (FindAttendanceByIDWithDetailsRow, error) {
	row := q.db.QueryRow(ctx, findAttendanceByIDWithDetails, attendanceID)
	var i FindAttendanceByIDWithDetailsRow
	err := row.Scan(
		&i.TAttendancesPkey,
		&i.AttendanceID,
		&i.AttendanceTypeID,
		&i.MemberID,
		&i.Description,
		&i.Date,
		&i.MailSendFlag,
		&i.SendOrganizationID,
		&i.PostedAt,
		&i.LastEditedAt,
		&i.EarlyLeaving.TEarlyLeavingsPkey,
		&i.EarlyLeaving.EarlyLeavingID,
		&i.EarlyLeaving.AttendanceID,
		&i.EarlyLeaving.LeaveTime,
		&i.LateArrival.TLateArrivalsPkey,
		&i.LateArrival.LateArrivalID,
		&i.LateArrival.AttendanceID,
		&i.LateArrival.ArriveTime,
		&i.Absence.TAbsencesPkey,
		&i.Absence.AbsenceID,
		&i.Absence.AttendanceID,
	)
	return i, err
}

const findAttendanceByIDWithMember = `-- name: FindAttendanceByIDWithMember :one
SELECT t_attendances.t_attendances_pkey, t_attendances.attendance_id, t_attendances.attendance_type_id, t_attendances.member_id, t_attendances.description, t_attendances.date, t_attendances.mail_send_flag, t_attendances.send_organization_id, t_attendances.posted_at, t_attendances.last_edited_at, m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_url, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at FROM t_attendances
LEFT JOIN m_members ON t_attendances.member_id = m_members.member_id
LEFT JOIN m_attend_statuses ON m_members.attend_status_id = m_attend_statuses.attend_status_id
LEFT JOIN m_grades ON m_members.grade_id = m_grades.grade_id
LEFT JOIN m_groups ON m_members.group_id = m_groups.group_id
WHERE attendance_id = $1
`

type FindAttendanceByIDWithMemberRow struct {
	TAttendancesPkey   pgtype.Int8 `json:"t_attendances_pkey"`
	AttendanceID       uuid.UUID   `json:"attendance_id"`
	AttendanceTypeID   uuid.UUID   `json:"attendance_type_id"`
	MemberID           uuid.UUID   `json:"member_id"`
	Description        string      `json:"description"`
	Date               pgtype.Date `json:"date"`
	MailSendFlag       bool        `json:"mail_send_flag"`
	SendOrganizationID pgtype.UUID `json:"send_organization_id"`
	PostedAt           time.Time   `json:"posted_at"`
	LastEditedAt       time.Time   `json:"last_edited_at"`
	Member             Member      `json:"member"`
}

func (q *Queries) FindAttendanceByIDWithMember(ctx context.Context, attendanceID uuid.UUID) (FindAttendanceByIDWithMemberRow, error) {
	row := q.db.QueryRow(ctx, findAttendanceByIDWithMember, attendanceID)
	var i FindAttendanceByIDWithMemberRow
	err := row.Scan(
		&i.TAttendancesPkey,
		&i.AttendanceID,
		&i.AttendanceTypeID,
		&i.MemberID,
		&i.Description,
		&i.Date,
		&i.MailSendFlag,
		&i.SendOrganizationID,
		&i.PostedAt,
		&i.LastEditedAt,
		&i.Member.MMembersPkey,
		&i.Member.MemberID,
		&i.Member.LoginID,
		&i.Member.Password,
		&i.Member.Email,
		&i.Member.Name,
		&i.Member.AttendStatusID,
		&i.Member.ProfileImageUrl,
		&i.Member.GradeID,
		&i.Member.GroupID,
		&i.Member.PersonalOrganizationID,
		&i.Member.RoleID,
		&i.Member.CreatedAt,
		&i.Member.UpdatedAt,
	)
	return i, err
}

const findAttendanceByIDWithSendOrganization = `-- name: FindAttendanceByIDWithSendOrganization :one
SELECT t_attendances.t_attendances_pkey, t_attendances.attendance_id, t_attendances.attendance_type_id, t_attendances.member_id, t_attendances.description, t_attendances.date, t_attendances.mail_send_flag, t_attendances.send_organization_id, t_attendances.posted_at, t_attendances.last_edited_at, m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.color, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at, m_organizations.chat_room_id FROM t_attendances
LEFT JOIN m_organizations ON t_attendances.send_organization_id = m_organizations.organization_id
WHERE attendance_id = $1
`

type FindAttendanceByIDWithSendOrganizationRow struct {
	TAttendancesPkey   pgtype.Int8  `json:"t_attendances_pkey"`
	AttendanceID       uuid.UUID    `json:"attendance_id"`
	AttendanceTypeID   uuid.UUID    `json:"attendance_type_id"`
	MemberID           uuid.UUID    `json:"member_id"`
	Description        string       `json:"description"`
	Date               pgtype.Date  `json:"date"`
	MailSendFlag       bool         `json:"mail_send_flag"`
	SendOrganizationID pgtype.UUID  `json:"send_organization_id"`
	PostedAt           time.Time    `json:"posted_at"`
	LastEditedAt       time.Time    `json:"last_edited_at"`
	Organization       Organization `json:"organization"`
}

func (q *Queries) FindAttendanceByIDWithSendOrganization(ctx context.Context, attendanceID uuid.UUID) (FindAttendanceByIDWithSendOrganizationRow, error) {
	row := q.db.QueryRow(ctx, findAttendanceByIDWithSendOrganization, attendanceID)
	var i FindAttendanceByIDWithSendOrganizationRow
	err := row.Scan(
		&i.TAttendancesPkey,
		&i.AttendanceID,
		&i.AttendanceTypeID,
		&i.MemberID,
		&i.Description,
		&i.Date,
		&i.MailSendFlag,
		&i.SendOrganizationID,
		&i.PostedAt,
		&i.LastEditedAt,
		&i.Organization.MOrganizationsPkey,
		&i.Organization.OrganizationID,
		&i.Organization.Name,
		&i.Organization.Description,
		&i.Organization.Color,
		&i.Organization.IsPersonal,
		&i.Organization.IsWhole,
		&i.Organization.CreatedAt,
		&i.Organization.UpdatedAt,
		&i.Organization.ChatRoomID,
	)
	return i, err
}

const getAttendanceUseKeysetPaginate = `-- name: GetAttendanceUseKeysetPaginate :many
SELECT t_attendances_pkey, attendance_id, attendance_type_id, member_id, description, date, mail_send_flag, send_organization_id, posted_at, last_edited_at FROM t_attendances
WHERE
	CASE WHEN $2::boolean = true THEN t_attendances.attendance_type_id = ANY($3) ELSE TRUE END
AND
	CASE WHEN $4::boolean = true THEN t_attendances.member_id = ANY($5) ELSE TRUE END
AND
	CASE WHEN $6::boolean = true THEN t_attendances.date >= $7 ELSE TRUE END
AND
	CASE WHEN $8::boolean = true THEN t_attendances.date <= $9 ELSE TRUE END
AND
	CASE WHEN $10::boolean = true THEN t_attendances.mail_send_flag = $11 ELSE TRUE END
AND
	CASE WHEN $12::boolean = true THEN t_attendances.send_organization_id = ANY($13) ELSE TRUE END
AND
	CASE $14::text
		WHEN 'next' THEN
			CASE $15::text
				WHEN 'date' THEN date > $16 OR (date = $16 AND t_attendances_pkey > $17::int)
				WHEN 'r_date' THEN date < $16 OR (date = $16 AND t_attendances_pkey > $17::int)
				ELSE t_attendances_pkey > $17::int
			END
		WHEN 'prev' THEN
			CASE $15::text
				WHEN 'date' THEN date < $16 OR (date = $16 AND t_attendances_pkey < $17::int)
				WHEN 'r_date' THEN date > $16 OR (date = $16 AND t_attendances_pkey < $17::int)
				ELSE t_attendances_pkey < $17::int
			END
	END
ORDER BY
	CASE WHEN $15::text = 'date' AND $14::text = 'next' THEN date END ASC,
	CASE WHEN $15::text = 'date' AND $14::text = 'prev' THEN date END DESC,
	CASE WHEN $15::text = 'r_date' AND $14::text = 'next' THEN date END DESC,
	CASE WHEN $15::text = 'r_date' AND $14::text = 'prev' THEN date END ASC,
	CASE WHEN $14::text = 'next' THEN t_attendances_pkey END ASC,
	CASE WHEN $14::text = 'prev' THEN t_attendances_pkey END DESC
LIMIT $1
`

type GetAttendanceUseKeysetPaginateParams struct {
	Limit                   int32       `json:"limit"`
	WhereInAttendanceType   bool        `json:"where_in_attendance_type"`
	InAttendanceType        uuid.UUID   `json:"in_attendance_type"`
	WhereInMember           bool        `json:"where_in_member"`
	InMember                uuid.UUID   `json:"in_member"`
	WhereEarlierDate        bool        `json:"where_earlier_date"`
	EarlierDate             pgtype.Date `json:"earlier_date"`
	WhereLaterDate          bool        `json:"where_later_date"`
	LaterDate               pgtype.Date `json:"later_date"`
	WhereMailSendFlag       bool        `json:"where_mail_send_flag"`
	MailSendFlag            bool        `json:"mail_send_flag"`
	WhereInSendOrganization bool        `json:"where_in_send_organization"`
	InSendOrganization      pgtype.UUID `json:"in_send_organization"`
	CursorDirection         string      `json:"cursor_direction"`
	OrderMethod             string      `json:"order_method"`
	DateCursor              pgtype.Date `json:"date_cursor"`
	Cursor                  int32       `json:"cursor"`
}

func (q *Queries) GetAttendanceUseKeysetPaginate(ctx context.Context, arg GetAttendanceUseKeysetPaginateParams) ([]Attendance, error) {
	rows, err := q.db.Query(ctx, getAttendanceUseKeysetPaginate,
		arg.Limit,
		arg.WhereInAttendanceType,
		arg.InAttendanceType,
		arg.WhereInMember,
		arg.InMember,
		arg.WhereEarlierDate,
		arg.EarlierDate,
		arg.WhereLaterDate,
		arg.LaterDate,
		arg.WhereMailSendFlag,
		arg.MailSendFlag,
		arg.WhereInSendOrganization,
		arg.InSendOrganization,
		arg.CursorDirection,
		arg.OrderMethod,
		arg.DateCursor,
		arg.Cursor,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Attendance{}
	for rows.Next() {
		var i Attendance
		if err := rows.Scan(
			&i.TAttendancesPkey,
			&i.AttendanceID,
			&i.AttendanceTypeID,
			&i.MemberID,
			&i.Description,
			&i.Date,
			&i.MailSendFlag,
			&i.SendOrganizationID,
			&i.PostedAt,
			&i.LastEditedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAttendanceUseNumberedPaginate = `-- name: GetAttendanceUseNumberedPaginate :many
SELECT t_attendances_pkey, attendance_id, attendance_type_id, member_id, description, date, mail_send_flag, send_organization_id, posted_at, last_edited_at FROM t_attendances
WHERE
	CASE WHEN $3::boolean = true THEN t_attendances.attendance_type_id = ANY($4) ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN t_attendances.member_id = ANY($6) ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN t_attendances.date >= $8 ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN t_attendances.date <= $10 ELSE TRUE END
AND
	CASE WHEN $11::boolean = true THEN t_attendances.mail_send_flag = $12 ELSE TRUE END
AND
	CASE WHEN $13::boolean = true THEN t_attendances.send_organization_id = ANY($14) ELSE TRUE END
ORDER BY
	CASE WHEN $15::text = 'date' THEN t_attendances.date END ASC,
	CASE WHEN $15::text = 'r_date' THEN t_attendances.date END DESC,
	t_attendances_pkey ASC
LIMIT $1 OFFSET $2
`

type GetAttendanceUseNumberedPaginateParams struct {
	Limit                   int32       `json:"limit"`
	Offset                  int32       `json:"offset"`
	WhereInAttendanceType   bool        `json:"where_in_attendance_type"`
	InAttendanceType        uuid.UUID   `json:"in_attendance_type"`
	WhereInMember           bool        `json:"where_in_member"`
	InMember                uuid.UUID   `json:"in_member"`
	WhereEarlierDate        bool        `json:"where_earlier_date"`
	EarlierDate             pgtype.Date `json:"earlier_date"`
	WhereLaterDate          bool        `json:"where_later_date"`
	LaterDate               pgtype.Date `json:"later_date"`
	WhereMailSendFlag       bool        `json:"where_mail_send_flag"`
	MailSendFlag            bool        `json:"mail_send_flag"`
	WhereInSendOrganization bool        `json:"where_in_send_organization"`
	InSendOrganization      pgtype.UUID `json:"in_send_organization"`
	OrderMethod             string      `json:"order_method"`
}

func (q *Queries) GetAttendanceUseNumberedPaginate(ctx context.Context, arg GetAttendanceUseNumberedPaginateParams) ([]Attendance, error) {
	rows, err := q.db.Query(ctx, getAttendanceUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.WhereInAttendanceType,
		arg.InAttendanceType,
		arg.WhereInMember,
		arg.InMember,
		arg.WhereEarlierDate,
		arg.EarlierDate,
		arg.WhereLaterDate,
		arg.LaterDate,
		arg.WhereMailSendFlag,
		arg.MailSendFlag,
		arg.WhereInSendOrganization,
		arg.InSendOrganization,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Attendance{}
	for rows.Next() {
		var i Attendance
		if err := rows.Scan(
			&i.TAttendancesPkey,
			&i.AttendanceID,
			&i.AttendanceTypeID,
			&i.MemberID,
			&i.Description,
			&i.Date,
			&i.MailSendFlag,
			&i.SendOrganizationID,
			&i.PostedAt,
			&i.LastEditedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAttendanceWithAll = `-- name: GetAttendanceWithAll :many
SELECT t_attendances.t_attendances_pkey, t_attendances.attendance_id, t_attendances.attendance_type_id, t_attendances.member_id, t_attendances.description, t_attendances.date, t_attendances.mail_send_flag, t_attendances.send_organization_id, t_attendances.posted_at, t_attendances.last_edited_at, m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_url, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_attendance_types.attendance_type_id, m_attendance_types.name as attendance_type_name, m_attendance_types.key as attendance_type_key, m_attendance_types.color as attendance_type_color, m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.color, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at, m_organizations.chat_room_id, t_early_leavings.t_early_leavings_pkey, t_early_leavings.early_leaving_id, t_early_leavings.attendance_id, t_early_leavings.leave_time, t_late_arrivals.t_late_arrivals_pkey, t_late_arrivals.late_arrival_id, t_late_arrivals.attendance_id, t_late_arrivals.arrive_time, t_absences.t_absences_pkey, t_absences.absence_id, t_absences.attendance_id FROM t_attendances
LEFT JOIN t_early_leavings ON t_attendances.attendance_id = t_early_leavings.attendance_id
LEFT JOIN t_late_arrivals ON t_attendances.attendance_id = t_late_arrivals.attendance_id
LEFT JOIN t_absences ON t_attendances.attendance_id = t_absences.attendance_id
LEFT JOIN m_members ON t_attendances.member_id = m_members.member_id
LEFT JOIN m_attend_statuses ON m_members.attend_status_id = m_attend_statuses.attend_status_id
LEFT JOIN m_grades ON m_members.grade_id = m_grades.grade_id
LEFT JOIN m_groups ON m_members.group_id = m_groups.group_id
LEFT JOIN m_attendance_types ON t_attendances.attendance_type_id = m_attendance_types.attendance_type_id
LEFT JOIN m_organizations ON t_attendances.send_organization_id = m_organizations.organization_id
WHERE
	CASE WHEN $1::boolean = true THEN t_attendances.attendance_type_id = ANY($2) ELSE TRUE END
AND
	CASE WHEN $3::boolean = true THEN t_attendances.member_id = ANY($4) ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN t_attendances.date >= $6 ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN t_attendances.date <= $8 ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN t_attendances.mail_send_flag = $10 ELSE TRUE END
AND
	CASE WHEN $11::boolean = true THEN t_attendances.send_organization_id = ANY($12) ELSE TRUE END
ORDER BY
	CASE WHEN $13::text = 'date' THEN t_attendances.date END ASC,
	CASE WHEN $13::text = 'r_date' THEN t_attendances.date END DESC,
	t_attendances_pkey ASC
`

type GetAttendanceWithAllParams struct {
	WhereInAttendanceType   bool        `json:"where_in_attendance_type"`
	InAttendanceType        uuid.UUID   `json:"in_attendance_type"`
	WhereInMember           bool        `json:"where_in_member"`
	InMember                uuid.UUID   `json:"in_member"`
	WhereEarlierDate        bool        `json:"where_earlier_date"`
	EarlierDate             pgtype.Date `json:"earlier_date"`
	WhereLaterDate          bool        `json:"where_later_date"`
	LaterDate               pgtype.Date `json:"later_date"`
	WhereMailSendFlag       bool        `json:"where_mail_send_flag"`
	MailSendFlag            bool        `json:"mail_send_flag"`
	WhereInSendOrganization bool        `json:"where_in_send_organization"`
	InSendOrganization      pgtype.UUID `json:"in_send_organization"`
	OrderMethod             string      `json:"order_method"`
}

type GetAttendanceWithAllRow struct {
	TAttendancesPkey    pgtype.Int8  `json:"t_attendances_pkey"`
	AttendanceID        uuid.UUID    `json:"attendance_id"`
	AttendanceTypeID    uuid.UUID    `json:"attendance_type_id"`
	MemberID            uuid.UUID    `json:"member_id"`
	Description         string       `json:"description"`
	Date                pgtype.Date  `json:"date"`
	MailSendFlag        bool         `json:"mail_send_flag"`
	SendOrganizationID  pgtype.UUID  `json:"send_organization_id"`
	PostedAt            time.Time    `json:"posted_at"`
	LastEditedAt        time.Time    `json:"last_edited_at"`
	Member              Member       `json:"member"`
	AttendanceTypeID_2  pgtype.UUID  `json:"attendance_type_id_2"`
	AttendanceTypeName  pgtype.Text  `json:"attendance_type_name"`
	AttendanceTypeKey   pgtype.Text  `json:"attendance_type_key"`
	AttendanceTypeColor pgtype.Text  `json:"attendance_type_color"`
	Organization        Organization `json:"organization"`
	EarlyLeaving        EarlyLeaving `json:"early_leaving"`
	LateArrival         LateArrival  `json:"late_arrival"`
	Absence             Absence      `json:"absence"`
}

func (q *Queries) GetAttendanceWithAll(ctx context.Context, arg GetAttendanceWithAllParams) ([]GetAttendanceWithAllRow, error) {
	rows, err := q.db.Query(ctx, getAttendanceWithAll,
		arg.WhereInAttendanceType,
		arg.InAttendanceType,
		arg.WhereInMember,
		arg.InMember,
		arg.WhereEarlierDate,
		arg.EarlierDate,
		arg.WhereLaterDate,
		arg.LaterDate,
		arg.WhereMailSendFlag,
		arg.MailSendFlag,
		arg.WhereInSendOrganization,
		arg.InSendOrganization,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAttendanceWithAllRow{}
	for rows.Next() {
		var i GetAttendanceWithAllRow
		if err := rows.Scan(
			&i.TAttendancesPkey,
			&i.AttendanceID,
			&i.AttendanceTypeID,
			&i.MemberID,
			&i.Description,
			&i.Date,
			&i.MailSendFlag,
			&i.SendOrganizationID,
			&i.PostedAt,
			&i.LastEditedAt,
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageUrl,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
			&i.AttendanceTypeID_2,
			&i.AttendanceTypeName,
			&i.AttendanceTypeKey,
			&i.AttendanceTypeColor,
			&i.Organization.MOrganizationsPkey,
			&i.Organization.OrganizationID,
			&i.Organization.Name,
			&i.Organization.Description,
			&i.Organization.Color,
			&i.Organization.IsPersonal,
			&i.Organization.IsWhole,
			&i.Organization.CreatedAt,
			&i.Organization.UpdatedAt,
			&i.Organization.ChatRoomID,
			&i.EarlyLeaving.TEarlyLeavingsPkey,
			&i.EarlyLeaving.EarlyLeavingID,
			&i.EarlyLeaving.AttendanceID,
			&i.EarlyLeaving.LeaveTime,
			&i.LateArrival.TLateArrivalsPkey,
			&i.LateArrival.LateArrivalID,
			&i.LateArrival.AttendanceID,
			&i.LateArrival.ArriveTime,
			&i.Absence.TAbsencesPkey,
			&i.Absence.AbsenceID,
			&i.Absence.AttendanceID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAttendanceWithAllUseKeysetPaginate = `-- name: GetAttendanceWithAllUseKeysetPaginate :many
SELECT t_attendances.t_attendances_pkey, t_attendances.attendance_id, t_attendances.attendance_type_id, t_attendances.member_id, t_attendances.description, t_attendances.date, t_attendances.mail_send_flag, t_attendances.send_organization_id, t_attendances.posted_at, t_attendances.last_edited_at, m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_url, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_attendance_types.attendance_type_id, m_attendance_types.name as attendance_type_name, m_attendance_types.key as attendance_type_key, m_attendance_types.color as attendance_type_color, m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.color, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at, m_organizations.chat_room_id, t_early_leavings.t_early_leavings_pkey, t_early_leavings.early_leaving_id, t_early_leavings.attendance_id, t_early_leavings.leave_time, t_late_arrivals.t_late_arrivals_pkey, t_late_arrivals.late_arrival_id, t_late_arrivals.attendance_id, t_late_arrivals.arrive_time, t_absences.t_absences_pkey, t_absences.absence_id, t_absences.attendance_id FROM t_attendances
LEFT JOIN t_early_leavings ON t_attendances.attendance_id = t_early_leavings.attendance_id
LEFT JOIN t_late_arrivals ON t_attendances.attendance_id = t_late_arrivals.attendance_id
LEFT JOIN t_absences ON t_attendances.attendance_id = t_absences.attendance_id
LEFT JOIN m_members ON t_attendances.member_id = m_members.member_id
LEFT JOIN m_attend_statuses ON m_members.attend_status_id = m_attend_statuses.attend_status_id
LEFT JOIN m_grades ON m_members.grade_id = m_grades.grade_id
LEFT JOIN m_groups ON m_members.group_id = m_groups.group_id
LEFT JOIN m_attendance_types ON t_attendances.attendance_type_id = m_attendance_types.attendance_type_id
LEFT JOIN m_organizations ON t_attendances.send_organization_id = m_organizations.organization_id
WHERE
	CASE WHEN $2::boolean = true THEN t_attendances.attendance_type_id = ANY($3) ELSE TRUE END
AND
	CASE WHEN $4::boolean = true THEN t_attendances.member_id = ANY($5) ELSE TRUE END
AND
	CASE WHEN $6::boolean = true THEN t_attendances.date >= $7 ELSE TRUE END
AND
	CASE WHEN $8::boolean = true THEN t_attendances.date <= $9 ELSE TRUE END
AND
	CASE WHEN $10::boolean = true THEN t_attendances.mail_send_flag = $11 ELSE TRUE END
AND
	CASE WHEN $12::boolean = true THEN t_attendances.send_organization_id = ANY($13) ELSE TRUE END
AND
	CASE $14::text
		WHEN 'next' THEN
			CASE $15::text
				WHEN 'date' THEN t_attendances.date > $16 OR (t_attendances.date = $16 AND t_attendances_pkey > $17::int)
				WHEN 'r_date' THEN t_attendances.date < $16 OR (t_attendances.date = $16 AND t_attendances_pkey > $17::int)
				ELSE t_attendances_pkey > $17::int
			END
		WHEN 'prev' THEN
			CASE $15::text
				WHEN 'date' THEN t_attendances.date < $16 OR (t_attendances.date = $16 AND t_attendances_pkey < $17::int)
				WHEN 'r_date' THEN t_attendances.date > $16 OR (t_attendances.date = $16 AND t_attendances_pkey < $17::int)
				ELSE t_attendances_pkey < $17::int
			END
	END
ORDER BY
	CASE WHEN $15::text = 'date' AND $14::text = 'next' THEN date END ASC,
	CASE WHEN $15::text = 'date' AND $14::text = 'prev' THEN date END DESC,
	CASE WHEN $15::text = 'r_date' AND $14::text = 'next' THEN date END DESC,
	CASE WHEN $15::text = 'r_date' AND $14::text = 'prev' THEN date END ASC,
	CASE WHEN $14::text = 'next' THEN t_attendances_pkey END ASC,
	CASE WHEN $14::text = 'prev' THEN t_attendances_pkey END DESC
LIMIT $1
`

type GetAttendanceWithAllUseKeysetPaginateParams struct {
	Limit                   int32       `json:"limit"`
	WhereInAttendanceType   bool        `json:"where_in_attendance_type"`
	InAttendanceType        uuid.UUID   `json:"in_attendance_type"`
	WhereInMember           bool        `json:"where_in_member"`
	InMember                uuid.UUID   `json:"in_member"`
	WhereEarlierDate        bool        `json:"where_earlier_date"`
	EarlierDate             pgtype.Date `json:"earlier_date"`
	WhereLaterDate          bool        `json:"where_later_date"`
	LaterDate               pgtype.Date `json:"later_date"`
	WhereMailSendFlag       bool        `json:"where_mail_send_flag"`
	MailSendFlag            bool        `json:"mail_send_flag"`
	WhereInSendOrganization bool        `json:"where_in_send_organization"`
	InSendOrganization      pgtype.UUID `json:"in_send_organization"`
	CursorDirection         string      `json:"cursor_direction"`
	OrderMethod             string      `json:"order_method"`
	DateCursor              pgtype.Date `json:"date_cursor"`
	Cursor                  int32       `json:"cursor"`
}

type GetAttendanceWithAllUseKeysetPaginateRow struct {
	TAttendancesPkey    pgtype.Int8  `json:"t_attendances_pkey"`
	AttendanceID        uuid.UUID    `json:"attendance_id"`
	AttendanceTypeID    uuid.UUID    `json:"attendance_type_id"`
	MemberID            uuid.UUID    `json:"member_id"`
	Description         string       `json:"description"`
	Date                pgtype.Date  `json:"date"`
	MailSendFlag        bool         `json:"mail_send_flag"`
	SendOrganizationID  pgtype.UUID  `json:"send_organization_id"`
	PostedAt            time.Time    `json:"posted_at"`
	LastEditedAt        time.Time    `json:"last_edited_at"`
	Member              Member       `json:"member"`
	AttendanceTypeID_2  pgtype.UUID  `json:"attendance_type_id_2"`
	AttendanceTypeName  pgtype.Text  `json:"attendance_type_name"`
	AttendanceTypeKey   pgtype.Text  `json:"attendance_type_key"`
	AttendanceTypeColor pgtype.Text  `json:"attendance_type_color"`
	Organization        Organization `json:"organization"`
	EarlyLeaving        EarlyLeaving `json:"early_leaving"`
	LateArrival         LateArrival  `json:"late_arrival"`
	Absence             Absence      `json:"absence"`
}

func (q *Queries) GetAttendanceWithAllUseKeysetPaginate(ctx context.Context, arg GetAttendanceWithAllUseKeysetPaginateParams) ([]GetAttendanceWithAllUseKeysetPaginateRow, error) {
	rows, err := q.db.Query(ctx, getAttendanceWithAllUseKeysetPaginate,
		arg.Limit,
		arg.WhereInAttendanceType,
		arg.InAttendanceType,
		arg.WhereInMember,
		arg.InMember,
		arg.WhereEarlierDate,
		arg.EarlierDate,
		arg.WhereLaterDate,
		arg.LaterDate,
		arg.WhereMailSendFlag,
		arg.MailSendFlag,
		arg.WhereInSendOrganization,
		arg.InSendOrganization,
		arg.CursorDirection,
		arg.OrderMethod,
		arg.DateCursor,
		arg.Cursor,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAttendanceWithAllUseKeysetPaginateRow{}
	for rows.Next() {
		var i GetAttendanceWithAllUseKeysetPaginateRow
		if err := rows.Scan(
			&i.TAttendancesPkey,
			&i.AttendanceID,
			&i.AttendanceTypeID,
			&i.MemberID,
			&i.Description,
			&i.Date,
			&i.MailSendFlag,
			&i.SendOrganizationID,
			&i.PostedAt,
			&i.LastEditedAt,
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageUrl,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
			&i.AttendanceTypeID_2,
			&i.AttendanceTypeName,
			&i.AttendanceTypeKey,
			&i.AttendanceTypeColor,
			&i.Organization.MOrganizationsPkey,
			&i.Organization.OrganizationID,
			&i.Organization.Name,
			&i.Organization.Description,
			&i.Organization.Color,
			&i.Organization.IsPersonal,
			&i.Organization.IsWhole,
			&i.Organization.CreatedAt,
			&i.Organization.UpdatedAt,
			&i.Organization.ChatRoomID,
			&i.EarlyLeaving.TEarlyLeavingsPkey,
			&i.EarlyLeaving.EarlyLeavingID,
			&i.EarlyLeaving.AttendanceID,
			&i.EarlyLeaving.LeaveTime,
			&i.LateArrival.TLateArrivalsPkey,
			&i.LateArrival.LateArrivalID,
			&i.LateArrival.AttendanceID,
			&i.LateArrival.ArriveTime,
			&i.Absence.TAbsencesPkey,
			&i.Absence.AbsenceID,
			&i.Absence.AttendanceID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAttendanceWithAllUseNumberedPaginate = `-- name: GetAttendanceWithAllUseNumberedPaginate :many
SELECT t_attendances.t_attendances_pkey, t_attendances.attendance_id, t_attendances.attendance_type_id, t_attendances.member_id, t_attendances.description, t_attendances.date, t_attendances.mail_send_flag, t_attendances.send_organization_id, t_attendances.posted_at, t_attendances.last_edited_at, m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_url, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_attendance_types.attendance_type_id, m_attendance_types.name as attendance_type_name, m_attendance_types.key as attendance_type_key, m_attendance_types.color as attendance_type_color, m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.color, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at, m_organizations.chat_room_id, t_early_leavings.t_early_leavings_pkey, t_early_leavings.early_leaving_id, t_early_leavings.attendance_id, t_early_leavings.leave_time, t_late_arrivals.t_late_arrivals_pkey, t_late_arrivals.late_arrival_id, t_late_arrivals.attendance_id, t_late_arrivals.arrive_time, t_absences.t_absences_pkey, t_absences.absence_id, t_absences.attendance_id FROM t_attendances
LEFT JOIN t_early_leavings ON t_attendances.attendance_id = t_early_leavings.attendance_id
LEFT JOIN t_late_arrivals ON t_attendances.attendance_id = t_late_arrivals.attendance_id
LEFT JOIN t_absences ON t_attendances.attendance_id = t_absences.attendance_id
LEFT JOIN m_members ON t_attendances.member_id = m_members.member_id
LEFT JOIN m_attend_statuses ON m_members.attend_status_id = m_attend_statuses.attend_status_id
LEFT JOIN m_grades ON m_members.grade_id = m_grades.grade_id
LEFT JOIN m_groups ON m_members.group_id = m_groups.group_id
LEFT JOIN m_attendance_types ON t_attendances.attendance_type_id = m_attendance_types.attendance_type_id
LEFT JOIN m_organizations ON t_attendances.send_organization_id = m_organizations.organization_id
WHERE
	CASE WHEN $3::boolean = true THEN t_attendances.attendance_type_id = ANY($4) ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN t_attendances.member_id = ANY($6) ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN t_attendances.date >= $8 ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN t_attendances.date <= $10 ELSE TRUE END
AND
	CASE WHEN $11::boolean = true THEN t_attendances.mail_send_flag = $12 ELSE TRUE END
AND
	CASE WHEN $13::boolean = true THEN t_attendances.send_organization_id = ANY($14) ELSE TRUE END
ORDER BY
	CASE WHEN $15::text = 'date' THEN t_attendances.date END ASC,
	CASE WHEN $15::text = 'r_date' THEN t_attendances.date END DESC,
	t_attendances_pkey ASC
LIMIT $1 OFFSET $2
`

type GetAttendanceWithAllUseNumberedPaginateParams struct {
	Limit                   int32       `json:"limit"`
	Offset                  int32       `json:"offset"`
	WhereInAttendanceType   bool        `json:"where_in_attendance_type"`
	InAttendanceType        uuid.UUID   `json:"in_attendance_type"`
	WhereInMember           bool        `json:"where_in_member"`
	InMember                uuid.UUID   `json:"in_member"`
	WhereEarlierDate        bool        `json:"where_earlier_date"`
	EarlierDate             pgtype.Date `json:"earlier_date"`
	WhereLaterDate          bool        `json:"where_later_date"`
	LaterDate               pgtype.Date `json:"later_date"`
	WhereMailSendFlag       bool        `json:"where_mail_send_flag"`
	MailSendFlag            bool        `json:"mail_send_flag"`
	WhereInSendOrganization bool        `json:"where_in_send_organization"`
	InSendOrganization      pgtype.UUID `json:"in_send_organization"`
	OrderMethod             string      `json:"order_method"`
}

type GetAttendanceWithAllUseNumberedPaginateRow struct {
	TAttendancesPkey    pgtype.Int8  `json:"t_attendances_pkey"`
	AttendanceID        uuid.UUID    `json:"attendance_id"`
	AttendanceTypeID    uuid.UUID    `json:"attendance_type_id"`
	MemberID            uuid.UUID    `json:"member_id"`
	Description         string       `json:"description"`
	Date                pgtype.Date  `json:"date"`
	MailSendFlag        bool         `json:"mail_send_flag"`
	SendOrganizationID  pgtype.UUID  `json:"send_organization_id"`
	PostedAt            time.Time    `json:"posted_at"`
	LastEditedAt        time.Time    `json:"last_edited_at"`
	Member              Member       `json:"member"`
	AttendanceTypeID_2  pgtype.UUID  `json:"attendance_type_id_2"`
	AttendanceTypeName  pgtype.Text  `json:"attendance_type_name"`
	AttendanceTypeKey   pgtype.Text  `json:"attendance_type_key"`
	AttendanceTypeColor pgtype.Text  `json:"attendance_type_color"`
	Organization        Organization `json:"organization"`
	EarlyLeaving        EarlyLeaving `json:"early_leaving"`
	LateArrival         LateArrival  `json:"late_arrival"`
	Absence             Absence      `json:"absence"`
}

func (q *Queries) GetAttendanceWithAllUseNumberedPaginate(ctx context.Context, arg GetAttendanceWithAllUseNumberedPaginateParams) ([]GetAttendanceWithAllUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getAttendanceWithAllUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.WhereInAttendanceType,
		arg.InAttendanceType,
		arg.WhereInMember,
		arg.InMember,
		arg.WhereEarlierDate,
		arg.EarlierDate,
		arg.WhereLaterDate,
		arg.LaterDate,
		arg.WhereMailSendFlag,
		arg.MailSendFlag,
		arg.WhereInSendOrganization,
		arg.InSendOrganization,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAttendanceWithAllUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetAttendanceWithAllUseNumberedPaginateRow
		if err := rows.Scan(
			&i.TAttendancesPkey,
			&i.AttendanceID,
			&i.AttendanceTypeID,
			&i.MemberID,
			&i.Description,
			&i.Date,
			&i.MailSendFlag,
			&i.SendOrganizationID,
			&i.PostedAt,
			&i.LastEditedAt,
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageUrl,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
			&i.AttendanceTypeID_2,
			&i.AttendanceTypeName,
			&i.AttendanceTypeKey,
			&i.AttendanceTypeColor,
			&i.Organization.MOrganizationsPkey,
			&i.Organization.OrganizationID,
			&i.Organization.Name,
			&i.Organization.Description,
			&i.Organization.Color,
			&i.Organization.IsPersonal,
			&i.Organization.IsWhole,
			&i.Organization.CreatedAt,
			&i.Organization.UpdatedAt,
			&i.Organization.ChatRoomID,
			&i.EarlyLeaving.TEarlyLeavingsPkey,
			&i.EarlyLeaving.EarlyLeavingID,
			&i.EarlyLeaving.AttendanceID,
			&i.EarlyLeaving.LeaveTime,
			&i.LateArrival.TLateArrivalsPkey,
			&i.LateArrival.LateArrivalID,
			&i.LateArrival.AttendanceID,
			&i.LateArrival.ArriveTime,
			&i.Absence.TAbsencesPkey,
			&i.Absence.AbsenceID,
			&i.Absence.AttendanceID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAttendanceWithAttendanceType = `-- name: GetAttendanceWithAttendanceType :many
SELECT t_attendances.t_attendances_pkey, t_attendances.attendance_id, t_attendances.attendance_type_id, t_attendances.member_id, t_attendances.description, t_attendances.date, t_attendances.mail_send_flag, t_attendances.send_organization_id, t_attendances.posted_at, t_attendances.last_edited_at, m_attendance_types.attendance_type_id, m_attendance_types.name as attendance_type_name, m_attendance_types.key as attendance_type_key, m_attendance_types.color as attendance_type_color FROM t_attendances
LEFT JOIN m_attendance_types ON t_attendances.attendance_type_id = m_attendance_types.attendance_type_id
WHERE
	CASE WHEN $1::boolean = true THEN t_attendances.attendance_type_id = ANY($2) ELSE TRUE END
AND
	CASE WHEN $3::boolean = true THEN t_attendances.member_id = ANY($4) ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN t_attendances.date >= $6 ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN t_attendances.date <= $8 ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN t_attendances.mail_send_flag = $10 ELSE TRUE END
AND
	CASE WHEN $11::boolean = true THEN t_attendances.send_organization_id = ANY($12) ELSE TRUE END
ORDER BY
	CASE WHEN $13::text = 'date' THEN t_attendances.date END ASC,
	CASE WHEN $13::text = 'r_date' THEN t_attendances.date END DESC,
	t_attendances_pkey ASC
`

type GetAttendanceWithAttendanceTypeParams struct {
	WhereInAttendanceType   bool        `json:"where_in_attendance_type"`
	InAttendanceType        uuid.UUID   `json:"in_attendance_type"`
	WhereInMember           bool        `json:"where_in_member"`
	InMember                uuid.UUID   `json:"in_member"`
	WhereEarlierDate        bool        `json:"where_earlier_date"`
	EarlierDate             pgtype.Date `json:"earlier_date"`
	WhereLaterDate          bool        `json:"where_later_date"`
	LaterDate               pgtype.Date `json:"later_date"`
	WhereMailSendFlag       bool        `json:"where_mail_send_flag"`
	MailSendFlag            bool        `json:"mail_send_flag"`
	WhereInSendOrganization bool        `json:"where_in_send_organization"`
	InSendOrganization      pgtype.UUID `json:"in_send_organization"`
	OrderMethod             string      `json:"order_method"`
}

type GetAttendanceWithAttendanceTypeRow struct {
	TAttendancesPkey    pgtype.Int8 `json:"t_attendances_pkey"`
	AttendanceID        uuid.UUID   `json:"attendance_id"`
	AttendanceTypeID    uuid.UUID   `json:"attendance_type_id"`
	MemberID            uuid.UUID   `json:"member_id"`
	Description         string      `json:"description"`
	Date                pgtype.Date `json:"date"`
	MailSendFlag        bool        `json:"mail_send_flag"`
	SendOrganizationID  pgtype.UUID `json:"send_organization_id"`
	PostedAt            time.Time   `json:"posted_at"`
	LastEditedAt        time.Time   `json:"last_edited_at"`
	AttendanceTypeID_2  pgtype.UUID `json:"attendance_type_id_2"`
	AttendanceTypeName  pgtype.Text `json:"attendance_type_name"`
	AttendanceTypeKey   pgtype.Text `json:"attendance_type_key"`
	AttendanceTypeColor pgtype.Text `json:"attendance_type_color"`
}

func (q *Queries) GetAttendanceWithAttendanceType(ctx context.Context, arg GetAttendanceWithAttendanceTypeParams) ([]GetAttendanceWithAttendanceTypeRow, error) {
	rows, err := q.db.Query(ctx, getAttendanceWithAttendanceType,
		arg.WhereInAttendanceType,
		arg.InAttendanceType,
		arg.WhereInMember,
		arg.InMember,
		arg.WhereEarlierDate,
		arg.EarlierDate,
		arg.WhereLaterDate,
		arg.LaterDate,
		arg.WhereMailSendFlag,
		arg.MailSendFlag,
		arg.WhereInSendOrganization,
		arg.InSendOrganization,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAttendanceWithAttendanceTypeRow{}
	for rows.Next() {
		var i GetAttendanceWithAttendanceTypeRow
		if err := rows.Scan(
			&i.TAttendancesPkey,
			&i.AttendanceID,
			&i.AttendanceTypeID,
			&i.MemberID,
			&i.Description,
			&i.Date,
			&i.MailSendFlag,
			&i.SendOrganizationID,
			&i.PostedAt,
			&i.LastEditedAt,
			&i.AttendanceTypeID_2,
			&i.AttendanceTypeName,
			&i.AttendanceTypeKey,
			&i.AttendanceTypeColor,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAttendanceWithAttendanceTypeUseKeysetPaginate = `-- name: GetAttendanceWithAttendanceTypeUseKeysetPaginate :many
SELECT t_attendances.t_attendances_pkey, t_attendances.attendance_id, t_attendances.attendance_type_id, t_attendances.member_id, t_attendances.description, t_attendances.date, t_attendances.mail_send_flag, t_attendances.send_organization_id, t_attendances.posted_at, t_attendances.last_edited_at, m_attendance_types.attendance_type_id, m_attendance_types.name as attendance_type_name, m_attendance_types.key as attendance_type_key, m_attendance_types.color as attendance_type_color FROM t_attendances
LEFT JOIN m_attendance_types ON t_attendances.attendance_type_id = m_attendance_types.attendance_type_id
WHERE
	CASE WHEN $2::boolean = true THEN t_attendances.attendance_type_id = ANY($3) ELSE TRUE END
AND
	CASE WHEN $4::boolean = true THEN t_attendances.member_id = ANY($5) ELSE TRUE END
AND
	CASE WHEN $6::boolean = true THEN t_attendances.date >= $7 ELSE TRUE END
AND
	CASE WHEN $8::boolean = true THEN t_attendances.date <= $9 ELSE TRUE END
AND
	CASE WHEN $10::boolean = true THEN t_attendances.mail_send_flag = $11 ELSE TRUE END
AND
	CASE WHEN $12::boolean = true THEN t_attendances.send_organization_id = ANY($13) ELSE TRUE END
AND
	CASE $14::text
		WHEN 'next' THEN
			CASE $15::text
				WHEN 'date' THEN t_attendances.date > $16 OR (t_attendances.date = $16 AND t_attendances_pkey > $17::int)
				WHEN 'r_date' THEN t_attendances.date < $16 OR (t_attendances.date = $16 AND t_attendances_pkey > $17::int)
				ELSE t_attendances_pkey > $17::int
			END
		WHEN 'prev' THEN
			CASE $15::text
				WHEN 'date' THEN t_attendances.date < $16 OR (t_attendances.date = $16 AND t_attendances_pkey < $17::int)
				WHEN 'r_date' THEN t_attendances.date > $16 OR (t_attendances.date = $16 AND t_attendances_pkey < $17::int)
				ELSE t_attendances_pkey < $17::int
			END
	END
ORDER BY
	CASE WHEN $15::text = 'date' AND $14::text = 'next' THEN date END ASC,
	CASE WHEN $15::text = 'date' AND $14::text = 'prev' THEN date END DESC,
	CASE WHEN $15::text = 'r_date' AND $14::text = 'next' THEN date END DESC,
	CASE WHEN $15::text = 'r_date' AND $14::text = 'prev' THEN date END ASC,
	CASE WHEN $14::text = 'next' THEN t_attendances_pkey END ASC,
	CASE WHEN $14::text = 'prev' THEN t_attendances_pkey END DESC
LIMIT $1
`

type GetAttendanceWithAttendanceTypeUseKeysetPaginateParams struct {
	Limit                   int32       `json:"limit"`
	WhereInAttendanceType   bool        `json:"where_in_attendance_type"`
	InAttendanceType        uuid.UUID   `json:"in_attendance_type"`
	WhereInMember           bool        `json:"where_in_member"`
	InMember                uuid.UUID   `json:"in_member"`
	WhereEarlierDate        bool        `json:"where_earlier_date"`
	EarlierDate             pgtype.Date `json:"earlier_date"`
	WhereLaterDate          bool        `json:"where_later_date"`
	LaterDate               pgtype.Date `json:"later_date"`
	WhereMailSendFlag       bool        `json:"where_mail_send_flag"`
	MailSendFlag            bool        `json:"mail_send_flag"`
	WhereInSendOrganization bool        `json:"where_in_send_organization"`
	InSendOrganization      pgtype.UUID `json:"in_send_organization"`
	CursorDirection         string      `json:"cursor_direction"`
	OrderMethod             string      `json:"order_method"`
	DateCursor              pgtype.Date `json:"date_cursor"`
	Cursor                  int32       `json:"cursor"`
}

type GetAttendanceWithAttendanceTypeUseKeysetPaginateRow struct {
	TAttendancesPkey    pgtype.Int8 `json:"t_attendances_pkey"`
	AttendanceID        uuid.UUID   `json:"attendance_id"`
	AttendanceTypeID    uuid.UUID   `json:"attendance_type_id"`
	MemberID            uuid.UUID   `json:"member_id"`
	Description         string      `json:"description"`
	Date                pgtype.Date `json:"date"`
	MailSendFlag        bool        `json:"mail_send_flag"`
	SendOrganizationID  pgtype.UUID `json:"send_organization_id"`
	PostedAt            time.Time   `json:"posted_at"`
	LastEditedAt        time.Time   `json:"last_edited_at"`
	AttendanceTypeID_2  pgtype.UUID `json:"attendance_type_id_2"`
	AttendanceTypeName  pgtype.Text `json:"attendance_type_name"`
	AttendanceTypeKey   pgtype.Text `json:"attendance_type_key"`
	AttendanceTypeColor pgtype.Text `json:"attendance_type_color"`
}

func (q *Queries) GetAttendanceWithAttendanceTypeUseKeysetPaginate(ctx context.Context, arg GetAttendanceWithAttendanceTypeUseKeysetPaginateParams) ([]GetAttendanceWithAttendanceTypeUseKeysetPaginateRow, error) {
	rows, err := q.db.Query(ctx, getAttendanceWithAttendanceTypeUseKeysetPaginate,
		arg.Limit,
		arg.WhereInAttendanceType,
		arg.InAttendanceType,
		arg.WhereInMember,
		arg.InMember,
		arg.WhereEarlierDate,
		arg.EarlierDate,
		arg.WhereLaterDate,
		arg.LaterDate,
		arg.WhereMailSendFlag,
		arg.MailSendFlag,
		arg.WhereInSendOrganization,
		arg.InSendOrganization,
		arg.CursorDirection,
		arg.OrderMethod,
		arg.DateCursor,
		arg.Cursor,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAttendanceWithAttendanceTypeUseKeysetPaginateRow{}
	for rows.Next() {
		var i GetAttendanceWithAttendanceTypeUseKeysetPaginateRow
		if err := rows.Scan(
			&i.TAttendancesPkey,
			&i.AttendanceID,
			&i.AttendanceTypeID,
			&i.MemberID,
			&i.Description,
			&i.Date,
			&i.MailSendFlag,
			&i.SendOrganizationID,
			&i.PostedAt,
			&i.LastEditedAt,
			&i.AttendanceTypeID_2,
			&i.AttendanceTypeName,
			&i.AttendanceTypeKey,
			&i.AttendanceTypeColor,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAttendanceWithAttendanceTypeUseNumberedPaginate = `-- name: GetAttendanceWithAttendanceTypeUseNumberedPaginate :many
SELECT t_attendances.t_attendances_pkey, t_attendances.attendance_id, t_attendances.attendance_type_id, t_attendances.member_id, t_attendances.description, t_attendances.date, t_attendances.mail_send_flag, t_attendances.send_organization_id, t_attendances.posted_at, t_attendances.last_edited_at, m_attendance_types.attendance_type_id, m_attendance_types.name as attendance_type_name, m_attendance_types.key as attendance_type_key, m_attendance_types.color as attendance_type_color FROM t_attendances
LEFT JOIN m_attendance_types ON t_attendances.attendance_type_id = m_attendance_types.attendance_type_id
WHERE
	CASE WHEN $3::boolean = true THEN t_attendances.attendance_type_id = ANY($4) ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN t_attendances.member_id = ANY($6) ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN t_attendances.date >= $8 ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN t_attendances.date <= $10 ELSE TRUE END
AND
	CASE WHEN $11::boolean = true THEN t_attendances.mail_send_flag = $12 ELSE TRUE END
AND
	CASE WHEN $13::boolean = true THEN t_attendances.send_organization_id = ANY($14) ELSE TRUE END
ORDER BY
	CASE WHEN $15::text = 'date' THEN t_attendances.date END ASC,
	CASE WHEN $15::text = 'r_date' THEN t_attendances.date END DESC,
	t_attendances_pkey ASC
LIMIT $1 OFFSET $2
`

type GetAttendanceWithAttendanceTypeUseNumberedPaginateParams struct {
	Limit                   int32       `json:"limit"`
	Offset                  int32       `json:"offset"`
	WhereInAttendanceType   bool        `json:"where_in_attendance_type"`
	InAttendanceType        uuid.UUID   `json:"in_attendance_type"`
	WhereInMember           bool        `json:"where_in_member"`
	InMember                uuid.UUID   `json:"in_member"`
	WhereEarlierDate        bool        `json:"where_earlier_date"`
	EarlierDate             pgtype.Date `json:"earlier_date"`
	WhereLaterDate          bool        `json:"where_later_date"`
	LaterDate               pgtype.Date `json:"later_date"`
	WhereMailSendFlag       bool        `json:"where_mail_send_flag"`
	MailSendFlag            bool        `json:"mail_send_flag"`
	WhereInSendOrganization bool        `json:"where_in_send_organization"`
	InSendOrganization      pgtype.UUID `json:"in_send_organization"`
	OrderMethod             string      `json:"order_method"`
}

type GetAttendanceWithAttendanceTypeUseNumberedPaginateRow struct {
	TAttendancesPkey    pgtype.Int8 `json:"t_attendances_pkey"`
	AttendanceID        uuid.UUID   `json:"attendance_id"`
	AttendanceTypeID    uuid.UUID   `json:"attendance_type_id"`
	MemberID            uuid.UUID   `json:"member_id"`
	Description         string      `json:"description"`
	Date                pgtype.Date `json:"date"`
	MailSendFlag        bool        `json:"mail_send_flag"`
	SendOrganizationID  pgtype.UUID `json:"send_organization_id"`
	PostedAt            time.Time   `json:"posted_at"`
	LastEditedAt        time.Time   `json:"last_edited_at"`
	AttendanceTypeID_2  pgtype.UUID `json:"attendance_type_id_2"`
	AttendanceTypeName  pgtype.Text `json:"attendance_type_name"`
	AttendanceTypeKey   pgtype.Text `json:"attendance_type_key"`
	AttendanceTypeColor pgtype.Text `json:"attendance_type_color"`
}

func (q *Queries) GetAttendanceWithAttendanceTypeUseNumberedPaginate(ctx context.Context, arg GetAttendanceWithAttendanceTypeUseNumberedPaginateParams) ([]GetAttendanceWithAttendanceTypeUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getAttendanceWithAttendanceTypeUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.WhereInAttendanceType,
		arg.InAttendanceType,
		arg.WhereInMember,
		arg.InMember,
		arg.WhereEarlierDate,
		arg.EarlierDate,
		arg.WhereLaterDate,
		arg.LaterDate,
		arg.WhereMailSendFlag,
		arg.MailSendFlag,
		arg.WhereInSendOrganization,
		arg.InSendOrganization,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAttendanceWithAttendanceTypeUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetAttendanceWithAttendanceTypeUseNumberedPaginateRow
		if err := rows.Scan(
			&i.TAttendancesPkey,
			&i.AttendanceID,
			&i.AttendanceTypeID,
			&i.MemberID,
			&i.Description,
			&i.Date,
			&i.MailSendFlag,
			&i.SendOrganizationID,
			&i.PostedAt,
			&i.LastEditedAt,
			&i.AttendanceTypeID_2,
			&i.AttendanceTypeName,
			&i.AttendanceTypeKey,
			&i.AttendanceTypeColor,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAttendanceWithDetails = `-- name: GetAttendanceWithDetails :many
SELECT t_attendances.t_attendances_pkey, t_attendances.attendance_id, t_attendances.attendance_type_id, t_attendances.member_id, t_attendances.description, t_attendances.date, t_attendances.mail_send_flag, t_attendances.send_organization_id, t_attendances.posted_at, t_attendances.last_edited_at, t_early_leavings.t_early_leavings_pkey, t_early_leavings.early_leaving_id, t_early_leavings.attendance_id, t_early_leavings.leave_time, t_late_arrivals.t_late_arrivals_pkey, t_late_arrivals.late_arrival_id, t_late_arrivals.attendance_id, t_late_arrivals.arrive_time, t_absences.t_absences_pkey, t_absences.absence_id, t_absences.attendance_id FROM t_attendances
LEFT JOIN t_early_leavings ON t_attendances.attendance_id = t_early_leavings.attendance_id
LEFT JOIN t_late_arrivals ON t_attendances.attendance_id = t_late_arrivals.attendance_id
LEFT JOIN t_absences ON t_attendances.attendance_id = t_absences.attendance_id
WHERE
	CASE WHEN $1::boolean = true THEN t_attendances.attendance_type_id = ANY($2) ELSE TRUE END
AND
	CASE WHEN $3::boolean = true THEN t_attendances.member_id = ANY($4) ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN t_attendances.date >= $6 ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN t_attendances.date <= $8 ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN t_attendances.mail_send_flag = $10 ELSE TRUE END
AND
	CASE WHEN $11::boolean = true THEN t_attendances.send_organization_id = ANY($12) ELSE TRUE END
ORDER BY
	CASE WHEN $13::text = 'date' THEN t_attendances.date END ASC,
	CASE WHEN $13::text = 'r_date' THEN t_attendances.date END DESC,
	t_attendances_pkey ASC
`

type GetAttendanceWithDetailsParams struct {
	WhereInAttendanceType   bool        `json:"where_in_attendance_type"`
	InAttendanceType        uuid.UUID   `json:"in_attendance_type"`
	WhereInMember           bool        `json:"where_in_member"`
	InMember                uuid.UUID   `json:"in_member"`
	WhereEarlierDate        bool        `json:"where_earlier_date"`
	EarlierDate             pgtype.Date `json:"earlier_date"`
	WhereLaterDate          bool        `json:"where_later_date"`
	LaterDate               pgtype.Date `json:"later_date"`
	WhereMailSendFlag       bool        `json:"where_mail_send_flag"`
	MailSendFlag            bool        `json:"mail_send_flag"`
	WhereInSendOrganization bool        `json:"where_in_send_organization"`
	InSendOrganization      pgtype.UUID `json:"in_send_organization"`
	OrderMethod             string      `json:"order_method"`
}

type GetAttendanceWithDetailsRow struct {
	TAttendancesPkey   pgtype.Int8  `json:"t_attendances_pkey"`
	AttendanceID       uuid.UUID    `json:"attendance_id"`
	AttendanceTypeID   uuid.UUID    `json:"attendance_type_id"`
	MemberID           uuid.UUID    `json:"member_id"`
	Description        string       `json:"description"`
	Date               pgtype.Date  `json:"date"`
	MailSendFlag       bool         `json:"mail_send_flag"`
	SendOrganizationID pgtype.UUID  `json:"send_organization_id"`
	PostedAt           time.Time    `json:"posted_at"`
	LastEditedAt       time.Time    `json:"last_edited_at"`
	EarlyLeaving       EarlyLeaving `json:"early_leaving"`
	LateArrival        LateArrival  `json:"late_arrival"`
	Absence            Absence      `json:"absence"`
}

func (q *Queries) GetAttendanceWithDetails(ctx context.Context, arg GetAttendanceWithDetailsParams) ([]GetAttendanceWithDetailsRow, error) {
	rows, err := q.db.Query(ctx, getAttendanceWithDetails,
		arg.WhereInAttendanceType,
		arg.InAttendanceType,
		arg.WhereInMember,
		arg.InMember,
		arg.WhereEarlierDate,
		arg.EarlierDate,
		arg.WhereLaterDate,
		arg.LaterDate,
		arg.WhereMailSendFlag,
		arg.MailSendFlag,
		arg.WhereInSendOrganization,
		arg.InSendOrganization,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAttendanceWithDetailsRow{}
	for rows.Next() {
		var i GetAttendanceWithDetailsRow
		if err := rows.Scan(
			&i.TAttendancesPkey,
			&i.AttendanceID,
			&i.AttendanceTypeID,
			&i.MemberID,
			&i.Description,
			&i.Date,
			&i.MailSendFlag,
			&i.SendOrganizationID,
			&i.PostedAt,
			&i.LastEditedAt,
			&i.EarlyLeaving.TEarlyLeavingsPkey,
			&i.EarlyLeaving.EarlyLeavingID,
			&i.EarlyLeaving.AttendanceID,
			&i.EarlyLeaving.LeaveTime,
			&i.LateArrival.TLateArrivalsPkey,
			&i.LateArrival.LateArrivalID,
			&i.LateArrival.AttendanceID,
			&i.LateArrival.ArriveTime,
			&i.Absence.TAbsencesPkey,
			&i.Absence.AbsenceID,
			&i.Absence.AttendanceID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAttendanceWithDetailsUseKeysetPaginate = `-- name: GetAttendanceWithDetailsUseKeysetPaginate :many
SELECT t_attendances.t_attendances_pkey, t_attendances.attendance_id, t_attendances.attendance_type_id, t_attendances.member_id, t_attendances.description, t_attendances.date, t_attendances.mail_send_flag, t_attendances.send_organization_id, t_attendances.posted_at, t_attendances.last_edited_at, t_early_leavings.t_early_leavings_pkey, t_early_leavings.early_leaving_id, t_early_leavings.attendance_id, t_early_leavings.leave_time, t_late_arrivals.t_late_arrivals_pkey, t_late_arrivals.late_arrival_id, t_late_arrivals.attendance_id, t_late_arrivals.arrive_time, t_absences.t_absences_pkey, t_absences.absence_id, t_absences.attendance_id FROM t_attendances
LEFT JOIN t_early_leavings ON t_attendances.attendance_id = t_early_leavings.attendance_id
LEFT JOIN t_late_arrivals ON t_attendances.attendance_id = t_late_arrivals.attendance_id
LEFT JOIN t_absences ON t_attendances.attendance_id = t_absences.attendance_id
WHERE
	CASE WHEN $2::boolean = true THEN t_attendances.attendance_type_id = ANY($3) ELSE TRUE END
AND
	CASE WHEN $4::boolean = true THEN t_attendances.member_id = ANY($5) ELSE TRUE END
AND
	CASE WHEN $6::boolean = true THEN t_attendances.date >= $7 ELSE TRUE END
AND
	CASE WHEN $8::boolean = true THEN t_attendances.date <= $9 ELSE TRUE END
AND
	CASE WHEN $10::boolean = true THEN t_attendances.mail_send_flag = $11 ELSE TRUE END
AND
	CASE WHEN $12::boolean = true THEN t_attendances.send_organization_id = ANY($13) ELSE TRUE END
AND
	CASE $14::text
		WHEN 'next' THEN
			CASE $15::text
				WHEN 'date' THEN t_attendances.date > $16 OR (t_attendances.date = $16 AND t_attendances_pkey > $17::int)
				WHEN 'r_date' THEN t_attendances.date < $16 OR (t_attendances.date = $16 AND t_attendances_pkey > $17::int)
				ELSE t_attendances_pkey > $17::int
			END
		WHEN 'prev' THEN
			CASE $15::text
				WHEN 'date' THEN t_attendances.date < $16 OR (t_attendances.date = $16 AND t_attendances_pkey < $17::int)
				WHEN 'r_date' THEN t_attendances.date > $16 OR (t_attendances.date = $16 AND t_attendances_pkey < $17::int)
				ELSE t_attendances_pkey < $17::int
			END
	END
ORDER BY
	CASE WHEN $15::text = 'date' AND $14::text = 'next' THEN date END ASC,
	CASE WHEN $15::text = 'date' AND $14::text = 'prev' THEN date END DESC,
	CASE WHEN $15::text = 'r_date' AND $14::text = 'next' THEN date END DESC,
	CASE WHEN $15::text = 'r_date' AND $14::text = 'prev' THEN date END ASC,
	CASE WHEN $14::text = 'next' THEN t_attendances_pkey END ASC,
	CASE WHEN $14::text = 'prev' THEN t_attendances_pkey END DESC
LIMIT $1
`

type GetAttendanceWithDetailsUseKeysetPaginateParams struct {
	Limit                   int32       `json:"limit"`
	WhereInAttendanceType   bool        `json:"where_in_attendance_type"`
	InAttendanceType        uuid.UUID   `json:"in_attendance_type"`
	WhereInMember           bool        `json:"where_in_member"`
	InMember                uuid.UUID   `json:"in_member"`
	WhereEarlierDate        bool        `json:"where_earlier_date"`
	EarlierDate             pgtype.Date `json:"earlier_date"`
	WhereLaterDate          bool        `json:"where_later_date"`
	LaterDate               pgtype.Date `json:"later_date"`
	WhereMailSendFlag       bool        `json:"where_mail_send_flag"`
	MailSendFlag            bool        `json:"mail_send_flag"`
	WhereInSendOrganization bool        `json:"where_in_send_organization"`
	InSendOrganization      pgtype.UUID `json:"in_send_organization"`
	CursorDirection         string      `json:"cursor_direction"`
	OrderMethod             string      `json:"order_method"`
	DateCursor              pgtype.Date `json:"date_cursor"`
	Cursor                  int32       `json:"cursor"`
}

type GetAttendanceWithDetailsUseKeysetPaginateRow struct {
	TAttendancesPkey   pgtype.Int8  `json:"t_attendances_pkey"`
	AttendanceID       uuid.UUID    `json:"attendance_id"`
	AttendanceTypeID   uuid.UUID    `json:"attendance_type_id"`
	MemberID           uuid.UUID    `json:"member_id"`
	Description        string       `json:"description"`
	Date               pgtype.Date  `json:"date"`
	MailSendFlag       bool         `json:"mail_send_flag"`
	SendOrganizationID pgtype.UUID  `json:"send_organization_id"`
	PostedAt           time.Time    `json:"posted_at"`
	LastEditedAt       time.Time    `json:"last_edited_at"`
	EarlyLeaving       EarlyLeaving `json:"early_leaving"`
	LateArrival        LateArrival  `json:"late_arrival"`
	Absence            Absence      `json:"absence"`
}

func (q *Queries) GetAttendanceWithDetailsUseKeysetPaginate(ctx context.Context, arg GetAttendanceWithDetailsUseKeysetPaginateParams) ([]GetAttendanceWithDetailsUseKeysetPaginateRow, error) {
	rows, err := q.db.Query(ctx, getAttendanceWithDetailsUseKeysetPaginate,
		arg.Limit,
		arg.WhereInAttendanceType,
		arg.InAttendanceType,
		arg.WhereInMember,
		arg.InMember,
		arg.WhereEarlierDate,
		arg.EarlierDate,
		arg.WhereLaterDate,
		arg.LaterDate,
		arg.WhereMailSendFlag,
		arg.MailSendFlag,
		arg.WhereInSendOrganization,
		arg.InSendOrganization,
		arg.CursorDirection,
		arg.OrderMethod,
		arg.DateCursor,
		arg.Cursor,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAttendanceWithDetailsUseKeysetPaginateRow{}
	for rows.Next() {
		var i GetAttendanceWithDetailsUseKeysetPaginateRow
		if err := rows.Scan(
			&i.TAttendancesPkey,
			&i.AttendanceID,
			&i.AttendanceTypeID,
			&i.MemberID,
			&i.Description,
			&i.Date,
			&i.MailSendFlag,
			&i.SendOrganizationID,
			&i.PostedAt,
			&i.LastEditedAt,
			&i.EarlyLeaving.TEarlyLeavingsPkey,
			&i.EarlyLeaving.EarlyLeavingID,
			&i.EarlyLeaving.AttendanceID,
			&i.EarlyLeaving.LeaveTime,
			&i.LateArrival.TLateArrivalsPkey,
			&i.LateArrival.LateArrivalID,
			&i.LateArrival.AttendanceID,
			&i.LateArrival.ArriveTime,
			&i.Absence.TAbsencesPkey,
			&i.Absence.AbsenceID,
			&i.Absence.AttendanceID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAttendanceWithDetailsUseNumberedPaginate = `-- name: GetAttendanceWithDetailsUseNumberedPaginate :many
SELECT t_attendances.t_attendances_pkey, t_attendances.attendance_id, t_attendances.attendance_type_id, t_attendances.member_id, t_attendances.description, t_attendances.date, t_attendances.mail_send_flag, t_attendances.send_organization_id, t_attendances.posted_at, t_attendances.last_edited_at, t_early_leavings.t_early_leavings_pkey, t_early_leavings.early_leaving_id, t_early_leavings.attendance_id, t_early_leavings.leave_time, t_late_arrivals.t_late_arrivals_pkey, t_late_arrivals.late_arrival_id, t_late_arrivals.attendance_id, t_late_arrivals.arrive_time, t_absences.t_absences_pkey, t_absences.absence_id, t_absences.attendance_id FROM t_attendances
LEFT JOIN t_early_leavings ON t_attendances.attendance_id = t_early_leavings.attendance_id
LEFT JOIN t_late_arrivals ON t_attendances.attendance_id = t_late_arrivals.attendance_id
LEFT JOIN t_absences ON t_attendances.attendance_id = t_absences.attendance_id
WHERE
	CASE WHEN $3::boolean = true THEN t_attendances.attendance_type_id = ANY($4) ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN t_attendances.member_id = ANY($6) ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN t_attendances.date >= $8 ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN t_attendances.date <= $10 ELSE TRUE END
AND
	CASE WHEN $11::boolean = true THEN t_attendances.mail_send_flag = $12 ELSE TRUE END
AND
	CASE WHEN $13::boolean = true THEN t_attendances.send_organization_id = ANY($14) ELSE TRUE END
ORDER BY
	CASE WHEN $15::text = 'date' THEN t_attendances.date END ASC,
	CASE WHEN $15::text = 'r_date' THEN t_attendances.date END DESC,
	t_attendances_pkey ASC
LIMIT $1 OFFSET $2
`

type GetAttendanceWithDetailsUseNumberedPaginateParams struct {
	Limit                   int32       `json:"limit"`
	Offset                  int32       `json:"offset"`
	WhereInAttendanceType   bool        `json:"where_in_attendance_type"`
	InAttendanceType        uuid.UUID   `json:"in_attendance_type"`
	WhereInMember           bool        `json:"where_in_member"`
	InMember                uuid.UUID   `json:"in_member"`
	WhereEarlierDate        bool        `json:"where_earlier_date"`
	EarlierDate             pgtype.Date `json:"earlier_date"`
	WhereLaterDate          bool        `json:"where_later_date"`
	LaterDate               pgtype.Date `json:"later_date"`
	WhereMailSendFlag       bool        `json:"where_mail_send_flag"`
	MailSendFlag            bool        `json:"mail_send_flag"`
	WhereInSendOrganization bool        `json:"where_in_send_organization"`
	InSendOrganization      pgtype.UUID `json:"in_send_organization"`
	OrderMethod             string      `json:"order_method"`
}

type GetAttendanceWithDetailsUseNumberedPaginateRow struct {
	TAttendancesPkey   pgtype.Int8  `json:"t_attendances_pkey"`
	AttendanceID       uuid.UUID    `json:"attendance_id"`
	AttendanceTypeID   uuid.UUID    `json:"attendance_type_id"`
	MemberID           uuid.UUID    `json:"member_id"`
	Description        string       `json:"description"`
	Date               pgtype.Date  `json:"date"`
	MailSendFlag       bool         `json:"mail_send_flag"`
	SendOrganizationID pgtype.UUID  `json:"send_organization_id"`
	PostedAt           time.Time    `json:"posted_at"`
	LastEditedAt       time.Time    `json:"last_edited_at"`
	EarlyLeaving       EarlyLeaving `json:"early_leaving"`
	LateArrival        LateArrival  `json:"late_arrival"`
	Absence            Absence      `json:"absence"`
}

func (q *Queries) GetAttendanceWithDetailsUseNumberedPaginate(ctx context.Context, arg GetAttendanceWithDetailsUseNumberedPaginateParams) ([]GetAttendanceWithDetailsUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getAttendanceWithDetailsUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.WhereInAttendanceType,
		arg.InAttendanceType,
		arg.WhereInMember,
		arg.InMember,
		arg.WhereEarlierDate,
		arg.EarlierDate,
		arg.WhereLaterDate,
		arg.LaterDate,
		arg.WhereMailSendFlag,
		arg.MailSendFlag,
		arg.WhereInSendOrganization,
		arg.InSendOrganization,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAttendanceWithDetailsUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetAttendanceWithDetailsUseNumberedPaginateRow
		if err := rows.Scan(
			&i.TAttendancesPkey,
			&i.AttendanceID,
			&i.AttendanceTypeID,
			&i.MemberID,
			&i.Description,
			&i.Date,
			&i.MailSendFlag,
			&i.SendOrganizationID,
			&i.PostedAt,
			&i.LastEditedAt,
			&i.EarlyLeaving.TEarlyLeavingsPkey,
			&i.EarlyLeaving.EarlyLeavingID,
			&i.EarlyLeaving.AttendanceID,
			&i.EarlyLeaving.LeaveTime,
			&i.LateArrival.TLateArrivalsPkey,
			&i.LateArrival.LateArrivalID,
			&i.LateArrival.AttendanceID,
			&i.LateArrival.ArriveTime,
			&i.Absence.TAbsencesPkey,
			&i.Absence.AbsenceID,
			&i.Absence.AttendanceID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAttendanceWithMember = `-- name: GetAttendanceWithMember :many
SELECT t_attendances.t_attendances_pkey, t_attendances.attendance_id, t_attendances.attendance_type_id, t_attendances.member_id, t_attendances.description, t_attendances.date, t_attendances.mail_send_flag, t_attendances.send_organization_id, t_attendances.posted_at, t_attendances.last_edited_at, m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_url, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at FROM t_attendances
LEFT JOIN m_members ON t_attendances.member_id = m_members.member_id
LEFT JOIN m_attend_statuses ON m_members.attend_status_id = m_attend_statuses.attend_status_id
LEFT JOIN m_grades ON m_members.grade_id = m_grades.grade_id
LEFT JOIN m_groups ON m_members.group_id = m_groups.group_id
WHERE
	CASE WHEN $1::boolean = true THEN t_attendances.attendance_type_id = ANY($2) ELSE TRUE END
AND
	CASE WHEN $3::boolean = true THEN t_attendances.member_id = ANY($4) ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN t_attendances.date >= $6 ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN t_attendances.date <= $8 ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN t_attendances.mail_send_flag = $10 ELSE TRUE END
AND
	CASE WHEN $11::boolean = true THEN t_attendances.send_organization_id = ANY($12) ELSE TRUE END
ORDER BY
	CASE WHEN $13::text = 'date' THEN t_attendances.date END ASC,
	CASE WHEN $13::text = 'r_date' THEN t_attendances.date END DESC,
	t_attendances_pkey ASC
`

type GetAttendanceWithMemberParams struct {
	WhereInAttendanceType   bool        `json:"where_in_attendance_type"`
	InAttendanceType        uuid.UUID   `json:"in_attendance_type"`
	WhereInMember           bool        `json:"where_in_member"`
	InMember                uuid.UUID   `json:"in_member"`
	WhereEarlierDate        bool        `json:"where_earlier_date"`
	EarlierDate             pgtype.Date `json:"earlier_date"`
	WhereLaterDate          bool        `json:"where_later_date"`
	LaterDate               pgtype.Date `json:"later_date"`
	WhereMailSendFlag       bool        `json:"where_mail_send_flag"`
	MailSendFlag            bool        `json:"mail_send_flag"`
	WhereInSendOrganization bool        `json:"where_in_send_organization"`
	InSendOrganization      pgtype.UUID `json:"in_send_organization"`
	OrderMethod             string      `json:"order_method"`
}

type GetAttendanceWithMemberRow struct {
	TAttendancesPkey   pgtype.Int8 `json:"t_attendances_pkey"`
	AttendanceID       uuid.UUID   `json:"attendance_id"`
	AttendanceTypeID   uuid.UUID   `json:"attendance_type_id"`
	MemberID           uuid.UUID   `json:"member_id"`
	Description        string      `json:"description"`
	Date               pgtype.Date `json:"date"`
	MailSendFlag       bool        `json:"mail_send_flag"`
	SendOrganizationID pgtype.UUID `json:"send_organization_id"`
	PostedAt           time.Time   `json:"posted_at"`
	LastEditedAt       time.Time   `json:"last_edited_at"`
	Member             Member      `json:"member"`
}

func (q *Queries) GetAttendanceWithMember(ctx context.Context, arg GetAttendanceWithMemberParams) ([]GetAttendanceWithMemberRow, error) {
	rows, err := q.db.Query(ctx, getAttendanceWithMember,
		arg.WhereInAttendanceType,
		arg.InAttendanceType,
		arg.WhereInMember,
		arg.InMember,
		arg.WhereEarlierDate,
		arg.EarlierDate,
		arg.WhereLaterDate,
		arg.LaterDate,
		arg.WhereMailSendFlag,
		arg.MailSendFlag,
		arg.WhereInSendOrganization,
		arg.InSendOrganization,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAttendanceWithMemberRow{}
	for rows.Next() {
		var i GetAttendanceWithMemberRow
		if err := rows.Scan(
			&i.TAttendancesPkey,
			&i.AttendanceID,
			&i.AttendanceTypeID,
			&i.MemberID,
			&i.Description,
			&i.Date,
			&i.MailSendFlag,
			&i.SendOrganizationID,
			&i.PostedAt,
			&i.LastEditedAt,
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageUrl,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAttendanceWithMemberUseKeysetPaginate = `-- name: GetAttendanceWithMemberUseKeysetPaginate :many
SELECT t_attendances.t_attendances_pkey, t_attendances.attendance_id, t_attendances.attendance_type_id, t_attendances.member_id, t_attendances.description, t_attendances.date, t_attendances.mail_send_flag, t_attendances.send_organization_id, t_attendances.posted_at, t_attendances.last_edited_at, m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_url, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at FROM t_attendances
LEFT JOIN m_members ON t_attendances.member_id = m_members.member_id
LEFT JOIN m_attend_statuses ON m_members.attend_status_id = m_attend_statuses.attend_status_id
LEFT JOIN m_grades ON m_members.grade_id = m_grades.grade_id
LEFT JOIN m_groups ON m_members.group_id = m_groups.group_id
WHERE
	CASE WHEN $2::boolean = true THEN t_attendances.attendance_type_id = ANY($3) ELSE TRUE END
AND
	CASE WHEN $4::boolean = true THEN t_attendances.member_id = ANY($5) ELSE TRUE END
AND
	CASE WHEN $6::boolean = true THEN t_attendances.date >= $7 ELSE TRUE END
AND
	CASE WHEN $8::boolean = true THEN t_attendances.date <= $9 ELSE TRUE END
AND
	CASE WHEN $10::boolean = true THEN t_attendances.mail_send_flag = $11 ELSE TRUE END
AND
	CASE WHEN $12::boolean = true THEN t_attendances.send_organization_id = ANY($13) ELSE TRUE END
AND
	CASE $14::text
		WHEN 'next' THEN
			CASE $15::text
				WHEN 'date' THEN t_attendances.date > $16 OR (t_attendances.date = $16 AND t_attendances_pkey > $17::int)
				WHEN 'r_date' THEN t_attendances.date < $16 OR (t_attendances.date = $16 AND t_attendances_pkey > $17::int)
				ELSE t_attendances_pkey > $17::int
			END
		WHEN 'prev' THEN
			CASE $15::text
				WHEN 'date' THEN t_attendances.date < $16 OR (t_attendances.date = $16 AND t_attendances_pkey < $17::int)
				WHEN 'r_date' THEN t_attendances.date > $16 OR (t_attendances.date = $16 AND t_attendances_pkey < $17::int)
				ELSE t_attendances_pkey < $17::int
			END
	END
ORDER BY
	CASE WHEN $15::text = 'date' AND $14::text = 'next' THEN date END ASC,
	CASE WHEN $15::text = 'date' AND $14::text = 'prev' THEN date END DESC,
	CASE WHEN $15::text = 'r_date' AND $14::text = 'next' THEN date END DESC,
	CASE WHEN $15::text = 'r_date' AND $14::text = 'prev' THEN date END ASC,
	CASE WHEN $14::text = 'next' THEN t_attendances_pkey END ASC,
	CASE WHEN $14::text = 'prev' THEN t_attendances_pkey END DESC
LIMIT $1
`

type GetAttendanceWithMemberUseKeysetPaginateParams struct {
	Limit                   int32       `json:"limit"`
	WhereInAttendanceType   bool        `json:"where_in_attendance_type"`
	InAttendanceType        uuid.UUID   `json:"in_attendance_type"`
	WhereInMember           bool        `json:"where_in_member"`
	InMember                uuid.UUID   `json:"in_member"`
	WhereEarlierDate        bool        `json:"where_earlier_date"`
	EarlierDate             pgtype.Date `json:"earlier_date"`
	WhereLaterDate          bool        `json:"where_later_date"`
	LaterDate               pgtype.Date `json:"later_date"`
	WhereMailSendFlag       bool        `json:"where_mail_send_flag"`
	MailSendFlag            bool        `json:"mail_send_flag"`
	WhereInSendOrganization bool        `json:"where_in_send_organization"`
	InSendOrganization      pgtype.UUID `json:"in_send_organization"`
	CursorDirection         string      `json:"cursor_direction"`
	OrderMethod             string      `json:"order_method"`
	DateCursor              pgtype.Date `json:"date_cursor"`
	Cursor                  int32       `json:"cursor"`
}

type GetAttendanceWithMemberUseKeysetPaginateRow struct {
	TAttendancesPkey   pgtype.Int8 `json:"t_attendances_pkey"`
	AttendanceID       uuid.UUID   `json:"attendance_id"`
	AttendanceTypeID   uuid.UUID   `json:"attendance_type_id"`
	MemberID           uuid.UUID   `json:"member_id"`
	Description        string      `json:"description"`
	Date               pgtype.Date `json:"date"`
	MailSendFlag       bool        `json:"mail_send_flag"`
	SendOrganizationID pgtype.UUID `json:"send_organization_id"`
	PostedAt           time.Time   `json:"posted_at"`
	LastEditedAt       time.Time   `json:"last_edited_at"`
	Member             Member      `json:"member"`
}

func (q *Queries) GetAttendanceWithMemberUseKeysetPaginate(ctx context.Context, arg GetAttendanceWithMemberUseKeysetPaginateParams) ([]GetAttendanceWithMemberUseKeysetPaginateRow, error) {
	rows, err := q.db.Query(ctx, getAttendanceWithMemberUseKeysetPaginate,
		arg.Limit,
		arg.WhereInAttendanceType,
		arg.InAttendanceType,
		arg.WhereInMember,
		arg.InMember,
		arg.WhereEarlierDate,
		arg.EarlierDate,
		arg.WhereLaterDate,
		arg.LaterDate,
		arg.WhereMailSendFlag,
		arg.MailSendFlag,
		arg.WhereInSendOrganization,
		arg.InSendOrganization,
		arg.CursorDirection,
		arg.OrderMethod,
		arg.DateCursor,
		arg.Cursor,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAttendanceWithMemberUseKeysetPaginateRow{}
	for rows.Next() {
		var i GetAttendanceWithMemberUseKeysetPaginateRow
		if err := rows.Scan(
			&i.TAttendancesPkey,
			&i.AttendanceID,
			&i.AttendanceTypeID,
			&i.MemberID,
			&i.Description,
			&i.Date,
			&i.MailSendFlag,
			&i.SendOrganizationID,
			&i.PostedAt,
			&i.LastEditedAt,
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageUrl,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAttendanceWithMemberUseNumberedPaginate = `-- name: GetAttendanceWithMemberUseNumberedPaginate :many
SELECT t_attendances.t_attendances_pkey, t_attendances.attendance_id, t_attendances.attendance_type_id, t_attendances.member_id, t_attendances.description, t_attendances.date, t_attendances.mail_send_flag, t_attendances.send_organization_id, t_attendances.posted_at, t_attendances.last_edited_at, m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_url, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at FROM t_attendances
LEFT JOIN m_members ON t_attendances.member_id = m_members.member_id
LEFT JOIN m_attend_statuses ON m_members.attend_status_id = m_attend_statuses.attend_status_id
LEFT JOIN m_grades ON m_members.grade_id = m_grades.grade_id
LEFT JOIN m_groups ON m_members.group_id = m_groups.group_id
WHERE
	CASE WHEN $3::boolean = true THEN t_attendances.attendance_type_id = ANY($4) ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN t_attendances.member_id = ANY($6) ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN t_attendances.date >= $8 ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN t_attendances.date <= $10 ELSE TRUE END
AND
	CASE WHEN $11::boolean = true THEN t_attendances.mail_send_flag = $12 ELSE TRUE END
AND
	CASE WHEN $13::boolean = true THEN t_attendances.send_organization_id = ANY($14) ELSE TRUE END
ORDER BY
	CASE WHEN $15::text = 'date' THEN t_attendances.date END ASC,
	CASE WHEN $15::text = 'r_date' THEN t_attendances.date END DESC,
	t_attendances_pkey ASC
LIMIT $1 OFFSET $2
`

type GetAttendanceWithMemberUseNumberedPaginateParams struct {
	Limit                   int32       `json:"limit"`
	Offset                  int32       `json:"offset"`
	WhereInAttendanceType   bool        `json:"where_in_attendance_type"`
	InAttendanceType        uuid.UUID   `json:"in_attendance_type"`
	WhereInMember           bool        `json:"where_in_member"`
	InMember                uuid.UUID   `json:"in_member"`
	WhereEarlierDate        bool        `json:"where_earlier_date"`
	EarlierDate             pgtype.Date `json:"earlier_date"`
	WhereLaterDate          bool        `json:"where_later_date"`
	LaterDate               pgtype.Date `json:"later_date"`
	WhereMailSendFlag       bool        `json:"where_mail_send_flag"`
	MailSendFlag            bool        `json:"mail_send_flag"`
	WhereInSendOrganization bool        `json:"where_in_send_organization"`
	InSendOrganization      pgtype.UUID `json:"in_send_organization"`
	OrderMethod             string      `json:"order_method"`
}

type GetAttendanceWithMemberUseNumberedPaginateRow struct {
	TAttendancesPkey   pgtype.Int8 `json:"t_attendances_pkey"`
	AttendanceID       uuid.UUID   `json:"attendance_id"`
	AttendanceTypeID   uuid.UUID   `json:"attendance_type_id"`
	MemberID           uuid.UUID   `json:"member_id"`
	Description        string      `json:"description"`
	Date               pgtype.Date `json:"date"`
	MailSendFlag       bool        `json:"mail_send_flag"`
	SendOrganizationID pgtype.UUID `json:"send_organization_id"`
	PostedAt           time.Time   `json:"posted_at"`
	LastEditedAt       time.Time   `json:"last_edited_at"`
	Member             Member      `json:"member"`
}

func (q *Queries) GetAttendanceWithMemberUseNumberedPaginate(ctx context.Context, arg GetAttendanceWithMemberUseNumberedPaginateParams) ([]GetAttendanceWithMemberUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getAttendanceWithMemberUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.WhereInAttendanceType,
		arg.InAttendanceType,
		arg.WhereInMember,
		arg.InMember,
		arg.WhereEarlierDate,
		arg.EarlierDate,
		arg.WhereLaterDate,
		arg.LaterDate,
		arg.WhereMailSendFlag,
		arg.MailSendFlag,
		arg.WhereInSendOrganization,
		arg.InSendOrganization,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAttendanceWithMemberUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetAttendanceWithMemberUseNumberedPaginateRow
		if err := rows.Scan(
			&i.TAttendancesPkey,
			&i.AttendanceID,
			&i.AttendanceTypeID,
			&i.MemberID,
			&i.Description,
			&i.Date,
			&i.MailSendFlag,
			&i.SendOrganizationID,
			&i.PostedAt,
			&i.LastEditedAt,
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageUrl,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAttendanceWithSendOrganization = `-- name: GetAttendanceWithSendOrganization :many
SELECT t_attendances.t_attendances_pkey, t_attendances.attendance_id, t_attendances.attendance_type_id, t_attendances.member_id, t_attendances.description, t_attendances.date, t_attendances.mail_send_flag, t_attendances.send_organization_id, t_attendances.posted_at, t_attendances.last_edited_at, m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.color, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at, m_organizations.chat_room_id FROM t_attendances
LEFT JOIN m_organizations ON t_attendances.send_organization_id = m_organizations.organization_id
WHERE
	CASE WHEN $1::boolean = true THEN t_attendances.attendance_type_id = ANY($2) ELSE TRUE END
AND
	CASE WHEN $3::boolean = true THEN t_attendances.member_id = ANY($4) ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN t_attendances.date >= $6 ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN t_attendances.date <= $8 ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN t_attendances.mail_send_flag = $10 ELSE TRUE END
AND
	CASE WHEN $11::boolean = true THEN t_attendances.send_organization_id = ANY($12) ELSE TRUE END
ORDER BY
	CASE WHEN $13::text = 'date' THEN t_attendances.date END ASC,
	CASE WHEN $13::text = 'r_date' THEN t_attendances.date END DESC,
	t_attendances_pkey ASC
`

type GetAttendanceWithSendOrganizationParams struct {
	WhereInAttendanceType   bool        `json:"where_in_attendance_type"`
	InAttendanceType        uuid.UUID   `json:"in_attendance_type"`
	WhereInMember           bool        `json:"where_in_member"`
	InMember                uuid.UUID   `json:"in_member"`
	WhereEarlierDate        bool        `json:"where_earlier_date"`
	EarlierDate             pgtype.Date `json:"earlier_date"`
	WhereLaterDate          bool        `json:"where_later_date"`
	LaterDate               pgtype.Date `json:"later_date"`
	WhereMailSendFlag       bool        `json:"where_mail_send_flag"`
	MailSendFlag            bool        `json:"mail_send_flag"`
	WhereInSendOrganization bool        `json:"where_in_send_organization"`
	InSendOrganization      pgtype.UUID `json:"in_send_organization"`
	OrderMethod             string      `json:"order_method"`
}

type GetAttendanceWithSendOrganizationRow struct {
	TAttendancesPkey   pgtype.Int8  `json:"t_attendances_pkey"`
	AttendanceID       uuid.UUID    `json:"attendance_id"`
	AttendanceTypeID   uuid.UUID    `json:"attendance_type_id"`
	MemberID           uuid.UUID    `json:"member_id"`
	Description        string       `json:"description"`
	Date               pgtype.Date  `json:"date"`
	MailSendFlag       bool         `json:"mail_send_flag"`
	SendOrganizationID pgtype.UUID  `json:"send_organization_id"`
	PostedAt           time.Time    `json:"posted_at"`
	LastEditedAt       time.Time    `json:"last_edited_at"`
	Organization       Organization `json:"organization"`
}

func (q *Queries) GetAttendanceWithSendOrganization(ctx context.Context, arg GetAttendanceWithSendOrganizationParams) ([]GetAttendanceWithSendOrganizationRow, error) {
	rows, err := q.db.Query(ctx, getAttendanceWithSendOrganization,
		arg.WhereInAttendanceType,
		arg.InAttendanceType,
		arg.WhereInMember,
		arg.InMember,
		arg.WhereEarlierDate,
		arg.EarlierDate,
		arg.WhereLaterDate,
		arg.LaterDate,
		arg.WhereMailSendFlag,
		arg.MailSendFlag,
		arg.WhereInSendOrganization,
		arg.InSendOrganization,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAttendanceWithSendOrganizationRow{}
	for rows.Next() {
		var i GetAttendanceWithSendOrganizationRow
		if err := rows.Scan(
			&i.TAttendancesPkey,
			&i.AttendanceID,
			&i.AttendanceTypeID,
			&i.MemberID,
			&i.Description,
			&i.Date,
			&i.MailSendFlag,
			&i.SendOrganizationID,
			&i.PostedAt,
			&i.LastEditedAt,
			&i.Organization.MOrganizationsPkey,
			&i.Organization.OrganizationID,
			&i.Organization.Name,
			&i.Organization.Description,
			&i.Organization.Color,
			&i.Organization.IsPersonal,
			&i.Organization.IsWhole,
			&i.Organization.CreatedAt,
			&i.Organization.UpdatedAt,
			&i.Organization.ChatRoomID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAttendanceWithSendOrganizationUseKeysetPaginate = `-- name: GetAttendanceWithSendOrganizationUseKeysetPaginate :many
SELECT t_attendances.t_attendances_pkey, t_attendances.attendance_id, t_attendances.attendance_type_id, t_attendances.member_id, t_attendances.description, t_attendances.date, t_attendances.mail_send_flag, t_attendances.send_organization_id, t_attendances.posted_at, t_attendances.last_edited_at, m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.color, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at, m_organizations.chat_room_id FROM t_attendances
LEFT JOIN m_organizations ON t_attendances.send_organization_id = m_organizations.organization_id
WHERE
	CASE WHEN $2::boolean = true THEN t_attendances.attendance_type_id = ANY($3) ELSE TRUE END
AND
	CASE WHEN $4::boolean = true THEN t_attendances.member_id = ANY($5) ELSE TRUE END
AND
	CASE WHEN $6::boolean = true THEN t_attendances.date >= $7 ELSE TRUE END
AND
	CASE WHEN $8::boolean = true THEN t_attendances.date <= $9 ELSE TRUE END
AND
	CASE WHEN $10::boolean = true THEN t_attendances.mail_send_flag = $11 ELSE TRUE END
AND
	CASE WHEN $12::boolean = true THEN t_attendances.send_organization_id = ANY($13) ELSE TRUE END
AND
	CASE $14::text
		WHEN 'next' THEN
			CASE $15::text
				WHEN 'date' THEN t_attendances.date > $16 OR (t_attendances.date = $16 AND t_attendances_pkey > $17::int)
				WHEN 'r_date' THEN t_attendances.date < $16 OR (t_attendances.date = $16 AND t_attendances_pkey > $17::int)
				ELSE t_attendances_pkey > $17::int
			END
		WHEN 'prev' THEN
			CASE $15::text
				WHEN 'date' THEN t_attendances.date < $16 OR (t_attendances.date = $16 AND t_attendances_pkey < $17::int)
				WHEN 'r_date' THEN t_attendances.date > $16 OR (t_attendances.date = $16 AND t_attendances_pkey < $17::int)
				ELSE t_attendances_pkey > $17
			END
	END
ORDER BY
	CASE WHEN $15::text = 'date' AND $14::text = 'next' THEN date END ASC,
	CASE WHEN $15::text = 'date' AND $14::text = 'prev' THEN date END DESC,
	CASE WHEN $15::text = 'r_date' AND $14::text = 'next' THEN date END DESC,
	CASE WHEN $15::text = 'r_date' AND $14::text = 'prev' THEN date END ASC,
	CASE WHEN $14::text = 'next' THEN t_attendances_pkey END ASC,
	CASE WHEN $14::text = 'prev' THEN t_attendances_pkey END DESC
LIMIT $1
`

type GetAttendanceWithSendOrganizationUseKeysetPaginateParams struct {
	Limit                   int32       `json:"limit"`
	WhereInAttendanceType   bool        `json:"where_in_attendance_type"`
	InAttendanceType        uuid.UUID   `json:"in_attendance_type"`
	WhereInMember           bool        `json:"where_in_member"`
	InMember                uuid.UUID   `json:"in_member"`
	WhereEarlierDate        bool        `json:"where_earlier_date"`
	EarlierDate             pgtype.Date `json:"earlier_date"`
	WhereLaterDate          bool        `json:"where_later_date"`
	LaterDate               pgtype.Date `json:"later_date"`
	WhereMailSendFlag       bool        `json:"where_mail_send_flag"`
	MailSendFlag            bool        `json:"mail_send_flag"`
	WhereInSendOrganization bool        `json:"where_in_send_organization"`
	InSendOrganization      pgtype.UUID `json:"in_send_organization"`
	CursorDirection         string      `json:"cursor_direction"`
	OrderMethod             string      `json:"order_method"`
	DateCursor              pgtype.Date `json:"date_cursor"`
	Cursor                  int32       `json:"cursor"`
}

type GetAttendanceWithSendOrganizationUseKeysetPaginateRow struct {
	TAttendancesPkey   pgtype.Int8  `json:"t_attendances_pkey"`
	AttendanceID       uuid.UUID    `json:"attendance_id"`
	AttendanceTypeID   uuid.UUID    `json:"attendance_type_id"`
	MemberID           uuid.UUID    `json:"member_id"`
	Description        string       `json:"description"`
	Date               pgtype.Date  `json:"date"`
	MailSendFlag       bool         `json:"mail_send_flag"`
	SendOrganizationID pgtype.UUID  `json:"send_organization_id"`
	PostedAt           time.Time    `json:"posted_at"`
	LastEditedAt       time.Time    `json:"last_edited_at"`
	Organization       Organization `json:"organization"`
}

func (q *Queries) GetAttendanceWithSendOrganizationUseKeysetPaginate(ctx context.Context, arg GetAttendanceWithSendOrganizationUseKeysetPaginateParams) ([]GetAttendanceWithSendOrganizationUseKeysetPaginateRow, error) {
	rows, err := q.db.Query(ctx, getAttendanceWithSendOrganizationUseKeysetPaginate,
		arg.Limit,
		arg.WhereInAttendanceType,
		arg.InAttendanceType,
		arg.WhereInMember,
		arg.InMember,
		arg.WhereEarlierDate,
		arg.EarlierDate,
		arg.WhereLaterDate,
		arg.LaterDate,
		arg.WhereMailSendFlag,
		arg.MailSendFlag,
		arg.WhereInSendOrganization,
		arg.InSendOrganization,
		arg.CursorDirection,
		arg.OrderMethod,
		arg.DateCursor,
		arg.Cursor,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAttendanceWithSendOrganizationUseKeysetPaginateRow{}
	for rows.Next() {
		var i GetAttendanceWithSendOrganizationUseKeysetPaginateRow
		if err := rows.Scan(
			&i.TAttendancesPkey,
			&i.AttendanceID,
			&i.AttendanceTypeID,
			&i.MemberID,
			&i.Description,
			&i.Date,
			&i.MailSendFlag,
			&i.SendOrganizationID,
			&i.PostedAt,
			&i.LastEditedAt,
			&i.Organization.MOrganizationsPkey,
			&i.Organization.OrganizationID,
			&i.Organization.Name,
			&i.Organization.Description,
			&i.Organization.Color,
			&i.Organization.IsPersonal,
			&i.Organization.IsWhole,
			&i.Organization.CreatedAt,
			&i.Organization.UpdatedAt,
			&i.Organization.ChatRoomID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAttendanceWithSendOrganizationUseNumberedPaginate = `-- name: GetAttendanceWithSendOrganizationUseNumberedPaginate :many
SELECT t_attendances.t_attendances_pkey, t_attendances.attendance_id, t_attendances.attendance_type_id, t_attendances.member_id, t_attendances.description, t_attendances.date, t_attendances.mail_send_flag, t_attendances.send_organization_id, t_attendances.posted_at, t_attendances.last_edited_at, m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.color, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at, m_organizations.chat_room_id FROM t_attendances
LEFT JOIN m_organizations ON t_attendances.send_organization_id = m_organizations.organization_id
WHERE
	CASE WHEN $3::boolean = true THEN t_attendances.attendance_type_id = ANY($4) ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN t_attendances.member_id = ANY($6) ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN t_attendances.date >= $8 ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN t_attendances.date <= $10 ELSE TRUE END
AND
	CASE WHEN $11::boolean = true THEN t_attendances.mail_send_flag = $12 ELSE TRUE END
AND
	CASE WHEN $13::boolean = true THEN t_attendances.send_organization_id = ANY($14) ELSE TRUE END
ORDER BY
	CASE WHEN $15::text = 'date' THEN t_attendances.date END ASC,
	CASE WHEN $15::text = 'r_date' THEN t_attendances.date END DESC,
	t_attendances_pkey ASC
LIMIT $1 OFFSET $2
`

type GetAttendanceWithSendOrganizationUseNumberedPaginateParams struct {
	Limit                   int32       `json:"limit"`
	Offset                  int32       `json:"offset"`
	WhereInAttendanceType   bool        `json:"where_in_attendance_type"`
	InAttendanceType        uuid.UUID   `json:"in_attendance_type"`
	WhereInMember           bool        `json:"where_in_member"`
	InMember                uuid.UUID   `json:"in_member"`
	WhereEarlierDate        bool        `json:"where_earlier_date"`
	EarlierDate             pgtype.Date `json:"earlier_date"`
	WhereLaterDate          bool        `json:"where_later_date"`
	LaterDate               pgtype.Date `json:"later_date"`
	WhereMailSendFlag       bool        `json:"where_mail_send_flag"`
	MailSendFlag            bool        `json:"mail_send_flag"`
	WhereInSendOrganization bool        `json:"where_in_send_organization"`
	InSendOrganization      pgtype.UUID `json:"in_send_organization"`
	OrderMethod             string      `json:"order_method"`
}

type GetAttendanceWithSendOrganizationUseNumberedPaginateRow struct {
	TAttendancesPkey   pgtype.Int8  `json:"t_attendances_pkey"`
	AttendanceID       uuid.UUID    `json:"attendance_id"`
	AttendanceTypeID   uuid.UUID    `json:"attendance_type_id"`
	MemberID           uuid.UUID    `json:"member_id"`
	Description        string       `json:"description"`
	Date               pgtype.Date  `json:"date"`
	MailSendFlag       bool         `json:"mail_send_flag"`
	SendOrganizationID pgtype.UUID  `json:"send_organization_id"`
	PostedAt           time.Time    `json:"posted_at"`
	LastEditedAt       time.Time    `json:"last_edited_at"`
	Organization       Organization `json:"organization"`
}

func (q *Queries) GetAttendanceWithSendOrganizationUseNumberedPaginate(ctx context.Context, arg GetAttendanceWithSendOrganizationUseNumberedPaginateParams) ([]GetAttendanceWithSendOrganizationUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getAttendanceWithSendOrganizationUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.WhereInAttendanceType,
		arg.InAttendanceType,
		arg.WhereInMember,
		arg.InMember,
		arg.WhereEarlierDate,
		arg.EarlierDate,
		arg.WhereLaterDate,
		arg.LaterDate,
		arg.WhereMailSendFlag,
		arg.MailSendFlag,
		arg.WhereInSendOrganization,
		arg.InSendOrganization,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAttendanceWithSendOrganizationUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetAttendanceWithSendOrganizationUseNumberedPaginateRow
		if err := rows.Scan(
			&i.TAttendancesPkey,
			&i.AttendanceID,
			&i.AttendanceTypeID,
			&i.MemberID,
			&i.Description,
			&i.Date,
			&i.MailSendFlag,
			&i.SendOrganizationID,
			&i.PostedAt,
			&i.LastEditedAt,
			&i.Organization.MOrganizationsPkey,
			&i.Organization.OrganizationID,
			&i.Organization.Name,
			&i.Organization.Description,
			&i.Organization.Color,
			&i.Organization.IsPersonal,
			&i.Organization.IsWhole,
			&i.Organization.CreatedAt,
			&i.Organization.UpdatedAt,
			&i.Organization.ChatRoomID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAttendances = `-- name: GetAttendances :many
SELECT t_attendances_pkey, attendance_id, attendance_type_id, member_id, description, date, mail_send_flag, send_organization_id, posted_at, last_edited_at FROM t_attendances
WHERE
	CASE WHEN $1::boolean = true THEN t_attendances.attendance_type_id = ANY($2) ELSE TRUE END
AND
	CASE WHEN $3::boolean = true THEN t_attendances.member_id = ANY($4) ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN t_attendances.date >= $6 ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN t_attendances.date <= $8 ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN t_attendances.mail_send_flag = $10 ELSE TRUE END
AND
	CASE WHEN $11::boolean = true THEN t_attendances.send_organization_id = ANY($12) ELSE TRUE END
ORDER BY
	CASE WHEN $13::text = 'date' THEN t_attendances.date END ASC,
	CASE WHEN $13::text = 'r_date' THEN t_attendances.date END DESC,
	t_attendances_pkey ASC
`

type GetAttendancesParams struct {
	WhereInAttendanceType   bool        `json:"where_in_attendance_type"`
	InAttendanceType        uuid.UUID   `json:"in_attendance_type"`
	WhereInMember           bool        `json:"where_in_member"`
	InMember                uuid.UUID   `json:"in_member"`
	WhereEarlierDate        bool        `json:"where_earlier_date"`
	EarlierDate             pgtype.Date `json:"earlier_date"`
	WhereLaterDate          bool        `json:"where_later_date"`
	LaterDate               pgtype.Date `json:"later_date"`
	WhereMailSendFlag       bool        `json:"where_mail_send_flag"`
	MailSendFlag            bool        `json:"mail_send_flag"`
	WhereInSendOrganization bool        `json:"where_in_send_organization"`
	InSendOrganization      pgtype.UUID `json:"in_send_organization"`
	OrderMethod             string      `json:"order_method"`
}

func (q *Queries) GetAttendances(ctx context.Context, arg GetAttendancesParams) ([]Attendance, error) {
	rows, err := q.db.Query(ctx, getAttendances,
		arg.WhereInAttendanceType,
		arg.InAttendanceType,
		arg.WhereInMember,
		arg.InMember,
		arg.WhereEarlierDate,
		arg.EarlierDate,
		arg.WhereLaterDate,
		arg.LaterDate,
		arg.WhereMailSendFlag,
		arg.MailSendFlag,
		arg.WhereInSendOrganization,
		arg.InSendOrganization,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Attendance{}
	for rows.Next() {
		var i Attendance
		if err := rows.Scan(
			&i.TAttendancesPkey,
			&i.AttendanceID,
			&i.AttendanceTypeID,
			&i.MemberID,
			&i.Description,
			&i.Date,
			&i.MailSendFlag,
			&i.SendOrganizationID,
			&i.PostedAt,
			&i.LastEditedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralAttendanceWithAll = `-- name: GetPluralAttendanceWithAll :many
SELECT t_attendances.t_attendances_pkey, t_attendances.attendance_id, t_attendances.attendance_type_id, t_attendances.member_id, t_attendances.description, t_attendances.date, t_attendances.mail_send_flag, t_attendances.send_organization_id, t_attendances.posted_at, t_attendances.last_edited_at, m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_url, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_attendance_types.attendance_type_id, m_attendance_types.name as attendance_type_name, m_attendance_types.key as attendance_type_key, m_attendance_types.color as attendance_type_color, m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.color, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at, m_organizations.chat_room_id, t_early_leavings.t_early_leavings_pkey, t_early_leavings.early_leaving_id, t_early_leavings.attendance_id, t_early_leavings.leave_time, t_late_arrivals.t_late_arrivals_pkey, t_late_arrivals.late_arrival_id, t_late_arrivals.attendance_id, t_late_arrivals.arrive_time, t_absences.t_absences_pkey, t_absences.absence_id, t_absences.attendance_id FROM t_attendances
LEFT JOIN t_early_leavings ON t_attendances.attendance_id = t_early_leavings.attendance_id
LEFT JOIN t_late_arrivals ON t_attendances.attendance_id = t_late_arrivals.attendance_id
LEFT JOIN t_absences ON t_attendances.attendance_id = t_absences.attendance_id
LEFT JOIN m_members ON t_attendances.member_id = m_members.member_id
LEFT JOIN m_attend_statuses ON m_members.attend_status_id = m_attend_statuses.attend_status_id
LEFT JOIN m_grades ON m_members.grade_id = m_grades.grade_id
LEFT JOIN m_groups ON m_members.group_id = m_groups.group_id
LEFT JOIN m_attendance_types ON t_attendances.attendance_type_id = m_attendance_types.attendance_type_id
LEFT JOIN m_organizations ON t_attendances.send_organization_id = m_organizations.organization_id
WHERE attendance_id = ANY($3::uuid[])
ORDER BY
	t_attendances_pkey ASC
LIMIT $1 OFFSET $2
`

type GetPluralAttendanceWithAllParams struct {
	Limit         int32       `json:"limit"`
	Offset        int32       `json:"offset"`
	AttendanceIds []uuid.UUID `json:"attendance_ids"`
}

type GetPluralAttendanceWithAllRow struct {
	TAttendancesPkey    pgtype.Int8  `json:"t_attendances_pkey"`
	AttendanceID        uuid.UUID    `json:"attendance_id"`
	AttendanceTypeID    uuid.UUID    `json:"attendance_type_id"`
	MemberID            uuid.UUID    `json:"member_id"`
	Description         string       `json:"description"`
	Date                pgtype.Date  `json:"date"`
	MailSendFlag        bool         `json:"mail_send_flag"`
	SendOrganizationID  pgtype.UUID  `json:"send_organization_id"`
	PostedAt            time.Time    `json:"posted_at"`
	LastEditedAt        time.Time    `json:"last_edited_at"`
	Member              Member       `json:"member"`
	AttendanceTypeID_2  pgtype.UUID  `json:"attendance_type_id_2"`
	AttendanceTypeName  pgtype.Text  `json:"attendance_type_name"`
	AttendanceTypeKey   pgtype.Text  `json:"attendance_type_key"`
	AttendanceTypeColor pgtype.Text  `json:"attendance_type_color"`
	Organization        Organization `json:"organization"`
	EarlyLeaving        EarlyLeaving `json:"early_leaving"`
	LateArrival         LateArrival  `json:"late_arrival"`
	Absence             Absence      `json:"absence"`
}

func (q *Queries) GetPluralAttendanceWithAll(ctx context.Context, arg GetPluralAttendanceWithAllParams) ([]GetPluralAttendanceWithAllRow, error) {
	rows, err := q.db.Query(ctx, getPluralAttendanceWithAll, arg.Limit, arg.Offset, arg.AttendanceIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralAttendanceWithAllRow{}
	for rows.Next() {
		var i GetPluralAttendanceWithAllRow
		if err := rows.Scan(
			&i.TAttendancesPkey,
			&i.AttendanceID,
			&i.AttendanceTypeID,
			&i.MemberID,
			&i.Description,
			&i.Date,
			&i.MailSendFlag,
			&i.SendOrganizationID,
			&i.PostedAt,
			&i.LastEditedAt,
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageUrl,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
			&i.AttendanceTypeID_2,
			&i.AttendanceTypeName,
			&i.AttendanceTypeKey,
			&i.AttendanceTypeColor,
			&i.Organization.MOrganizationsPkey,
			&i.Organization.OrganizationID,
			&i.Organization.Name,
			&i.Organization.Description,
			&i.Organization.Color,
			&i.Organization.IsPersonal,
			&i.Organization.IsWhole,
			&i.Organization.CreatedAt,
			&i.Organization.UpdatedAt,
			&i.Organization.ChatRoomID,
			&i.EarlyLeaving.TEarlyLeavingsPkey,
			&i.EarlyLeaving.EarlyLeavingID,
			&i.EarlyLeaving.AttendanceID,
			&i.EarlyLeaving.LeaveTime,
			&i.LateArrival.TLateArrivalsPkey,
			&i.LateArrival.LateArrivalID,
			&i.LateArrival.AttendanceID,
			&i.LateArrival.ArriveTime,
			&i.Absence.TAbsencesPkey,
			&i.Absence.AbsenceID,
			&i.Absence.AttendanceID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralAttendanceWithAttendanceType = `-- name: GetPluralAttendanceWithAttendanceType :many
SELECT t_attendances.t_attendances_pkey, t_attendances.attendance_id, t_attendances.attendance_type_id, t_attendances.member_id, t_attendances.description, t_attendances.date, t_attendances.mail_send_flag, t_attendances.send_organization_id, t_attendances.posted_at, t_attendances.last_edited_at, m_attendance_types.attendance_type_id, m_attendance_types.name as attendance_type_name, m_attendance_types.key as attendance_type_key, m_attendance_types.color as attendance_type_color FROM t_attendances
LEFT JOIN m_attendance_types ON t_attendances.attendance_type_id = m_attendance_types.attendance_type_id
WHERE attendance_id = ANY($3::uuid[])
ORDER BY
	t_attendances_pkey ASC
LIMIT $1 OFFSET $2
`

type GetPluralAttendanceWithAttendanceTypeParams struct {
	Limit         int32       `json:"limit"`
	Offset        int32       `json:"offset"`
	AttendanceIds []uuid.UUID `json:"attendance_ids"`
}

type GetPluralAttendanceWithAttendanceTypeRow struct {
	TAttendancesPkey    pgtype.Int8 `json:"t_attendances_pkey"`
	AttendanceID        uuid.UUID   `json:"attendance_id"`
	AttendanceTypeID    uuid.UUID   `json:"attendance_type_id"`
	MemberID            uuid.UUID   `json:"member_id"`
	Description         string      `json:"description"`
	Date                pgtype.Date `json:"date"`
	MailSendFlag        bool        `json:"mail_send_flag"`
	SendOrganizationID  pgtype.UUID `json:"send_organization_id"`
	PostedAt            time.Time   `json:"posted_at"`
	LastEditedAt        time.Time   `json:"last_edited_at"`
	AttendanceTypeID_2  pgtype.UUID `json:"attendance_type_id_2"`
	AttendanceTypeName  pgtype.Text `json:"attendance_type_name"`
	AttendanceTypeKey   pgtype.Text `json:"attendance_type_key"`
	AttendanceTypeColor pgtype.Text `json:"attendance_type_color"`
}

func (q *Queries) GetPluralAttendanceWithAttendanceType(ctx context.Context, arg GetPluralAttendanceWithAttendanceTypeParams) ([]GetPluralAttendanceWithAttendanceTypeRow, error) {
	rows, err := q.db.Query(ctx, getPluralAttendanceWithAttendanceType, arg.Limit, arg.Offset, arg.AttendanceIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralAttendanceWithAttendanceTypeRow{}
	for rows.Next() {
		var i GetPluralAttendanceWithAttendanceTypeRow
		if err := rows.Scan(
			&i.TAttendancesPkey,
			&i.AttendanceID,
			&i.AttendanceTypeID,
			&i.MemberID,
			&i.Description,
			&i.Date,
			&i.MailSendFlag,
			&i.SendOrganizationID,
			&i.PostedAt,
			&i.LastEditedAt,
			&i.AttendanceTypeID_2,
			&i.AttendanceTypeName,
			&i.AttendanceTypeKey,
			&i.AttendanceTypeColor,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralAttendanceWithDetails = `-- name: GetPluralAttendanceWithDetails :many
SELECT t_attendances.t_attendances_pkey, t_attendances.attendance_id, t_attendances.attendance_type_id, t_attendances.member_id, t_attendances.description, t_attendances.date, t_attendances.mail_send_flag, t_attendances.send_organization_id, t_attendances.posted_at, t_attendances.last_edited_at, t_early_leavings.t_early_leavings_pkey, t_early_leavings.early_leaving_id, t_early_leavings.attendance_id, t_early_leavings.leave_time, t_late_arrivals.t_late_arrivals_pkey, t_late_arrivals.late_arrival_id, t_late_arrivals.attendance_id, t_late_arrivals.arrive_time, t_absences.t_absences_pkey, t_absences.absence_id, t_absences.attendance_id FROM t_attendances
LEFT JOIN t_early_leavings ON t_attendances.attendance_id = t_early_leavings.attendance_id
LEFT JOIN t_late_arrivals ON t_attendances.attendance_id = t_late_arrivals.attendance_id
LEFT JOIN t_absences ON t_attendances.attendance_id = t_absences.attendance_id
WHERE attendance_id = ANY($3::uuid[])
ORDER BY
	t_attendances_pkey ASC
LIMIT $1 OFFSET $2
`

type GetPluralAttendanceWithDetailsParams struct {
	Limit         int32       `json:"limit"`
	Offset        int32       `json:"offset"`
	AttendanceIds []uuid.UUID `json:"attendance_ids"`
}

type GetPluralAttendanceWithDetailsRow struct {
	TAttendancesPkey   pgtype.Int8  `json:"t_attendances_pkey"`
	AttendanceID       uuid.UUID    `json:"attendance_id"`
	AttendanceTypeID   uuid.UUID    `json:"attendance_type_id"`
	MemberID           uuid.UUID    `json:"member_id"`
	Description        string       `json:"description"`
	Date               pgtype.Date  `json:"date"`
	MailSendFlag       bool         `json:"mail_send_flag"`
	SendOrganizationID pgtype.UUID  `json:"send_organization_id"`
	PostedAt           time.Time    `json:"posted_at"`
	LastEditedAt       time.Time    `json:"last_edited_at"`
	EarlyLeaving       EarlyLeaving `json:"early_leaving"`
	LateArrival        LateArrival  `json:"late_arrival"`
	Absence            Absence      `json:"absence"`
}

func (q *Queries) GetPluralAttendanceWithDetails(ctx context.Context, arg GetPluralAttendanceWithDetailsParams) ([]GetPluralAttendanceWithDetailsRow, error) {
	rows, err := q.db.Query(ctx, getPluralAttendanceWithDetails, arg.Limit, arg.Offset, arg.AttendanceIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralAttendanceWithDetailsRow{}
	for rows.Next() {
		var i GetPluralAttendanceWithDetailsRow
		if err := rows.Scan(
			&i.TAttendancesPkey,
			&i.AttendanceID,
			&i.AttendanceTypeID,
			&i.MemberID,
			&i.Description,
			&i.Date,
			&i.MailSendFlag,
			&i.SendOrganizationID,
			&i.PostedAt,
			&i.LastEditedAt,
			&i.EarlyLeaving.TEarlyLeavingsPkey,
			&i.EarlyLeaving.EarlyLeavingID,
			&i.EarlyLeaving.AttendanceID,
			&i.EarlyLeaving.LeaveTime,
			&i.LateArrival.TLateArrivalsPkey,
			&i.LateArrival.LateArrivalID,
			&i.LateArrival.AttendanceID,
			&i.LateArrival.ArriveTime,
			&i.Absence.TAbsencesPkey,
			&i.Absence.AbsenceID,
			&i.Absence.AttendanceID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralAttendanceWithMember = `-- name: GetPluralAttendanceWithMember :many
SELECT t_attendances.t_attendances_pkey, t_attendances.attendance_id, t_attendances.attendance_type_id, t_attendances.member_id, t_attendances.description, t_attendances.date, t_attendances.mail_send_flag, t_attendances.send_organization_id, t_attendances.posted_at, t_attendances.last_edited_at, m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_url, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at FROM t_attendances
LEFT JOIN m_members ON t_attendances.member_id = m_members.member_id
LEFT JOIN m_attend_statuses ON m_members.attend_status_id = m_attend_statuses.attend_status_id
LEFT JOIN m_grades ON m_members.grade_id = m_grades.grade_id
LEFT JOIN m_groups ON m_members.group_id = m_groups.group_id
WHERE attendance_id = ANY($3::uuid[])
ORDER BY
	t_attendances_pkey ASC
LIMIT $1 OFFSET $2
`

type GetPluralAttendanceWithMemberParams struct {
	Limit         int32       `json:"limit"`
	Offset        int32       `json:"offset"`
	AttendanceIds []uuid.UUID `json:"attendance_ids"`
}

type GetPluralAttendanceWithMemberRow struct {
	TAttendancesPkey   pgtype.Int8 `json:"t_attendances_pkey"`
	AttendanceID       uuid.UUID   `json:"attendance_id"`
	AttendanceTypeID   uuid.UUID   `json:"attendance_type_id"`
	MemberID           uuid.UUID   `json:"member_id"`
	Description        string      `json:"description"`
	Date               pgtype.Date `json:"date"`
	MailSendFlag       bool        `json:"mail_send_flag"`
	SendOrganizationID pgtype.UUID `json:"send_organization_id"`
	PostedAt           time.Time   `json:"posted_at"`
	LastEditedAt       time.Time   `json:"last_edited_at"`
	Member             Member      `json:"member"`
}

func (q *Queries) GetPluralAttendanceWithMember(ctx context.Context, arg GetPluralAttendanceWithMemberParams) ([]GetPluralAttendanceWithMemberRow, error) {
	rows, err := q.db.Query(ctx, getPluralAttendanceWithMember, arg.Limit, arg.Offset, arg.AttendanceIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralAttendanceWithMemberRow{}
	for rows.Next() {
		var i GetPluralAttendanceWithMemberRow
		if err := rows.Scan(
			&i.TAttendancesPkey,
			&i.AttendanceID,
			&i.AttendanceTypeID,
			&i.MemberID,
			&i.Description,
			&i.Date,
			&i.MailSendFlag,
			&i.SendOrganizationID,
			&i.PostedAt,
			&i.LastEditedAt,
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageUrl,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralAttendanceWithSendOrganization = `-- name: GetPluralAttendanceWithSendOrganization :many
SELECT t_attendances.t_attendances_pkey, t_attendances.attendance_id, t_attendances.attendance_type_id, t_attendances.member_id, t_attendances.description, t_attendances.date, t_attendances.mail_send_flag, t_attendances.send_organization_id, t_attendances.posted_at, t_attendances.last_edited_at, m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.color, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at, m_organizations.chat_room_id FROM t_attendances
LEFT JOIN m_organizations ON t_attendances.send_organization_id = m_organizations.organization_id
WHERE attendance_id = ANY($3::uuid[])
ORDER BY
	t_attendances_pkey ASC
LIMIT $1 OFFSET $2
`

type GetPluralAttendanceWithSendOrganizationParams struct {
	Limit         int32       `json:"limit"`
	Offset        int32       `json:"offset"`
	AttendanceIds []uuid.UUID `json:"attendance_ids"`
}

type GetPluralAttendanceWithSendOrganizationRow struct {
	TAttendancesPkey   pgtype.Int8  `json:"t_attendances_pkey"`
	AttendanceID       uuid.UUID    `json:"attendance_id"`
	AttendanceTypeID   uuid.UUID    `json:"attendance_type_id"`
	MemberID           uuid.UUID    `json:"member_id"`
	Description        string       `json:"description"`
	Date               pgtype.Date  `json:"date"`
	MailSendFlag       bool         `json:"mail_send_flag"`
	SendOrganizationID pgtype.UUID  `json:"send_organization_id"`
	PostedAt           time.Time    `json:"posted_at"`
	LastEditedAt       time.Time    `json:"last_edited_at"`
	Organization       Organization `json:"organization"`
}

func (q *Queries) GetPluralAttendanceWithSendOrganization(ctx context.Context, arg GetPluralAttendanceWithSendOrganizationParams) ([]GetPluralAttendanceWithSendOrganizationRow, error) {
	rows, err := q.db.Query(ctx, getPluralAttendanceWithSendOrganization, arg.Limit, arg.Offset, arg.AttendanceIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralAttendanceWithSendOrganizationRow{}
	for rows.Next() {
		var i GetPluralAttendanceWithSendOrganizationRow
		if err := rows.Scan(
			&i.TAttendancesPkey,
			&i.AttendanceID,
			&i.AttendanceTypeID,
			&i.MemberID,
			&i.Description,
			&i.Date,
			&i.MailSendFlag,
			&i.SendOrganizationID,
			&i.PostedAt,
			&i.LastEditedAt,
			&i.Organization.MOrganizationsPkey,
			&i.Organization.OrganizationID,
			&i.Organization.Name,
			&i.Organization.Description,
			&i.Organization.Color,
			&i.Organization.IsPersonal,
			&i.Organization.IsWhole,
			&i.Organization.CreatedAt,
			&i.Organization.UpdatedAt,
			&i.Organization.ChatRoomID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralAttendances = `-- name: GetPluralAttendances :many
SELECT t_attendances_pkey, attendance_id, attendance_type_id, member_id, description, date, mail_send_flag, send_organization_id, posted_at, last_edited_at FROM t_attendances
WHERE attendance_id = ANY($3::uuid[])
ORDER BY
	t_attendances_pkey ASC
LIMIT $1 OFFSET $2
`

type GetPluralAttendancesParams struct {
	Limit         int32       `json:"limit"`
	Offset        int32       `json:"offset"`
	AttendanceIds []uuid.UUID `json:"attendance_ids"`
}

func (q *Queries) GetPluralAttendances(ctx context.Context, arg GetPluralAttendancesParams) ([]Attendance, error) {
	rows, err := q.db.Query(ctx, getPluralAttendances, arg.Limit, arg.Offset, arg.AttendanceIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Attendance{}
	for rows.Next() {
		var i Attendance
		if err := rows.Scan(
			&i.TAttendancesPkey,
			&i.AttendanceID,
			&i.AttendanceTypeID,
			&i.MemberID,
			&i.Description,
			&i.Date,
			&i.MailSendFlag,
			&i.SendOrganizationID,
			&i.PostedAt,
			&i.LastEditedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const pluralDeleteAttendances = `-- name: PluralDeleteAttendances :exec
DELETE FROM t_attendances WHERE attendance_id = ANY($1::uuid[])
`

func (q *Queries) PluralDeleteAttendances(ctx context.Context, dollar_1 []uuid.UUID) error {
	_, err := q.db.Exec(ctx, pluralDeleteAttendances, dollar_1)
	return err
}

const updateAttendance = `-- name: UpdateAttendance :one
UPDATE t_attendances SET attendance_type_id = $2, member_id = $3, description = $4, date = $5, mail_send_flag = $6, send_organization_id = $7, last_edited_at = $8 WHERE attendance_id = $1 RETURNING t_attendances_pkey, attendance_id, attendance_type_id, member_id, description, date, mail_send_flag, send_organization_id, posted_at, last_edited_at
`

type UpdateAttendanceParams struct {
	AttendanceID       uuid.UUID   `json:"attendance_id"`
	AttendanceTypeID   uuid.UUID   `json:"attendance_type_id"`
	MemberID           uuid.UUID   `json:"member_id"`
	Description        string      `json:"description"`
	Date               pgtype.Date `json:"date"`
	MailSendFlag       bool        `json:"mail_send_flag"`
	SendOrganizationID pgtype.UUID `json:"send_organization_id"`
	LastEditedAt       time.Time   `json:"last_edited_at"`
}

func (q *Queries) UpdateAttendance(ctx context.Context, arg UpdateAttendanceParams) (Attendance, error) {
	row := q.db.QueryRow(ctx, updateAttendance,
		arg.AttendanceID,
		arg.AttendanceTypeID,
		arg.MemberID,
		arg.Description,
		arg.Date,
		arg.MailSendFlag,
		arg.SendOrganizationID,
		arg.LastEditedAt,
	)
	var i Attendance
	err := row.Scan(
		&i.TAttendancesPkey,
		&i.AttendanceID,
		&i.AttendanceTypeID,
		&i.MemberID,
		&i.Description,
		&i.Date,
		&i.MailSendFlag,
		&i.SendOrganizationID,
		&i.PostedAt,
		&i.LastEditedAt,
	)
	return i, err
}
