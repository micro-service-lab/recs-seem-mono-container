// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: group.sql

package query

import (
	"context"

	"github.com/google/uuid"
)

const countGroupsByOrganizationID = `-- name: CountGroupsByOrganizationID :one
SELECT COUNT(*) FROM m_groups WHERE organization_id = $1
`

func (q *Queries) CountGroupsByOrganizationID(ctx context.Context, organizationID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countGroupsByOrganizationID, organizationID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createGroup = `-- name: CreateGroup :one
INSERT INTO m_groups (key, organization_id) VALUES ($1, $2) RETURNING m_groups_pkey, group_id, key, organization_id
`

type CreateGroupParams struct {
	Key            string    `json:"key"`
	OrganizationID uuid.UUID `json:"organization_id"`
}

func (q *Queries) CreateGroup(ctx context.Context, arg CreateGroupParams) (Group, error) {
	row := q.db.QueryRow(ctx, createGroup, arg.Key, arg.OrganizationID)
	var i Group
	err := row.Scan(
		&i.MGroupsPkey,
		&i.GroupID,
		&i.Key,
		&i.OrganizationID,
	)
	return i, err
}

type CreateGroupsParams struct {
	Key            string    `json:"key"`
	OrganizationID uuid.UUID `json:"organization_id"`
}

const deleteGroup = `-- name: DeleteGroup :exec
DELETE FROM m_groups WHERE group_id = $1
`

func (q *Queries) DeleteGroup(ctx context.Context, groupID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteGroup, groupID)
	return err
}

const findGroupByID = `-- name: FindGroupByID :one
SELECT m_groups_pkey, group_id, key, organization_id FROM m_groups WHERE group_id = $1
`

func (q *Queries) FindGroupByID(ctx context.Context, groupID uuid.UUID) (Group, error) {
	row := q.db.QueryRow(ctx, findGroupByID, groupID)
	var i Group
	err := row.Scan(
		&i.MGroupsPkey,
		&i.GroupID,
		&i.Key,
		&i.OrganizationID,
	)
	return i, err
}

const findGroupByIDWithOrganization = `-- name: FindGroupByIDWithOrganization :one
SELECT m_groups.m_groups_pkey, m_groups.group_id, m_groups.key, m_groups.organization_id, m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at FROM m_groups
INNER JOIN m_organizations ON m_groups.organization_id = m_organizations.organization_id
WHERE group_id = $1
`

type FindGroupByIDWithOrganizationRow struct {
	Group        Group        `json:"group"`
	Organization Organization `json:"organization"`
}

func (q *Queries) FindGroupByIDWithOrganization(ctx context.Context, groupID uuid.UUID) (FindGroupByIDWithOrganizationRow, error) {
	row := q.db.QueryRow(ctx, findGroupByIDWithOrganization, groupID)
	var i FindGroupByIDWithOrganizationRow
	err := row.Scan(
		&i.Group.MGroupsPkey,
		&i.Group.GroupID,
		&i.Group.Key,
		&i.Group.OrganizationID,
		&i.Organization.MOrganizationsPkey,
		&i.Organization.OrganizationID,
		&i.Organization.Name,
		&i.Organization.Description,
		&i.Organization.IsPersonal,
		&i.Organization.IsWhole,
		&i.Organization.CreatedAt,
		&i.Organization.UpdatedAt,
	)
	return i, err
}

const findGroupByKey = `-- name: FindGroupByKey :one
SELECT m_groups_pkey, group_id, key, organization_id FROM m_groups WHERE key = $1
`

func (q *Queries) FindGroupByKey(ctx context.Context, key string) (Group, error) {
	row := q.db.QueryRow(ctx, findGroupByKey, key)
	var i Group
	err := row.Scan(
		&i.MGroupsPkey,
		&i.GroupID,
		&i.Key,
		&i.OrganizationID,
	)
	return i, err
}

const findGroupByKeyWithOrganization = `-- name: FindGroupByKeyWithOrganization :one
SELECT m_groups.m_groups_pkey, m_groups.group_id, m_groups.key, m_groups.organization_id, m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at FROM m_groups
INNER JOIN m_organizations ON m_groups.organization_id = m_organizations.organization_id
WHERE key = $1
`

type FindGroupByKeyWithOrganizationRow struct {
	Group        Group        `json:"group"`
	Organization Organization `json:"organization"`
}

func (q *Queries) FindGroupByKeyWithOrganization(ctx context.Context, key string) (FindGroupByKeyWithOrganizationRow, error) {
	row := q.db.QueryRow(ctx, findGroupByKeyWithOrganization, key)
	var i FindGroupByKeyWithOrganizationRow
	err := row.Scan(
		&i.Group.MGroupsPkey,
		&i.Group.GroupID,
		&i.Group.Key,
		&i.Group.OrganizationID,
		&i.Organization.MOrganizationsPkey,
		&i.Organization.OrganizationID,
		&i.Organization.Name,
		&i.Organization.Description,
		&i.Organization.IsPersonal,
		&i.Organization.IsWhole,
		&i.Organization.CreatedAt,
		&i.Organization.UpdatedAt,
	)
	return i, err
}

const getGroupsByOrganizationID = `-- name: GetGroupsByOrganizationID :many
SELECT m_groups_pkey, group_id, key, organization_id FROM m_groups WHERE organization_id = $1
ORDER BY
	m_groups_pkey DESC
LIMIT $2 OFFSET $3
`

type GetGroupsByOrganizationIDParams struct {
	OrganizationID uuid.UUID `json:"organization_id"`
	Limit          int32     `json:"limit"`
	Offset         int32     `json:"offset"`
}

func (q *Queries) GetGroupsByOrganizationID(ctx context.Context, arg GetGroupsByOrganizationIDParams) ([]Group, error) {
	rows, err := q.db.Query(ctx, getGroupsByOrganizationID, arg.OrganizationID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Group{}
	for rows.Next() {
		var i Group
		if err := rows.Scan(
			&i.MGroupsPkey,
			&i.GroupID,
			&i.Key,
			&i.OrganizationID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGroupsByOrganizationIDWithOrganization = `-- name: GetGroupsByOrganizationIDWithOrganization :many
SELECT m_groups.m_groups_pkey, m_groups.group_id, m_groups.key, m_groups.organization_id, m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at FROM m_groups
INNER JOIN m_organizations ON m_groups.organization_id = m_organizations.organization_id
WHERE m_groups.organization_id = $1
ORDER BY
	CASE WHEN $4::text = 'name' THEN m_groups.name END ASC,
	m_groups_pkey DESC
LIMIT $2 OFFSET $3
`

type GetGroupsByOrganizationIDWithOrganizationParams struct {
	OrganizationID uuid.UUID `json:"organization_id"`
	Limit          int32     `json:"limit"`
	Offset         int32     `json:"offset"`
	OrderMethod    string    `json:"order_method"`
}

type GetGroupsByOrganizationIDWithOrganizationRow struct {
	Group        Group        `json:"group"`
	Organization Organization `json:"organization"`
}

func (q *Queries) GetGroupsByOrganizationIDWithOrganization(ctx context.Context, arg GetGroupsByOrganizationIDWithOrganizationParams) ([]GetGroupsByOrganizationIDWithOrganizationRow, error) {
	rows, err := q.db.Query(ctx, getGroupsByOrganizationIDWithOrganization,
		arg.OrganizationID,
		arg.Limit,
		arg.Offset,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetGroupsByOrganizationIDWithOrganizationRow{}
	for rows.Next() {
		var i GetGroupsByOrganizationIDWithOrganizationRow
		if err := rows.Scan(
			&i.Group.MGroupsPkey,
			&i.Group.GroupID,
			&i.Group.Key,
			&i.Group.OrganizationID,
			&i.Organization.MOrganizationsPkey,
			&i.Organization.OrganizationID,
			&i.Organization.Name,
			&i.Organization.Description,
			&i.Organization.IsPersonal,
			&i.Organization.IsWhole,
			&i.Organization.CreatedAt,
			&i.Organization.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
