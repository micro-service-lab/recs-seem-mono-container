// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: event.sql

package query

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countEvents = `-- name: CountEvents :one
SELECT COUNT(*) FROM t_events
WHERE
	CASE WHEN $1::boolean = true THEN title LIKE '%' || $2::text || '%' ELSE TRUE END
AND
	CASE WHEN $3::boolean = true THEN t_events.organization_id = $4 ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN mail_send_flag = $6 ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN send_organization_id = $8 ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN start_time >= $10 ELSE TRUE END
AND
	CASE WHEN $11::boolean = true THEN start_time <= $12 ELSE TRUE END
AND
	CASE WHEN $13::boolean = true THEN end_time >= $14 ELSE TRUE END
AND
	CASE WHEN $15::boolean = true THEN end_time <= $16 ELSE TRUE END
`

type CountEventsParams struct {
	WhereLikeTitle        bool        `json:"where_like_title"`
	SearchTitle           string      `json:"search_title"`
	WhereOrganization     bool        `json:"where_organization"`
	OrganizationID        pgtype.UUID `json:"organization_id"`
	WhereMailSendFlag     bool        `json:"where_mail_send_flag"`
	MailSendFlag          bool        `json:"mail_send_flag"`
	WhereSendOrganization bool        `json:"where_send_organization"`
	SendOrganizationID    pgtype.UUID `json:"send_organization_id"`
	WhereEarlierStartTime bool        `json:"where_earlier_start_time"`
	EarlierStartTime      time.Time   `json:"earlier_start_time"`
	WhereLaterStartTime   bool        `json:"where_later_start_time"`
	LaterStartTime        time.Time   `json:"later_start_time"`
	WhereEarlierEndTime   bool        `json:"where_earlier_end_time"`
	EarlierEndTime        time.Time   `json:"earlier_end_time"`
	WhereLaterEndTime     bool        `json:"where_later_end_time"`
	LaterEndTime          time.Time   `json:"later_end_time"`
}

func (q *Queries) CountEvents(ctx context.Context, arg CountEventsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countEvents,
		arg.WhereLikeTitle,
		arg.SearchTitle,
		arg.WhereOrganization,
		arg.OrganizationID,
		arg.WhereMailSendFlag,
		arg.MailSendFlag,
		arg.WhereSendOrganization,
		arg.SendOrganizationID,
		arg.WhereEarlierStartTime,
		arg.EarlierStartTime,
		arg.WhereLaterStartTime,
		arg.LaterStartTime,
		arg.WhereEarlierEndTime,
		arg.EarlierEndTime,
		arg.WhereLaterEndTime,
		arg.LaterEndTime,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createEvent = `-- name: CreateEvent :one
INSERT INTO t_events (event_type_id, title, description, organization_id, start_time, end_time, mail_send_flag, send_organization_id, posted_by, last_edited_by, posted_at, last_edited_at) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12) RETURNING t_events_pkey, event_id, event_type_id, title, description, organization_id, start_time, end_time, mail_send_flag, send_organization_id, posted_by, last_edited_by, posted_at, last_edited_at
`

type CreateEventParams struct {
	EventTypeID        uuid.UUID   `json:"event_type_id"`
	Title              string      `json:"title"`
	Description        pgtype.Text `json:"description"`
	OrganizationID     pgtype.UUID `json:"organization_id"`
	StartTime          time.Time   `json:"start_time"`
	EndTime            time.Time   `json:"end_time"`
	MailSendFlag       bool        `json:"mail_send_flag"`
	SendOrganizationID pgtype.UUID `json:"send_organization_id"`
	PostedBy           pgtype.UUID `json:"posted_by"`
	LastEditedBy       pgtype.UUID `json:"last_edited_by"`
	PostedAt           time.Time   `json:"posted_at"`
	LastEditedAt       time.Time   `json:"last_edited_at"`
}

func (q *Queries) CreateEvent(ctx context.Context, arg CreateEventParams) (Event, error) {
	row := q.db.QueryRow(ctx, createEvent,
		arg.EventTypeID,
		arg.Title,
		arg.Description,
		arg.OrganizationID,
		arg.StartTime,
		arg.EndTime,
		arg.MailSendFlag,
		arg.SendOrganizationID,
		arg.PostedBy,
		arg.LastEditedBy,
		arg.PostedAt,
		arg.LastEditedAt,
	)
	var i Event
	err := row.Scan(
		&i.TEventsPkey,
		&i.EventID,
		&i.EventTypeID,
		&i.Title,
		&i.Description,
		&i.OrganizationID,
		&i.StartTime,
		&i.EndTime,
		&i.MailSendFlag,
		&i.SendOrganizationID,
		&i.PostedBy,
		&i.LastEditedBy,
		&i.PostedAt,
		&i.LastEditedAt,
	)
	return i, err
}

type CreateEventsParams struct {
	EventTypeID        uuid.UUID   `json:"event_type_id"`
	Title              string      `json:"title"`
	Description        pgtype.Text `json:"description"`
	OrganizationID     pgtype.UUID `json:"organization_id"`
	StartTime          time.Time   `json:"start_time"`
	EndTime            time.Time   `json:"end_time"`
	MailSendFlag       bool        `json:"mail_send_flag"`
	SendOrganizationID pgtype.UUID `json:"send_organization_id"`
	PostedBy           pgtype.UUID `json:"posted_by"`
	LastEditedBy       pgtype.UUID `json:"last_edited_by"`
	PostedAt           time.Time   `json:"posted_at"`
	LastEditedAt       time.Time   `json:"last_edited_at"`
}

const deleteEvent = `-- name: DeleteEvent :exec
DELETE FROM t_events WHERE event_id = $1
`

func (q *Queries) DeleteEvent(ctx context.Context, eventID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteEvent, eventID)
	return err
}

const findEventByID = `-- name: FindEventByID :one
SELECT t_events_pkey, event_id, event_type_id, title, description, organization_id, start_time, end_time, mail_send_flag, send_organization_id, posted_by, last_edited_by, posted_at, last_edited_at FROM t_events WHERE event_id = $1
`

func (q *Queries) FindEventByID(ctx context.Context, eventID uuid.UUID) (Event, error) {
	row := q.db.QueryRow(ctx, findEventByID, eventID)
	var i Event
	err := row.Scan(
		&i.TEventsPkey,
		&i.EventID,
		&i.EventTypeID,
		&i.Title,
		&i.Description,
		&i.OrganizationID,
		&i.StartTime,
		&i.EndTime,
		&i.MailSendFlag,
		&i.SendOrganizationID,
		&i.PostedBy,
		&i.LastEditedBy,
		&i.PostedAt,
		&i.LastEditedAt,
	)
	return i, err
}

const findEventByIDWithOrganization = `-- name: FindEventByIDWithOrganization :one
SELECT t_events.t_events_pkey, t_events.event_id, t_events.event_type_id, t_events.title, t_events.description, t_events.organization_id, t_events.start_time, t_events.end_time, t_events.mail_send_flag, t_events.send_organization_id, t_events.posted_by, t_events.last_edited_by, t_events.posted_at, t_events.last_edited_at, m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at FROM t_events
INNER JOIN m_organizations ON t_events.organization_id = m_organizations.organization_id
WHERE event_id = $1
`

type FindEventByIDWithOrganizationRow struct {
	Event        Event        `json:"event"`
	Organization Organization `json:"organization"`
}

func (q *Queries) FindEventByIDWithOrganization(ctx context.Context, eventID uuid.UUID) (FindEventByIDWithOrganizationRow, error) {
	row := q.db.QueryRow(ctx, findEventByIDWithOrganization, eventID)
	var i FindEventByIDWithOrganizationRow
	err := row.Scan(
		&i.Event.TEventsPkey,
		&i.Event.EventID,
		&i.Event.EventTypeID,
		&i.Event.Title,
		&i.Event.Description,
		&i.Event.OrganizationID,
		&i.Event.StartTime,
		&i.Event.EndTime,
		&i.Event.MailSendFlag,
		&i.Event.SendOrganizationID,
		&i.Event.PostedBy,
		&i.Event.LastEditedBy,
		&i.Event.PostedAt,
		&i.Event.LastEditedAt,
		&i.Organization.MOrganizationsPkey,
		&i.Organization.OrganizationID,
		&i.Organization.Name,
		&i.Organization.Description,
		&i.Organization.IsPersonal,
		&i.Organization.IsWhole,
		&i.Organization.CreatedAt,
		&i.Organization.UpdatedAt,
	)
	return i, err
}

const getEvents = `-- name: GetEvents :many
SELECT t_events_pkey, event_id, event_type_id, title, description, organization_id, start_time, end_time, mail_send_flag, send_organization_id, posted_by, last_edited_by, posted_at, last_edited_at FROM t_events
WHERE
	CASE WHEN $3::boolean = true THEN title LIKE '%' || $4::text || '%' ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN organization_id = $6 ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN mail_send_flag = $8 ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN send_organization_id = $10 ELSE TRUE END
AND
	CASE WHEN $11::boolean = true THEN start_time >= $12 ELSE TRUE END
AND
	CASE WHEN $13::boolean = true THEN start_time <= $14 ELSE TRUE END
AND
	CASE WHEN $15::boolean = true THEN end_time >= $16 ELSE TRUE END
AND
	CASE WHEN $17::boolean = true THEN end_time <= $18 ELSE TRUE END
ORDER BY
	CASE WHEN $19::text = 'start_time' THEN start_time END ASC,
	t_events_pkey DESC
LIMIT $1 OFFSET $2
`

type GetEventsParams struct {
	Limit                 int32       `json:"limit"`
	Offset                int32       `json:"offset"`
	WhereLikeTitle        bool        `json:"where_like_title"`
	SearchTitle           string      `json:"search_title"`
	WhereOrganization     bool        `json:"where_organization"`
	OrganizationID        pgtype.UUID `json:"organization_id"`
	WhereMailSendFlag     bool        `json:"where_mail_send_flag"`
	MailSendFlag          bool        `json:"mail_send_flag"`
	WhereSendOrganization bool        `json:"where_send_organization"`
	SendOrganizationID    pgtype.UUID `json:"send_organization_id"`
	WhereEarlierStartTime bool        `json:"where_earlier_start_time"`
	EarlierStartTime      time.Time   `json:"earlier_start_time"`
	WhereLaterStartTime   bool        `json:"where_later_start_time"`
	LaterStartTime        time.Time   `json:"later_start_time"`
	WhereEarlierEndTime   bool        `json:"where_earlier_end_time"`
	EarlierEndTime        time.Time   `json:"earlier_end_time"`
	WhereLaterEndTime     bool        `json:"where_later_end_time"`
	LaterEndTime          time.Time   `json:"later_end_time"`
	OrderMethod           string      `json:"order_method"`
}

func (q *Queries) GetEvents(ctx context.Context, arg GetEventsParams) ([]Event, error) {
	rows, err := q.db.Query(ctx, getEvents,
		arg.Limit,
		arg.Offset,
		arg.WhereLikeTitle,
		arg.SearchTitle,
		arg.WhereOrganization,
		arg.OrganizationID,
		arg.WhereMailSendFlag,
		arg.MailSendFlag,
		arg.WhereSendOrganization,
		arg.SendOrganizationID,
		arg.WhereEarlierStartTime,
		arg.EarlierStartTime,
		arg.WhereLaterStartTime,
		arg.LaterStartTime,
		arg.WhereEarlierEndTime,
		arg.EarlierEndTime,
		arg.WhereLaterEndTime,
		arg.LaterEndTime,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Event{}
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.TEventsPkey,
			&i.EventID,
			&i.EventTypeID,
			&i.Title,
			&i.Description,
			&i.OrganizationID,
			&i.StartTime,
			&i.EndTime,
			&i.MailSendFlag,
			&i.SendOrganizationID,
			&i.PostedBy,
			&i.LastEditedBy,
			&i.PostedAt,
			&i.LastEditedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsWithAll = `-- name: GetEventsWithAll :many
SELECT t_events.t_events_pkey, t_events.event_id, t_events.event_type_id, t_events.title, t_events.description, t_events.organization_id, t_events.start_time, t_events.end_time, t_events.mail_send_flag, t_events.send_organization_id, t_events.posted_by, t_events.last_edited_by, t_events.posted_at, t_events.last_edited_at, o.m_organizations_pkey, o.organization_id, o.name, o.description, o.is_personal, o.is_whole, o.created_at, o.updated_at, s.m_organizations_pkey, s.organization_id, s.name, s.description, s.is_personal, s.is_whole, s.created_at, s.updated_at FROM t_events
INNER JOIN m_organizations o ON t_events.organization_id = m_organizations.organization_id
INNER JOIN m_organizations s ON t_events.send_organization_id = s.organization_id
WHERE
	CASE WHEN $3::boolean = true THEN title LIKE '%' || $4::text || '%' ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN t_events.organization_id = $6 ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN mail_send_flag = $8 ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN send_organization_id = $10 ELSE TRUE END
AND
	CASE WHEN $11::boolean = true THEN start_time >= $12 ELSE TRUE END
AND
	CASE WHEN $13::boolean = true THEN start_time <= $14 ELSE TRUE END
AND
	CASE WHEN $15::boolean = true THEN end_time >= $16 ELSE TRUE END
AND
	CASE WHEN $17::boolean = true THEN end_time <= $18 ELSE TRUE END
ORDER BY
	CASE WHEN $19::text = 'start_time' THEN start_time END ASC,
	t_events_pkey DESC
LIMIT $1 OFFSET $2
`

type GetEventsWithAllParams struct {
	Limit                 int32       `json:"limit"`
	Offset                int32       `json:"offset"`
	WhereLikeTitle        bool        `json:"where_like_title"`
	SearchTitle           string      `json:"search_title"`
	WhereOrganization     bool        `json:"where_organization"`
	OrganizationID        pgtype.UUID `json:"organization_id"`
	WhereMailSendFlag     bool        `json:"where_mail_send_flag"`
	MailSendFlag          bool        `json:"mail_send_flag"`
	WhereSendOrganization bool        `json:"where_send_organization"`
	SendOrganizationID    pgtype.UUID `json:"send_organization_id"`
	WhereEarlierStartTime bool        `json:"where_earlier_start_time"`
	EarlierStartTime      time.Time   `json:"earlier_start_time"`
	WhereLaterStartTime   bool        `json:"where_later_start_time"`
	LaterStartTime        time.Time   `json:"later_start_time"`
	WhereEarlierEndTime   bool        `json:"where_earlier_end_time"`
	EarlierEndTime        time.Time   `json:"earlier_end_time"`
	WhereLaterEndTime     bool        `json:"where_later_end_time"`
	LaterEndTime          time.Time   `json:"later_end_time"`
	OrderMethod           string      `json:"order_method"`
}

type GetEventsWithAllRow struct {
	Event          Event        `json:"event"`
	Organization   Organization `json:"organization"`
	Organization_2 Organization `json:"organization_2"`
}

func (q *Queries) GetEventsWithAll(ctx context.Context, arg GetEventsWithAllParams) ([]GetEventsWithAllRow, error) {
	rows, err := q.db.Query(ctx, getEventsWithAll,
		arg.Limit,
		arg.Offset,
		arg.WhereLikeTitle,
		arg.SearchTitle,
		arg.WhereOrganization,
		arg.OrganizationID,
		arg.WhereMailSendFlag,
		arg.MailSendFlag,
		arg.WhereSendOrganization,
		arg.SendOrganizationID,
		arg.WhereEarlierStartTime,
		arg.EarlierStartTime,
		arg.WhereLaterStartTime,
		arg.LaterStartTime,
		arg.WhereEarlierEndTime,
		arg.EarlierEndTime,
		arg.WhereLaterEndTime,
		arg.LaterEndTime,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEventsWithAllRow{}
	for rows.Next() {
		var i GetEventsWithAllRow
		if err := rows.Scan(
			&i.Event.TEventsPkey,
			&i.Event.EventID,
			&i.Event.EventTypeID,
			&i.Event.Title,
			&i.Event.Description,
			&i.Event.OrganizationID,
			&i.Event.StartTime,
			&i.Event.EndTime,
			&i.Event.MailSendFlag,
			&i.Event.SendOrganizationID,
			&i.Event.PostedBy,
			&i.Event.LastEditedBy,
			&i.Event.PostedAt,
			&i.Event.LastEditedAt,
			&i.Organization.MOrganizationsPkey,
			&i.Organization.OrganizationID,
			&i.Organization.Name,
			&i.Organization.Description,
			&i.Organization.IsPersonal,
			&i.Organization.IsWhole,
			&i.Organization.CreatedAt,
			&i.Organization.UpdatedAt,
			&i.Organization_2.MOrganizationsPkey,
			&i.Organization_2.OrganizationID,
			&i.Organization_2.Name,
			&i.Organization_2.Description,
			&i.Organization_2.IsPersonal,
			&i.Organization_2.IsWhole,
			&i.Organization_2.CreatedAt,
			&i.Organization_2.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsWithOrganization = `-- name: GetEventsWithOrganization :many
SELECT t_events.t_events_pkey, t_events.event_id, t_events.event_type_id, t_events.title, t_events.description, t_events.organization_id, t_events.start_time, t_events.end_time, t_events.mail_send_flag, t_events.send_organization_id, t_events.posted_by, t_events.last_edited_by, t_events.posted_at, t_events.last_edited_at, m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at FROM t_events
INNER JOIN m_organizations ON t_events.organization_id = m_organizations.organization_id
WHERE
	CASE WHEN $3::boolean = true THEN title LIKE '%' || $4::text || '%' ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN t_events.organization_id = $6 ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN mail_send_flag = $8 ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN send_organization_id = $10 ELSE TRUE END
AND
	CASE WHEN $11::boolean = true THEN start_time >= $12 ELSE TRUE END
AND
	CASE WHEN $13::boolean = true THEN start_time <= $14 ELSE TRUE END
AND
	CASE WHEN $15::boolean = true THEN end_time >= $16 ELSE TRUE END
AND
	CASE WHEN $17::boolean = true THEN end_time <= $18 ELSE TRUE END
ORDER BY
	CASE WHEN $19::text = 'start_time' THEN start_time END ASC,
	t_events_pkey DESC
LIMIT $1 OFFSET $2
`

type GetEventsWithOrganizationParams struct {
	Limit                 int32       `json:"limit"`
	Offset                int32       `json:"offset"`
	WhereLikeTitle        bool        `json:"where_like_title"`
	SearchTitle           string      `json:"search_title"`
	WhereOrganization     bool        `json:"where_organization"`
	OrganizationID        pgtype.UUID `json:"organization_id"`
	WhereMailSendFlag     bool        `json:"where_mail_send_flag"`
	MailSendFlag          bool        `json:"mail_send_flag"`
	WhereSendOrganization bool        `json:"where_send_organization"`
	SendOrganizationID    pgtype.UUID `json:"send_organization_id"`
	WhereEarlierStartTime bool        `json:"where_earlier_start_time"`
	EarlierStartTime      time.Time   `json:"earlier_start_time"`
	WhereLaterStartTime   bool        `json:"where_later_start_time"`
	LaterStartTime        time.Time   `json:"later_start_time"`
	WhereEarlierEndTime   bool        `json:"where_earlier_end_time"`
	EarlierEndTime        time.Time   `json:"earlier_end_time"`
	WhereLaterEndTime     bool        `json:"where_later_end_time"`
	LaterEndTime          time.Time   `json:"later_end_time"`
	OrderMethod           string      `json:"order_method"`
}

type GetEventsWithOrganizationRow struct {
	Event        Event        `json:"event"`
	Organization Organization `json:"organization"`
}

func (q *Queries) GetEventsWithOrganization(ctx context.Context, arg GetEventsWithOrganizationParams) ([]GetEventsWithOrganizationRow, error) {
	rows, err := q.db.Query(ctx, getEventsWithOrganization,
		arg.Limit,
		arg.Offset,
		arg.WhereLikeTitle,
		arg.SearchTitle,
		arg.WhereOrganization,
		arg.OrganizationID,
		arg.WhereMailSendFlag,
		arg.MailSendFlag,
		arg.WhereSendOrganization,
		arg.SendOrganizationID,
		arg.WhereEarlierStartTime,
		arg.EarlierStartTime,
		arg.WhereLaterStartTime,
		arg.LaterStartTime,
		arg.WhereEarlierEndTime,
		arg.EarlierEndTime,
		arg.WhereLaterEndTime,
		arg.LaterEndTime,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEventsWithOrganizationRow{}
	for rows.Next() {
		var i GetEventsWithOrganizationRow
		if err := rows.Scan(
			&i.Event.TEventsPkey,
			&i.Event.EventID,
			&i.Event.EventTypeID,
			&i.Event.Title,
			&i.Event.Description,
			&i.Event.OrganizationID,
			&i.Event.StartTime,
			&i.Event.EndTime,
			&i.Event.MailSendFlag,
			&i.Event.SendOrganizationID,
			&i.Event.PostedBy,
			&i.Event.LastEditedBy,
			&i.Event.PostedAt,
			&i.Event.LastEditedAt,
			&i.Organization.MOrganizationsPkey,
			&i.Organization.OrganizationID,
			&i.Organization.Name,
			&i.Organization.Description,
			&i.Organization.IsPersonal,
			&i.Organization.IsWhole,
			&i.Organization.CreatedAt,
			&i.Organization.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsWithSendOrganization = `-- name: GetEventsWithSendOrganization :many
SELECT t_events.t_events_pkey, t_events.event_id, t_events.event_type_id, t_events.title, t_events.description, t_events.organization_id, t_events.start_time, t_events.end_time, t_events.mail_send_flag, t_events.send_organization_id, t_events.posted_by, t_events.last_edited_by, t_events.posted_at, t_events.last_edited_at, m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at FROM t_events
INNER JOIN m_organizations ON t_events.send_organization_id = m_organizations.organization_id
WHERE
	CASE WHEN $3::boolean = true THEN title LIKE '%' || $4::text || '%' ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN t_events.organization_id = $6 ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN mail_send_flag = $8 ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN send_organization_id = $10 ELSE TRUE END
AND
	CASE WHEN $11::boolean = true THEN start_time >= $12 ELSE TRUE END
AND
	CASE WHEN $13::boolean = true THEN start_time <= $14 ELSE TRUE END
AND
	CASE WHEN $15::boolean = true THEN end_time >= $16 ELSE TRUE END
AND
	CASE WHEN $17::boolean = true THEN end_time <= $18 ELSE TRUE END
ORDER BY
	CASE WHEN $19::text = 'start_time' THEN start_time END ASC,
	t_events_pkey DESC
LIMIT $1 OFFSET $2
`

type GetEventsWithSendOrganizationParams struct {
	Limit                 int32       `json:"limit"`
	Offset                int32       `json:"offset"`
	WhereLikeTitle        bool        `json:"where_like_title"`
	SearchTitle           string      `json:"search_title"`
	WhereOrganization     bool        `json:"where_organization"`
	OrganizationID        pgtype.UUID `json:"organization_id"`
	WhereMailSendFlag     bool        `json:"where_mail_send_flag"`
	MailSendFlag          bool        `json:"mail_send_flag"`
	WhereSendOrganization bool        `json:"where_send_organization"`
	SendOrganizationID    pgtype.UUID `json:"send_organization_id"`
	WhereEarlierStartTime bool        `json:"where_earlier_start_time"`
	EarlierStartTime      time.Time   `json:"earlier_start_time"`
	WhereLaterStartTime   bool        `json:"where_later_start_time"`
	LaterStartTime        time.Time   `json:"later_start_time"`
	WhereEarlierEndTime   bool        `json:"where_earlier_end_time"`
	EarlierEndTime        time.Time   `json:"earlier_end_time"`
	WhereLaterEndTime     bool        `json:"where_later_end_time"`
	LaterEndTime          time.Time   `json:"later_end_time"`
	OrderMethod           string      `json:"order_method"`
}

type GetEventsWithSendOrganizationRow struct {
	Event        Event        `json:"event"`
	Organization Organization `json:"organization"`
}

func (q *Queries) GetEventsWithSendOrganization(ctx context.Context, arg GetEventsWithSendOrganizationParams) ([]GetEventsWithSendOrganizationRow, error) {
	rows, err := q.db.Query(ctx, getEventsWithSendOrganization,
		arg.Limit,
		arg.Offset,
		arg.WhereLikeTitle,
		arg.SearchTitle,
		arg.WhereOrganization,
		arg.OrganizationID,
		arg.WhereMailSendFlag,
		arg.MailSendFlag,
		arg.WhereSendOrganization,
		arg.SendOrganizationID,
		arg.WhereEarlierStartTime,
		arg.EarlierStartTime,
		arg.WhereLaterStartTime,
		arg.LaterStartTime,
		arg.WhereEarlierEndTime,
		arg.EarlierEndTime,
		arg.WhereLaterEndTime,
		arg.LaterEndTime,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEventsWithSendOrganizationRow{}
	for rows.Next() {
		var i GetEventsWithSendOrganizationRow
		if err := rows.Scan(
			&i.Event.TEventsPkey,
			&i.Event.EventID,
			&i.Event.EventTypeID,
			&i.Event.Title,
			&i.Event.Description,
			&i.Event.OrganizationID,
			&i.Event.StartTime,
			&i.Event.EndTime,
			&i.Event.MailSendFlag,
			&i.Event.SendOrganizationID,
			&i.Event.PostedBy,
			&i.Event.LastEditedBy,
			&i.Event.PostedAt,
			&i.Event.LastEditedAt,
			&i.Organization.MOrganizationsPkey,
			&i.Organization.OrganizationID,
			&i.Organization.Name,
			&i.Organization.Description,
			&i.Organization.IsPersonal,
			&i.Organization.IsWhole,
			&i.Organization.CreatedAt,
			&i.Organization.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEvent = `-- name: UpdateEvent :one
UPDATE t_events SET event_type_id = $2, title = $3, description = $4, organization_id = $5, start_time = $6, end_time = $7, send_organization_id = $8, posted_by = $9, last_edited_by = $10, posted_at = $11, last_edited_at = $12 WHERE event_id = $1 RETURNING t_events_pkey, event_id, event_type_id, title, description, organization_id, start_time, end_time, mail_send_flag, send_organization_id, posted_by, last_edited_by, posted_at, last_edited_at
`

type UpdateEventParams struct {
	EventID            uuid.UUID   `json:"event_id"`
	EventTypeID        uuid.UUID   `json:"event_type_id"`
	Title              string      `json:"title"`
	Description        pgtype.Text `json:"description"`
	OrganizationID     pgtype.UUID `json:"organization_id"`
	StartTime          time.Time   `json:"start_time"`
	EndTime            time.Time   `json:"end_time"`
	SendOrganizationID pgtype.UUID `json:"send_organization_id"`
	PostedBy           pgtype.UUID `json:"posted_by"`
	LastEditedBy       pgtype.UUID `json:"last_edited_by"`
	PostedAt           time.Time   `json:"posted_at"`
	LastEditedAt       time.Time   `json:"last_edited_at"`
}

func (q *Queries) UpdateEvent(ctx context.Context, arg UpdateEventParams) (Event, error) {
	row := q.db.QueryRow(ctx, updateEvent,
		arg.EventID,
		arg.EventTypeID,
		arg.Title,
		arg.Description,
		arg.OrganizationID,
		arg.StartTime,
		arg.EndTime,
		arg.SendOrganizationID,
		arg.PostedBy,
		arg.LastEditedBy,
		arg.PostedAt,
		arg.LastEditedAt,
	)
	var i Event
	err := row.Scan(
		&i.TEventsPkey,
		&i.EventID,
		&i.EventTypeID,
		&i.Title,
		&i.Description,
		&i.OrganizationID,
		&i.StartTime,
		&i.EndTime,
		&i.MailSendFlag,
		&i.SendOrganizationID,
		&i.PostedBy,
		&i.LastEditedBy,
		&i.PostedAt,
		&i.LastEditedAt,
	)
	return i, err
}
