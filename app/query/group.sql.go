// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: group.sql

package query

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countGroups = `-- name: CountGroups :one
SELECT COUNT(*) FROM m_groups
`

func (q *Queries) CountGroups(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countGroups)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createGroup = `-- name: CreateGroup :one
INSERT INTO m_groups (key, organization_id) VALUES ($1, $2) RETURNING m_groups_pkey, group_id, key, organization_id
`

type CreateGroupParams struct {
	Key            string    `json:"key"`
	OrganizationID uuid.UUID `json:"organization_id"`
}

func (q *Queries) CreateGroup(ctx context.Context, arg CreateGroupParams) (Group, error) {
	row := q.db.QueryRow(ctx, createGroup, arg.Key, arg.OrganizationID)
	var i Group
	err := row.Scan(
		&i.MGroupsPkey,
		&i.GroupID,
		&i.Key,
		&i.OrganizationID,
	)
	return i, err
}

type CreateGroupsParams struct {
	Key            string    `json:"key"`
	OrganizationID uuid.UUID `json:"organization_id"`
}

const deleteGroup = `-- name: DeleteGroup :execrows
DELETE FROM m_groups WHERE group_id = $1
`

func (q *Queries) DeleteGroup(ctx context.Context, groupID uuid.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, deleteGroup, groupID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteGroupByKey = `-- name: DeleteGroupByKey :execrows
DELETE FROM m_groups WHERE key = $1
`

func (q *Queries) DeleteGroupByKey(ctx context.Context, key string) (int64, error) {
	result, err := q.db.Exec(ctx, deleteGroupByKey, key)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const findGroupByID = `-- name: FindGroupByID :one
SELECT m_groups_pkey, group_id, key, organization_id FROM m_groups WHERE group_id = $1
`

func (q *Queries) FindGroupByID(ctx context.Context, groupID uuid.UUID) (Group, error) {
	row := q.db.QueryRow(ctx, findGroupByID, groupID)
	var i Group
	err := row.Scan(
		&i.MGroupsPkey,
		&i.GroupID,
		&i.Key,
		&i.OrganizationID,
	)
	return i, err
}

const findGroupByIDWithOrganization = `-- name: FindGroupByIDWithOrganization :one
SELECT m_groups.m_groups_pkey, m_groups.group_id, m_groups.key, m_groups.organization_id, m_organizations.name organization_name, m_organizations.description organization_description,
m_organizations.color organization_color, m_organizations.is_personal organization_is_personal,
m_organizations.is_whole organization_is_whole, m_organizations.chat_room_id organization_chat_room_id
FROM m_groups
LEFT JOIN m_organizations ON m_groups.organization_id = m_organizations.organization_id
WHERE group_id = $1
`

type FindGroupByIDWithOrganizationRow struct {
	MGroupsPkey             pgtype.Int8 `json:"m_groups_pkey"`
	GroupID                 uuid.UUID   `json:"group_id"`
	Key                     string      `json:"key"`
	OrganizationID          uuid.UUID   `json:"organization_id"`
	OrganizationName        pgtype.Text `json:"organization_name"`
	OrganizationDescription pgtype.Text `json:"organization_description"`
	OrganizationColor       pgtype.Text `json:"organization_color"`
	OrganizationIsPersonal  pgtype.Bool `json:"organization_is_personal"`
	OrganizationIsWhole     pgtype.Bool `json:"organization_is_whole"`
	OrganizationChatRoomID  pgtype.UUID `json:"organization_chat_room_id"`
}

func (q *Queries) FindGroupByIDWithOrganization(ctx context.Context, groupID uuid.UUID) (FindGroupByIDWithOrganizationRow, error) {
	row := q.db.QueryRow(ctx, findGroupByIDWithOrganization, groupID)
	var i FindGroupByIDWithOrganizationRow
	err := row.Scan(
		&i.MGroupsPkey,
		&i.GroupID,
		&i.Key,
		&i.OrganizationID,
		&i.OrganizationName,
		&i.OrganizationDescription,
		&i.OrganizationColor,
		&i.OrganizationIsPersonal,
		&i.OrganizationIsWhole,
		&i.OrganizationChatRoomID,
	)
	return i, err
}

const findGroupByKey = `-- name: FindGroupByKey :one
SELECT m_groups_pkey, group_id, key, organization_id FROM m_groups WHERE key = $1
`

func (q *Queries) FindGroupByKey(ctx context.Context, key string) (Group, error) {
	row := q.db.QueryRow(ctx, findGroupByKey, key)
	var i Group
	err := row.Scan(
		&i.MGroupsPkey,
		&i.GroupID,
		&i.Key,
		&i.OrganizationID,
	)
	return i, err
}

const findGroupByKeyWithOrganization = `-- name: FindGroupByKeyWithOrganization :one
SELECT m_groups.m_groups_pkey, m_groups.group_id, m_groups.key, m_groups.organization_id, m_organizations.name organization_name, m_organizations.description organization_description,
m_organizations.color organization_color, m_organizations.is_personal organization_is_personal,
m_organizations.is_whole organization_is_whole, m_organizations.chat_room_id organization_chat_room_id
FROM m_groups
LEFT JOIN m_organizations ON m_groups.organization_id = m_organizations.organization_id
WHERE key = $1
`

type FindGroupByKeyWithOrganizationRow struct {
	MGroupsPkey             pgtype.Int8 `json:"m_groups_pkey"`
	GroupID                 uuid.UUID   `json:"group_id"`
	Key                     string      `json:"key"`
	OrganizationID          uuid.UUID   `json:"organization_id"`
	OrganizationName        pgtype.Text `json:"organization_name"`
	OrganizationDescription pgtype.Text `json:"organization_description"`
	OrganizationColor       pgtype.Text `json:"organization_color"`
	OrganizationIsPersonal  pgtype.Bool `json:"organization_is_personal"`
	OrganizationIsWhole     pgtype.Bool `json:"organization_is_whole"`
	OrganizationChatRoomID  pgtype.UUID `json:"organization_chat_room_id"`
}

func (q *Queries) FindGroupByKeyWithOrganization(ctx context.Context, key string) (FindGroupByKeyWithOrganizationRow, error) {
	row := q.db.QueryRow(ctx, findGroupByKeyWithOrganization, key)
	var i FindGroupByKeyWithOrganizationRow
	err := row.Scan(
		&i.MGroupsPkey,
		&i.GroupID,
		&i.Key,
		&i.OrganizationID,
		&i.OrganizationName,
		&i.OrganizationDescription,
		&i.OrganizationColor,
		&i.OrganizationIsPersonal,
		&i.OrganizationIsWhole,
		&i.OrganizationChatRoomID,
	)
	return i, err
}

const getGroups = `-- name: GetGroups :many
SELECT m_groups_pkey, group_id, key, organization_id FROM m_groups
ORDER BY
	m_groups_pkey ASC
`

func (q *Queries) GetGroups(ctx context.Context) ([]Group, error) {
	rows, err := q.db.Query(ctx, getGroups)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Group{}
	for rows.Next() {
		var i Group
		if err := rows.Scan(
			&i.MGroupsPkey,
			&i.GroupID,
			&i.Key,
			&i.OrganizationID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGroupsUseKeysetPaginate = `-- name: GetGroupsUseKeysetPaginate :many
SELECT m_groups_pkey, group_id, key, organization_id FROM m_groups
WHERE
	CASE $2::text
		WHEN 'next' THEN
			m_groups_pkey > $3::int
		WHEN 'prev' THEN
			m_groups_pkey < $3::int
	END
ORDER BY
	CASE WHEN $2::text = 'next' THEN m_groups_pkey END ASC,
	CASE WHEN $2::text = 'prev' THEN m_groups_pkey END DESC
LIMIT $1
`

type GetGroupsUseKeysetPaginateParams struct {
	Limit           int32  `json:"limit"`
	CursorDirection string `json:"cursor_direction"`
	Cursor          int32  `json:"cursor"`
}

func (q *Queries) GetGroupsUseKeysetPaginate(ctx context.Context, arg GetGroupsUseKeysetPaginateParams) ([]Group, error) {
	rows, err := q.db.Query(ctx, getGroupsUseKeysetPaginate, arg.Limit, arg.CursorDirection, arg.Cursor)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Group{}
	for rows.Next() {
		var i Group
		if err := rows.Scan(
			&i.MGroupsPkey,
			&i.GroupID,
			&i.Key,
			&i.OrganizationID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGroupsUseNumberedPaginate = `-- name: GetGroupsUseNumberedPaginate :many
SELECT m_groups_pkey, group_id, key, organization_id FROM m_groups
ORDER BY
	m_groups_pkey ASC
LIMIT $1 OFFSET $2
`

type GetGroupsUseNumberedPaginateParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetGroupsUseNumberedPaginate(ctx context.Context, arg GetGroupsUseNumberedPaginateParams) ([]Group, error) {
	rows, err := q.db.Query(ctx, getGroupsUseNumberedPaginate, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Group{}
	for rows.Next() {
		var i Group
		if err := rows.Scan(
			&i.MGroupsPkey,
			&i.GroupID,
			&i.Key,
			&i.OrganizationID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGroupsWithOrganization = `-- name: GetGroupsWithOrganization :many
SELECT m_groups.m_groups_pkey, m_groups.group_id, m_groups.key, m_groups.organization_id, m_organizations.name organization_name, m_organizations.description organization_description,
m_organizations.color organization_color, m_organizations.is_personal organization_is_personal,
m_organizations.is_whole organization_is_whole, m_organizations.chat_room_id organization_chat_room_id
FROM m_groups
LEFT JOIN m_organizations ON m_groups.organization_id = m_organizations.organization_id
ORDER BY
	m_groups_pkey ASC
`

type GetGroupsWithOrganizationRow struct {
	MGroupsPkey             pgtype.Int8 `json:"m_groups_pkey"`
	GroupID                 uuid.UUID   `json:"group_id"`
	Key                     string      `json:"key"`
	OrganizationID          uuid.UUID   `json:"organization_id"`
	OrganizationName        pgtype.Text `json:"organization_name"`
	OrganizationDescription pgtype.Text `json:"organization_description"`
	OrganizationColor       pgtype.Text `json:"organization_color"`
	OrganizationIsPersonal  pgtype.Bool `json:"organization_is_personal"`
	OrganizationIsWhole     pgtype.Bool `json:"organization_is_whole"`
	OrganizationChatRoomID  pgtype.UUID `json:"organization_chat_room_id"`
}

func (q *Queries) GetGroupsWithOrganization(ctx context.Context) ([]GetGroupsWithOrganizationRow, error) {
	rows, err := q.db.Query(ctx, getGroupsWithOrganization)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetGroupsWithOrganizationRow{}
	for rows.Next() {
		var i GetGroupsWithOrganizationRow
		if err := rows.Scan(
			&i.MGroupsPkey,
			&i.GroupID,
			&i.Key,
			&i.OrganizationID,
			&i.OrganizationName,
			&i.OrganizationDescription,
			&i.OrganizationColor,
			&i.OrganizationIsPersonal,
			&i.OrganizationIsWhole,
			&i.OrganizationChatRoomID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGroupsWithOrganizationUseKeysetPaginate = `-- name: GetGroupsWithOrganizationUseKeysetPaginate :many
SELECT m_groups.m_groups_pkey, m_groups.group_id, m_groups.key, m_groups.organization_id, m_organizations.name organization_name, m_organizations.description organization_description,
m_organizations.color organization_color, m_organizations.is_personal organization_is_personal,
m_organizations.is_whole organization_is_whole, m_organizations.chat_room_id organization_chat_room_id
FROM m_groups
LEFT JOIN m_organizations ON m_groups.organization_id = m_organizations.organization_id
WHERE
	CASE $2::text
		WHEN 'next' THEN
			m_groups_pkey > $3::int
		WHEN 'prev' THEN
			m_groups_pkey < $3::int
	END
ORDER BY
	CASE WHEN $2::text = 'next' THEN m_groups_pkey END ASC,
	CASE WHEN $2::text = 'prev' THEN m_groups_pkey END DESC
LIMIT $1
`

type GetGroupsWithOrganizationUseKeysetPaginateParams struct {
	Limit           int32  `json:"limit"`
	CursorDirection string `json:"cursor_direction"`
	Cursor          int32  `json:"cursor"`
}

type GetGroupsWithOrganizationUseKeysetPaginateRow struct {
	MGroupsPkey             pgtype.Int8 `json:"m_groups_pkey"`
	GroupID                 uuid.UUID   `json:"group_id"`
	Key                     string      `json:"key"`
	OrganizationID          uuid.UUID   `json:"organization_id"`
	OrganizationName        pgtype.Text `json:"organization_name"`
	OrganizationDescription pgtype.Text `json:"organization_description"`
	OrganizationColor       pgtype.Text `json:"organization_color"`
	OrganizationIsPersonal  pgtype.Bool `json:"organization_is_personal"`
	OrganizationIsWhole     pgtype.Bool `json:"organization_is_whole"`
	OrganizationChatRoomID  pgtype.UUID `json:"organization_chat_room_id"`
}

func (q *Queries) GetGroupsWithOrganizationUseKeysetPaginate(ctx context.Context, arg GetGroupsWithOrganizationUseKeysetPaginateParams) ([]GetGroupsWithOrganizationUseKeysetPaginateRow, error) {
	rows, err := q.db.Query(ctx, getGroupsWithOrganizationUseKeysetPaginate, arg.Limit, arg.CursorDirection, arg.Cursor)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetGroupsWithOrganizationUseKeysetPaginateRow{}
	for rows.Next() {
		var i GetGroupsWithOrganizationUseKeysetPaginateRow
		if err := rows.Scan(
			&i.MGroupsPkey,
			&i.GroupID,
			&i.Key,
			&i.OrganizationID,
			&i.OrganizationName,
			&i.OrganizationDescription,
			&i.OrganizationColor,
			&i.OrganizationIsPersonal,
			&i.OrganizationIsWhole,
			&i.OrganizationChatRoomID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGroupsWithOrganizationUseNumberedPaginate = `-- name: GetGroupsWithOrganizationUseNumberedPaginate :many
SELECT m_groups.m_groups_pkey, m_groups.group_id, m_groups.key, m_groups.organization_id, m_organizations.name organization_name, m_organizations.description organization_description,
m_organizations.color organization_color, m_organizations.is_personal organization_is_personal,
m_organizations.is_whole organization_is_whole, m_organizations.chat_room_id organization_chat_room_id
FROM m_groups
LEFT JOIN m_organizations ON m_groups.organization_id = m_organizations.organization_id
ORDER BY
	m_groups_pkey ASC
LIMIT $1 OFFSET $2
`

type GetGroupsWithOrganizationUseNumberedPaginateParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetGroupsWithOrganizationUseNumberedPaginateRow struct {
	MGroupsPkey             pgtype.Int8 `json:"m_groups_pkey"`
	GroupID                 uuid.UUID   `json:"group_id"`
	Key                     string      `json:"key"`
	OrganizationID          uuid.UUID   `json:"organization_id"`
	OrganizationName        pgtype.Text `json:"organization_name"`
	OrganizationDescription pgtype.Text `json:"organization_description"`
	OrganizationColor       pgtype.Text `json:"organization_color"`
	OrganizationIsPersonal  pgtype.Bool `json:"organization_is_personal"`
	OrganizationIsWhole     pgtype.Bool `json:"organization_is_whole"`
	OrganizationChatRoomID  pgtype.UUID `json:"organization_chat_room_id"`
}

func (q *Queries) GetGroupsWithOrganizationUseNumberedPaginate(ctx context.Context, arg GetGroupsWithOrganizationUseNumberedPaginateParams) ([]GetGroupsWithOrganizationUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getGroupsWithOrganizationUseNumberedPaginate, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetGroupsWithOrganizationUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetGroupsWithOrganizationUseNumberedPaginateRow
		if err := rows.Scan(
			&i.MGroupsPkey,
			&i.GroupID,
			&i.Key,
			&i.OrganizationID,
			&i.OrganizationName,
			&i.OrganizationDescription,
			&i.OrganizationColor,
			&i.OrganizationIsPersonal,
			&i.OrganizationIsWhole,
			&i.OrganizationChatRoomID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralGroups = `-- name: GetPluralGroups :many
SELECT m_groups_pkey, group_id, key, organization_id FROM m_groups
WHERE group_id = ANY($1::uuid[])
ORDER BY
	m_groups_pkey ASC
`

func (q *Queries) GetPluralGroups(ctx context.Context, groupIds []uuid.UUID) ([]Group, error) {
	rows, err := q.db.Query(ctx, getPluralGroups, groupIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Group{}
	for rows.Next() {
		var i Group
		if err := rows.Scan(
			&i.MGroupsPkey,
			&i.GroupID,
			&i.Key,
			&i.OrganizationID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralGroupsUseNumberedPaginate = `-- name: GetPluralGroupsUseNumberedPaginate :many
SELECT m_groups_pkey, group_id, key, organization_id FROM m_groups
WHERE group_id = ANY($3::uuid[])
ORDER BY
	m_groups_pkey ASC
LIMIT $1 OFFSET $2
`

type GetPluralGroupsUseNumberedPaginateParams struct {
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
	GroupIds []uuid.UUID `json:"group_ids"`
}

func (q *Queries) GetPluralGroupsUseNumberedPaginate(ctx context.Context, arg GetPluralGroupsUseNumberedPaginateParams) ([]Group, error) {
	rows, err := q.db.Query(ctx, getPluralGroupsUseNumberedPaginate, arg.Limit, arg.Offset, arg.GroupIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Group{}
	for rows.Next() {
		var i Group
		if err := rows.Scan(
			&i.MGroupsPkey,
			&i.GroupID,
			&i.Key,
			&i.OrganizationID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralGroupsWithOrganization = `-- name: GetPluralGroupsWithOrganization :many
SELECT m_groups.m_groups_pkey, m_groups.group_id, m_groups.key, m_groups.organization_id, m_organizations.name organization_name, m_organizations.description organization_description,
m_organizations.color organization_color, m_organizations.is_personal organization_is_personal,
m_organizations.is_whole organization_is_whole, m_organizations.chat_room_id organization_chat_room_id
FROM m_groups
LEFT JOIN m_organizations ON m_groups.organization_id = m_organizations.organization_id
WHERE group_id = ANY($1::uuid[])
ORDER BY
	m_groups_pkey ASC
`

type GetPluralGroupsWithOrganizationRow struct {
	MGroupsPkey             pgtype.Int8 `json:"m_groups_pkey"`
	GroupID                 uuid.UUID   `json:"group_id"`
	Key                     string      `json:"key"`
	OrganizationID          uuid.UUID   `json:"organization_id"`
	OrganizationName        pgtype.Text `json:"organization_name"`
	OrganizationDescription pgtype.Text `json:"organization_description"`
	OrganizationColor       pgtype.Text `json:"organization_color"`
	OrganizationIsPersonal  pgtype.Bool `json:"organization_is_personal"`
	OrganizationIsWhole     pgtype.Bool `json:"organization_is_whole"`
	OrganizationChatRoomID  pgtype.UUID `json:"organization_chat_room_id"`
}

func (q *Queries) GetPluralGroupsWithOrganization(ctx context.Context, groupIds []uuid.UUID) ([]GetPluralGroupsWithOrganizationRow, error) {
	rows, err := q.db.Query(ctx, getPluralGroupsWithOrganization, groupIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralGroupsWithOrganizationRow{}
	for rows.Next() {
		var i GetPluralGroupsWithOrganizationRow
		if err := rows.Scan(
			&i.MGroupsPkey,
			&i.GroupID,
			&i.Key,
			&i.OrganizationID,
			&i.OrganizationName,
			&i.OrganizationDescription,
			&i.OrganizationColor,
			&i.OrganizationIsPersonal,
			&i.OrganizationIsWhole,
			&i.OrganizationChatRoomID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralGroupsWithOrganizationUseNumberedPaginate = `-- name: GetPluralGroupsWithOrganizationUseNumberedPaginate :many
SELECT m_groups.m_groups_pkey, m_groups.group_id, m_groups.key, m_groups.organization_id, m_organizations.name organization_name, m_organizations.description organization_description,
m_organizations.color organization_color, m_organizations.is_personal organization_is_personal,
m_organizations.is_whole organization_is_whole, m_organizations.chat_room_id organization_chat_room_id
FROM m_groups
LEFT JOIN m_organizations ON m_groups.organization_id = m_organizations.organization_id
WHERE group_id = ANY($3::uuid[])
ORDER BY
	m_groups_pkey ASC
LIMIT $1 OFFSET $2
`

type GetPluralGroupsWithOrganizationUseNumberedPaginateParams struct {
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
	GroupIds []uuid.UUID `json:"group_ids"`
}

type GetPluralGroupsWithOrganizationUseNumberedPaginateRow struct {
	MGroupsPkey             pgtype.Int8 `json:"m_groups_pkey"`
	GroupID                 uuid.UUID   `json:"group_id"`
	Key                     string      `json:"key"`
	OrganizationID          uuid.UUID   `json:"organization_id"`
	OrganizationName        pgtype.Text `json:"organization_name"`
	OrganizationDescription pgtype.Text `json:"organization_description"`
	OrganizationColor       pgtype.Text `json:"organization_color"`
	OrganizationIsPersonal  pgtype.Bool `json:"organization_is_personal"`
	OrganizationIsWhole     pgtype.Bool `json:"organization_is_whole"`
	OrganizationChatRoomID  pgtype.UUID `json:"organization_chat_room_id"`
}

func (q *Queries) GetPluralGroupsWithOrganizationUseNumberedPaginate(ctx context.Context, arg GetPluralGroupsWithOrganizationUseNumberedPaginateParams) ([]GetPluralGroupsWithOrganizationUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getPluralGroupsWithOrganizationUseNumberedPaginate, arg.Limit, arg.Offset, arg.GroupIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralGroupsWithOrganizationUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetPluralGroupsWithOrganizationUseNumberedPaginateRow
		if err := rows.Scan(
			&i.MGroupsPkey,
			&i.GroupID,
			&i.Key,
			&i.OrganizationID,
			&i.OrganizationName,
			&i.OrganizationDescription,
			&i.OrganizationColor,
			&i.OrganizationIsPersonal,
			&i.OrganizationIsWhole,
			&i.OrganizationChatRoomID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const pluralDeleteGroups = `-- name: PluralDeleteGroups :execrows
DELETE FROM m_groups WHERE group_id = ANY($1::uuid[])
`

func (q *Queries) PluralDeleteGroups(ctx context.Context, groupIds []uuid.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, pluralDeleteGroups, groupIds)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
