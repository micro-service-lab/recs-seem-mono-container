// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: chat_room_belonging.sql

package query

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const countChatRoomsByMemberID = `-- name: CountChatRoomsByMemberID :one
SELECT COUNT(*) FROM m_chat_room_belongings WHERE member_id = $1
`

func (q *Queries) CountChatRoomsByMemberID(ctx context.Context, memberID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countChatRoomsByMemberID, memberID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMembersOnChatRoomID = `-- name: CountMembersOnChatRoomID :one
SELECT COUNT(*) FROM m_chat_room_belongings WHERE chat_room_id = $1
`

func (q *Queries) CountMembersOnChatRoomID(ctx context.Context, chatRoomID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countMembersOnChatRoomID, chatRoomID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createChatRoomBelonging = `-- name: CreateChatRoomBelonging :one
INSERT INTO m_chat_room_belongings (member_id, chat_room_id, added_at) VALUES ($1, $2, $3) RETURNING m_chat_room_belongings_pkey, member_id, chat_room_id, added_at
`

type CreateChatRoomBelongingParams struct {
	MemberID   uuid.UUID `json:"member_id"`
	ChatRoomID uuid.UUID `json:"chat_room_id"`
	AddedAt    time.Time `json:"added_at"`
}

func (q *Queries) CreateChatRoomBelonging(ctx context.Context, arg CreateChatRoomBelongingParams) (ChatRoomBelonging, error) {
	row := q.db.QueryRow(ctx, createChatRoomBelonging, arg.MemberID, arg.ChatRoomID, arg.AddedAt)
	var i ChatRoomBelonging
	err := row.Scan(
		&i.MChatRoomBelongingsPkey,
		&i.MemberID,
		&i.ChatRoomID,
		&i.AddedAt,
	)
	return i, err
}

type CreateChatRoomBelongingsParams struct {
	MemberID   uuid.UUID `json:"member_id"`
	ChatRoomID uuid.UUID `json:"chat_room_id"`
	AddedAt    time.Time `json:"added_at"`
}

const deleteChatRoomBelonging = `-- name: DeleteChatRoomBelonging :exec
DELETE FROM m_chat_room_belongings WHERE member_id = $1 AND chat_room_id = $2
`

type DeleteChatRoomBelongingParams struct {
	MemberID   uuid.UUID `json:"member_id"`
	ChatRoomID uuid.UUID `json:"chat_room_id"`
}

func (q *Queries) DeleteChatRoomBelonging(ctx context.Context, arg DeleteChatRoomBelongingParams) error {
	_, err := q.db.Exec(ctx, deleteChatRoomBelonging, arg.MemberID, arg.ChatRoomID)
	return err
}

const getChatRoomsByMemberID = `-- name: GetChatRoomsByMemberID :many
SELECT m_chat_room_belongings.m_chat_room_belongings_pkey, m_chat_room_belongings.member_id, m_chat_room_belongings.chat_room_id, m_chat_room_belongings.added_at, m_chat_rooms.m_chat_rooms_pkey, m_chat_rooms.chat_room_id, m_chat_rooms.name, m_chat_rooms.is_private, m_chat_rooms.cover_image_id, m_chat_rooms.owner_id, m_chat_rooms.created_at, m_chat_rooms.updated_at FROM m_chat_room_belongings
INNER JOIN m_chat_rooms ON m_chat_room_belongings.chat_room_id = m_chat_rooms.chat_room_id
WHERE member_id = $1
AND CASE
	WHEN $4::boolean = true THEN m_members.name LIKE '%' || $5::text || '%'
END
ORDER BY
	CASE WHEN $6::text = 'name' THEN m_chat_rooms.name END ASC,
	CASE WHEN $6::text = 'add' THEN m_chat_room_belongings.added_at END DESC,
	CASE WHEN $6::text = 'late_chat' THEN
		(SELECT MAX(created_at) FROM t_messages m WHERE m.chat_room_id = m_chat_room_belongings.chat_room_id)
	END DESC,
	CASE WHEN $6::text = 'old_chat' THEN
		(SELECT MAX(created_at) FROM t_messages m WHERE m.chat_room_id = m_chat_room_belongings.chat_room_id)
	END ASC,
	m_chat_room_belongings_pkey DESC
LIMIT $2 OFFSET $3
`

type GetChatRoomsByMemberIDParams struct {
	MemberID      uuid.UUID `json:"member_id"`
	Limit         int32     `json:"limit"`
	Offset        int32     `json:"offset"`
	WhereLikeName bool      `json:"where_like_name"`
	SearchName    string    `json:"search_name"`
	OrderMethod   string    `json:"order_method"`
}

type GetChatRoomsByMemberIDRow struct {
	ChatRoomBelonging ChatRoomBelonging `json:"chat_room_belonging"`
	ChatRoom          ChatRoom          `json:"chat_room"`
}

func (q *Queries) GetChatRoomsByMemberID(ctx context.Context, arg GetChatRoomsByMemberIDParams) ([]GetChatRoomsByMemberIDRow, error) {
	rows, err := q.db.Query(ctx, getChatRoomsByMemberID,
		arg.MemberID,
		arg.Limit,
		arg.Offset,
		arg.WhereLikeName,
		arg.SearchName,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetChatRoomsByMemberIDRow{}
	for rows.Next() {
		var i GetChatRoomsByMemberIDRow
		if err := rows.Scan(
			&i.ChatRoomBelonging.MChatRoomBelongingsPkey,
			&i.ChatRoomBelonging.MemberID,
			&i.ChatRoomBelonging.ChatRoomID,
			&i.ChatRoomBelonging.AddedAt,
			&i.ChatRoom.MChatRoomsPkey,
			&i.ChatRoom.ChatRoomID,
			&i.ChatRoom.Name,
			&i.ChatRoom.IsPrivate,
			&i.ChatRoom.CoverImageID,
			&i.ChatRoom.OwnerID,
			&i.ChatRoom.CreatedAt,
			&i.ChatRoom.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMembersOnChatRoomID = `-- name: GetMembersOnChatRoomID :many
SELECT m_chat_room_belongings.m_chat_room_belongings_pkey, m_chat_room_belongings.member_id, m_chat_room_belongings.chat_room_id, m_chat_room_belongings.added_at, m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at FROM m_chat_room_belongings
INNER JOIN m_members ON m_chat_room_belongings.member_id = m_members.member_id
WHERE chat_room_id = $1
AND CASE
	WHEN $4::boolean = true THEN m_members.name LIKE '%' || $5::text || '%'
END
ORDER BY
	CASE WHEN $6::text = 'name' THEN m_members.name END ASC,
	CASE WHEN $6::text = 'add' THEN m_chat_room_belongings.added_at END DESC,
	m_chat_room_belongings_pkey DESC
LIMIT $2 OFFSET $3
`

type GetMembersOnChatRoomIDParams struct {
	ChatRoomID    uuid.UUID `json:"chat_room_id"`
	Limit         int32     `json:"limit"`
	Offset        int32     `json:"offset"`
	WhereLikeName bool      `json:"where_like_name"`
	SearchName    string    `json:"search_name"`
	OrderMethod   string    `json:"order_method"`
}

type GetMembersOnChatRoomIDRow struct {
	ChatRoomBelonging ChatRoomBelonging `json:"chat_room_belonging"`
	Member            Member            `json:"member"`
}

func (q *Queries) GetMembersOnChatRoomID(ctx context.Context, arg GetMembersOnChatRoomIDParams) ([]GetMembersOnChatRoomIDRow, error) {
	rows, err := q.db.Query(ctx, getMembersOnChatRoomID,
		arg.ChatRoomID,
		arg.Limit,
		arg.Offset,
		arg.WhereLikeName,
		arg.SearchName,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMembersOnChatRoomIDRow{}
	for rows.Next() {
		var i GetMembersOnChatRoomIDRow
		if err := rows.Scan(
			&i.ChatRoomBelonging.MChatRoomBelongingsPkey,
			&i.ChatRoomBelonging.MemberID,
			&i.ChatRoomBelonging.ChatRoomID,
			&i.ChatRoomBelonging.AddedAt,
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageID,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
