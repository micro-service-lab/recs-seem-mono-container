// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: professsor.sql

package query

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countProfessors = `-- name: CountProfessors :one
SELECT COUNT(*) FROM m_professors
`

func (q *Queries) CountProfessors(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countProfessors)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createProfessor = `-- name: CreateProfessor :one
INSERT INTO m_professors (member_id) VALUES ($1) RETURNING m_professors_pkey, professor_id, member_id
`

func (q *Queries) CreateProfessor(ctx context.Context, memberID uuid.UUID) (Professor, error) {
	row := q.db.QueryRow(ctx, createProfessor, memberID)
	var i Professor
	err := row.Scan(&i.MProfessorsPkey, &i.ProfessorID, &i.MemberID)
	return i, err
}

const deleteProfessor = `-- name: DeleteProfessor :execrows
DELETE FROM m_professors WHERE professor_id = $1
`

func (q *Queries) DeleteProfessor(ctx context.Context, professorID uuid.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, deleteProfessor, professorID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const findProfessorByID = `-- name: FindProfessorByID :one
SELECT m_professors_pkey, professor_id, member_id FROM m_professors WHERE professor_id = $1
`

func (q *Queries) FindProfessorByID(ctx context.Context, professorID uuid.UUID) (Professor, error) {
	row := q.db.QueryRow(ctx, findProfessorByID, professorID)
	var i Professor
	err := row.Scan(&i.MProfessorsPkey, &i.ProfessorID, &i.MemberID)
	return i, err
}

const findProfessorByIDWithMember = `-- name: FindProfessorByIDWithMember :one
SELECT m_professors.m_professors_pkey, m_professors.professor_id, m_professors.member_id, m_members.name member_name, m_members.first_name member_first_name, m_members.last_name member_last_name, m_members.email member_email,
m_members.profile_image_id member_profile_image_id, t_images.height member_profile_image_height,
t_images.width member_profile_image_width, t_images.attachable_item_id member_profile_image_attachable_item_id,
t_attachable_items.owner_id member_profile_image_owner_id, t_attachable_items.from_outer member_profile_image_from_outer, t_attachable_items.alias member_profile_image_alias,
t_attachable_items.url member_profile_image_url, t_attachable_items.size member_profile_image_size, t_attachable_items.mime_type_id member_profile_image_mime_type_id FROM m_professors
LEFT JOIN m_members ON m_professors.member_id = m_members.member_id
LEFT JOIN t_images ON m_members.profile_image_id = t_images.image_id
LEFT JOIN t_attachable_items ON t_images.attachable_item_id = t_attachable_items.attachable_item_id
WHERE professor_id = $1
`

type FindProfessorByIDWithMemberRow struct {
	MProfessorsPkey                    pgtype.Int8   `json:"m_professors_pkey"`
	ProfessorID                        uuid.UUID     `json:"professor_id"`
	MemberID                           uuid.UUID     `json:"member_id"`
	MemberName                         pgtype.Text   `json:"member_name"`
	MemberFirstName                    pgtype.Text   `json:"member_first_name"`
	MemberLastName                     pgtype.Text   `json:"member_last_name"`
	MemberEmail                        pgtype.Text   `json:"member_email"`
	MemberProfileImageID               pgtype.UUID   `json:"member_profile_image_id"`
	MemberProfileImageHeight           pgtype.Float8 `json:"member_profile_image_height"`
	MemberProfileImageWidth            pgtype.Float8 `json:"member_profile_image_width"`
	MemberProfileImageAttachableItemID pgtype.UUID   `json:"member_profile_image_attachable_item_id"`
	MemberProfileImageOwnerID          pgtype.UUID   `json:"member_profile_image_owner_id"`
	MemberProfileImageFromOuter        pgtype.Bool   `json:"member_profile_image_from_outer"`
	MemberProfileImageAlias            pgtype.Text   `json:"member_profile_image_alias"`
	MemberProfileImageUrl              pgtype.Text   `json:"member_profile_image_url"`
	MemberProfileImageSize             pgtype.Float8 `json:"member_profile_image_size"`
	MemberProfileImageMimeTypeID       pgtype.UUID   `json:"member_profile_image_mime_type_id"`
}

func (q *Queries) FindProfessorByIDWithMember(ctx context.Context, professorID uuid.UUID) (FindProfessorByIDWithMemberRow, error) {
	row := q.db.QueryRow(ctx, findProfessorByIDWithMember, professorID)
	var i FindProfessorByIDWithMemberRow
	err := row.Scan(
		&i.MProfessorsPkey,
		&i.ProfessorID,
		&i.MemberID,
		&i.MemberName,
		&i.MemberFirstName,
		&i.MemberLastName,
		&i.MemberEmail,
		&i.MemberProfileImageID,
		&i.MemberProfileImageHeight,
		&i.MemberProfileImageWidth,
		&i.MemberProfileImageAttachableItemID,
		&i.MemberProfileImageOwnerID,
		&i.MemberProfileImageFromOuter,
		&i.MemberProfileImageAlias,
		&i.MemberProfileImageUrl,
		&i.MemberProfileImageSize,
		&i.MemberProfileImageMimeTypeID,
	)
	return i, err
}

const getPluralProfessors = `-- name: GetPluralProfessors :many
SELECT m_professors_pkey, professor_id, member_id FROM m_professors
WHERE professor_id = ANY($1::uuid[])
ORDER BY
	m_professors_pkey ASC
`

func (q *Queries) GetPluralProfessors(ctx context.Context, professorIds []uuid.UUID) ([]Professor, error) {
	rows, err := q.db.Query(ctx, getPluralProfessors, professorIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Professor{}
	for rows.Next() {
		var i Professor
		if err := rows.Scan(&i.MProfessorsPkey, &i.ProfessorID, &i.MemberID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralProfessorsUseNumberedPaginate = `-- name: GetPluralProfessorsUseNumberedPaginate :many
SELECT m_professors_pkey, professor_id, member_id FROM m_professors
WHERE professor_id = ANY($3::uuid[])
ORDER BY
	m_professors_pkey ASC
LIMIT $1 OFFSET $2
`

type GetPluralProfessorsUseNumberedPaginateParams struct {
	Limit        int32       `json:"limit"`
	Offset       int32       `json:"offset"`
	ProfessorIds []uuid.UUID `json:"professor_ids"`
}

func (q *Queries) GetPluralProfessorsUseNumberedPaginate(ctx context.Context, arg GetPluralProfessorsUseNumberedPaginateParams) ([]Professor, error) {
	rows, err := q.db.Query(ctx, getPluralProfessorsUseNumberedPaginate, arg.Limit, arg.Offset, arg.ProfessorIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Professor{}
	for rows.Next() {
		var i Professor
		if err := rows.Scan(&i.MProfessorsPkey, &i.ProfessorID, &i.MemberID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralProfessorsWithMember = `-- name: GetPluralProfessorsWithMember :many
SELECT m_professors.m_professors_pkey, m_professors.professor_id, m_professors.member_id, m_members.name member_name, m_members.first_name member_first_name, m_members.last_name member_last_name, m_members.email member_email,
m_members.profile_image_id member_profile_image_id, t_images.height member_profile_image_height,
t_images.width member_profile_image_width, t_images.attachable_item_id member_profile_image_attachable_item_id,
t_attachable_items.owner_id member_profile_image_owner_id, t_attachable_items.from_outer member_profile_image_from_outer, t_attachable_items.alias member_profile_image_alias,
t_attachable_items.url member_profile_image_url, t_attachable_items.size member_profile_image_size, t_attachable_items.mime_type_id member_profile_image_mime_type_id FROM m_professors
LEFT JOIN m_members ON m_professors.member_id = m_members.member_id
LEFT JOIN t_images ON m_members.profile_image_id = t_images.image_id
LEFT JOIN t_attachable_items ON t_images.attachable_item_id = t_attachable_items.attachable_item_id
WHERE professor_id = ANY($1::uuid[])
ORDER BY
	m_professors_pkey ASC
`

type GetPluralProfessorsWithMemberRow struct {
	MProfessorsPkey                    pgtype.Int8   `json:"m_professors_pkey"`
	ProfessorID                        uuid.UUID     `json:"professor_id"`
	MemberID                           uuid.UUID     `json:"member_id"`
	MemberName                         pgtype.Text   `json:"member_name"`
	MemberFirstName                    pgtype.Text   `json:"member_first_name"`
	MemberLastName                     pgtype.Text   `json:"member_last_name"`
	MemberEmail                        pgtype.Text   `json:"member_email"`
	MemberProfileImageID               pgtype.UUID   `json:"member_profile_image_id"`
	MemberProfileImageHeight           pgtype.Float8 `json:"member_profile_image_height"`
	MemberProfileImageWidth            pgtype.Float8 `json:"member_profile_image_width"`
	MemberProfileImageAttachableItemID pgtype.UUID   `json:"member_profile_image_attachable_item_id"`
	MemberProfileImageOwnerID          pgtype.UUID   `json:"member_profile_image_owner_id"`
	MemberProfileImageFromOuter        pgtype.Bool   `json:"member_profile_image_from_outer"`
	MemberProfileImageAlias            pgtype.Text   `json:"member_profile_image_alias"`
	MemberProfileImageUrl              pgtype.Text   `json:"member_profile_image_url"`
	MemberProfileImageSize             pgtype.Float8 `json:"member_profile_image_size"`
	MemberProfileImageMimeTypeID       pgtype.UUID   `json:"member_profile_image_mime_type_id"`
}

func (q *Queries) GetPluralProfessorsWithMember(ctx context.Context, professorIds []uuid.UUID) ([]GetPluralProfessorsWithMemberRow, error) {
	rows, err := q.db.Query(ctx, getPluralProfessorsWithMember, professorIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralProfessorsWithMemberRow{}
	for rows.Next() {
		var i GetPluralProfessorsWithMemberRow
		if err := rows.Scan(
			&i.MProfessorsPkey,
			&i.ProfessorID,
			&i.MemberID,
			&i.MemberName,
			&i.MemberFirstName,
			&i.MemberLastName,
			&i.MemberEmail,
			&i.MemberProfileImageID,
			&i.MemberProfileImageHeight,
			&i.MemberProfileImageWidth,
			&i.MemberProfileImageAttachableItemID,
			&i.MemberProfileImageOwnerID,
			&i.MemberProfileImageFromOuter,
			&i.MemberProfileImageAlias,
			&i.MemberProfileImageUrl,
			&i.MemberProfileImageSize,
			&i.MemberProfileImageMimeTypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralProfessorsWithMemberUseNumberedPaginate = `-- name: GetPluralProfessorsWithMemberUseNumberedPaginate :many
SELECT m_professors.m_professors_pkey, m_professors.professor_id, m_professors.member_id, m_members.name member_name, m_members.first_name member_first_name, m_members.last_name member_last_name, m_members.email member_email,
m_members.profile_image_id member_profile_image_id, t_images.height member_profile_image_height,
t_images.width member_profile_image_width, t_images.attachable_item_id member_profile_image_attachable_item_id,
t_attachable_items.owner_id member_profile_image_owner_id, t_attachable_items.from_outer member_profile_image_from_outer, t_attachable_items.alias member_profile_image_alias,
t_attachable_items.url member_profile_image_url, t_attachable_items.size member_profile_image_size, t_attachable_items.mime_type_id member_profile_image_mime_type_id FROM m_professors
LEFT JOIN m_members ON m_professors.member_id = m_members.member_id
LEFT JOIN t_images ON m_members.profile_image_id = t_images.image_id
LEFT JOIN t_attachable_items ON t_images.attachable_item_id = t_attachable_items.attachable_item_id
WHERE professor_id = ANY($3::uuid[])
ORDER BY
	m_professors_pkey ASC
LIMIT $1 OFFSET $2
`

type GetPluralProfessorsWithMemberUseNumberedPaginateParams struct {
	Limit        int32       `json:"limit"`
	Offset       int32       `json:"offset"`
	ProfessorIds []uuid.UUID `json:"professor_ids"`
}

type GetPluralProfessorsWithMemberUseNumberedPaginateRow struct {
	MProfessorsPkey                    pgtype.Int8   `json:"m_professors_pkey"`
	ProfessorID                        uuid.UUID     `json:"professor_id"`
	MemberID                           uuid.UUID     `json:"member_id"`
	MemberName                         pgtype.Text   `json:"member_name"`
	MemberFirstName                    pgtype.Text   `json:"member_first_name"`
	MemberLastName                     pgtype.Text   `json:"member_last_name"`
	MemberEmail                        pgtype.Text   `json:"member_email"`
	MemberProfileImageID               pgtype.UUID   `json:"member_profile_image_id"`
	MemberProfileImageHeight           pgtype.Float8 `json:"member_profile_image_height"`
	MemberProfileImageWidth            pgtype.Float8 `json:"member_profile_image_width"`
	MemberProfileImageAttachableItemID pgtype.UUID   `json:"member_profile_image_attachable_item_id"`
	MemberProfileImageOwnerID          pgtype.UUID   `json:"member_profile_image_owner_id"`
	MemberProfileImageFromOuter        pgtype.Bool   `json:"member_profile_image_from_outer"`
	MemberProfileImageAlias            pgtype.Text   `json:"member_profile_image_alias"`
	MemberProfileImageUrl              pgtype.Text   `json:"member_profile_image_url"`
	MemberProfileImageSize             pgtype.Float8 `json:"member_profile_image_size"`
	MemberProfileImageMimeTypeID       pgtype.UUID   `json:"member_profile_image_mime_type_id"`
}

func (q *Queries) GetPluralProfessorsWithMemberUseNumberedPaginate(ctx context.Context, arg GetPluralProfessorsWithMemberUseNumberedPaginateParams) ([]GetPluralProfessorsWithMemberUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getPluralProfessorsWithMemberUseNumberedPaginate, arg.Limit, arg.Offset, arg.ProfessorIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralProfessorsWithMemberUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetPluralProfessorsWithMemberUseNumberedPaginateRow
		if err := rows.Scan(
			&i.MProfessorsPkey,
			&i.ProfessorID,
			&i.MemberID,
			&i.MemberName,
			&i.MemberFirstName,
			&i.MemberLastName,
			&i.MemberEmail,
			&i.MemberProfileImageID,
			&i.MemberProfileImageHeight,
			&i.MemberProfileImageWidth,
			&i.MemberProfileImageAttachableItemID,
			&i.MemberProfileImageOwnerID,
			&i.MemberProfileImageFromOuter,
			&i.MemberProfileImageAlias,
			&i.MemberProfileImageUrl,
			&i.MemberProfileImageSize,
			&i.MemberProfileImageMimeTypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProfessors = `-- name: GetProfessors :many
SELECT m_professors_pkey, professor_id, member_id FROM m_professors
ORDER BY
	m_professors_pkey ASC
`

func (q *Queries) GetProfessors(ctx context.Context) ([]Professor, error) {
	rows, err := q.db.Query(ctx, getProfessors)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Professor{}
	for rows.Next() {
		var i Professor
		if err := rows.Scan(&i.MProfessorsPkey, &i.ProfessorID, &i.MemberID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProfessorsUseKeysetPaginate = `-- name: GetProfessorsUseKeysetPaginate :many
SELECT m_professors_pkey, professor_id, member_id FROM m_professors
WHERE
	CASE $2::text
		WHEN 'next' THEN
			m_professors_pkey > $3::int
		WHEN 'prev' THEN
			m_professors_pkey < $3::int
	END
ORDER BY
	CASE WHEN $2::text = 'next' THEN m_professors_pkey END ASC,
	CASE WHEN $2::text = 'prev' THEN m_professors_pkey END DESC
LIMIT $1
`

type GetProfessorsUseKeysetPaginateParams struct {
	Limit           int32  `json:"limit"`
	CursorDirection string `json:"cursor_direction"`
	Cursor          int32  `json:"cursor"`
}

func (q *Queries) GetProfessorsUseKeysetPaginate(ctx context.Context, arg GetProfessorsUseKeysetPaginateParams) ([]Professor, error) {
	rows, err := q.db.Query(ctx, getProfessorsUseKeysetPaginate, arg.Limit, arg.CursorDirection, arg.Cursor)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Professor{}
	for rows.Next() {
		var i Professor
		if err := rows.Scan(&i.MProfessorsPkey, &i.ProfessorID, &i.MemberID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProfessorsUseNumberedPaginate = `-- name: GetProfessorsUseNumberedPaginate :many
SELECT m_professors_pkey, professor_id, member_id FROM m_professors
ORDER BY
	m_professors_pkey ASC
LIMIT $1 OFFSET $2
`

type GetProfessorsUseNumberedPaginateParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetProfessorsUseNumberedPaginate(ctx context.Context, arg GetProfessorsUseNumberedPaginateParams) ([]Professor, error) {
	rows, err := q.db.Query(ctx, getProfessorsUseNumberedPaginate, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Professor{}
	for rows.Next() {
		var i Professor
		if err := rows.Scan(&i.MProfessorsPkey, &i.ProfessorID, &i.MemberID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProfessorsWithMember = `-- name: GetProfessorsWithMember :many
SELECT m_professors.m_professors_pkey, m_professors.professor_id, m_professors.member_id, m_members.name member_name, m_members.first_name member_first_name, m_members.last_name member_last_name, m_members.email member_email,
m_members.profile_image_id member_profile_image_id, t_images.height member_profile_image_height,
t_images.width member_profile_image_width, t_images.attachable_item_id member_profile_image_attachable_item_id,
t_attachable_items.owner_id member_profile_image_owner_id, t_attachable_items.from_outer member_profile_image_from_outer, t_attachable_items.alias member_profile_image_alias,
t_attachable_items.url member_profile_image_url, t_attachable_items.size member_profile_image_size, t_attachable_items.mime_type_id member_profile_image_mime_type_id FROM m_professors
LEFT JOIN m_members ON m_professors.member_id = m_members.member_id
LEFT JOIN t_images ON m_members.profile_image_id = t_images.image_id
LEFT JOIN t_attachable_items ON t_images.attachable_item_id = t_attachable_items.attachable_item_id
ORDER BY
	m_professors_pkey ASC
`

type GetProfessorsWithMemberRow struct {
	MProfessorsPkey                    pgtype.Int8   `json:"m_professors_pkey"`
	ProfessorID                        uuid.UUID     `json:"professor_id"`
	MemberID                           uuid.UUID     `json:"member_id"`
	MemberName                         pgtype.Text   `json:"member_name"`
	MemberFirstName                    pgtype.Text   `json:"member_first_name"`
	MemberLastName                     pgtype.Text   `json:"member_last_name"`
	MemberEmail                        pgtype.Text   `json:"member_email"`
	MemberProfileImageID               pgtype.UUID   `json:"member_profile_image_id"`
	MemberProfileImageHeight           pgtype.Float8 `json:"member_profile_image_height"`
	MemberProfileImageWidth            pgtype.Float8 `json:"member_profile_image_width"`
	MemberProfileImageAttachableItemID pgtype.UUID   `json:"member_profile_image_attachable_item_id"`
	MemberProfileImageOwnerID          pgtype.UUID   `json:"member_profile_image_owner_id"`
	MemberProfileImageFromOuter        pgtype.Bool   `json:"member_profile_image_from_outer"`
	MemberProfileImageAlias            pgtype.Text   `json:"member_profile_image_alias"`
	MemberProfileImageUrl              pgtype.Text   `json:"member_profile_image_url"`
	MemberProfileImageSize             pgtype.Float8 `json:"member_profile_image_size"`
	MemberProfileImageMimeTypeID       pgtype.UUID   `json:"member_profile_image_mime_type_id"`
}

func (q *Queries) GetProfessorsWithMember(ctx context.Context) ([]GetProfessorsWithMemberRow, error) {
	rows, err := q.db.Query(ctx, getProfessorsWithMember)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProfessorsWithMemberRow{}
	for rows.Next() {
		var i GetProfessorsWithMemberRow
		if err := rows.Scan(
			&i.MProfessorsPkey,
			&i.ProfessorID,
			&i.MemberID,
			&i.MemberName,
			&i.MemberFirstName,
			&i.MemberLastName,
			&i.MemberEmail,
			&i.MemberProfileImageID,
			&i.MemberProfileImageHeight,
			&i.MemberProfileImageWidth,
			&i.MemberProfileImageAttachableItemID,
			&i.MemberProfileImageOwnerID,
			&i.MemberProfileImageFromOuter,
			&i.MemberProfileImageAlias,
			&i.MemberProfileImageUrl,
			&i.MemberProfileImageSize,
			&i.MemberProfileImageMimeTypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProfessorsWithMemberUseKeysetPaginate = `-- name: GetProfessorsWithMemberUseKeysetPaginate :many
SELECT m_professors.m_professors_pkey, m_professors.professor_id, m_professors.member_id, m_members.name member_name, m_members.first_name member_first_name, m_members.last_name member_last_name, m_members.email member_email,
m_members.profile_image_id member_profile_image_id, t_images.height member_profile_image_height,
t_images.width member_profile_image_width, t_images.attachable_item_id member_profile_image_attachable_item_id,
t_attachable_items.owner_id member_profile_image_owner_id, t_attachable_items.from_outer member_profile_image_from_outer, t_attachable_items.alias member_profile_image_alias,
t_attachable_items.url member_profile_image_url, t_attachable_items.size member_profile_image_size, t_attachable_items.mime_type_id member_profile_image_mime_type_id FROM m_professors
LEFT JOIN m_members ON m_professors.member_id = m_members.member_id
LEFT JOIN t_images ON m_members.profile_image_id = t_images.image_id
LEFT JOIN t_attachable_items ON t_images.attachable_item_id = t_attachable_items.attachable_item_id
WHERE
	CASE $2::text
		WHEN 'next' THEN
			m_professors_pkey > $3::int
		WHEN 'prev' THEN
			m_professors_pkey < $3::int
	END
ORDER BY
	CASE WHEN $2::text = 'next' THEN m_professors_pkey END ASC,
	CASE WHEN $2::text = 'prev' THEN m_professors_pkey END DESC
LIMIT $1
`

type GetProfessorsWithMemberUseKeysetPaginateParams struct {
	Limit           int32  `json:"limit"`
	CursorDirection string `json:"cursor_direction"`
	Cursor          int32  `json:"cursor"`
}

type GetProfessorsWithMemberUseKeysetPaginateRow struct {
	MProfessorsPkey                    pgtype.Int8   `json:"m_professors_pkey"`
	ProfessorID                        uuid.UUID     `json:"professor_id"`
	MemberID                           uuid.UUID     `json:"member_id"`
	MemberName                         pgtype.Text   `json:"member_name"`
	MemberFirstName                    pgtype.Text   `json:"member_first_name"`
	MemberLastName                     pgtype.Text   `json:"member_last_name"`
	MemberEmail                        pgtype.Text   `json:"member_email"`
	MemberProfileImageID               pgtype.UUID   `json:"member_profile_image_id"`
	MemberProfileImageHeight           pgtype.Float8 `json:"member_profile_image_height"`
	MemberProfileImageWidth            pgtype.Float8 `json:"member_profile_image_width"`
	MemberProfileImageAttachableItemID pgtype.UUID   `json:"member_profile_image_attachable_item_id"`
	MemberProfileImageOwnerID          pgtype.UUID   `json:"member_profile_image_owner_id"`
	MemberProfileImageFromOuter        pgtype.Bool   `json:"member_profile_image_from_outer"`
	MemberProfileImageAlias            pgtype.Text   `json:"member_profile_image_alias"`
	MemberProfileImageUrl              pgtype.Text   `json:"member_profile_image_url"`
	MemberProfileImageSize             pgtype.Float8 `json:"member_profile_image_size"`
	MemberProfileImageMimeTypeID       pgtype.UUID   `json:"member_profile_image_mime_type_id"`
}

func (q *Queries) GetProfessorsWithMemberUseKeysetPaginate(ctx context.Context, arg GetProfessorsWithMemberUseKeysetPaginateParams) ([]GetProfessorsWithMemberUseKeysetPaginateRow, error) {
	rows, err := q.db.Query(ctx, getProfessorsWithMemberUseKeysetPaginate, arg.Limit, arg.CursorDirection, arg.Cursor)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProfessorsWithMemberUseKeysetPaginateRow{}
	for rows.Next() {
		var i GetProfessorsWithMemberUseKeysetPaginateRow
		if err := rows.Scan(
			&i.MProfessorsPkey,
			&i.ProfessorID,
			&i.MemberID,
			&i.MemberName,
			&i.MemberFirstName,
			&i.MemberLastName,
			&i.MemberEmail,
			&i.MemberProfileImageID,
			&i.MemberProfileImageHeight,
			&i.MemberProfileImageWidth,
			&i.MemberProfileImageAttachableItemID,
			&i.MemberProfileImageOwnerID,
			&i.MemberProfileImageFromOuter,
			&i.MemberProfileImageAlias,
			&i.MemberProfileImageUrl,
			&i.MemberProfileImageSize,
			&i.MemberProfileImageMimeTypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProfessorsWithMemberUseNumberedPaginate = `-- name: GetProfessorsWithMemberUseNumberedPaginate :many
SELECT m_professors.m_professors_pkey, m_professors.professor_id, m_professors.member_id, m_members.name member_name, m_members.first_name member_first_name, m_members.last_name member_last_name, m_members.email member_email,
m_members.profile_image_id member_profile_image_id, t_images.height member_profile_image_height,
t_images.width member_profile_image_width, t_images.attachable_item_id member_profile_image_attachable_item_id,
t_attachable_items.owner_id member_profile_image_owner_id, t_attachable_items.from_outer member_profile_image_from_outer, t_attachable_items.alias member_profile_image_alias,
t_attachable_items.url member_profile_image_url, t_attachable_items.size member_profile_image_size, t_attachable_items.mime_type_id member_profile_image_mime_type_id FROM m_professors
LEFT JOIN m_members ON m_professors.member_id = m_members.member_id
LEFT JOIN t_images ON m_members.profile_image_id = t_images.image_id
LEFT JOIN t_attachable_items ON t_images.attachable_item_id = t_attachable_items.attachable_item_id
ORDER BY
	m_professors_pkey ASC
LIMIT $1 OFFSET $2
`

type GetProfessorsWithMemberUseNumberedPaginateParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetProfessorsWithMemberUseNumberedPaginateRow struct {
	MProfessorsPkey                    pgtype.Int8   `json:"m_professors_pkey"`
	ProfessorID                        uuid.UUID     `json:"professor_id"`
	MemberID                           uuid.UUID     `json:"member_id"`
	MemberName                         pgtype.Text   `json:"member_name"`
	MemberFirstName                    pgtype.Text   `json:"member_first_name"`
	MemberLastName                     pgtype.Text   `json:"member_last_name"`
	MemberEmail                        pgtype.Text   `json:"member_email"`
	MemberProfileImageID               pgtype.UUID   `json:"member_profile_image_id"`
	MemberProfileImageHeight           pgtype.Float8 `json:"member_profile_image_height"`
	MemberProfileImageWidth            pgtype.Float8 `json:"member_profile_image_width"`
	MemberProfileImageAttachableItemID pgtype.UUID   `json:"member_profile_image_attachable_item_id"`
	MemberProfileImageOwnerID          pgtype.UUID   `json:"member_profile_image_owner_id"`
	MemberProfileImageFromOuter        pgtype.Bool   `json:"member_profile_image_from_outer"`
	MemberProfileImageAlias            pgtype.Text   `json:"member_profile_image_alias"`
	MemberProfileImageUrl              pgtype.Text   `json:"member_profile_image_url"`
	MemberProfileImageSize             pgtype.Float8 `json:"member_profile_image_size"`
	MemberProfileImageMimeTypeID       pgtype.UUID   `json:"member_profile_image_mime_type_id"`
}

func (q *Queries) GetProfessorsWithMemberUseNumberedPaginate(ctx context.Context, arg GetProfessorsWithMemberUseNumberedPaginateParams) ([]GetProfessorsWithMemberUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getProfessorsWithMemberUseNumberedPaginate, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProfessorsWithMemberUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetProfessorsWithMemberUseNumberedPaginateRow
		if err := rows.Scan(
			&i.MProfessorsPkey,
			&i.ProfessorID,
			&i.MemberID,
			&i.MemberName,
			&i.MemberFirstName,
			&i.MemberLastName,
			&i.MemberEmail,
			&i.MemberProfileImageID,
			&i.MemberProfileImageHeight,
			&i.MemberProfileImageWidth,
			&i.MemberProfileImageAttachableItemID,
			&i.MemberProfileImageOwnerID,
			&i.MemberProfileImageFromOuter,
			&i.MemberProfileImageAlias,
			&i.MemberProfileImageUrl,
			&i.MemberProfileImageSize,
			&i.MemberProfileImageMimeTypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const pluralDeleteProfessors = `-- name: PluralDeleteProfessors :execrows
DELETE FROM m_professors WHERE professor_id = ANY($1::uuid[])
`

func (q *Queries) PluralDeleteProfessors(ctx context.Context, professorIds []uuid.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, pluralDeleteProfessors, professorIds)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
