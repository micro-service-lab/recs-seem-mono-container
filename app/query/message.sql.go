// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: message.sql

package query

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countMessages = `-- name: CountMessages :one
SELECT COUNT(*) FROM t_messages
WHERE
	CASE WHEN $1::boolean = true THEN t_chat_room_actions in (SELECT chat_room_action_id FROM t_chat_room_actions WHERE chat_room_id = ANY($2::uuid[])) ELSE TRUE END
AND
	CASE WHEN $3::boolean = true THEN sender_id = ANY($4::uuid[]) ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN body LIKE '%' || $6::text || '%' ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN posted_at >= $8 ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN posted_at <= $10 ELSE TRUE END
AND
	CASE WHEN $11::boolean = true THEN last_edited_at >= $12 ELSE TRUE END
AND
	CASE WHEN $13::boolean = true THEN last_edited_at <= $14 ELSE TRUE END
`

type CountMessagesParams struct {
	WhereInChatRoom          bool        `json:"where_in_chat_room"`
	InChatRoom               []uuid.UUID `json:"in_chat_room"`
	WhereInSender            bool        `json:"where_in_sender"`
	InSender                 []uuid.UUID `json:"in_sender"`
	WhereLikeBody            bool        `json:"where_like_body"`
	SearchBody               string      `json:"search_body"`
	WhereEarlierPostedAt     bool        `json:"where_earlier_posted_at"`
	EarlierPostedAt          time.Time   `json:"earlier_posted_at"`
	WhereLaterPostedAt       bool        `json:"where_later_posted_at"`
	LaterPostedAt            time.Time   `json:"later_posted_at"`
	WhereEarlierLastEditedAt bool        `json:"where_earlier_last_edited_at"`
	EarlierLastEditedAt      time.Time   `json:"earlier_last_edited_at"`
	WhereLaterLastEditedAt   bool        `json:"where_later_last_edited_at"`
	LaterLastEditedAt        time.Time   `json:"later_last_edited_at"`
}

func (q *Queries) CountMessages(ctx context.Context, arg CountMessagesParams) (int64, error) {
	row := q.db.QueryRow(ctx, countMessages,
		arg.WhereInChatRoom,
		arg.InChatRoom,
		arg.WhereInSender,
		arg.InSender,
		arg.WhereLikeBody,
		arg.SearchBody,
		arg.WhereEarlierPostedAt,
		arg.EarlierPostedAt,
		arg.WhereLaterPostedAt,
		arg.LaterPostedAt,
		arg.WhereEarlierLastEditedAt,
		arg.EarlierLastEditedAt,
		arg.WhereLaterLastEditedAt,
		arg.LaterLastEditedAt,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createMessage = `-- name: CreateMessage :one
INSERT INTO t_messages (chat_room_action_id, sender_id, body, posted_at, last_edited_at) VALUES ($1, $2, $3, $4, $5) RETURNING t_messages_pkey, message_id, sender_id, body, posted_at, last_edited_at, chat_room_action_id
`

type CreateMessageParams struct {
	ChatRoomActionID uuid.UUID   `json:"chat_room_action_id"`
	SenderID         pgtype.UUID `json:"sender_id"`
	Body             string      `json:"body"`
	PostedAt         time.Time   `json:"posted_at"`
	LastEditedAt     time.Time   `json:"last_edited_at"`
}

func (q *Queries) CreateMessage(ctx context.Context, arg CreateMessageParams) (Message, error) {
	row := q.db.QueryRow(ctx, createMessage,
		arg.ChatRoomActionID,
		arg.SenderID,
		arg.Body,
		arg.PostedAt,
		arg.LastEditedAt,
	)
	var i Message
	err := row.Scan(
		&i.TMessagesPkey,
		&i.MessageID,
		&i.SenderID,
		&i.Body,
		&i.PostedAt,
		&i.LastEditedAt,
		&i.ChatRoomActionID,
	)
	return i, err
}

type CreateMessagesParams struct {
	ChatRoomActionID uuid.UUID   `json:"chat_room_action_id"`
	SenderID         pgtype.UUID `json:"sender_id"`
	Body             string      `json:"body"`
	PostedAt         time.Time   `json:"posted_at"`
	LastEditedAt     time.Time   `json:"last_edited_at"`
}

const deleteMessage = `-- name: DeleteMessage :execrows
DELETE FROM t_messages WHERE message_id = $1
`

func (q *Queries) DeleteMessage(ctx context.Context, messageID uuid.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, deleteMessage, messageID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteMessagesOnChatRoom = `-- name: DeleteMessagesOnChatRoom :execrows
DELETE FROM t_messages WHERE (SELECT chat_room_id FROM t_chat_room_actions WHERE t_chat_room_actions.chat_room_action_id = t_messages.chat_room_action_id) = $1
`

func (q *Queries) DeleteMessagesOnChatRoom(ctx context.Context, chatRoomID uuid.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, deleteMessagesOnChatRoom, chatRoomID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const findMessageByID = `-- name: FindMessageByID :one
SELECT t_messages_pkey, message_id, sender_id, body, posted_at, last_edited_at, chat_room_action_id FROM t_messages WHERE message_id = $1
`

func (q *Queries) FindMessageByID(ctx context.Context, messageID uuid.UUID) (Message, error) {
	row := q.db.QueryRow(ctx, findMessageByID, messageID)
	var i Message
	err := row.Scan(
		&i.TMessagesPkey,
		&i.MessageID,
		&i.SenderID,
		&i.Body,
		&i.PostedAt,
		&i.LastEditedAt,
		&i.ChatRoomActionID,
	)
	return i, err
}

const findMessageByIDWithChatRoom = `-- name: FindMessageByIDWithChatRoom :one
SELECT t_messages.t_messages_pkey, t_messages.message_id, t_messages.sender_id, t_messages.body, t_messages.posted_at, t_messages.last_edited_at, t_messages.chat_room_action_id, m_chat_rooms.chat_room_id, m_chat_rooms.name chat_room_name, m_chat_rooms.is_private chat_room_is_private,
m_chat_rooms.from_organization chat_room_from_organization, m_chat_rooms.owner_id chat_room_owner_id,
m_chat_rooms.cover_image_id chat_room_cover_image_id, t_images.height chat_room_cover_image_height,
t_images.width chat_room_cover_image_width, t_images.attachable_item_id chat_room_cover_image_attachable_item_id,
t_attachable_items.owner_id chat_room_cover_image_owner_id, t_attachable_items.from_outer chat_room_cover_image_from_outer, t_attachable_items.alias chat_room_cover_image_alias,
t_attachable_items.url chat_room_cover_image_url, t_attachable_items.size chat_room_cover_image_size, t_attachable_items.mime_type_id chat_room_cover_image_mime_type_id FROM t_messages
LEFT JOIN t_chat_room_actions ON t_messages.chat_room_action_id = t_chat_room_actions.chat_room_action_id
LEFT JOIN m_chat_rooms ON t_messages.chat_room_id = m_chat_rooms.chat_room_id
LEFT JOIN t_images ON m_chat_rooms.cover_image_id = t_images.image_id
LEFT JOIN t_attachable_items ON t_images.attachable_item_id = t_attachable_items.attachable_item_id
WHERE message_id = $1
`

type FindMessageByIDWithChatRoomRow struct {
	TMessagesPkey                      pgtype.Int8   `json:"t_messages_pkey"`
	MessageID                          uuid.UUID     `json:"message_id"`
	SenderID                           pgtype.UUID   `json:"sender_id"`
	Body                               string        `json:"body"`
	PostedAt                           time.Time     `json:"posted_at"`
	LastEditedAt                       time.Time     `json:"last_edited_at"`
	ChatRoomActionID                   uuid.UUID     `json:"chat_room_action_id"`
	ChatRoomID                         pgtype.UUID   `json:"chat_room_id"`
	ChatRoomName                       pgtype.Text   `json:"chat_room_name"`
	ChatRoomIsPrivate                  pgtype.Bool   `json:"chat_room_is_private"`
	ChatRoomFromOrganization           pgtype.Bool   `json:"chat_room_from_organization"`
	ChatRoomOwnerID                    pgtype.UUID   `json:"chat_room_owner_id"`
	ChatRoomCoverImageID               pgtype.UUID   `json:"chat_room_cover_image_id"`
	ChatRoomCoverImageHeight           pgtype.Float8 `json:"chat_room_cover_image_height"`
	ChatRoomCoverImageWidth            pgtype.Float8 `json:"chat_room_cover_image_width"`
	ChatRoomCoverImageAttachableItemID pgtype.UUID   `json:"chat_room_cover_image_attachable_item_id"`
	ChatRoomCoverImageOwnerID          pgtype.UUID   `json:"chat_room_cover_image_owner_id"`
	ChatRoomCoverImageFromOuter        pgtype.Bool   `json:"chat_room_cover_image_from_outer"`
	ChatRoomCoverImageAlias            pgtype.Text   `json:"chat_room_cover_image_alias"`
	ChatRoomCoverImageUrl              pgtype.Text   `json:"chat_room_cover_image_url"`
	ChatRoomCoverImageSize             pgtype.Float8 `json:"chat_room_cover_image_size"`
	ChatRoomCoverImageMimeTypeID       pgtype.UUID   `json:"chat_room_cover_image_mime_type_id"`
}

func (q *Queries) FindMessageByIDWithChatRoom(ctx context.Context, messageID uuid.UUID) (FindMessageByIDWithChatRoomRow, error) {
	row := q.db.QueryRow(ctx, findMessageByIDWithChatRoom, messageID)
	var i FindMessageByIDWithChatRoomRow
	err := row.Scan(
		&i.TMessagesPkey,
		&i.MessageID,
		&i.SenderID,
		&i.Body,
		&i.PostedAt,
		&i.LastEditedAt,
		&i.ChatRoomActionID,
		&i.ChatRoomID,
		&i.ChatRoomName,
		&i.ChatRoomIsPrivate,
		&i.ChatRoomFromOrganization,
		&i.ChatRoomOwnerID,
		&i.ChatRoomCoverImageID,
		&i.ChatRoomCoverImageHeight,
		&i.ChatRoomCoverImageWidth,
		&i.ChatRoomCoverImageAttachableItemID,
		&i.ChatRoomCoverImageOwnerID,
		&i.ChatRoomCoverImageFromOuter,
		&i.ChatRoomCoverImageAlias,
		&i.ChatRoomCoverImageUrl,
		&i.ChatRoomCoverImageSize,
		&i.ChatRoomCoverImageMimeTypeID,
	)
	return i, err
}

const findMessageByIDWithSender = `-- name: FindMessageByIDWithSender :one
SELECT t_messages.t_messages_pkey, t_messages.message_id, t_messages.sender_id, t_messages.body, t_messages.posted_at, t_messages.last_edited_at, t_messages.chat_room_action_id, m_members.name member_name, m_members.first_name member_first_name, m_members.last_name member_last_name, m_members.email member_email,
m_members.profile_image_id member_profile_image_id, t_images.height member_profile_image_height,
t_images.width member_profile_image_width, t_images.attachable_item_id member_profile_image_attachable_item_id,
t_attachable_items.owner_id member_profile_image_owner_id, t_attachable_items.from_outer member_profile_image_from_outer, t_attachable_items.alias member_profile_image_alias,
t_attachable_items.url member_profile_image_url, t_attachable_items.size member_profile_image_size, t_attachable_items.mime_type_id member_profile_image_mime_type_id FROM t_messages
LEFT JOIN m_members ON t_messages.sender_id = m_members.member_id
LEFT JOIN t_images ON m_members.profile_image_id = t_images.image_id
LEFT JOIN t_attachable_items ON t_images.attachable_item_id = t_attachable_items.attachable_item_id
WHERE message_id = $1
`

type FindMessageByIDWithSenderRow struct {
	TMessagesPkey                      pgtype.Int8   `json:"t_messages_pkey"`
	MessageID                          uuid.UUID     `json:"message_id"`
	SenderID                           pgtype.UUID   `json:"sender_id"`
	Body                               string        `json:"body"`
	PostedAt                           time.Time     `json:"posted_at"`
	LastEditedAt                       time.Time     `json:"last_edited_at"`
	ChatRoomActionID                   uuid.UUID     `json:"chat_room_action_id"`
	MemberName                         pgtype.Text   `json:"member_name"`
	MemberFirstName                    pgtype.Text   `json:"member_first_name"`
	MemberLastName                     pgtype.Text   `json:"member_last_name"`
	MemberEmail                        pgtype.Text   `json:"member_email"`
	MemberProfileImageID               pgtype.UUID   `json:"member_profile_image_id"`
	MemberProfileImageHeight           pgtype.Float8 `json:"member_profile_image_height"`
	MemberProfileImageWidth            pgtype.Float8 `json:"member_profile_image_width"`
	MemberProfileImageAttachableItemID pgtype.UUID   `json:"member_profile_image_attachable_item_id"`
	MemberProfileImageOwnerID          pgtype.UUID   `json:"member_profile_image_owner_id"`
	MemberProfileImageFromOuter        pgtype.Bool   `json:"member_profile_image_from_outer"`
	MemberProfileImageAlias            pgtype.Text   `json:"member_profile_image_alias"`
	MemberProfileImageUrl              pgtype.Text   `json:"member_profile_image_url"`
	MemberProfileImageSize             pgtype.Float8 `json:"member_profile_image_size"`
	MemberProfileImageMimeTypeID       pgtype.UUID   `json:"member_profile_image_mime_type_id"`
}

func (q *Queries) FindMessageByIDWithSender(ctx context.Context, messageID uuid.UUID) (FindMessageByIDWithSenderRow, error) {
	row := q.db.QueryRow(ctx, findMessageByIDWithSender, messageID)
	var i FindMessageByIDWithSenderRow
	err := row.Scan(
		&i.TMessagesPkey,
		&i.MessageID,
		&i.SenderID,
		&i.Body,
		&i.PostedAt,
		&i.LastEditedAt,
		&i.ChatRoomActionID,
		&i.MemberName,
		&i.MemberFirstName,
		&i.MemberLastName,
		&i.MemberEmail,
		&i.MemberProfileImageID,
		&i.MemberProfileImageHeight,
		&i.MemberProfileImageWidth,
		&i.MemberProfileImageAttachableItemID,
		&i.MemberProfileImageOwnerID,
		&i.MemberProfileImageFromOuter,
		&i.MemberProfileImageAlias,
		&i.MemberProfileImageUrl,
		&i.MemberProfileImageSize,
		&i.MemberProfileImageMimeTypeID,
	)
	return i, err
}

const getMessages = `-- name: GetMessages :many
SELECT t_messages_pkey, message_id, sender_id, body, posted_at, last_edited_at, chat_room_action_id FROM t_messages
WHERE
	CASE WHEN $1::boolean = true THEN chat_room_id = ANY($2::uuid[]) ELSE TRUE END
AND
	CASE WHEN $3::boolean = true THEN sender_id = ANY($4::uuid[]) ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN body LIKE '%' || $6::text || '%' ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN posted_at >= $8 ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN posted_at <= $10 ELSE TRUE END
AND
	CASE WHEN $11::boolean = true THEN last_edited_at >= $12 ELSE TRUE END
AND
	CASE WHEN $13::boolean = true THEN last_edited_at <= $14 ELSE TRUE END
ORDER BY
	CASE WHEN $15::text = 'posted_at' THEN posted_at END ASC NULLS LAST,
	CASE WHEN $15::text = 'r_posted_at' THEN posted_at END DESC NULLS LAST,
	CASE WHEN $15::text = 'last_edited_at' THEN last_edited_at END ASC NULLS LAST,
	CASE WHEN $15::text = 'r_last_edited_at' THEN last_edited_at END DESC NULLS LAST,
	t_messages_pkey ASC
`

type GetMessagesParams struct {
	WhereInChatRoom          bool        `json:"where_in_chat_room"`
	InChatRoom               []uuid.UUID `json:"in_chat_room"`
	WhereInSender            bool        `json:"where_in_sender"`
	InSender                 []uuid.UUID `json:"in_sender"`
	WhereLikeBody            bool        `json:"where_like_body"`
	SearchBody               string      `json:"search_body"`
	WhereEarlierPostedAt     bool        `json:"where_earlier_posted_at"`
	EarlierPostedAt          time.Time   `json:"earlier_posted_at"`
	WhereLaterPostedAt       bool        `json:"where_later_posted_at"`
	LaterPostedAt            time.Time   `json:"later_posted_at"`
	WhereEarlierLastEditedAt bool        `json:"where_earlier_last_edited_at"`
	EarlierLastEditedAt      time.Time   `json:"earlier_last_edited_at"`
	WhereLaterLastEditedAt   bool        `json:"where_later_last_edited_at"`
	LaterLastEditedAt        time.Time   `json:"later_last_edited_at"`
	OrderMethod              string      `json:"order_method"`
}

func (q *Queries) GetMessages(ctx context.Context, arg GetMessagesParams) ([]Message, error) {
	rows, err := q.db.Query(ctx, getMessages,
		arg.WhereInChatRoom,
		arg.InChatRoom,
		arg.WhereInSender,
		arg.InSender,
		arg.WhereLikeBody,
		arg.SearchBody,
		arg.WhereEarlierPostedAt,
		arg.EarlierPostedAt,
		arg.WhereLaterPostedAt,
		arg.LaterPostedAt,
		arg.WhereEarlierLastEditedAt,
		arg.EarlierLastEditedAt,
		arg.WhereLaterLastEditedAt,
		arg.LaterLastEditedAt,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Message{}
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.TMessagesPkey,
			&i.MessageID,
			&i.SenderID,
			&i.Body,
			&i.PostedAt,
			&i.LastEditedAt,
			&i.ChatRoomActionID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMessagesUseKeysetPaginate = `-- name: GetMessagesUseKeysetPaginate :many
SELECT t_messages_pkey, message_id, sender_id, body, posted_at, last_edited_at, chat_room_action_id FROM t_messages
WHERE
	CASE WHEN $2::boolean = true THEN chat_room_id = ANY($3::uuid[]) ELSE TRUE END
AND
	CASE WHEN $4::boolean = true THEN sender_id = ANY($5::uuid[]) ELSE TRUE END
AND
	CASE WHEN $6::boolean = true THEN body LIKE '%' || $7::text || '%' ELSE TRUE END
AND
	CASE WHEN $8::boolean = true THEN posted_at >= $9 ELSE TRUE END
AND
	CASE WHEN $10::boolean = true THEN posted_at <= $11 ELSE TRUE END
AND
	CASE WHEN $12::boolean = true THEN last_edited_at >= $13 ELSE TRUE END
AND
	CASE WHEN $14::boolean = true THEN last_edited_at <= $15 ELSE TRUE END
AND
	CASE $16::text
		WHEN 'next' THEN
			CASE $17::text
				WHEN 'posted_at' THEN posted_at > $18 OR (posted_at = $18 AND t_messages_pkey > $19::int)
				WHEN 'r_posted_at' THEN posted_at < $18 OR (posted_at = $18 AND t_messages_pkey > $19::int)
				WHEN 'last_edited_at' THEN last_edited_at > $20 OR (last_edited_at = $20 AND t_messages_pkey > $19::int)
				WHEN 'r_last_edited_at' THEN last_edited_at < $20 OR (last_edited_at = $20 AND t_messages_pkey > $19::int)
				ELSE t_messages_pkey > $19::int
			END
		WHEN 'prev' THEN
			CASE $17::text
				WHEN 'posted_at' THEN posted_at < $18 OR (posted_at = $18 AND t_messages_pkey < $19::int)
				WHEN 'r_posted_at' THEN posted_at > $18 OR (posted_at = $18 AND t_messages_pkey < $19::int)
				WHEN 'last_edited_at' THEN last_edited_at < $20 OR (last_edited_at = $20 AND t_messages_pkey < $19::int)
				WHEN 'r_last_edited_at' THEN last_edited_at > $20 OR (last_edited_at = $20 AND t_messages_pkey < $19::int)
				ELSE t_messages_pkey < $19::int
			END
	END
ORDER BY
	CASE WHEN $17::text = 'posted_at' AND $16::text = 'next' THEN posted_at END ASC NULLS LAST,
	CASE WHEN $17::text = 'posted_at' AND $16::text = 'prev' THEN posted_at END DESC NULLS LAST,
	CASE WHEN $17::text = 'r_posted_at' AND $16::text = 'next' THEN posted_at END DESC NULLS LAST,
	CASE WHEN $17::text = 'r_posted_at' AND $16::text = 'prev' THEN posted_at END ASC NULLS LAST,
	CASE WHEN $17::text = 'last_edited_at' AND $16::text = 'next' THEN last_edited_at END ASC NULLS LAST,
	CASE WHEN $17::text = 'last_edited_at' AND $16::text = 'prev' THEN last_edited_at END DESC NULLS LAST,
	CASE WHEN $17::text = 'r_last_edited_at' AND $16::text = 'next' THEN last_edited_at END DESC NULLS LAST,
	CASE WHEN $17::text = 'r_last_edited_at' AND $16::text = 'prev' THEN last_edited_at END ASC NULLS LAST,
	CASE WHEN $16::text = 'next' THEN t_messages_pkey END ASC,
	CASE WHEN $16::text = 'prev' THEN t_messages_pkey END DESC
LIMIT $1
`

type GetMessagesUseKeysetPaginateParams struct {
	Limit                    int32       `json:"limit"`
	WhereInChatRoom          bool        `json:"where_in_chat_room"`
	InChatRoom               []uuid.UUID `json:"in_chat_room"`
	WhereInSender            bool        `json:"where_in_sender"`
	InSender                 []uuid.UUID `json:"in_sender"`
	WhereLikeBody            bool        `json:"where_like_body"`
	SearchBody               string      `json:"search_body"`
	WhereEarlierPostedAt     bool        `json:"where_earlier_posted_at"`
	EarlierPostedAt          time.Time   `json:"earlier_posted_at"`
	WhereLaterPostedAt       bool        `json:"where_later_posted_at"`
	LaterPostedAt            time.Time   `json:"later_posted_at"`
	WhereEarlierLastEditedAt bool        `json:"where_earlier_last_edited_at"`
	EarlierLastEditedAt      time.Time   `json:"earlier_last_edited_at"`
	WhereLaterLastEditedAt   bool        `json:"where_later_last_edited_at"`
	LaterLastEditedAt        time.Time   `json:"later_last_edited_at"`
	CursorDirection          string      `json:"cursor_direction"`
	OrderMethod              string      `json:"order_method"`
	PostedAtCursor           time.Time   `json:"posted_at_cursor"`
	Cursor                   int32       `json:"cursor"`
	LastEditedAtCursor       time.Time   `json:"last_edited_at_cursor"`
}

func (q *Queries) GetMessagesUseKeysetPaginate(ctx context.Context, arg GetMessagesUseKeysetPaginateParams) ([]Message, error) {
	rows, err := q.db.Query(ctx, getMessagesUseKeysetPaginate,
		arg.Limit,
		arg.WhereInChatRoom,
		arg.InChatRoom,
		arg.WhereInSender,
		arg.InSender,
		arg.WhereLikeBody,
		arg.SearchBody,
		arg.WhereEarlierPostedAt,
		arg.EarlierPostedAt,
		arg.WhereLaterPostedAt,
		arg.LaterPostedAt,
		arg.WhereEarlierLastEditedAt,
		arg.EarlierLastEditedAt,
		arg.WhereLaterLastEditedAt,
		arg.LaterLastEditedAt,
		arg.CursorDirection,
		arg.OrderMethod,
		arg.PostedAtCursor,
		arg.Cursor,
		arg.LastEditedAtCursor,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Message{}
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.TMessagesPkey,
			&i.MessageID,
			&i.SenderID,
			&i.Body,
			&i.PostedAt,
			&i.LastEditedAt,
			&i.ChatRoomActionID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMessagesUseNumberedPaginate = `-- name: GetMessagesUseNumberedPaginate :many
SELECT t_messages_pkey, message_id, sender_id, body, posted_at, last_edited_at, chat_room_action_id FROM t_messages
WHERE
	CASE WHEN $3::boolean = true THEN chat_room_id = ANY($4::uuid[]) ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN sender_id = ANY($6::uuid[]) ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN body LIKE '%' || $8::text || '%' ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN posted_at >= $10 ELSE TRUE END
AND
	CASE WHEN $11::boolean = true THEN posted_at <= $12 ELSE TRUE END
AND
	CASE WHEN $13::boolean = true THEN last_edited_at >= $14 ELSE TRUE END
AND
	CASE WHEN $15::boolean = true THEN last_edited_at <= $16 ELSE TRUE END
ORDER BY
	CASE WHEN $17::text = 'posted_at' THEN posted_at END ASC NULLS LAST,
	CASE WHEN $17::text = 'r_posted_at' THEN posted_at END DESC NULLS LAST,
	CASE WHEN $17::text = 'last_edited_at' THEN last_edited_at END ASC NULLS LAST,
	CASE WHEN $17::text = 'r_last_edited_at' THEN last_edited_at END DESC NULLS LAST,
	t_messages_pkey ASC
LIMIT $1 OFFSET $2
`

type GetMessagesUseNumberedPaginateParams struct {
	Limit                    int32       `json:"limit"`
	Offset                   int32       `json:"offset"`
	WhereInChatRoom          bool        `json:"where_in_chat_room"`
	InChatRoom               []uuid.UUID `json:"in_chat_room"`
	WhereInSender            bool        `json:"where_in_sender"`
	InSender                 []uuid.UUID `json:"in_sender"`
	WhereLikeBody            bool        `json:"where_like_body"`
	SearchBody               string      `json:"search_body"`
	WhereEarlierPostedAt     bool        `json:"where_earlier_posted_at"`
	EarlierPostedAt          time.Time   `json:"earlier_posted_at"`
	WhereLaterPostedAt       bool        `json:"where_later_posted_at"`
	LaterPostedAt            time.Time   `json:"later_posted_at"`
	WhereEarlierLastEditedAt bool        `json:"where_earlier_last_edited_at"`
	EarlierLastEditedAt      time.Time   `json:"earlier_last_edited_at"`
	WhereLaterLastEditedAt   bool        `json:"where_later_last_edited_at"`
	LaterLastEditedAt        time.Time   `json:"later_last_edited_at"`
	OrderMethod              string      `json:"order_method"`
}

func (q *Queries) GetMessagesUseNumberedPaginate(ctx context.Context, arg GetMessagesUseNumberedPaginateParams) ([]Message, error) {
	rows, err := q.db.Query(ctx, getMessagesUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.WhereInChatRoom,
		arg.InChatRoom,
		arg.WhereInSender,
		arg.InSender,
		arg.WhereLikeBody,
		arg.SearchBody,
		arg.WhereEarlierPostedAt,
		arg.EarlierPostedAt,
		arg.WhereLaterPostedAt,
		arg.LaterPostedAt,
		arg.WhereEarlierLastEditedAt,
		arg.EarlierLastEditedAt,
		arg.WhereLaterLastEditedAt,
		arg.LaterLastEditedAt,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Message{}
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.TMessagesPkey,
			&i.MessageID,
			&i.SenderID,
			&i.Body,
			&i.PostedAt,
			&i.LastEditedAt,
			&i.ChatRoomActionID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMessagesWithChatRoom = `-- name: GetMessagesWithChatRoom :many
SELECT t_messages.t_messages_pkey, t_messages.message_id, t_messages.sender_id, t_messages.body, t_messages.posted_at, t_messages.last_edited_at, t_messages.chat_room_action_id, m_chat_rooms.chat_room_id, m_chat_rooms.name chat_room_name, m_chat_rooms.is_private chat_room_is_private,
m_chat_rooms.from_organization chat_room_from_organization, m_chat_rooms.owner_id chat_room_owner_id,
m_chat_rooms.cover_image_id chat_room_cover_image_id, t_images.height chat_room_cover_image_height,
t_images.width chat_room_cover_image_width, t_images.attachable_item_id chat_room_cover_image_attachable_item_id,
t_attachable_items.owner_id chat_room_cover_image_owner_id, t_attachable_items.from_outer chat_room_cover_image_from_outer, t_attachable_items.alias chat_room_cover_image_alias,
t_attachable_items.url chat_room_cover_image_url, t_attachable_items.size chat_room_cover_image_size, t_attachable_items.mime_type_id chat_room_cover_image_mime_type_id FROM t_messages
LEFT JOIN t_chat_room_actions ON t_messages.chat_room_action_id = t_chat_room_actions.chat_room_action_id
LEFT JOIN m_chat_rooms ON t_messages.chat_room_id = m_chat_rooms.chat_room_id
LEFT JOIN t_images ON m_chat_rooms.cover_image_id = t_images.image_id
LEFT JOIN t_attachable_items ON t_images.attachable_item_id = t_attachable_items.attachable_item_id
WHERE
	CASE WHEN $1::boolean = true THEN t_chat_room_actions in (SELECT chat_room_action_id FROM t_chat_room_actions WHERE chat_room_id = ANY($2::uuid[])) ELSE TRUE END
AND
	CASE WHEN $3::boolean = true THEN sender_id = ANY($4::uuid[]) ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN body LIKE '%' || $6::text || '%' ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN posted_at >= $8 ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN posted_at <= $10 ELSE TRUE END
AND
	CASE WHEN $11::boolean = true THEN last_edited_at >= $12 ELSE TRUE END
AND
	CASE WHEN $13::boolean = true THEN last_edited_at <= $14 ELSE TRUE END
ORDER BY
	CASE WHEN $15::text = 'posted_at' THEN posted_at END ASC NULLS LAST,
	CASE WHEN $15::text = 'r_posted_at' THEN posted_at END DESC NULLS LAST,
	CASE WHEN $15::text = 'last_edited_at' THEN last_edited_at END ASC NULLS LAST,
	CASE WHEN $15::text = 'r_last_edited_at' THEN last_edited_at END DESC NULLS LAST,
	t_messages_pkey ASC
`

type GetMessagesWithChatRoomParams struct {
	WhereInChatRoom          bool        `json:"where_in_chat_room"`
	InChatRoom               []uuid.UUID `json:"in_chat_room"`
	WhereInSender            bool        `json:"where_in_sender"`
	InSender                 []uuid.UUID `json:"in_sender"`
	WhereLikeBody            bool        `json:"where_like_body"`
	SearchBody               string      `json:"search_body"`
	WhereEarlierPostedAt     bool        `json:"where_earlier_posted_at"`
	EarlierPostedAt          time.Time   `json:"earlier_posted_at"`
	WhereLaterPostedAt       bool        `json:"where_later_posted_at"`
	LaterPostedAt            time.Time   `json:"later_posted_at"`
	WhereEarlierLastEditedAt bool        `json:"where_earlier_last_edited_at"`
	EarlierLastEditedAt      time.Time   `json:"earlier_last_edited_at"`
	WhereLaterLastEditedAt   bool        `json:"where_later_last_edited_at"`
	LaterLastEditedAt        time.Time   `json:"later_last_edited_at"`
	OrderMethod              string      `json:"order_method"`
}

type GetMessagesWithChatRoomRow struct {
	TMessagesPkey                      pgtype.Int8   `json:"t_messages_pkey"`
	MessageID                          uuid.UUID     `json:"message_id"`
	SenderID                           pgtype.UUID   `json:"sender_id"`
	Body                               string        `json:"body"`
	PostedAt                           time.Time     `json:"posted_at"`
	LastEditedAt                       time.Time     `json:"last_edited_at"`
	ChatRoomActionID                   uuid.UUID     `json:"chat_room_action_id"`
	ChatRoomID                         pgtype.UUID   `json:"chat_room_id"`
	ChatRoomName                       pgtype.Text   `json:"chat_room_name"`
	ChatRoomIsPrivate                  pgtype.Bool   `json:"chat_room_is_private"`
	ChatRoomFromOrganization           pgtype.Bool   `json:"chat_room_from_organization"`
	ChatRoomOwnerID                    pgtype.UUID   `json:"chat_room_owner_id"`
	ChatRoomCoverImageID               pgtype.UUID   `json:"chat_room_cover_image_id"`
	ChatRoomCoverImageHeight           pgtype.Float8 `json:"chat_room_cover_image_height"`
	ChatRoomCoverImageWidth            pgtype.Float8 `json:"chat_room_cover_image_width"`
	ChatRoomCoverImageAttachableItemID pgtype.UUID   `json:"chat_room_cover_image_attachable_item_id"`
	ChatRoomCoverImageOwnerID          pgtype.UUID   `json:"chat_room_cover_image_owner_id"`
	ChatRoomCoverImageFromOuter        pgtype.Bool   `json:"chat_room_cover_image_from_outer"`
	ChatRoomCoverImageAlias            pgtype.Text   `json:"chat_room_cover_image_alias"`
	ChatRoomCoverImageUrl              pgtype.Text   `json:"chat_room_cover_image_url"`
	ChatRoomCoverImageSize             pgtype.Float8 `json:"chat_room_cover_image_size"`
	ChatRoomCoverImageMimeTypeID       pgtype.UUID   `json:"chat_room_cover_image_mime_type_id"`
}

func (q *Queries) GetMessagesWithChatRoom(ctx context.Context, arg GetMessagesWithChatRoomParams) ([]GetMessagesWithChatRoomRow, error) {
	rows, err := q.db.Query(ctx, getMessagesWithChatRoom,
		arg.WhereInChatRoom,
		arg.InChatRoom,
		arg.WhereInSender,
		arg.InSender,
		arg.WhereLikeBody,
		arg.SearchBody,
		arg.WhereEarlierPostedAt,
		arg.EarlierPostedAt,
		arg.WhereLaterPostedAt,
		arg.LaterPostedAt,
		arg.WhereEarlierLastEditedAt,
		arg.EarlierLastEditedAt,
		arg.WhereLaterLastEditedAt,
		arg.LaterLastEditedAt,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMessagesWithChatRoomRow{}
	for rows.Next() {
		var i GetMessagesWithChatRoomRow
		if err := rows.Scan(
			&i.TMessagesPkey,
			&i.MessageID,
			&i.SenderID,
			&i.Body,
			&i.PostedAt,
			&i.LastEditedAt,
			&i.ChatRoomActionID,
			&i.ChatRoomID,
			&i.ChatRoomName,
			&i.ChatRoomIsPrivate,
			&i.ChatRoomFromOrganization,
			&i.ChatRoomOwnerID,
			&i.ChatRoomCoverImageID,
			&i.ChatRoomCoverImageHeight,
			&i.ChatRoomCoverImageWidth,
			&i.ChatRoomCoverImageAttachableItemID,
			&i.ChatRoomCoverImageOwnerID,
			&i.ChatRoomCoverImageFromOuter,
			&i.ChatRoomCoverImageAlias,
			&i.ChatRoomCoverImageUrl,
			&i.ChatRoomCoverImageSize,
			&i.ChatRoomCoverImageMimeTypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMessagesWithChatRoomUseKeysetPaginate = `-- name: GetMessagesWithChatRoomUseKeysetPaginate :many
SELECT t_messages.t_messages_pkey, t_messages.message_id, t_messages.sender_id, t_messages.body, t_messages.posted_at, t_messages.last_edited_at, t_messages.chat_room_action_id, m_chat_rooms.chat_room_id, m_chat_rooms.name chat_room_name, m_chat_rooms.is_private chat_room_is_private,
m_chat_rooms.from_organization chat_room_from_organization, m_chat_rooms.owner_id chat_room_owner_id,
m_chat_rooms.cover_image_id chat_room_cover_image_id, t_images.height chat_room_cover_image_height,
t_images.width chat_room_cover_image_width, t_images.attachable_item_id chat_room_cover_image_attachable_item_id,
t_attachable_items.owner_id chat_room_cover_image_owner_id, t_attachable_items.from_outer chat_room_cover_image_from_outer, t_attachable_items.alias chat_room_cover_image_alias,
t_attachable_items.url chat_room_cover_image_url, t_attachable_items.size chat_room_cover_image_size, t_attachable_items.mime_type_id chat_room_cover_image_mime_type_id FROM t_messages
LEFT JOIN t_chat_room_actions ON t_messages.chat_room_action_id = t_chat_room_actions.chat_room_action_id
LEFT JOIN m_chat_rooms ON t_messages.chat_room_id = m_chat_rooms.chat_room_id
LEFT JOIN t_images ON m_chat_rooms.cover_image_id = t_images.image_id
LEFT JOIN t_attachable_items ON t_images.attachable_item_id = t_attachable_items.attachable_item_id
WHERE
	CASE WHEN $2::boolean = true THEN t_chat_room_actions in (SELECT chat_room_action_id FROM t_chat_room_actions WHERE chat_room_id = ANY($3::uuid[])) ELSE TRUE END
AND
	CASE WHEN $4::boolean = true THEN sender_id = ANY($5::uuid[]) ELSE TRUE END
AND
	CASE WHEN $6::boolean = true THEN body LIKE '%' || $7::text || '%' ELSE TRUE END
AND
	CASE WHEN $8::boolean = true THEN posted_at >= $9 ELSE TRUE END
AND
	CASE WHEN $10::boolean = true THEN posted_at <= $11 ELSE TRUE END
AND
	CASE WHEN $12::boolean = true THEN last_edited_at >= $13 ELSE TRUE END
AND
	CASE WHEN $14::boolean = true THEN last_edited_at <= $15 ELSE TRUE END
AND
	CASE $16::text
		WHEN 'next' THEN
			CASE $17::text
				WHEN 'posted_at' THEN posted_at > $18 OR (posted_at = $18 AND t_messages_pkey > $19::int)
				WHEN 'r_posted_at' THEN posted_at < $18 OR (posted_at = $18 AND t_messages_pkey > $19::int)
				WHEN 'last_edited_at' THEN last_edited_at > $20 OR (last_edited_at = $20 AND t_messages_pkey > $19::int)
				WHEN 'r_last_edited_at' THEN last_edited_at < $20 OR (last_edited_at = $20 AND t_messages_pkey > $19::int)
				ELSE t_messages_pkey > $19::int
			END
		WHEN 'prev' THEN
			CASE $17::text
				WHEN 'posted_at' THEN posted_at < $18 OR (posted_at = $18 AND t_messages_pkey < $19::int)
				WHEN 'r_posted_at' THEN posted_at > $18 OR (posted_at = $18 AND t_messages_pkey < $19::int)
				WHEN 'last_edited_at' THEN last_edited_at < $20 OR (last_edited_at = $20 AND t_messages_pkey < $19::int)
				WHEN 'r_last_edited_at' THEN last_edited_at > $20 OR (last_edited_at = $20 AND t_messages_pkey < $19::int)
				ELSE t_messages_pkey < $19::int
			END
	END
ORDER BY
	CASE WHEN $17::text = 'posted_at' AND $16::text = 'next' THEN posted_at END ASC NULLS LAST,
	CASE WHEN $17::text = 'posted_at' AND $16::text = 'prev' THEN posted_at END DESC NULLS LAST,
	CASE WHEN $17::text = 'r_posted_at' AND $16::text = 'next' THEN posted_at END DESC NULLS LAST,
	CASE WHEN $17::text = 'r_posted_at' AND $16::text = 'prev' THEN posted_at END ASC NULLS LAST,
	CASE WHEN $17::text = 'last_edited_at' AND $16::text = 'next' THEN last_edited_at END ASC NULLS LAST,
	CASE WHEN $17::text = 'last_edited_at' AND $16::text = 'prev' THEN last_edited_at END DESC NULLS LAST,
	CASE WHEN $17::text = 'r_last_edited_at' AND $16::text = 'next' THEN last_edited_at END DESC NULLS LAST,
	CASE WHEN $17::text = 'r_last_edited_at' AND $16::text = 'prev' THEN last_edited_at END ASC NULLS LAST,
	CASE WHEN $16::text = 'next' THEN t_messages_pkey END ASC,
	CASE WHEN $16::text = 'prev' THEN t_messages_pkey END DESC
LIMIT $1
`

type GetMessagesWithChatRoomUseKeysetPaginateParams struct {
	Limit                    int32       `json:"limit"`
	WhereInChatRoom          bool        `json:"where_in_chat_room"`
	InChatRoom               []uuid.UUID `json:"in_chat_room"`
	WhereInSender            bool        `json:"where_in_sender"`
	InSender                 []uuid.UUID `json:"in_sender"`
	WhereLikeBody            bool        `json:"where_like_body"`
	SearchBody               string      `json:"search_body"`
	WhereEarlierPostedAt     bool        `json:"where_earlier_posted_at"`
	EarlierPostedAt          time.Time   `json:"earlier_posted_at"`
	WhereLaterPostedAt       bool        `json:"where_later_posted_at"`
	LaterPostedAt            time.Time   `json:"later_posted_at"`
	WhereEarlierLastEditedAt bool        `json:"where_earlier_last_edited_at"`
	EarlierLastEditedAt      time.Time   `json:"earlier_last_edited_at"`
	WhereLaterLastEditedAt   bool        `json:"where_later_last_edited_at"`
	LaterLastEditedAt        time.Time   `json:"later_last_edited_at"`
	CursorDirection          string      `json:"cursor_direction"`
	OrderMethod              string      `json:"order_method"`
	PostedAtCursor           time.Time   `json:"posted_at_cursor"`
	Cursor                   int32       `json:"cursor"`
	LastEditedAtCursor       time.Time   `json:"last_edited_at_cursor"`
}

type GetMessagesWithChatRoomUseKeysetPaginateRow struct {
	TMessagesPkey                      pgtype.Int8   `json:"t_messages_pkey"`
	MessageID                          uuid.UUID     `json:"message_id"`
	SenderID                           pgtype.UUID   `json:"sender_id"`
	Body                               string        `json:"body"`
	PostedAt                           time.Time     `json:"posted_at"`
	LastEditedAt                       time.Time     `json:"last_edited_at"`
	ChatRoomActionID                   uuid.UUID     `json:"chat_room_action_id"`
	ChatRoomID                         pgtype.UUID   `json:"chat_room_id"`
	ChatRoomName                       pgtype.Text   `json:"chat_room_name"`
	ChatRoomIsPrivate                  pgtype.Bool   `json:"chat_room_is_private"`
	ChatRoomFromOrganization           pgtype.Bool   `json:"chat_room_from_organization"`
	ChatRoomOwnerID                    pgtype.UUID   `json:"chat_room_owner_id"`
	ChatRoomCoverImageID               pgtype.UUID   `json:"chat_room_cover_image_id"`
	ChatRoomCoverImageHeight           pgtype.Float8 `json:"chat_room_cover_image_height"`
	ChatRoomCoverImageWidth            pgtype.Float8 `json:"chat_room_cover_image_width"`
	ChatRoomCoverImageAttachableItemID pgtype.UUID   `json:"chat_room_cover_image_attachable_item_id"`
	ChatRoomCoverImageOwnerID          pgtype.UUID   `json:"chat_room_cover_image_owner_id"`
	ChatRoomCoverImageFromOuter        pgtype.Bool   `json:"chat_room_cover_image_from_outer"`
	ChatRoomCoverImageAlias            pgtype.Text   `json:"chat_room_cover_image_alias"`
	ChatRoomCoverImageUrl              pgtype.Text   `json:"chat_room_cover_image_url"`
	ChatRoomCoverImageSize             pgtype.Float8 `json:"chat_room_cover_image_size"`
	ChatRoomCoverImageMimeTypeID       pgtype.UUID   `json:"chat_room_cover_image_mime_type_id"`
}

func (q *Queries) GetMessagesWithChatRoomUseKeysetPaginate(ctx context.Context, arg GetMessagesWithChatRoomUseKeysetPaginateParams) ([]GetMessagesWithChatRoomUseKeysetPaginateRow, error) {
	rows, err := q.db.Query(ctx, getMessagesWithChatRoomUseKeysetPaginate,
		arg.Limit,
		arg.WhereInChatRoom,
		arg.InChatRoom,
		arg.WhereInSender,
		arg.InSender,
		arg.WhereLikeBody,
		arg.SearchBody,
		arg.WhereEarlierPostedAt,
		arg.EarlierPostedAt,
		arg.WhereLaterPostedAt,
		arg.LaterPostedAt,
		arg.WhereEarlierLastEditedAt,
		arg.EarlierLastEditedAt,
		arg.WhereLaterLastEditedAt,
		arg.LaterLastEditedAt,
		arg.CursorDirection,
		arg.OrderMethod,
		arg.PostedAtCursor,
		arg.Cursor,
		arg.LastEditedAtCursor,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMessagesWithChatRoomUseKeysetPaginateRow{}
	for rows.Next() {
		var i GetMessagesWithChatRoomUseKeysetPaginateRow
		if err := rows.Scan(
			&i.TMessagesPkey,
			&i.MessageID,
			&i.SenderID,
			&i.Body,
			&i.PostedAt,
			&i.LastEditedAt,
			&i.ChatRoomActionID,
			&i.ChatRoomID,
			&i.ChatRoomName,
			&i.ChatRoomIsPrivate,
			&i.ChatRoomFromOrganization,
			&i.ChatRoomOwnerID,
			&i.ChatRoomCoverImageID,
			&i.ChatRoomCoverImageHeight,
			&i.ChatRoomCoverImageWidth,
			&i.ChatRoomCoverImageAttachableItemID,
			&i.ChatRoomCoverImageOwnerID,
			&i.ChatRoomCoverImageFromOuter,
			&i.ChatRoomCoverImageAlias,
			&i.ChatRoomCoverImageUrl,
			&i.ChatRoomCoverImageSize,
			&i.ChatRoomCoverImageMimeTypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMessagesWithChatRoomUseNumberedPaginate = `-- name: GetMessagesWithChatRoomUseNumberedPaginate :many
SELECT t_messages.t_messages_pkey, t_messages.message_id, t_messages.sender_id, t_messages.body, t_messages.posted_at, t_messages.last_edited_at, t_messages.chat_room_action_id, m_chat_rooms.chat_room_id, m_chat_rooms.name chat_room_name, m_chat_rooms.is_private chat_room_is_private,
m_chat_rooms.from_organization chat_room_from_organization, m_chat_rooms.owner_id chat_room_owner_id,
m_chat_rooms.cover_image_id chat_room_cover_image_id, t_images.height chat_room_cover_image_height,
t_images.width chat_room_cover_image_width, t_images.attachable_item_id chat_room_cover_image_attachable_item_id,
t_attachable_items.owner_id chat_room_cover_image_owner_id, t_attachable_items.from_outer chat_room_cover_image_from_outer, t_attachable_items.alias chat_room_cover_image_alias,
t_attachable_items.url chat_room_cover_image_url, t_attachable_items.size chat_room_cover_image_size, t_attachable_items.mime_type_id chat_room_cover_image_mime_type_id FROM t_messages
LEFT JOIN t_chat_room_actions ON t_messages.chat_room_action_id = t_chat_room_actions.chat_room_action_id
LEFT JOIN m_chat_rooms ON t_messages.chat_room_id = m_chat_rooms.chat_room_id
LEFT JOIN t_images ON m_chat_rooms.cover_image_id = t_images.image_id
LEFT JOIN t_attachable_items ON t_images.attachable_item_id = t_attachable_items.attachable_item_id
WHERE
	CASE WHEN $3::boolean = true THEN t_chat_room_actions in (SELECT chat_room_action_id FROM t_chat_room_actions WHERE chat_room_id = ANY($4::uuid[])) ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN sender_id = ANY($6::uuid[]) ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN body LIKE '%' || $8::text || '%' ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN posted_at >= $10 ELSE TRUE END
AND
	CASE WHEN $11::boolean = true THEN posted_at <= $12 ELSE TRUE END
AND
	CASE WHEN $13::boolean = true THEN last_edited_at >= $14 ELSE TRUE END
AND
	CASE WHEN $15::boolean = true THEN last_edited_at <= $16 ELSE TRUE END
ORDER BY
	CASE WHEN $17::text = 'posted_at' THEN posted_at END ASC NULLS LAST,
	CASE WHEN $17::text = 'r_posted_at' THEN posted_at END DESC NULLS LAST,
	CASE WHEN $17::text = 'last_edited_at' THEN last_edited_at END ASC NULLS LAST,
	CASE WHEN $17::text = 'r_last_edited_at' THEN last_edited_at END DESC NULLS LAST,
	t_messages_pkey ASC
LIMIT $1 OFFSET $2
`

type GetMessagesWithChatRoomUseNumberedPaginateParams struct {
	Limit                    int32       `json:"limit"`
	Offset                   int32       `json:"offset"`
	WhereInChatRoom          bool        `json:"where_in_chat_room"`
	InChatRoom               []uuid.UUID `json:"in_chat_room"`
	WhereInSender            bool        `json:"where_in_sender"`
	InSender                 []uuid.UUID `json:"in_sender"`
	WhereLikeBody            bool        `json:"where_like_body"`
	SearchBody               string      `json:"search_body"`
	WhereEarlierPostedAt     bool        `json:"where_earlier_posted_at"`
	EarlierPostedAt          time.Time   `json:"earlier_posted_at"`
	WhereLaterPostedAt       bool        `json:"where_later_posted_at"`
	LaterPostedAt            time.Time   `json:"later_posted_at"`
	WhereEarlierLastEditedAt bool        `json:"where_earlier_last_edited_at"`
	EarlierLastEditedAt      time.Time   `json:"earlier_last_edited_at"`
	WhereLaterLastEditedAt   bool        `json:"where_later_last_edited_at"`
	LaterLastEditedAt        time.Time   `json:"later_last_edited_at"`
	OrderMethod              string      `json:"order_method"`
}

type GetMessagesWithChatRoomUseNumberedPaginateRow struct {
	TMessagesPkey                      pgtype.Int8   `json:"t_messages_pkey"`
	MessageID                          uuid.UUID     `json:"message_id"`
	SenderID                           pgtype.UUID   `json:"sender_id"`
	Body                               string        `json:"body"`
	PostedAt                           time.Time     `json:"posted_at"`
	LastEditedAt                       time.Time     `json:"last_edited_at"`
	ChatRoomActionID                   uuid.UUID     `json:"chat_room_action_id"`
	ChatRoomID                         pgtype.UUID   `json:"chat_room_id"`
	ChatRoomName                       pgtype.Text   `json:"chat_room_name"`
	ChatRoomIsPrivate                  pgtype.Bool   `json:"chat_room_is_private"`
	ChatRoomFromOrganization           pgtype.Bool   `json:"chat_room_from_organization"`
	ChatRoomOwnerID                    pgtype.UUID   `json:"chat_room_owner_id"`
	ChatRoomCoverImageID               pgtype.UUID   `json:"chat_room_cover_image_id"`
	ChatRoomCoverImageHeight           pgtype.Float8 `json:"chat_room_cover_image_height"`
	ChatRoomCoverImageWidth            pgtype.Float8 `json:"chat_room_cover_image_width"`
	ChatRoomCoverImageAttachableItemID pgtype.UUID   `json:"chat_room_cover_image_attachable_item_id"`
	ChatRoomCoverImageOwnerID          pgtype.UUID   `json:"chat_room_cover_image_owner_id"`
	ChatRoomCoverImageFromOuter        pgtype.Bool   `json:"chat_room_cover_image_from_outer"`
	ChatRoomCoverImageAlias            pgtype.Text   `json:"chat_room_cover_image_alias"`
	ChatRoomCoverImageUrl              pgtype.Text   `json:"chat_room_cover_image_url"`
	ChatRoomCoverImageSize             pgtype.Float8 `json:"chat_room_cover_image_size"`
	ChatRoomCoverImageMimeTypeID       pgtype.UUID   `json:"chat_room_cover_image_mime_type_id"`
}

func (q *Queries) GetMessagesWithChatRoomUseNumberedPaginate(ctx context.Context, arg GetMessagesWithChatRoomUseNumberedPaginateParams) ([]GetMessagesWithChatRoomUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getMessagesWithChatRoomUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.WhereInChatRoom,
		arg.InChatRoom,
		arg.WhereInSender,
		arg.InSender,
		arg.WhereLikeBody,
		arg.SearchBody,
		arg.WhereEarlierPostedAt,
		arg.EarlierPostedAt,
		arg.WhereLaterPostedAt,
		arg.LaterPostedAt,
		arg.WhereEarlierLastEditedAt,
		arg.EarlierLastEditedAt,
		arg.WhereLaterLastEditedAt,
		arg.LaterLastEditedAt,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMessagesWithChatRoomUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetMessagesWithChatRoomUseNumberedPaginateRow
		if err := rows.Scan(
			&i.TMessagesPkey,
			&i.MessageID,
			&i.SenderID,
			&i.Body,
			&i.PostedAt,
			&i.LastEditedAt,
			&i.ChatRoomActionID,
			&i.ChatRoomID,
			&i.ChatRoomName,
			&i.ChatRoomIsPrivate,
			&i.ChatRoomFromOrganization,
			&i.ChatRoomOwnerID,
			&i.ChatRoomCoverImageID,
			&i.ChatRoomCoverImageHeight,
			&i.ChatRoomCoverImageWidth,
			&i.ChatRoomCoverImageAttachableItemID,
			&i.ChatRoomCoverImageOwnerID,
			&i.ChatRoomCoverImageFromOuter,
			&i.ChatRoomCoverImageAlias,
			&i.ChatRoomCoverImageUrl,
			&i.ChatRoomCoverImageSize,
			&i.ChatRoomCoverImageMimeTypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMessagesWithSender = `-- name: GetMessagesWithSender :many
SELECT t_messages.t_messages_pkey, t_messages.message_id, t_messages.sender_id, t_messages.body, t_messages.posted_at, t_messages.last_edited_at, t_messages.chat_room_action_id, m_members.name member_name, m_members.first_name member_first_name, m_members.last_name member_last_name, m_members.email member_email,
m_members.profile_image_id member_profile_image_id, t_images.height member_profile_image_height,
t_images.width member_profile_image_width, t_images.attachable_item_id member_profile_image_attachable_item_id,
t_attachable_items.owner_id member_profile_image_owner_id, t_attachable_items.from_outer member_profile_image_from_outer, t_attachable_items.alias member_profile_image_alias,
t_attachable_items.url member_profile_image_url, t_attachable_items.size member_profile_image_size, t_attachable_items.mime_type_id member_profile_image_mime_type_id FROM t_messages
LEFT JOIN m_members ON t_messages.sender_id = m_members.member_id
LEFT JOIN t_images ON m_members.profile_image_id = t_images.image_id
LEFT JOIN t_attachable_items ON t_images.attachable_item_id = t_attachable_items.attachable_item_id
WHERE
	CASE WHEN $1::boolean = true THEN t_chat_room_actions in (SELECT chat_room_action_id FROM t_chat_room_actions WHERE chat_room_id = ANY($2::uuid[])) ELSE TRUE END
AND
	CASE WHEN $3::boolean = true THEN sender_id = ANY($4::uuid[]) ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN body LIKE '%' || $6::text || '%' ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN posted_at >= $8 ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN posted_at <= $10 ELSE TRUE END
AND
	CASE WHEN $11::boolean = true THEN last_edited_at >= $12 ELSE TRUE END
AND
	CASE WHEN $13::boolean = true THEN last_edited_at <= $14 ELSE TRUE END
ORDER BY
	CASE WHEN $15::text = 'posted_at' THEN posted_at END ASC NULLS LAST,
	CASE WHEN $15::text = 'r_posted_at' THEN posted_at END DESC NULLS LAST,
	CASE WHEN $15::text = 'last_edited_at' THEN last_edited_at END ASC NULLS LAST,
	CASE WHEN $15::text = 'r_last_edited_at' THEN last_edited_at END DESC NULLS LAST,
	t_messages_pkey ASC
`

type GetMessagesWithSenderParams struct {
	WhereInChatRoom          bool        `json:"where_in_chat_room"`
	InChatRoom               []uuid.UUID `json:"in_chat_room"`
	WhereInSender            bool        `json:"where_in_sender"`
	InSender                 []uuid.UUID `json:"in_sender"`
	WhereLikeBody            bool        `json:"where_like_body"`
	SearchBody               string      `json:"search_body"`
	WhereEarlierPostedAt     bool        `json:"where_earlier_posted_at"`
	EarlierPostedAt          time.Time   `json:"earlier_posted_at"`
	WhereLaterPostedAt       bool        `json:"where_later_posted_at"`
	LaterPostedAt            time.Time   `json:"later_posted_at"`
	WhereEarlierLastEditedAt bool        `json:"where_earlier_last_edited_at"`
	EarlierLastEditedAt      time.Time   `json:"earlier_last_edited_at"`
	WhereLaterLastEditedAt   bool        `json:"where_later_last_edited_at"`
	LaterLastEditedAt        time.Time   `json:"later_last_edited_at"`
	OrderMethod              string      `json:"order_method"`
}

type GetMessagesWithSenderRow struct {
	TMessagesPkey                      pgtype.Int8   `json:"t_messages_pkey"`
	MessageID                          uuid.UUID     `json:"message_id"`
	SenderID                           pgtype.UUID   `json:"sender_id"`
	Body                               string        `json:"body"`
	PostedAt                           time.Time     `json:"posted_at"`
	LastEditedAt                       time.Time     `json:"last_edited_at"`
	ChatRoomActionID                   uuid.UUID     `json:"chat_room_action_id"`
	MemberName                         pgtype.Text   `json:"member_name"`
	MemberFirstName                    pgtype.Text   `json:"member_first_name"`
	MemberLastName                     pgtype.Text   `json:"member_last_name"`
	MemberEmail                        pgtype.Text   `json:"member_email"`
	MemberProfileImageID               pgtype.UUID   `json:"member_profile_image_id"`
	MemberProfileImageHeight           pgtype.Float8 `json:"member_profile_image_height"`
	MemberProfileImageWidth            pgtype.Float8 `json:"member_profile_image_width"`
	MemberProfileImageAttachableItemID pgtype.UUID   `json:"member_profile_image_attachable_item_id"`
	MemberProfileImageOwnerID          pgtype.UUID   `json:"member_profile_image_owner_id"`
	MemberProfileImageFromOuter        pgtype.Bool   `json:"member_profile_image_from_outer"`
	MemberProfileImageAlias            pgtype.Text   `json:"member_profile_image_alias"`
	MemberProfileImageUrl              pgtype.Text   `json:"member_profile_image_url"`
	MemberProfileImageSize             pgtype.Float8 `json:"member_profile_image_size"`
	MemberProfileImageMimeTypeID       pgtype.UUID   `json:"member_profile_image_mime_type_id"`
}

func (q *Queries) GetMessagesWithSender(ctx context.Context, arg GetMessagesWithSenderParams) ([]GetMessagesWithSenderRow, error) {
	rows, err := q.db.Query(ctx, getMessagesWithSender,
		arg.WhereInChatRoom,
		arg.InChatRoom,
		arg.WhereInSender,
		arg.InSender,
		arg.WhereLikeBody,
		arg.SearchBody,
		arg.WhereEarlierPostedAt,
		arg.EarlierPostedAt,
		arg.WhereLaterPostedAt,
		arg.LaterPostedAt,
		arg.WhereEarlierLastEditedAt,
		arg.EarlierLastEditedAt,
		arg.WhereLaterLastEditedAt,
		arg.LaterLastEditedAt,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMessagesWithSenderRow{}
	for rows.Next() {
		var i GetMessagesWithSenderRow
		if err := rows.Scan(
			&i.TMessagesPkey,
			&i.MessageID,
			&i.SenderID,
			&i.Body,
			&i.PostedAt,
			&i.LastEditedAt,
			&i.ChatRoomActionID,
			&i.MemberName,
			&i.MemberFirstName,
			&i.MemberLastName,
			&i.MemberEmail,
			&i.MemberProfileImageID,
			&i.MemberProfileImageHeight,
			&i.MemberProfileImageWidth,
			&i.MemberProfileImageAttachableItemID,
			&i.MemberProfileImageOwnerID,
			&i.MemberProfileImageFromOuter,
			&i.MemberProfileImageAlias,
			&i.MemberProfileImageUrl,
			&i.MemberProfileImageSize,
			&i.MemberProfileImageMimeTypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMessagesWithSenderUseKeysetPaginate = `-- name: GetMessagesWithSenderUseKeysetPaginate :many
SELECT t_messages.t_messages_pkey, t_messages.message_id, t_messages.sender_id, t_messages.body, t_messages.posted_at, t_messages.last_edited_at, t_messages.chat_room_action_id, m_members.name member_name, m_members.first_name member_first_name, m_members.last_name member_last_name, m_members.email member_email,
m_members.profile_image_id member_profile_image_id, t_images.height member_profile_image_height,
t_images.width member_profile_image_width, t_images.attachable_item_id member_profile_image_attachable_item_id,
t_attachable_items.owner_id member_profile_image_owner_id, t_attachable_items.from_outer member_profile_image_from_outer, t_attachable_items.alias member_profile_image_alias,
t_attachable_items.url member_profile_image_url, t_attachable_items.size member_profile_image_size, t_attachable_items.mime_type_id member_profile_image_mime_type_id FROM t_messages
LEFT JOIN m_members ON t_messages.sender_id = m_members.member_id
LEFT JOIN t_images ON m_members.profile_image_id = t_images.image_id
LEFT JOIN t_attachable_items ON t_images.attachable_item_id = t_attachable_items.attachable_item_id
WHERE
	CASE WHEN $2::boolean = true THEN t_chat_room_actions in (SELECT chat_room_action_id FROM t_chat_room_actions WHERE chat_room_id = ANY($3::uuid[])) ELSE TRUE END
AND
	CASE WHEN $4::boolean = true THEN sender_id = ANY($5::uuid[]) ELSE TRUE END
AND
	CASE WHEN $6::boolean = true THEN body LIKE '%' || $7::text || '%' ELSE TRUE END
AND
	CASE WHEN $8::boolean = true THEN posted_at >= $9 ELSE TRUE END
AND
	CASE WHEN $10::boolean = true THEN posted_at <= $11 ELSE TRUE END
AND
	CASE WHEN $12::boolean = true THEN last_edited_at >= $13 ELSE TRUE END
AND
	CASE WHEN $14::boolean = true THEN last_edited_at <= $15 ELSE TRUE END
AND
	CASE $16::text
		WHEN 'next' THEN
			CASE $17::text
				WHEN 'posted_at' THEN posted_at > $18 OR (posted_at = $18 AND t_messages_pkey > $19::int)
				WHEN 'r_posted_at' THEN posted_at < $18 OR (posted_at = $18 AND t_messages_pkey > $19::int)
				WHEN 'last_edited_at' THEN last_edited_at > $20 OR (last_edited_at = $20 AND t_messages_pkey > $19::int)
				WHEN 'r_last_edited_at' THEN last_edited_at < $20 OR (last_edited_at = $20 AND t_messages_pkey > $19::int)
				ELSE t_messages_pkey > $19::int
			END
		WHEN 'prev' THEN
			CASE $17::text
				WHEN 'posted_at' THEN posted_at < $18 OR (posted_at = $18 AND t_messages_pkey < $19::int)
				WHEN 'r_posted_at' THEN posted_at > $18 OR (posted_at = $18 AND t_messages_pkey < $19::int)
				WHEN 'last_edited_at' THEN last_edited_at < $20 OR (last_edited_at = $20 AND t_messages_pkey < $19::int)
				WHEN 'r_last_edited_at' THEN last_edited_at > $20 OR (last_edited_at = $20 AND t_messages_pkey < $19::int)
				ELSE t_messages_pkey < $19::int
			END
	END
ORDER BY
	CASE WHEN $17::text = 'posted_at' AND $16::text = 'next' THEN posted_at END ASC NULLS LAST,
	CASE WHEN $17::text = 'posted_at' AND $16::text = 'prev' THEN posted_at END DESC NULLS LAST,
	CASE WHEN $17::text = 'r_posted_at' AND $16::text = 'next' THEN posted_at END DESC NULLS LAST,
	CASE WHEN $17::text = 'r_posted_at' AND $16::text = 'prev' THEN posted_at END ASC NULLS LAST,
	CASE WHEN $17::text = 'last_edited_at' AND $16::text = 'next' THEN last_edited_at END ASC NULLS LAST,
	CASE WHEN $17::text = 'last_edited_at' AND $16::text = 'prev' THEN last_edited_at END DESC NULLS LAST,
	CASE WHEN $17::text = 'r_last_edited_at' AND $16::text = 'next' THEN last_edited_at END DESC NULLS LAST,
	CASE WHEN $17::text = 'r_last_edited_at' AND $16::text = 'prev' THEN last_edited_at END ASC NULLS LAST,
	CASE WHEN $16::text = 'next' THEN t_messages_pkey END ASC,
	CASE WHEN $16::text = 'prev' THEN t_messages_pkey END DESC
LIMIT $1
`

type GetMessagesWithSenderUseKeysetPaginateParams struct {
	Limit                    int32       `json:"limit"`
	WhereInChatRoom          bool        `json:"where_in_chat_room"`
	InChatRoom               []uuid.UUID `json:"in_chat_room"`
	WhereInSender            bool        `json:"where_in_sender"`
	InSender                 []uuid.UUID `json:"in_sender"`
	WhereLikeBody            bool        `json:"where_like_body"`
	SearchBody               string      `json:"search_body"`
	WhereEarlierPostedAt     bool        `json:"where_earlier_posted_at"`
	EarlierPostedAt          time.Time   `json:"earlier_posted_at"`
	WhereLaterPostedAt       bool        `json:"where_later_posted_at"`
	LaterPostedAt            time.Time   `json:"later_posted_at"`
	WhereEarlierLastEditedAt bool        `json:"where_earlier_last_edited_at"`
	EarlierLastEditedAt      time.Time   `json:"earlier_last_edited_at"`
	WhereLaterLastEditedAt   bool        `json:"where_later_last_edited_at"`
	LaterLastEditedAt        time.Time   `json:"later_last_edited_at"`
	CursorDirection          string      `json:"cursor_direction"`
	OrderMethod              string      `json:"order_method"`
	PostedAtCursor           time.Time   `json:"posted_at_cursor"`
	Cursor                   int32       `json:"cursor"`
	LastEditedAtCursor       time.Time   `json:"last_edited_at_cursor"`
}

type GetMessagesWithSenderUseKeysetPaginateRow struct {
	TMessagesPkey                      pgtype.Int8   `json:"t_messages_pkey"`
	MessageID                          uuid.UUID     `json:"message_id"`
	SenderID                           pgtype.UUID   `json:"sender_id"`
	Body                               string        `json:"body"`
	PostedAt                           time.Time     `json:"posted_at"`
	LastEditedAt                       time.Time     `json:"last_edited_at"`
	ChatRoomActionID                   uuid.UUID     `json:"chat_room_action_id"`
	MemberName                         pgtype.Text   `json:"member_name"`
	MemberFirstName                    pgtype.Text   `json:"member_first_name"`
	MemberLastName                     pgtype.Text   `json:"member_last_name"`
	MemberEmail                        pgtype.Text   `json:"member_email"`
	MemberProfileImageID               pgtype.UUID   `json:"member_profile_image_id"`
	MemberProfileImageHeight           pgtype.Float8 `json:"member_profile_image_height"`
	MemberProfileImageWidth            pgtype.Float8 `json:"member_profile_image_width"`
	MemberProfileImageAttachableItemID pgtype.UUID   `json:"member_profile_image_attachable_item_id"`
	MemberProfileImageOwnerID          pgtype.UUID   `json:"member_profile_image_owner_id"`
	MemberProfileImageFromOuter        pgtype.Bool   `json:"member_profile_image_from_outer"`
	MemberProfileImageAlias            pgtype.Text   `json:"member_profile_image_alias"`
	MemberProfileImageUrl              pgtype.Text   `json:"member_profile_image_url"`
	MemberProfileImageSize             pgtype.Float8 `json:"member_profile_image_size"`
	MemberProfileImageMimeTypeID       pgtype.UUID   `json:"member_profile_image_mime_type_id"`
}

func (q *Queries) GetMessagesWithSenderUseKeysetPaginate(ctx context.Context, arg GetMessagesWithSenderUseKeysetPaginateParams) ([]GetMessagesWithSenderUseKeysetPaginateRow, error) {
	rows, err := q.db.Query(ctx, getMessagesWithSenderUseKeysetPaginate,
		arg.Limit,
		arg.WhereInChatRoom,
		arg.InChatRoom,
		arg.WhereInSender,
		arg.InSender,
		arg.WhereLikeBody,
		arg.SearchBody,
		arg.WhereEarlierPostedAt,
		arg.EarlierPostedAt,
		arg.WhereLaterPostedAt,
		arg.LaterPostedAt,
		arg.WhereEarlierLastEditedAt,
		arg.EarlierLastEditedAt,
		arg.WhereLaterLastEditedAt,
		arg.LaterLastEditedAt,
		arg.CursorDirection,
		arg.OrderMethod,
		arg.PostedAtCursor,
		arg.Cursor,
		arg.LastEditedAtCursor,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMessagesWithSenderUseKeysetPaginateRow{}
	for rows.Next() {
		var i GetMessagesWithSenderUseKeysetPaginateRow
		if err := rows.Scan(
			&i.TMessagesPkey,
			&i.MessageID,
			&i.SenderID,
			&i.Body,
			&i.PostedAt,
			&i.LastEditedAt,
			&i.ChatRoomActionID,
			&i.MemberName,
			&i.MemberFirstName,
			&i.MemberLastName,
			&i.MemberEmail,
			&i.MemberProfileImageID,
			&i.MemberProfileImageHeight,
			&i.MemberProfileImageWidth,
			&i.MemberProfileImageAttachableItemID,
			&i.MemberProfileImageOwnerID,
			&i.MemberProfileImageFromOuter,
			&i.MemberProfileImageAlias,
			&i.MemberProfileImageUrl,
			&i.MemberProfileImageSize,
			&i.MemberProfileImageMimeTypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMessagesWithSenderUseNumberedPaginate = `-- name: GetMessagesWithSenderUseNumberedPaginate :many
SELECT t_messages.t_messages_pkey, t_messages.message_id, t_messages.sender_id, t_messages.body, t_messages.posted_at, t_messages.last_edited_at, t_messages.chat_room_action_id, m_members.name member_name, m_members.first_name member_first_name, m_members.last_name member_last_name, m_members.email member_email,
m_members.profile_image_id member_profile_image_id, t_images.height member_profile_image_height,
t_images.width member_profile_image_width, t_images.attachable_item_id member_profile_image_attachable_item_id,
t_attachable_items.owner_id member_profile_image_owner_id, t_attachable_items.from_outer member_profile_image_from_outer, t_attachable_items.alias member_profile_image_alias,
t_attachable_items.url member_profile_image_url, t_attachable_items.size member_profile_image_size, t_attachable_items.mime_type_id member_profile_image_mime_type_id FROM t_messages
LEFT JOIN m_members ON t_messages.sender_id = m_members.member_id
LEFT JOIN t_images ON m_members.profile_image_id = t_images.image_id
LEFT JOIN t_attachable_items ON t_images.attachable_item_id = t_attachable_items.attachable_item_id
WHERE
	CASE WHEN $3::boolean = true THEN t_chat_room_actions in (SELECT chat_room_action_id FROM t_chat_room_actions WHERE chat_room_id = ANY($4::uuid[])) ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN sender_id = ANY($6::uuid[]) ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN body LIKE '%' || $8::text || '%' ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN posted_at >= $10 ELSE TRUE END
AND
	CASE WHEN $11::boolean = true THEN posted_at <= $12 ELSE TRUE END
AND
	CASE WHEN $13::boolean = true THEN last_edited_at >= $14 ELSE TRUE END
AND
	CASE WHEN $15::boolean = true THEN last_edited_at <= $16 ELSE TRUE END
ORDER BY
	CASE WHEN $17::text = 'posted_at' THEN posted_at END ASC NULLS LAST,
	CASE WHEN $17::text = 'r_posted_at' THEN posted_at END DESC NULLS LAST,
	CASE WHEN $17::text = 'last_edited_at' THEN last_edited_at END ASC NULLS LAST,
	CASE WHEN $17::text = 'r_last_edited_at' THEN last_edited_at END DESC NULLS LAST,
	t_messages_pkey ASC
LIMIT $1 OFFSET $2
`

type GetMessagesWithSenderUseNumberedPaginateParams struct {
	Limit                    int32       `json:"limit"`
	Offset                   int32       `json:"offset"`
	WhereInChatRoom          bool        `json:"where_in_chat_room"`
	InChatRoom               []uuid.UUID `json:"in_chat_room"`
	WhereInSender            bool        `json:"where_in_sender"`
	InSender                 []uuid.UUID `json:"in_sender"`
	WhereLikeBody            bool        `json:"where_like_body"`
	SearchBody               string      `json:"search_body"`
	WhereEarlierPostedAt     bool        `json:"where_earlier_posted_at"`
	EarlierPostedAt          time.Time   `json:"earlier_posted_at"`
	WhereLaterPostedAt       bool        `json:"where_later_posted_at"`
	LaterPostedAt            time.Time   `json:"later_posted_at"`
	WhereEarlierLastEditedAt bool        `json:"where_earlier_last_edited_at"`
	EarlierLastEditedAt      time.Time   `json:"earlier_last_edited_at"`
	WhereLaterLastEditedAt   bool        `json:"where_later_last_edited_at"`
	LaterLastEditedAt        time.Time   `json:"later_last_edited_at"`
	OrderMethod              string      `json:"order_method"`
}

type GetMessagesWithSenderUseNumberedPaginateRow struct {
	TMessagesPkey                      pgtype.Int8   `json:"t_messages_pkey"`
	MessageID                          uuid.UUID     `json:"message_id"`
	SenderID                           pgtype.UUID   `json:"sender_id"`
	Body                               string        `json:"body"`
	PostedAt                           time.Time     `json:"posted_at"`
	LastEditedAt                       time.Time     `json:"last_edited_at"`
	ChatRoomActionID                   uuid.UUID     `json:"chat_room_action_id"`
	MemberName                         pgtype.Text   `json:"member_name"`
	MemberFirstName                    pgtype.Text   `json:"member_first_name"`
	MemberLastName                     pgtype.Text   `json:"member_last_name"`
	MemberEmail                        pgtype.Text   `json:"member_email"`
	MemberProfileImageID               pgtype.UUID   `json:"member_profile_image_id"`
	MemberProfileImageHeight           pgtype.Float8 `json:"member_profile_image_height"`
	MemberProfileImageWidth            pgtype.Float8 `json:"member_profile_image_width"`
	MemberProfileImageAttachableItemID pgtype.UUID   `json:"member_profile_image_attachable_item_id"`
	MemberProfileImageOwnerID          pgtype.UUID   `json:"member_profile_image_owner_id"`
	MemberProfileImageFromOuter        pgtype.Bool   `json:"member_profile_image_from_outer"`
	MemberProfileImageAlias            pgtype.Text   `json:"member_profile_image_alias"`
	MemberProfileImageUrl              pgtype.Text   `json:"member_profile_image_url"`
	MemberProfileImageSize             pgtype.Float8 `json:"member_profile_image_size"`
	MemberProfileImageMimeTypeID       pgtype.UUID   `json:"member_profile_image_mime_type_id"`
}

func (q *Queries) GetMessagesWithSenderUseNumberedPaginate(ctx context.Context, arg GetMessagesWithSenderUseNumberedPaginateParams) ([]GetMessagesWithSenderUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getMessagesWithSenderUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.WhereInChatRoom,
		arg.InChatRoom,
		arg.WhereInSender,
		arg.InSender,
		arg.WhereLikeBody,
		arg.SearchBody,
		arg.WhereEarlierPostedAt,
		arg.EarlierPostedAt,
		arg.WhereLaterPostedAt,
		arg.LaterPostedAt,
		arg.WhereEarlierLastEditedAt,
		arg.EarlierLastEditedAt,
		arg.WhereLaterLastEditedAt,
		arg.LaterLastEditedAt,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMessagesWithSenderUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetMessagesWithSenderUseNumberedPaginateRow
		if err := rows.Scan(
			&i.TMessagesPkey,
			&i.MessageID,
			&i.SenderID,
			&i.Body,
			&i.PostedAt,
			&i.LastEditedAt,
			&i.ChatRoomActionID,
			&i.MemberName,
			&i.MemberFirstName,
			&i.MemberLastName,
			&i.MemberEmail,
			&i.MemberProfileImageID,
			&i.MemberProfileImageHeight,
			&i.MemberProfileImageWidth,
			&i.MemberProfileImageAttachableItemID,
			&i.MemberProfileImageOwnerID,
			&i.MemberProfileImageFromOuter,
			&i.MemberProfileImageAlias,
			&i.MemberProfileImageUrl,
			&i.MemberProfileImageSize,
			&i.MemberProfileImageMimeTypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralMessages = `-- name: GetPluralMessages :many
SELECT t_messages_pkey, message_id, sender_id, body, posted_at, last_edited_at, chat_room_action_id FROM t_messages WHERE message_id = ANY($1::uuid[])
ORDER BY
	CASE WHEN $2::text = 'posted_at' THEN posted_at END ASC NULLS LAST,
	CASE WHEN $2::text = 'r_posted_at' THEN posted_at END DESC NULLS LAST,
	CASE WHEN $2::text = 'last_edited_at' THEN last_edited_at END ASC NULLS LAST,
	CASE WHEN $2::text = 'r_last_edited_at' THEN last_edited_at END DESC NULLS LAST,
	t_messages_pkey ASC
`

type GetPluralMessagesParams struct {
	MessageIds  []uuid.UUID `json:"message_ids"`
	OrderMethod string      `json:"order_method"`
}

func (q *Queries) GetPluralMessages(ctx context.Context, arg GetPluralMessagesParams) ([]Message, error) {
	rows, err := q.db.Query(ctx, getPluralMessages, arg.MessageIds, arg.OrderMethod)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Message{}
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.TMessagesPkey,
			&i.MessageID,
			&i.SenderID,
			&i.Body,
			&i.PostedAt,
			&i.LastEditedAt,
			&i.ChatRoomActionID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralMessagesUseNumberedPaginate = `-- name: GetPluralMessagesUseNumberedPaginate :many
SELECT t_messages_pkey, message_id, sender_id, body, posted_at, last_edited_at, chat_room_action_id FROM t_messages WHERE message_id = ANY($3::uuid[])
ORDER BY
	CASE WHEN $4::text = 'posted_at' THEN posted_at END ASC NULLS LAST,
	CASE WHEN $4::text = 'r_posted_at' THEN posted_at END DESC NULLS LAST,
	CASE WHEN $4::text = 'last_edited_at' THEN last_edited_at END ASC NULLS LAST,
	CASE WHEN $4::text = 'r_last_edited_at' THEN last_edited_at END DESC NULLS LAST,
	t_messages_pkey ASC
LIMIT $1 OFFSET $2
`

type GetPluralMessagesUseNumberedPaginateParams struct {
	Limit       int32       `json:"limit"`
	Offset      int32       `json:"offset"`
	MessageIds  []uuid.UUID `json:"message_ids"`
	OrderMethod string      `json:"order_method"`
}

func (q *Queries) GetPluralMessagesUseNumberedPaginate(ctx context.Context, arg GetPluralMessagesUseNumberedPaginateParams) ([]Message, error) {
	rows, err := q.db.Query(ctx, getPluralMessagesUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.MessageIds,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Message{}
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.TMessagesPkey,
			&i.MessageID,
			&i.SenderID,
			&i.Body,
			&i.PostedAt,
			&i.LastEditedAt,
			&i.ChatRoomActionID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralMessagesWithChatRoom = `-- name: GetPluralMessagesWithChatRoom :many
SELECT t_messages.t_messages_pkey, t_messages.message_id, t_messages.sender_id, t_messages.body, t_messages.posted_at, t_messages.last_edited_at, t_messages.chat_room_action_id, m_chat_rooms.chat_room_id, m_chat_rooms.name chat_room_name, m_chat_rooms.is_private chat_room_is_private,
m_chat_rooms.from_organization chat_room_from_organization, m_chat_rooms.owner_id chat_room_owner_id,
m_chat_rooms.cover_image_id chat_room_cover_image_id, t_images.height chat_room_cover_image_height,
t_images.width chat_room_cover_image_width, t_images.attachable_item_id chat_room_cover_image_attachable_item_id,
t_attachable_items.owner_id chat_room_cover_image_owner_id, t_attachable_items.from_outer chat_room_cover_image_from_outer, t_attachable_items.alias chat_room_cover_image_alias,
t_attachable_items.url chat_room_cover_image_url, t_attachable_items.size chat_room_cover_image_size, t_attachable_items.mime_type_id chat_room_cover_image_mime_type_id FROM t_messages
LEFT JOIN t_chat_room_actions ON t_messages.chat_room_action_id = t_chat_room_actions.chat_room_action_id
LEFT JOIN m_chat_rooms ON t_messages.chat_room_id = m_chat_rooms.chat_room_id
LEFT JOIN t_images ON m_chat_rooms.cover_image_id = t_images.image_id
LEFT JOIN t_attachable_items ON t_images.attachable_item_id = t_attachable_items.attachable_item_id
WHERE message_id = ANY($1::uuid[])
ORDER BY
	CASE WHEN $2::text = 'posted_at' THEN posted_at END ASC NULLS LAST,
	CASE WHEN $2::text = 'r_posted_at' THEN posted_at END DESC NULLS LAST,
	CASE WHEN $2::text = 'last_edited_at' THEN last_edited_at END ASC NULLS LAST,
	CASE WHEN $2::text = 'r_last_edited_at' THEN last_edited_at END DESC NULLS LAST,
	t_messages_pkey ASC
`

type GetPluralMessagesWithChatRoomParams struct {
	MessageIds  []uuid.UUID `json:"message_ids"`
	OrderMethod string      `json:"order_method"`
}

type GetPluralMessagesWithChatRoomRow struct {
	TMessagesPkey                      pgtype.Int8   `json:"t_messages_pkey"`
	MessageID                          uuid.UUID     `json:"message_id"`
	SenderID                           pgtype.UUID   `json:"sender_id"`
	Body                               string        `json:"body"`
	PostedAt                           time.Time     `json:"posted_at"`
	LastEditedAt                       time.Time     `json:"last_edited_at"`
	ChatRoomActionID                   uuid.UUID     `json:"chat_room_action_id"`
	ChatRoomID                         pgtype.UUID   `json:"chat_room_id"`
	ChatRoomName                       pgtype.Text   `json:"chat_room_name"`
	ChatRoomIsPrivate                  pgtype.Bool   `json:"chat_room_is_private"`
	ChatRoomFromOrganization           pgtype.Bool   `json:"chat_room_from_organization"`
	ChatRoomOwnerID                    pgtype.UUID   `json:"chat_room_owner_id"`
	ChatRoomCoverImageID               pgtype.UUID   `json:"chat_room_cover_image_id"`
	ChatRoomCoverImageHeight           pgtype.Float8 `json:"chat_room_cover_image_height"`
	ChatRoomCoverImageWidth            pgtype.Float8 `json:"chat_room_cover_image_width"`
	ChatRoomCoverImageAttachableItemID pgtype.UUID   `json:"chat_room_cover_image_attachable_item_id"`
	ChatRoomCoverImageOwnerID          pgtype.UUID   `json:"chat_room_cover_image_owner_id"`
	ChatRoomCoverImageFromOuter        pgtype.Bool   `json:"chat_room_cover_image_from_outer"`
	ChatRoomCoverImageAlias            pgtype.Text   `json:"chat_room_cover_image_alias"`
	ChatRoomCoverImageUrl              pgtype.Text   `json:"chat_room_cover_image_url"`
	ChatRoomCoverImageSize             pgtype.Float8 `json:"chat_room_cover_image_size"`
	ChatRoomCoverImageMimeTypeID       pgtype.UUID   `json:"chat_room_cover_image_mime_type_id"`
}

func (q *Queries) GetPluralMessagesWithChatRoom(ctx context.Context, arg GetPluralMessagesWithChatRoomParams) ([]GetPluralMessagesWithChatRoomRow, error) {
	rows, err := q.db.Query(ctx, getPluralMessagesWithChatRoom, arg.MessageIds, arg.OrderMethod)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralMessagesWithChatRoomRow{}
	for rows.Next() {
		var i GetPluralMessagesWithChatRoomRow
		if err := rows.Scan(
			&i.TMessagesPkey,
			&i.MessageID,
			&i.SenderID,
			&i.Body,
			&i.PostedAt,
			&i.LastEditedAt,
			&i.ChatRoomActionID,
			&i.ChatRoomID,
			&i.ChatRoomName,
			&i.ChatRoomIsPrivate,
			&i.ChatRoomFromOrganization,
			&i.ChatRoomOwnerID,
			&i.ChatRoomCoverImageID,
			&i.ChatRoomCoverImageHeight,
			&i.ChatRoomCoverImageWidth,
			&i.ChatRoomCoverImageAttachableItemID,
			&i.ChatRoomCoverImageOwnerID,
			&i.ChatRoomCoverImageFromOuter,
			&i.ChatRoomCoverImageAlias,
			&i.ChatRoomCoverImageUrl,
			&i.ChatRoomCoverImageSize,
			&i.ChatRoomCoverImageMimeTypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralMessagesWithChatRoomUseNumberedPaginate = `-- name: GetPluralMessagesWithChatRoomUseNumberedPaginate :many
SELECT t_messages.t_messages_pkey, t_messages.message_id, t_messages.sender_id, t_messages.body, t_messages.posted_at, t_messages.last_edited_at, t_messages.chat_room_action_id, m_chat_rooms.chat_room_id, m_chat_rooms.name chat_room_name, m_chat_rooms.is_private chat_room_is_private,
m_chat_rooms.from_organization chat_room_from_organization, m_chat_rooms.owner_id chat_room_owner_id,
m_chat_rooms.cover_image_id chat_room_cover_image_id, t_images.height chat_room_cover_image_height,
t_images.width chat_room_cover_image_width, t_images.attachable_item_id chat_room_cover_image_attachable_item_id,
t_attachable_items.owner_id chat_room_cover_image_owner_id, t_attachable_items.from_outer chat_room_cover_image_from_outer, t_attachable_items.alias chat_room_cover_image_alias,
t_attachable_items.url chat_room_cover_image_url, t_attachable_items.size chat_room_cover_image_size, t_attachable_items.mime_type_id chat_room_cover_image_mime_type_id FROM t_messages
LEFT JOIN t_chat_room_actions ON t_messages.chat_room_action_id = t_chat_room_actions.chat_room_action_id
LEFT JOIN m_chat_rooms ON t_messages.chat_room_id = m_chat_rooms.chat_room_id
LEFT JOIN t_images ON m_chat_rooms.cover_image_id = t_images.image_id
LEFT JOIN t_attachable_items ON t_images.attachable_item_id = t_attachable_items.attachable_item_id
WHERE message_id = ANY($3::uuid[])
ORDER BY
	CASE WHEN $4::text = 'posted_at' THEN posted_at END ASC NULLS LAST,
	CASE WHEN $4::text = 'r_posted_at' THEN posted_at END DESC NULLS LAST,
	CASE WHEN $4::text = 'last_edited_at' THEN last_edited_at END ASC NULLS LAST,
	CASE WHEN $4::text = 'r_last_edited_at' THEN last_edited_at END DESC NULLS LAST,
	t_messages_pkey ASC
LIMIT $1 OFFSET $2
`

type GetPluralMessagesWithChatRoomUseNumberedPaginateParams struct {
	Limit       int32       `json:"limit"`
	Offset      int32       `json:"offset"`
	MessageIds  []uuid.UUID `json:"message_ids"`
	OrderMethod string      `json:"order_method"`
}

type GetPluralMessagesWithChatRoomUseNumberedPaginateRow struct {
	TMessagesPkey                      pgtype.Int8   `json:"t_messages_pkey"`
	MessageID                          uuid.UUID     `json:"message_id"`
	SenderID                           pgtype.UUID   `json:"sender_id"`
	Body                               string        `json:"body"`
	PostedAt                           time.Time     `json:"posted_at"`
	LastEditedAt                       time.Time     `json:"last_edited_at"`
	ChatRoomActionID                   uuid.UUID     `json:"chat_room_action_id"`
	ChatRoomID                         pgtype.UUID   `json:"chat_room_id"`
	ChatRoomName                       pgtype.Text   `json:"chat_room_name"`
	ChatRoomIsPrivate                  pgtype.Bool   `json:"chat_room_is_private"`
	ChatRoomFromOrganization           pgtype.Bool   `json:"chat_room_from_organization"`
	ChatRoomOwnerID                    pgtype.UUID   `json:"chat_room_owner_id"`
	ChatRoomCoverImageID               pgtype.UUID   `json:"chat_room_cover_image_id"`
	ChatRoomCoverImageHeight           pgtype.Float8 `json:"chat_room_cover_image_height"`
	ChatRoomCoverImageWidth            pgtype.Float8 `json:"chat_room_cover_image_width"`
	ChatRoomCoverImageAttachableItemID pgtype.UUID   `json:"chat_room_cover_image_attachable_item_id"`
	ChatRoomCoverImageOwnerID          pgtype.UUID   `json:"chat_room_cover_image_owner_id"`
	ChatRoomCoverImageFromOuter        pgtype.Bool   `json:"chat_room_cover_image_from_outer"`
	ChatRoomCoverImageAlias            pgtype.Text   `json:"chat_room_cover_image_alias"`
	ChatRoomCoverImageUrl              pgtype.Text   `json:"chat_room_cover_image_url"`
	ChatRoomCoverImageSize             pgtype.Float8 `json:"chat_room_cover_image_size"`
	ChatRoomCoverImageMimeTypeID       pgtype.UUID   `json:"chat_room_cover_image_mime_type_id"`
}

func (q *Queries) GetPluralMessagesWithChatRoomUseNumberedPaginate(ctx context.Context, arg GetPluralMessagesWithChatRoomUseNumberedPaginateParams) ([]GetPluralMessagesWithChatRoomUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getPluralMessagesWithChatRoomUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.MessageIds,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralMessagesWithChatRoomUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetPluralMessagesWithChatRoomUseNumberedPaginateRow
		if err := rows.Scan(
			&i.TMessagesPkey,
			&i.MessageID,
			&i.SenderID,
			&i.Body,
			&i.PostedAt,
			&i.LastEditedAt,
			&i.ChatRoomActionID,
			&i.ChatRoomID,
			&i.ChatRoomName,
			&i.ChatRoomIsPrivate,
			&i.ChatRoomFromOrganization,
			&i.ChatRoomOwnerID,
			&i.ChatRoomCoverImageID,
			&i.ChatRoomCoverImageHeight,
			&i.ChatRoomCoverImageWidth,
			&i.ChatRoomCoverImageAttachableItemID,
			&i.ChatRoomCoverImageOwnerID,
			&i.ChatRoomCoverImageFromOuter,
			&i.ChatRoomCoverImageAlias,
			&i.ChatRoomCoverImageUrl,
			&i.ChatRoomCoverImageSize,
			&i.ChatRoomCoverImageMimeTypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralMessagesWithSender = `-- name: GetPluralMessagesWithSender :many
SELECT t_messages.t_messages_pkey, t_messages.message_id, t_messages.sender_id, t_messages.body, t_messages.posted_at, t_messages.last_edited_at, t_messages.chat_room_action_id, m_members.name member_name, m_members.first_name member_first_name, m_members.last_name member_last_name, m_members.email member_email,
m_members.profile_image_id member_profile_image_id, t_images.height member_profile_image_height,
t_images.width member_profile_image_width, t_images.attachable_item_id member_profile_image_attachable_item_id,
t_attachable_items.owner_id member_profile_image_owner_id, t_attachable_items.from_outer member_profile_image_from_outer, t_attachable_items.alias member_profile_image_alias,
t_attachable_items.url member_profile_image_url, t_attachable_items.size member_profile_image_size, t_attachable_items.mime_type_id member_profile_image_mime_type_id FROM t_messages
LEFT JOIN m_members ON t_messages.sender_id = m_members.member_id
LEFT JOIN t_images ON m_members.profile_image_id = t_images.image_id
LEFT JOIN t_attachable_items ON t_images.attachable_item_id = t_attachable_items.attachable_item_id
WHERE message_id = ANY($1::uuid[])
ORDER BY
	CASE WHEN $2::text = 'posted_at' THEN posted_at END ASC NULLS LAST,
	CASE WHEN $2::text = 'r_posted_at' THEN posted_at END DESC NULLS LAST,
	CASE WHEN $2::text = 'last_edited_at' THEN last_edited_at END ASC NULLS LAST,
	CASE WHEN $2::text = 'r_last_edited_at' THEN last_edited_at END DESC NULLS LAST,
	t_messages_pkey ASC
`

type GetPluralMessagesWithSenderParams struct {
	MessageIds  []uuid.UUID `json:"message_ids"`
	OrderMethod string      `json:"order_method"`
}

type GetPluralMessagesWithSenderRow struct {
	TMessagesPkey                      pgtype.Int8   `json:"t_messages_pkey"`
	MessageID                          uuid.UUID     `json:"message_id"`
	SenderID                           pgtype.UUID   `json:"sender_id"`
	Body                               string        `json:"body"`
	PostedAt                           time.Time     `json:"posted_at"`
	LastEditedAt                       time.Time     `json:"last_edited_at"`
	ChatRoomActionID                   uuid.UUID     `json:"chat_room_action_id"`
	MemberName                         pgtype.Text   `json:"member_name"`
	MemberFirstName                    pgtype.Text   `json:"member_first_name"`
	MemberLastName                     pgtype.Text   `json:"member_last_name"`
	MemberEmail                        pgtype.Text   `json:"member_email"`
	MemberProfileImageID               pgtype.UUID   `json:"member_profile_image_id"`
	MemberProfileImageHeight           pgtype.Float8 `json:"member_profile_image_height"`
	MemberProfileImageWidth            pgtype.Float8 `json:"member_profile_image_width"`
	MemberProfileImageAttachableItemID pgtype.UUID   `json:"member_profile_image_attachable_item_id"`
	MemberProfileImageOwnerID          pgtype.UUID   `json:"member_profile_image_owner_id"`
	MemberProfileImageFromOuter        pgtype.Bool   `json:"member_profile_image_from_outer"`
	MemberProfileImageAlias            pgtype.Text   `json:"member_profile_image_alias"`
	MemberProfileImageUrl              pgtype.Text   `json:"member_profile_image_url"`
	MemberProfileImageSize             pgtype.Float8 `json:"member_profile_image_size"`
	MemberProfileImageMimeTypeID       pgtype.UUID   `json:"member_profile_image_mime_type_id"`
}

func (q *Queries) GetPluralMessagesWithSender(ctx context.Context, arg GetPluralMessagesWithSenderParams) ([]GetPluralMessagesWithSenderRow, error) {
	rows, err := q.db.Query(ctx, getPluralMessagesWithSender, arg.MessageIds, arg.OrderMethod)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralMessagesWithSenderRow{}
	for rows.Next() {
		var i GetPluralMessagesWithSenderRow
		if err := rows.Scan(
			&i.TMessagesPkey,
			&i.MessageID,
			&i.SenderID,
			&i.Body,
			&i.PostedAt,
			&i.LastEditedAt,
			&i.ChatRoomActionID,
			&i.MemberName,
			&i.MemberFirstName,
			&i.MemberLastName,
			&i.MemberEmail,
			&i.MemberProfileImageID,
			&i.MemberProfileImageHeight,
			&i.MemberProfileImageWidth,
			&i.MemberProfileImageAttachableItemID,
			&i.MemberProfileImageOwnerID,
			&i.MemberProfileImageFromOuter,
			&i.MemberProfileImageAlias,
			&i.MemberProfileImageUrl,
			&i.MemberProfileImageSize,
			&i.MemberProfileImageMimeTypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralMessagesWithSenderUseNumberedPaginate = `-- name: GetPluralMessagesWithSenderUseNumberedPaginate :many
SELECT t_messages.t_messages_pkey, t_messages.message_id, t_messages.sender_id, t_messages.body, t_messages.posted_at, t_messages.last_edited_at, t_messages.chat_room_action_id, m_members.name member_name, m_members.first_name member_first_name, m_members.last_name member_last_name, m_members.email member_email,
m_members.profile_image_id member_profile_image_id, t_images.height member_profile_image_height,
t_images.width member_profile_image_width, t_images.attachable_item_id member_profile_image_attachable_item_id,
t_attachable_items.owner_id member_profile_image_owner_id, t_attachable_items.from_outer member_profile_image_from_outer, t_attachable_items.alias member_profile_image_alias,
t_attachable_items.url member_profile_image_url, t_attachable_items.size member_profile_image_size, t_attachable_items.mime_type_id member_profile_image_mime_type_id FROM t_messages
LEFT JOIN m_members ON t_messages.sender_id = m_members.member_id
LEFT JOIN t_images ON m_members.profile_image_id = t_images.image_id
LEFT JOIN t_attachable_items ON t_images.attachable_item_id = t_attachable_items.attachable_item_id
WHERE message_id = ANY($3::uuid[])
ORDER BY
	CASE WHEN $4::text = 'posted_at' THEN posted_at END ASC NULLS LAST,
	CASE WHEN $4::text = 'r_posted_at' THEN posted_at END DESC NULLS LAST,
	CASE WHEN $4::text = 'last_edited_at' THEN last_edited_at END ASC NULLS LAST,
	CASE WHEN $4::text = 'r_last_edited_at' THEN last_edited_at END DESC NULLS LAST,
	t_messages_pkey ASC
LIMIT $1 OFFSET $2
`

type GetPluralMessagesWithSenderUseNumberedPaginateParams struct {
	Limit       int32       `json:"limit"`
	Offset      int32       `json:"offset"`
	MessageIds  []uuid.UUID `json:"message_ids"`
	OrderMethod string      `json:"order_method"`
}

type GetPluralMessagesWithSenderUseNumberedPaginateRow struct {
	TMessagesPkey                      pgtype.Int8   `json:"t_messages_pkey"`
	MessageID                          uuid.UUID     `json:"message_id"`
	SenderID                           pgtype.UUID   `json:"sender_id"`
	Body                               string        `json:"body"`
	PostedAt                           time.Time     `json:"posted_at"`
	LastEditedAt                       time.Time     `json:"last_edited_at"`
	ChatRoomActionID                   uuid.UUID     `json:"chat_room_action_id"`
	MemberName                         pgtype.Text   `json:"member_name"`
	MemberFirstName                    pgtype.Text   `json:"member_first_name"`
	MemberLastName                     pgtype.Text   `json:"member_last_name"`
	MemberEmail                        pgtype.Text   `json:"member_email"`
	MemberProfileImageID               pgtype.UUID   `json:"member_profile_image_id"`
	MemberProfileImageHeight           pgtype.Float8 `json:"member_profile_image_height"`
	MemberProfileImageWidth            pgtype.Float8 `json:"member_profile_image_width"`
	MemberProfileImageAttachableItemID pgtype.UUID   `json:"member_profile_image_attachable_item_id"`
	MemberProfileImageOwnerID          pgtype.UUID   `json:"member_profile_image_owner_id"`
	MemberProfileImageFromOuter        pgtype.Bool   `json:"member_profile_image_from_outer"`
	MemberProfileImageAlias            pgtype.Text   `json:"member_profile_image_alias"`
	MemberProfileImageUrl              pgtype.Text   `json:"member_profile_image_url"`
	MemberProfileImageSize             pgtype.Float8 `json:"member_profile_image_size"`
	MemberProfileImageMimeTypeID       pgtype.UUID   `json:"member_profile_image_mime_type_id"`
}

func (q *Queries) GetPluralMessagesWithSenderUseNumberedPaginate(ctx context.Context, arg GetPluralMessagesWithSenderUseNumberedPaginateParams) ([]GetPluralMessagesWithSenderUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getPluralMessagesWithSenderUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.MessageIds,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralMessagesWithSenderUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetPluralMessagesWithSenderUseNumberedPaginateRow
		if err := rows.Scan(
			&i.TMessagesPkey,
			&i.MessageID,
			&i.SenderID,
			&i.Body,
			&i.PostedAt,
			&i.LastEditedAt,
			&i.ChatRoomActionID,
			&i.MemberName,
			&i.MemberFirstName,
			&i.MemberLastName,
			&i.MemberEmail,
			&i.MemberProfileImageID,
			&i.MemberProfileImageHeight,
			&i.MemberProfileImageWidth,
			&i.MemberProfileImageAttachableItemID,
			&i.MemberProfileImageOwnerID,
			&i.MemberProfileImageFromOuter,
			&i.MemberProfileImageAlias,
			&i.MemberProfileImageUrl,
			&i.MemberProfileImageSize,
			&i.MemberProfileImageMimeTypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const pluralDeleteMessages = `-- name: PluralDeleteMessages :execrows
DELETE FROM t_messages WHERE message_id = ANY($1::uuid[])
`

func (q *Queries) PluralDeleteMessages(ctx context.Context, memberIds []uuid.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, pluralDeleteMessages, memberIds)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateMessage = `-- name: UpdateMessage :one
UPDATE t_messages SET body = $2, last_edited_at = $3 WHERE message_id = $1 RETURNING t_messages_pkey, message_id, sender_id, body, posted_at, last_edited_at, chat_room_action_id
`

type UpdateMessageParams struct {
	MessageID    uuid.UUID `json:"message_id"`
	Body         string    `json:"body"`
	LastEditedAt time.Time `json:"last_edited_at"`
}

func (q *Queries) UpdateMessage(ctx context.Context, arg UpdateMessageParams) (Message, error) {
	row := q.db.QueryRow(ctx, updateMessage, arg.MessageID, arg.Body, arg.LastEditedAt)
	var i Message
	err := row.Scan(
		&i.TMessagesPkey,
		&i.MessageID,
		&i.SenderID,
		&i.Body,
		&i.PostedAt,
		&i.LastEditedAt,
		&i.ChatRoomActionID,
	)
	return i, err
}
