// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: membership.sql

package query

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countMembersOnOrganization = `-- name: CountMembersOnOrganization :one
SELECT COUNT(*) FROM m_memberships WHERE organization_id = $1
AND CASE WHEN $2::boolean = true THEN
		EXISTS (SELECT 1 FROM m_members WHERE m_memberships.member_id = m_members.member_id AND m_members.name LIKE '%' || $3::text || '%')
	ELSE TRUE END
`

type CountMembersOnOrganizationParams struct {
	OrganizationID uuid.UUID `json:"organization_id"`
	WhereLikeName  bool      `json:"where_like_name"`
	SearchName     string    `json:"search_name"`
}

func (q *Queries) CountMembersOnOrganization(ctx context.Context, arg CountMembersOnOrganizationParams) (int64, error) {
	row := q.db.QueryRow(ctx, countMembersOnOrganization, arg.OrganizationID, arg.WhereLikeName, arg.SearchName)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countOrganizationsOnMember = `-- name: CountOrganizationsOnMember :one
SELECT COUNT(*) FROM m_memberships WHERE member_id = $1
AND CASE WHEN $2::boolean = true THEN
		EXISTS (SELECT 1 FROM m_organizations WHERE m_memberships.organization_id = m_organizations.organization_id AND m_organizations.name LIKE '%' || $3::text || '%')
	ELSE TRUE END
`

type CountOrganizationsOnMemberParams struct {
	MemberID      uuid.UUID `json:"member_id"`
	WhereLikeName bool      `json:"where_like_name"`
	SearchName    string    `json:"search_name"`
}

func (q *Queries) CountOrganizationsOnMember(ctx context.Context, arg CountOrganizationsOnMemberParams) (int64, error) {
	row := q.db.QueryRow(ctx, countOrganizationsOnMember, arg.MemberID, arg.WhereLikeName, arg.SearchName)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createMembership = `-- name: CreateMembership :one
INSERT INTO m_memberships (member_id, organization_id, work_position_id, added_at) VALUES ($1, $2, $3, $4) RETURNING m_memberships_pkey, member_id, organization_id, work_position_id, added_at
`

type CreateMembershipParams struct {
	MemberID       uuid.UUID   `json:"member_id"`
	OrganizationID uuid.UUID   `json:"organization_id"`
	WorkPositionID pgtype.UUID `json:"work_position_id"`
	AddedAt        time.Time   `json:"added_at"`
}

func (q *Queries) CreateMembership(ctx context.Context, arg CreateMembershipParams) (Membership, error) {
	row := q.db.QueryRow(ctx, createMembership,
		arg.MemberID,
		arg.OrganizationID,
		arg.WorkPositionID,
		arg.AddedAt,
	)
	var i Membership
	err := row.Scan(
		&i.MMembershipsPkey,
		&i.MemberID,
		&i.OrganizationID,
		&i.WorkPositionID,
		&i.AddedAt,
	)
	return i, err
}

type CreateMembershipsParams struct {
	MemberID       uuid.UUID   `json:"member_id"`
	OrganizationID uuid.UUID   `json:"organization_id"`
	WorkPositionID pgtype.UUID `json:"work_position_id"`
	AddedAt        time.Time   `json:"added_at"`
}

const deleteMembership = `-- name: DeleteMembership :execrows
DELETE FROM m_memberships WHERE member_id = $1 AND organization_id = $2
`

type DeleteMembershipParams struct {
	MemberID       uuid.UUID `json:"member_id"`
	OrganizationID uuid.UUID `json:"organization_id"`
}

func (q *Queries) DeleteMembership(ctx context.Context, arg DeleteMembershipParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteMembership, arg.MemberID, arg.OrganizationID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteMembershipsOnMember = `-- name: DeleteMembershipsOnMember :execrows
DELETE FROM m_memberships WHERE member_id = $1
`

func (q *Queries) DeleteMembershipsOnMember(ctx context.Context, memberID uuid.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, deleteMembershipsOnMember, memberID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteMembershipsOnMembers = `-- name: DeleteMembershipsOnMembers :execrows
DELETE FROM m_memberships WHERE member_id = ANY($1::uuid[])
`

func (q *Queries) DeleteMembershipsOnMembers(ctx context.Context, memberIds []uuid.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, deleteMembershipsOnMembers, memberIds)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteMembershipsOnOrganization = `-- name: DeleteMembershipsOnOrganization :execrows
DELETE FROM m_memberships WHERE organization_id = $1
`

func (q *Queries) DeleteMembershipsOnOrganization(ctx context.Context, organizationID uuid.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, deleteMembershipsOnOrganization, organizationID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteMembershipsOnOrganizations = `-- name: DeleteMembershipsOnOrganizations :execrows
DELETE FROM m_memberships WHERE organization_id = ANY($1::uuid[])
`

func (q *Queries) DeleteMembershipsOnOrganizations(ctx context.Context, organizationIds []uuid.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, deleteMembershipsOnOrganizations, organizationIds)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getMembersOnOrganization = `-- name: GetMembersOnOrganization :many
SELECT m_memberships.m_memberships_pkey, m_memberships.member_id, m_memberships.organization_id, m_memberships.work_position_id, m_memberships.added_at, m_members.name member_name, m_members.first_name member_first_name, m_members.last_name member_last_name, m_members.email member_email, m_members.grade_id member_grade_id, m_members.group_id member_group_id,
m_members.profile_image_id member_profile_image_id, t_images.height member_profile_image_height,
t_images.width member_profile_image_width, t_images.attachable_item_id member_profile_image_attachable_item_id,
t_attachable_items.owner_id member_profile_image_owner_id, t_attachable_items.from_outer member_profile_image_from_outer, t_attachable_items.alias member_profile_image_alias,
t_attachable_items.url member_profile_image_url, t_attachable_items.size member_profile_image_size, t_attachable_items.mime_type_id member_profile_image_mime_type_id FROM m_memberships
LEFT JOIN m_members ON m_memberships.member_id = m_members.member_id
LEFT JOIN t_images ON m_members.profile_image_id = t_images.image_id
LEFT JOIN t_attachable_items ON t_images.attachable_item_id = t_attachable_items.attachable_item_id
WHERE organization_id = $1
AND CASE
	WHEN $2::boolean = true THEN m_members.name LIKE '%' || $3::text || '%' ELSE TRUE
END
ORDER BY
	CASE WHEN $4::text = 'name' THEN m_members.name END ASC NULLS LAST,
	CASE WHEN $4::text = 'r_name' THEN m_members.name END DESC NULLS LAST,
	CASE WHEN $4::text = 'old_add' THEN m_memberships.added_at END ASC NULLS LAST,
	CASE WHEN $4::text = 'late_add' THEN m_memberships.added_at END DESC NULLS LAST,
	m_memberships_pkey ASC
`

type GetMembersOnOrganizationParams struct {
	OrganizationID uuid.UUID `json:"organization_id"`
	WhereLikeName  bool      `json:"where_like_name"`
	SearchName     string    `json:"search_name"`
	OrderMethod    string    `json:"order_method"`
}

type GetMembersOnOrganizationRow struct {
	MMembershipsPkey                   pgtype.Int8   `json:"m_memberships_pkey"`
	MemberID                           uuid.UUID     `json:"member_id"`
	OrganizationID                     uuid.UUID     `json:"organization_id"`
	WorkPositionID                     pgtype.UUID   `json:"work_position_id"`
	AddedAt                            time.Time     `json:"added_at"`
	MemberName                         pgtype.Text   `json:"member_name"`
	MemberFirstName                    pgtype.Text   `json:"member_first_name"`
	MemberLastName                     pgtype.Text   `json:"member_last_name"`
	MemberEmail                        pgtype.Text   `json:"member_email"`
	MemberGradeID                      pgtype.UUID   `json:"member_grade_id"`
	MemberGroupID                      pgtype.UUID   `json:"member_group_id"`
	MemberProfileImageID               pgtype.UUID   `json:"member_profile_image_id"`
	MemberProfileImageHeight           pgtype.Float8 `json:"member_profile_image_height"`
	MemberProfileImageWidth            pgtype.Float8 `json:"member_profile_image_width"`
	MemberProfileImageAttachableItemID pgtype.UUID   `json:"member_profile_image_attachable_item_id"`
	MemberProfileImageOwnerID          pgtype.UUID   `json:"member_profile_image_owner_id"`
	MemberProfileImageFromOuter        pgtype.Bool   `json:"member_profile_image_from_outer"`
	MemberProfileImageAlias            pgtype.Text   `json:"member_profile_image_alias"`
	MemberProfileImageUrl              pgtype.Text   `json:"member_profile_image_url"`
	MemberProfileImageSize             pgtype.Float8 `json:"member_profile_image_size"`
	MemberProfileImageMimeTypeID       pgtype.UUID   `json:"member_profile_image_mime_type_id"`
}

func (q *Queries) GetMembersOnOrganization(ctx context.Context, arg GetMembersOnOrganizationParams) ([]GetMembersOnOrganizationRow, error) {
	rows, err := q.db.Query(ctx, getMembersOnOrganization,
		arg.OrganizationID,
		arg.WhereLikeName,
		arg.SearchName,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMembersOnOrganizationRow{}
	for rows.Next() {
		var i GetMembersOnOrganizationRow
		if err := rows.Scan(
			&i.MMembershipsPkey,
			&i.MemberID,
			&i.OrganizationID,
			&i.WorkPositionID,
			&i.AddedAt,
			&i.MemberName,
			&i.MemberFirstName,
			&i.MemberLastName,
			&i.MemberEmail,
			&i.MemberGradeID,
			&i.MemberGroupID,
			&i.MemberProfileImageID,
			&i.MemberProfileImageHeight,
			&i.MemberProfileImageWidth,
			&i.MemberProfileImageAttachableItemID,
			&i.MemberProfileImageOwnerID,
			&i.MemberProfileImageFromOuter,
			&i.MemberProfileImageAlias,
			&i.MemberProfileImageUrl,
			&i.MemberProfileImageSize,
			&i.MemberProfileImageMimeTypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMembersOnOrganizationUseKeysetPaginate = `-- name: GetMembersOnOrganizationUseKeysetPaginate :many
SELECT m_memberships.m_memberships_pkey, m_memberships.member_id, m_memberships.organization_id, m_memberships.work_position_id, m_memberships.added_at, m_members.name member_name, m_members.first_name member_first_name, m_members.last_name member_last_name, m_members.email member_email, m_members.grade_id member_grade_id, m_members.group_id member_group_id,
m_members.profile_image_id member_profile_image_id, t_images.height member_profile_image_height,
t_images.width member_profile_image_width, t_images.attachable_item_id member_profile_image_attachable_item_id,
t_attachable_items.owner_id member_profile_image_owner_id, t_attachable_items.from_outer member_profile_image_from_outer, t_attachable_items.alias member_profile_image_alias,
t_attachable_items.url member_profile_image_url, t_attachable_items.size member_profile_image_size, t_attachable_items.mime_type_id member_profile_image_mime_type_id FROM m_memberships
LEFT JOIN m_members ON m_memberships.member_id = m_members.member_id
LEFT JOIN t_images ON m_members.profile_image_id = t_images.image_id
LEFT JOIN t_attachable_items ON t_images.attachable_item_id = t_attachable_items.attachable_item_id
WHERE organization_id = $1
AND CASE
	WHEN $3::boolean = true THEN m_members.name LIKE '%' || $4::text || '%' ELSE TRUE
END
AND CASE $5::text
	WHEN 'next' THEN
		CASE $6::text
			WHEN 'name' THEN m_members.name > $7 OR (m_members.name = $7 AND m_memberships_pkey > $8::int)
			WHEN 'r_name' THEN m_members.name < $7 OR (m_members.name = $7 AND m_memberships_pkey > $8::int)
			WHEN 'old_add' THEN m_memberships.added_at > $9 OR (m_memberships.added_at = $9 AND m_memberships_pkey > $8::int)
			WHEN 'late_add' THEN m_memberships.added_at < $9 OR (m_memberships.added_at = $9 AND m_memberships_pkey > $8::int)
			ELSE m_memberships_pkey > $8::int
		END
	WHEN 'prev' THEN
		CASE $6::text
			WHEN 'name' THEN m_members.name < $7 OR (m_members.name = $7 AND m_memberships_pkey < $8::int)
			WHEN 'r_name' THEN m_members.name > $7 OR (m_members.name = $7 AND m_memberships_pkey < $8::int)
			WHEN 'old_add' THEN m_memberships.added_at < $9 OR (m_memberships.added_at = $9 AND m_memberships_pkey < $8::int)
			WHEN 'late_add' THEN m_memberships.added_at > $9 OR (m_memberships.added_at = $9 AND m_memberships_pkey < $8::int)
			ELSE m_memberships_pkey < $8::int
		END
END
ORDER BY
	CASE WHEN $6::text = 'name' AND $5::text = 'next' THEN m_members.name END ASC NULLS LAST,
	CASE WHEN $6::text = 'name' AND $5::text = 'prev' THEN m_members.name END DESC NULLS LAST,
	CASE WHEN $6::text = 'r_name' AND $5::text = 'next' THEN m_members.name END DESC NULLS LAST,
	CASE WHEN $6::text = 'r_name' AND $5::text = 'prev' THEN m_members.name END ASC NULLS LAST,
	CASE WHEN $6::text = 'old_add' AND $5::text = 'next' THEN m_memberships.added_at END ASC NULLS LAST,
	CASE WHEN $6::text = 'old_add' AND $5::text = 'prev' THEN m_memberships.added_at END DESC NULLS LAST,
	CASE WHEN $6::text = 'late_add' AND $5::text = 'next' THEN m_memberships.added_at END DESC NULLS LAST,
	CASE WHEN $6::text = 'late_add' AND $5::text = 'prev' THEN m_memberships.added_at END ASC NULLS LAST,
	CASE WHEN $5::text = 'next' THEN m_memberships_pkey END ASC,
	CASE WHEN $5::text = 'prev' THEN m_memberships_pkey END DESC
LIMIT $2
`

type GetMembersOnOrganizationUseKeysetPaginateParams struct {
	OrganizationID  uuid.UUID `json:"organization_id"`
	Limit           int32     `json:"limit"`
	WhereLikeName   bool      `json:"where_like_name"`
	SearchName      string    `json:"search_name"`
	CursorDirection string    `json:"cursor_direction"`
	OrderMethod     string    `json:"order_method"`
	NameCursor      string    `json:"name_cursor"`
	Cursor          int32     `json:"cursor"`
	AddedAtCursor   time.Time `json:"added_at_cursor"`
}

type GetMembersOnOrganizationUseKeysetPaginateRow struct {
	MMembershipsPkey                   pgtype.Int8   `json:"m_memberships_pkey"`
	MemberID                           uuid.UUID     `json:"member_id"`
	OrganizationID                     uuid.UUID     `json:"organization_id"`
	WorkPositionID                     pgtype.UUID   `json:"work_position_id"`
	AddedAt                            time.Time     `json:"added_at"`
	MemberName                         pgtype.Text   `json:"member_name"`
	MemberFirstName                    pgtype.Text   `json:"member_first_name"`
	MemberLastName                     pgtype.Text   `json:"member_last_name"`
	MemberEmail                        pgtype.Text   `json:"member_email"`
	MemberGradeID                      pgtype.UUID   `json:"member_grade_id"`
	MemberGroupID                      pgtype.UUID   `json:"member_group_id"`
	MemberProfileImageID               pgtype.UUID   `json:"member_profile_image_id"`
	MemberProfileImageHeight           pgtype.Float8 `json:"member_profile_image_height"`
	MemberProfileImageWidth            pgtype.Float8 `json:"member_profile_image_width"`
	MemberProfileImageAttachableItemID pgtype.UUID   `json:"member_profile_image_attachable_item_id"`
	MemberProfileImageOwnerID          pgtype.UUID   `json:"member_profile_image_owner_id"`
	MemberProfileImageFromOuter        pgtype.Bool   `json:"member_profile_image_from_outer"`
	MemberProfileImageAlias            pgtype.Text   `json:"member_profile_image_alias"`
	MemberProfileImageUrl              pgtype.Text   `json:"member_profile_image_url"`
	MemberProfileImageSize             pgtype.Float8 `json:"member_profile_image_size"`
	MemberProfileImageMimeTypeID       pgtype.UUID   `json:"member_profile_image_mime_type_id"`
}

func (q *Queries) GetMembersOnOrganizationUseKeysetPaginate(ctx context.Context, arg GetMembersOnOrganizationUseKeysetPaginateParams) ([]GetMembersOnOrganizationUseKeysetPaginateRow, error) {
	rows, err := q.db.Query(ctx, getMembersOnOrganizationUseKeysetPaginate,
		arg.OrganizationID,
		arg.Limit,
		arg.WhereLikeName,
		arg.SearchName,
		arg.CursorDirection,
		arg.OrderMethod,
		arg.NameCursor,
		arg.Cursor,
		arg.AddedAtCursor,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMembersOnOrganizationUseKeysetPaginateRow{}
	for rows.Next() {
		var i GetMembersOnOrganizationUseKeysetPaginateRow
		if err := rows.Scan(
			&i.MMembershipsPkey,
			&i.MemberID,
			&i.OrganizationID,
			&i.WorkPositionID,
			&i.AddedAt,
			&i.MemberName,
			&i.MemberFirstName,
			&i.MemberLastName,
			&i.MemberEmail,
			&i.MemberGradeID,
			&i.MemberGroupID,
			&i.MemberProfileImageID,
			&i.MemberProfileImageHeight,
			&i.MemberProfileImageWidth,
			&i.MemberProfileImageAttachableItemID,
			&i.MemberProfileImageOwnerID,
			&i.MemberProfileImageFromOuter,
			&i.MemberProfileImageAlias,
			&i.MemberProfileImageUrl,
			&i.MemberProfileImageSize,
			&i.MemberProfileImageMimeTypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMembersOnOrganizationUseNumberedPaginate = `-- name: GetMembersOnOrganizationUseNumberedPaginate :many
SELECT m_memberships.m_memberships_pkey, m_memberships.member_id, m_memberships.organization_id, m_memberships.work_position_id, m_memberships.added_at, m_members.name member_name, m_members.first_name member_first_name, m_members.last_name member_last_name, m_members.email member_email, m_members.grade_id member_grade_id, m_members.group_id member_group_id,
m_members.profile_image_id member_profile_image_id, t_images.height member_profile_image_height,
t_images.width member_profile_image_width, t_images.attachable_item_id member_profile_image_attachable_item_id,
t_attachable_items.owner_id member_profile_image_owner_id, t_attachable_items.from_outer member_profile_image_from_outer, t_attachable_items.alias member_profile_image_alias,
t_attachable_items.url member_profile_image_url, t_attachable_items.size member_profile_image_size, t_attachable_items.mime_type_id member_profile_image_mime_type_id FROM m_memberships
LEFT JOIN m_members ON m_memberships.member_id = m_members.member_id
LEFT JOIN t_images ON m_members.profile_image_id = t_images.image_id
LEFT JOIN t_attachable_items ON t_images.attachable_item_id = t_attachable_items.attachable_item_id
WHERE organization_id = $1
AND CASE
	WHEN $4::boolean = true THEN m_members.name LIKE '%' || $5::text || '%' ELSE TRUE
END
ORDER BY
	CASE WHEN $6::text = 'name' THEN m_members.name END ASC NULLS LAST,
	CASE WHEN $6::text = 'r_name' THEN m_members.name END DESC NULLS LAST,
	CASE WHEN $6::text = 'old_add' THEN m_memberships.added_at END ASC NULLS LAST,
	CASE WHEN $6::text = 'late_add' THEN m_memberships.added_at END DESC NULLS LAST,
	m_memberships_pkey ASC
LIMIT $2 OFFSET $3
`

type GetMembersOnOrganizationUseNumberedPaginateParams struct {
	OrganizationID uuid.UUID `json:"organization_id"`
	Limit          int32     `json:"limit"`
	Offset         int32     `json:"offset"`
	WhereLikeName  bool      `json:"where_like_name"`
	SearchName     string    `json:"search_name"`
	OrderMethod    string    `json:"order_method"`
}

type GetMembersOnOrganizationUseNumberedPaginateRow struct {
	MMembershipsPkey                   pgtype.Int8   `json:"m_memberships_pkey"`
	MemberID                           uuid.UUID     `json:"member_id"`
	OrganizationID                     uuid.UUID     `json:"organization_id"`
	WorkPositionID                     pgtype.UUID   `json:"work_position_id"`
	AddedAt                            time.Time     `json:"added_at"`
	MemberName                         pgtype.Text   `json:"member_name"`
	MemberFirstName                    pgtype.Text   `json:"member_first_name"`
	MemberLastName                     pgtype.Text   `json:"member_last_name"`
	MemberEmail                        pgtype.Text   `json:"member_email"`
	MemberGradeID                      pgtype.UUID   `json:"member_grade_id"`
	MemberGroupID                      pgtype.UUID   `json:"member_group_id"`
	MemberProfileImageID               pgtype.UUID   `json:"member_profile_image_id"`
	MemberProfileImageHeight           pgtype.Float8 `json:"member_profile_image_height"`
	MemberProfileImageWidth            pgtype.Float8 `json:"member_profile_image_width"`
	MemberProfileImageAttachableItemID pgtype.UUID   `json:"member_profile_image_attachable_item_id"`
	MemberProfileImageOwnerID          pgtype.UUID   `json:"member_profile_image_owner_id"`
	MemberProfileImageFromOuter        pgtype.Bool   `json:"member_profile_image_from_outer"`
	MemberProfileImageAlias            pgtype.Text   `json:"member_profile_image_alias"`
	MemberProfileImageUrl              pgtype.Text   `json:"member_profile_image_url"`
	MemberProfileImageSize             pgtype.Float8 `json:"member_profile_image_size"`
	MemberProfileImageMimeTypeID       pgtype.UUID   `json:"member_profile_image_mime_type_id"`
}

func (q *Queries) GetMembersOnOrganizationUseNumberedPaginate(ctx context.Context, arg GetMembersOnOrganizationUseNumberedPaginateParams) ([]GetMembersOnOrganizationUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getMembersOnOrganizationUseNumberedPaginate,
		arg.OrganizationID,
		arg.Limit,
		arg.Offset,
		arg.WhereLikeName,
		arg.SearchName,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMembersOnOrganizationUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetMembersOnOrganizationUseNumberedPaginateRow
		if err := rows.Scan(
			&i.MMembershipsPkey,
			&i.MemberID,
			&i.OrganizationID,
			&i.WorkPositionID,
			&i.AddedAt,
			&i.MemberName,
			&i.MemberFirstName,
			&i.MemberLastName,
			&i.MemberEmail,
			&i.MemberGradeID,
			&i.MemberGroupID,
			&i.MemberProfileImageID,
			&i.MemberProfileImageHeight,
			&i.MemberProfileImageWidth,
			&i.MemberProfileImageAttachableItemID,
			&i.MemberProfileImageOwnerID,
			&i.MemberProfileImageFromOuter,
			&i.MemberProfileImageAlias,
			&i.MemberProfileImageUrl,
			&i.MemberProfileImageSize,
			&i.MemberProfileImageMimeTypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrganizationsOnMember = `-- name: GetOrganizationsOnMember :many
SELECT m_memberships.m_memberships_pkey, m_memberships.member_id, m_memberships.organization_id, m_memberships.work_position_id, m_memberships.added_at, m_organizations.name organization_name, m_organizations.description organization_description,
m_organizations.color organization_color, m_organizations.is_personal organization_is_personal, m_organizations.is_whole organization_is_whole,
m_organizations.chat_room_id organization_chat_room_id
FROM m_memberships
LEFT JOIN m_organizations ON m_memberships.organization_id = m_organizations.organization_id
WHERE member_id = $1
AND CASE
	WHEN $2::boolean = true THEN m_organization.name LIKE '%' || $3::text || '%'
END
ORDER BY
	CASE WHEN $4::text = 'name' THEN m_organizations.name END ASC NULLS LAST,
	CASE WHEN $4::text = 'r_name' THEN m_organizations.name END DESC NULLS LAST,
	CASE WHEN $4::text = 'old_add' THEN m_memberships.added_at END ASC NULLS LAST,
	CASE WHEN $4::text = 'late_add' THEN m_memberships.added_at END DESC NULLS LAST,
	m_memberships_pkey ASC
`

type GetOrganizationsOnMemberParams struct {
	MemberID      uuid.UUID `json:"member_id"`
	WhereLikeName bool      `json:"where_like_name"`
	SearchName    string    `json:"search_name"`
	OrderMethod   string    `json:"order_method"`
}

type GetOrganizationsOnMemberRow struct {
	MMembershipsPkey        pgtype.Int8 `json:"m_memberships_pkey"`
	MemberID                uuid.UUID   `json:"member_id"`
	OrganizationID          uuid.UUID   `json:"organization_id"`
	WorkPositionID          pgtype.UUID `json:"work_position_id"`
	AddedAt                 time.Time   `json:"added_at"`
	OrganizationName        pgtype.Text `json:"organization_name"`
	OrganizationDescription pgtype.Text `json:"organization_description"`
	OrganizationColor       pgtype.Text `json:"organization_color"`
	OrganizationIsPersonal  pgtype.Bool `json:"organization_is_personal"`
	OrganizationIsWhole     pgtype.Bool `json:"organization_is_whole"`
	OrganizationChatRoomID  pgtype.UUID `json:"organization_chat_room_id"`
}

func (q *Queries) GetOrganizationsOnMember(ctx context.Context, arg GetOrganizationsOnMemberParams) ([]GetOrganizationsOnMemberRow, error) {
	rows, err := q.db.Query(ctx, getOrganizationsOnMember,
		arg.MemberID,
		arg.WhereLikeName,
		arg.SearchName,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOrganizationsOnMemberRow{}
	for rows.Next() {
		var i GetOrganizationsOnMemberRow
		if err := rows.Scan(
			&i.MMembershipsPkey,
			&i.MemberID,
			&i.OrganizationID,
			&i.WorkPositionID,
			&i.AddedAt,
			&i.OrganizationName,
			&i.OrganizationDescription,
			&i.OrganizationColor,
			&i.OrganizationIsPersonal,
			&i.OrganizationIsWhole,
			&i.OrganizationChatRoomID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrganizationsOnMemberUseKeysetPaginate = `-- name: GetOrganizationsOnMemberUseKeysetPaginate :many
SELECT m_memberships.m_memberships_pkey, m_memberships.member_id, m_memberships.organization_id, m_memberships.work_position_id, m_memberships.added_at, m_organizations.name organization_name, m_organizations.description organization_description,
m_organizations.color organization_color, m_organizations.is_personal organization_is_personal, m_organizations.is_whole organization_is_whole,
m_organizations.chat_room_id organization_chat_room_id
FROM m_memberships
LEFT JOIN m_organizations ON m_memberships.organization_id = m_organizations.organization_id
WHERE member_id = $1
AND CASE
	WHEN $3::boolean = true THEN m_organization.name LIKE '%' || $4::text || '%'
END
AND CASE $5::text
	WHEN 'next' THEN
		CASE $6::text
			WHEN 'name' THEN m_organizations.name > $7 OR (m_organizations.name = $7 AND m_memberships_pkey > $8::int)
			WHEN 'r_name' THEN m_organizations.name < $7 OR (m_organizations.name = $7 AND m_memberships_pkey > $8::int)
			WHEN 'old_add' THEN m_memberships.added_at > $9 OR (m_memberships.added_at = $9 AND m_memberships_pkey > $8::int)
			WHEN 'late_add' THEN m_memberships.added_at < $9 OR (m_memberships.added_at = $9 AND m_memberships_pkey > $8::int)
			ELSE m_memberships_pkey > $8::int
		END
	WHEN 'prev' THEN
		CASE $6::text
			WHEN 'name' THEN m_organizations.name < $7 OR (m_organizations.name = $7 AND m_memberships_pkey < $8::int)
			WHEN 'r_name' THEN m_organizations.name > $7 OR (m_organizations.name = $7 AND m_memberships_pkey < $8::int)
			WHEN 'old_add' THEN m_memberships.added_at < $9 OR (m_memberships.added_at = $9 AND m_memberships_pkey < $8::int)
			WHEN 'late_add' THEN m_memberships.added_at > $9 OR (m_memberships.added_at = $9 AND m_memberships_pkey < $8::int)
			ELSE m_memberships_pkey < $8::int
		END
END
ORDER BY
	CASE WHEN $6::text = 'name' AND $5::text = 'next' THEN m_organizations.name END ASC NULLS LAST,
	CASE WHEN $6::text = 'name' AND $5::text = 'prev' THEN m_organizations.name END DESC NULLS LAST,
	CASE WHEN $6::text = 'r_name' AND $5::text = 'next' THEN m_organizations.name END DESC NULLS LAST,
	CASE WHEN $6::text = 'r_name' AND $5::text = 'prev' THEN m_organizations.name END ASC NULLS LAST,
	CASE WHEN $6::text = 'old_add' AND $5::text = 'next' THEN m_memberships.added_at END ASC NULLS LAST,
	CASE WHEN $6::text = 'old_add' AND $5::text = 'prev' THEN m_memberships.added_at END DESC NULLS LAST,
	CASE WHEN $6::text = 'late_add' AND $5::text = 'next' THEN m_memberships.added_at END DESC NULLS LAST,
	CASE WHEN $6::text = 'late_add' AND $5::text = 'prev' THEN m_memberships.added_at END ASC NULLS LAST,
	CASE WHEN $5::text = 'next' THEN m_memberships_pkey END ASC,
	CASE WHEN $5::text = 'prev' THEN m_memberships_pkey END DESC
LIMIT $2
`

type GetOrganizationsOnMemberUseKeysetPaginateParams struct {
	MemberID        uuid.UUID `json:"member_id"`
	Limit           int32     `json:"limit"`
	WhereLikeName   bool      `json:"where_like_name"`
	SearchName      string    `json:"search_name"`
	CursorDirection string    `json:"cursor_direction"`
	OrderMethod     string    `json:"order_method"`
	NameCursor      string    `json:"name_cursor"`
	Cursor          int32     `json:"cursor"`
	AddCursor       time.Time `json:"add_cursor"`
}

type GetOrganizationsOnMemberUseKeysetPaginateRow struct {
	MMembershipsPkey        pgtype.Int8 `json:"m_memberships_pkey"`
	MemberID                uuid.UUID   `json:"member_id"`
	OrganizationID          uuid.UUID   `json:"organization_id"`
	WorkPositionID          pgtype.UUID `json:"work_position_id"`
	AddedAt                 time.Time   `json:"added_at"`
	OrganizationName        pgtype.Text `json:"organization_name"`
	OrganizationDescription pgtype.Text `json:"organization_description"`
	OrganizationColor       pgtype.Text `json:"organization_color"`
	OrganizationIsPersonal  pgtype.Bool `json:"organization_is_personal"`
	OrganizationIsWhole     pgtype.Bool `json:"organization_is_whole"`
	OrganizationChatRoomID  pgtype.UUID `json:"organization_chat_room_id"`
}

func (q *Queries) GetOrganizationsOnMemberUseKeysetPaginate(ctx context.Context, arg GetOrganizationsOnMemberUseKeysetPaginateParams) ([]GetOrganizationsOnMemberUseKeysetPaginateRow, error) {
	rows, err := q.db.Query(ctx, getOrganizationsOnMemberUseKeysetPaginate,
		arg.MemberID,
		arg.Limit,
		arg.WhereLikeName,
		arg.SearchName,
		arg.CursorDirection,
		arg.OrderMethod,
		arg.NameCursor,
		arg.Cursor,
		arg.AddCursor,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOrganizationsOnMemberUseKeysetPaginateRow{}
	for rows.Next() {
		var i GetOrganizationsOnMemberUseKeysetPaginateRow
		if err := rows.Scan(
			&i.MMembershipsPkey,
			&i.MemberID,
			&i.OrganizationID,
			&i.WorkPositionID,
			&i.AddedAt,
			&i.OrganizationName,
			&i.OrganizationDescription,
			&i.OrganizationColor,
			&i.OrganizationIsPersonal,
			&i.OrganizationIsWhole,
			&i.OrganizationChatRoomID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrganizationsOnMemberUseNumberedPaginate = `-- name: GetOrganizationsOnMemberUseNumberedPaginate :many
SELECT m_memberships.m_memberships_pkey, m_memberships.member_id, m_memberships.organization_id, m_memberships.work_position_id, m_memberships.added_at, m_organizations.name organization_name, m_organizations.description organization_description,
m_organizations.color organization_color, m_organizations.is_personal organization_is_personal, m_organizations.is_whole organization_is_whole,
m_organizations.chat_room_id organization_chat_room_id
FROM m_memberships
LEFT JOIN m_organizations ON m_memberships.organization_id = m_organizations.organization_id
WHERE member_id = $1
AND CASE
	WHEN $4::boolean = true THEN m_organization.name LIKE '%' || $5::text || '%'
END
ORDER BY
	CASE WHEN $6::text = 'name' THEN m_organizations.name END ASC NULLS LAST,
	CASE WHEN $6::text = 'r_name' THEN m_organizations.name END DESC NULLS LAST,
	CASE WHEN $6::text = 'old_add' THEN m_memberships.added_at END ASC NULLS LAST,
	CASE WHEN $6::text = 'late_add' THEN m_memberships.added_at END DESC NULLS LAST,
	m_memberships_pkey ASC
LIMIT $2 OFFSET $3
`

type GetOrganizationsOnMemberUseNumberedPaginateParams struct {
	MemberID      uuid.UUID `json:"member_id"`
	Limit         int32     `json:"limit"`
	Offset        int32     `json:"offset"`
	WhereLikeName bool      `json:"where_like_name"`
	SearchName    string    `json:"search_name"`
	OrderMethod   string    `json:"order_method"`
}

type GetOrganizationsOnMemberUseNumberedPaginateRow struct {
	MMembershipsPkey        pgtype.Int8 `json:"m_memberships_pkey"`
	MemberID                uuid.UUID   `json:"member_id"`
	OrganizationID          uuid.UUID   `json:"organization_id"`
	WorkPositionID          pgtype.UUID `json:"work_position_id"`
	AddedAt                 time.Time   `json:"added_at"`
	OrganizationName        pgtype.Text `json:"organization_name"`
	OrganizationDescription pgtype.Text `json:"organization_description"`
	OrganizationColor       pgtype.Text `json:"organization_color"`
	OrganizationIsPersonal  pgtype.Bool `json:"organization_is_personal"`
	OrganizationIsWhole     pgtype.Bool `json:"organization_is_whole"`
	OrganizationChatRoomID  pgtype.UUID `json:"organization_chat_room_id"`
}

func (q *Queries) GetOrganizationsOnMemberUseNumberedPaginate(ctx context.Context, arg GetOrganizationsOnMemberUseNumberedPaginateParams) ([]GetOrganizationsOnMemberUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getOrganizationsOnMemberUseNumberedPaginate,
		arg.MemberID,
		arg.Limit,
		arg.Offset,
		arg.WhereLikeName,
		arg.SearchName,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOrganizationsOnMemberUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetOrganizationsOnMemberUseNumberedPaginateRow
		if err := rows.Scan(
			&i.MMembershipsPkey,
			&i.MemberID,
			&i.OrganizationID,
			&i.WorkPositionID,
			&i.AddedAt,
			&i.OrganizationName,
			&i.OrganizationDescription,
			&i.OrganizationColor,
			&i.OrganizationIsPersonal,
			&i.OrganizationIsWhole,
			&i.OrganizationChatRoomID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralMembersOnOrganization = `-- name: GetPluralMembersOnOrganization :many
SELECT m_memberships.m_memberships_pkey, m_memberships.member_id, m_memberships.organization_id, m_memberships.work_position_id, m_memberships.added_at, m_members.name member_name, m_members.first_name member_first_name, m_members.last_name member_last_name, m_members.email member_email, m_members.grade_id member_grade_id, m_members.group_id member_group_id,
m_members.profile_image_id member_profile_image_id, t_images.height member_profile_image_height,
t_images.width member_profile_image_width, t_images.attachable_item_id member_profile_image_attachable_item_id,
t_attachable_items.owner_id member_profile_image_owner_id, t_attachable_items.from_outer member_profile_image_from_outer, t_attachable_items.alias member_profile_image_alias,
t_attachable_items.url member_profile_image_url, t_attachable_items.size member_profile_image_size, t_attachable_items.mime_type_id member_profile_image_mime_type_id FROM m_memberships
LEFT JOIN m_members ON m_memberships.member_id = m_members.member_id
LEFT JOIN t_images ON m_members.profile_image_id = t_images.image_id
LEFT JOIN t_attachable_items ON t_images.attachable_item_id = t_attachable_items.attachable_item_id
WHERE organization_id = ANY($1::uuid[])
ORDER BY
	CASE WHEN $2::text = 'name' THEN m_members.name END ASC NULLS LAST,
	CASE WHEN $2::text = 'r_name' THEN m_members.name END DESC NULLS LAST,
	CASE WHEN $2::text = 'old_add' THEN m_memberships.added_at END ASC NULLS LAST,
	CASE WHEN $2::text = 'late_add' THEN m_memberships.added_at END DESC NULLS LAST,
	m_memberships_pkey ASC
`

type GetPluralMembersOnOrganizationParams struct {
	OrganizationIds []uuid.UUID `json:"organization_ids"`
	OrderMethod     string      `json:"order_method"`
}

type GetPluralMembersOnOrganizationRow struct {
	MMembershipsPkey                   pgtype.Int8   `json:"m_memberships_pkey"`
	MemberID                           uuid.UUID     `json:"member_id"`
	OrganizationID                     uuid.UUID     `json:"organization_id"`
	WorkPositionID                     pgtype.UUID   `json:"work_position_id"`
	AddedAt                            time.Time     `json:"added_at"`
	MemberName                         pgtype.Text   `json:"member_name"`
	MemberFirstName                    pgtype.Text   `json:"member_first_name"`
	MemberLastName                     pgtype.Text   `json:"member_last_name"`
	MemberEmail                        pgtype.Text   `json:"member_email"`
	MemberGradeID                      pgtype.UUID   `json:"member_grade_id"`
	MemberGroupID                      pgtype.UUID   `json:"member_group_id"`
	MemberProfileImageID               pgtype.UUID   `json:"member_profile_image_id"`
	MemberProfileImageHeight           pgtype.Float8 `json:"member_profile_image_height"`
	MemberProfileImageWidth            pgtype.Float8 `json:"member_profile_image_width"`
	MemberProfileImageAttachableItemID pgtype.UUID   `json:"member_profile_image_attachable_item_id"`
	MemberProfileImageOwnerID          pgtype.UUID   `json:"member_profile_image_owner_id"`
	MemberProfileImageFromOuter        pgtype.Bool   `json:"member_profile_image_from_outer"`
	MemberProfileImageAlias            pgtype.Text   `json:"member_profile_image_alias"`
	MemberProfileImageUrl              pgtype.Text   `json:"member_profile_image_url"`
	MemberProfileImageSize             pgtype.Float8 `json:"member_profile_image_size"`
	MemberProfileImageMimeTypeID       pgtype.UUID   `json:"member_profile_image_mime_type_id"`
}

func (q *Queries) GetPluralMembersOnOrganization(ctx context.Context, arg GetPluralMembersOnOrganizationParams) ([]GetPluralMembersOnOrganizationRow, error) {
	rows, err := q.db.Query(ctx, getPluralMembersOnOrganization, arg.OrganizationIds, arg.OrderMethod)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralMembersOnOrganizationRow{}
	for rows.Next() {
		var i GetPluralMembersOnOrganizationRow
		if err := rows.Scan(
			&i.MMembershipsPkey,
			&i.MemberID,
			&i.OrganizationID,
			&i.WorkPositionID,
			&i.AddedAt,
			&i.MemberName,
			&i.MemberFirstName,
			&i.MemberLastName,
			&i.MemberEmail,
			&i.MemberGradeID,
			&i.MemberGroupID,
			&i.MemberProfileImageID,
			&i.MemberProfileImageHeight,
			&i.MemberProfileImageWidth,
			&i.MemberProfileImageAttachableItemID,
			&i.MemberProfileImageOwnerID,
			&i.MemberProfileImageFromOuter,
			&i.MemberProfileImageAlias,
			&i.MemberProfileImageUrl,
			&i.MemberProfileImageSize,
			&i.MemberProfileImageMimeTypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralMembersOnOrganizationUseNumberedPaginate = `-- name: GetPluralMembersOnOrganizationUseNumberedPaginate :many
SELECT m_memberships.m_memberships_pkey, m_memberships.member_id, m_memberships.organization_id, m_memberships.work_position_id, m_memberships.added_at, m_members.name member_name, m_members.first_name member_first_name, m_members.last_name member_last_name, m_members.email member_email, m_members.grade_id member_grade_id, m_members.group_id member_group_id,
m_members.profile_image_id member_profile_image_id, t_images.height member_profile_image_height,
t_images.width member_profile_image_width, t_images.attachable_item_id member_profile_image_attachable_item_id,
t_attachable_items.owner_id member_profile_image_owner_id, t_attachable_items.from_outer member_profile_image_from_outer, t_attachable_items.alias member_profile_image_alias,
t_attachable_items.url member_profile_image_url, t_attachable_items.size member_profile_image_size, t_attachable_items.mime_type_id member_profile_image_mime_type_id FROM m_memberships
LEFT JOIN m_members ON m_memberships.member_id = m_members.member_id
LEFT JOIN t_images ON m_members.profile_image_id = t_images.image_id
LEFT JOIN t_attachable_items ON t_images.attachable_item_id = t_attachable_items.attachable_item_id
WHERE organization_id = ANY($3::uuid[])
ORDER BY
	CASE WHEN $4::text = 'name' THEN m_members.name END ASC NULLS LAST,
	CASE WHEN $4::text = 'r_name' THEN m_members.name END DESC NULLS LAST,
	CASE WHEN $4::text = 'old_add' THEN m_memberships.added_at END ASC NULLS LAST,
	CASE WHEN $4::text = 'late_add' THEN m_memberships.added_at END DESC NULLS LAST,
	m_memberships_pkey ASC
LIMIT $1 OFFSET $2
`

type GetPluralMembersOnOrganizationUseNumberedPaginateParams struct {
	Limit           int32       `json:"limit"`
	Offset          int32       `json:"offset"`
	OrganizationIds []uuid.UUID `json:"organization_ids"`
	OrderMethod     string      `json:"order_method"`
}

type GetPluralMembersOnOrganizationUseNumberedPaginateRow struct {
	MMembershipsPkey                   pgtype.Int8   `json:"m_memberships_pkey"`
	MemberID                           uuid.UUID     `json:"member_id"`
	OrganizationID                     uuid.UUID     `json:"organization_id"`
	WorkPositionID                     pgtype.UUID   `json:"work_position_id"`
	AddedAt                            time.Time     `json:"added_at"`
	MemberName                         pgtype.Text   `json:"member_name"`
	MemberFirstName                    pgtype.Text   `json:"member_first_name"`
	MemberLastName                     pgtype.Text   `json:"member_last_name"`
	MemberEmail                        pgtype.Text   `json:"member_email"`
	MemberGradeID                      pgtype.UUID   `json:"member_grade_id"`
	MemberGroupID                      pgtype.UUID   `json:"member_group_id"`
	MemberProfileImageID               pgtype.UUID   `json:"member_profile_image_id"`
	MemberProfileImageHeight           pgtype.Float8 `json:"member_profile_image_height"`
	MemberProfileImageWidth            pgtype.Float8 `json:"member_profile_image_width"`
	MemberProfileImageAttachableItemID pgtype.UUID   `json:"member_profile_image_attachable_item_id"`
	MemberProfileImageOwnerID          pgtype.UUID   `json:"member_profile_image_owner_id"`
	MemberProfileImageFromOuter        pgtype.Bool   `json:"member_profile_image_from_outer"`
	MemberProfileImageAlias            pgtype.Text   `json:"member_profile_image_alias"`
	MemberProfileImageUrl              pgtype.Text   `json:"member_profile_image_url"`
	MemberProfileImageSize             pgtype.Float8 `json:"member_profile_image_size"`
	MemberProfileImageMimeTypeID       pgtype.UUID   `json:"member_profile_image_mime_type_id"`
}

func (q *Queries) GetPluralMembersOnOrganizationUseNumberedPaginate(ctx context.Context, arg GetPluralMembersOnOrganizationUseNumberedPaginateParams) ([]GetPluralMembersOnOrganizationUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getPluralMembersOnOrganizationUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.OrganizationIds,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralMembersOnOrganizationUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetPluralMembersOnOrganizationUseNumberedPaginateRow
		if err := rows.Scan(
			&i.MMembershipsPkey,
			&i.MemberID,
			&i.OrganizationID,
			&i.WorkPositionID,
			&i.AddedAt,
			&i.MemberName,
			&i.MemberFirstName,
			&i.MemberLastName,
			&i.MemberEmail,
			&i.MemberGradeID,
			&i.MemberGroupID,
			&i.MemberProfileImageID,
			&i.MemberProfileImageHeight,
			&i.MemberProfileImageWidth,
			&i.MemberProfileImageAttachableItemID,
			&i.MemberProfileImageOwnerID,
			&i.MemberProfileImageFromOuter,
			&i.MemberProfileImageAlias,
			&i.MemberProfileImageUrl,
			&i.MemberProfileImageSize,
			&i.MemberProfileImageMimeTypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralOrganizationsOnMember = `-- name: GetPluralOrganizationsOnMember :many
SELECT m_memberships.m_memberships_pkey, m_memberships.member_id, m_memberships.organization_id, m_memberships.work_position_id, m_memberships.added_at, m_organizations.name organization_name, m_organizations.description organization_description,
m_organizations.color organization_color, m_organizations.is_personal organization_is_personal, m_organizations.is_whole organization_is_whole,
m_organizations.chat_room_id organization_chat_room_id
FROM m_memberships
LEFT JOIN m_organizations ON m_memberships.organization_id = m_organizations.organization_id
WHERE member_id = ANY($1::uuid[])
ORDER BY
	CASE WHEN $2::text = 'name' THEN m_organizations.name END ASC NULLS LAST,
	CASE WHEN $2::text = 'r_name' THEN m_organizations.name END DESC NULLS LAST,
	CASE WHEN $2::text = 'old_add' THEN m_memberships.added_at END ASC NULLS LAST,
	CASE WHEN $2::text = 'late_add' THEN m_memberships.added_at END DESC NULLS LAST,
	m_memberships_pkey ASC
`

type GetPluralOrganizationsOnMemberParams struct {
	MemberIds   []uuid.UUID `json:"member_ids"`
	OrderMethod string      `json:"order_method"`
}

type GetPluralOrganizationsOnMemberRow struct {
	MMembershipsPkey        pgtype.Int8 `json:"m_memberships_pkey"`
	MemberID                uuid.UUID   `json:"member_id"`
	OrganizationID          uuid.UUID   `json:"organization_id"`
	WorkPositionID          pgtype.UUID `json:"work_position_id"`
	AddedAt                 time.Time   `json:"added_at"`
	OrganizationName        pgtype.Text `json:"organization_name"`
	OrganizationDescription pgtype.Text `json:"organization_description"`
	OrganizationColor       pgtype.Text `json:"organization_color"`
	OrganizationIsPersonal  pgtype.Bool `json:"organization_is_personal"`
	OrganizationIsWhole     pgtype.Bool `json:"organization_is_whole"`
	OrganizationChatRoomID  pgtype.UUID `json:"organization_chat_room_id"`
}

func (q *Queries) GetPluralOrganizationsOnMember(ctx context.Context, arg GetPluralOrganizationsOnMemberParams) ([]GetPluralOrganizationsOnMemberRow, error) {
	rows, err := q.db.Query(ctx, getPluralOrganizationsOnMember, arg.MemberIds, arg.OrderMethod)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralOrganizationsOnMemberRow{}
	for rows.Next() {
		var i GetPluralOrganizationsOnMemberRow
		if err := rows.Scan(
			&i.MMembershipsPkey,
			&i.MemberID,
			&i.OrganizationID,
			&i.WorkPositionID,
			&i.AddedAt,
			&i.OrganizationName,
			&i.OrganizationDescription,
			&i.OrganizationColor,
			&i.OrganizationIsPersonal,
			&i.OrganizationIsWhole,
			&i.OrganizationChatRoomID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralOrganizationsOnMemberUseNumberedPaginate = `-- name: GetPluralOrganizationsOnMemberUseNumberedPaginate :many
SELECT m_memberships.m_memberships_pkey, m_memberships.member_id, m_memberships.organization_id, m_memberships.work_position_id, m_memberships.added_at, m_organizations.name organization_name, m_organizations.description organization_description,
m_organizations.color organization_color, m_organizations.is_personal organization_is_personal, m_organizations.is_whole organization_is_whole,
m_organizations.chat_room_id organization_chat_room_id
FROM m_memberships
LEFT JOIN m_organizations ON m_memberships.organization_id = m_organizations.organization_id
WHERE member_id = ANY($3::uuid[])
ORDER BY
	CASE WHEN $4::text = 'name' THEN m_organizations.name END ASC NULLS LAST,
	CASE WHEN $4::text = 'r_name' THEN m_organizations.name END DESC NULLS LAST,
	CASE WHEN $4::text = 'old_add' THEN m_memberships.added_at END ASC NULLS LAST,
	CASE WHEN $4::text = 'late_add' THEN m_memberships.added_at END DESC NULLS LAST,
	m_memberships_pkey ASC
LIMIT $1 OFFSET $2
`

type GetPluralOrganizationsOnMemberUseNumberedPaginateParams struct {
	Limit       int32       `json:"limit"`
	Offset      int32       `json:"offset"`
	MemberIds   []uuid.UUID `json:"member_ids"`
	OrderMethod string      `json:"order_method"`
}

type GetPluralOrganizationsOnMemberUseNumberedPaginateRow struct {
	MMembershipsPkey        pgtype.Int8 `json:"m_memberships_pkey"`
	MemberID                uuid.UUID   `json:"member_id"`
	OrganizationID          uuid.UUID   `json:"organization_id"`
	WorkPositionID          pgtype.UUID `json:"work_position_id"`
	AddedAt                 time.Time   `json:"added_at"`
	OrganizationName        pgtype.Text `json:"organization_name"`
	OrganizationDescription pgtype.Text `json:"organization_description"`
	OrganizationColor       pgtype.Text `json:"organization_color"`
	OrganizationIsPersonal  pgtype.Bool `json:"organization_is_personal"`
	OrganizationIsWhole     pgtype.Bool `json:"organization_is_whole"`
	OrganizationChatRoomID  pgtype.UUID `json:"organization_chat_room_id"`
}

func (q *Queries) GetPluralOrganizationsOnMemberUseNumberedPaginate(ctx context.Context, arg GetPluralOrganizationsOnMemberUseNumberedPaginateParams) ([]GetPluralOrganizationsOnMemberUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getPluralOrganizationsOnMemberUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.MemberIds,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralOrganizationsOnMemberUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetPluralOrganizationsOnMemberUseNumberedPaginateRow
		if err := rows.Scan(
			&i.MMembershipsPkey,
			&i.MemberID,
			&i.OrganizationID,
			&i.WorkPositionID,
			&i.AddedAt,
			&i.OrganizationName,
			&i.OrganizationDescription,
			&i.OrganizationColor,
			&i.OrganizationIsPersonal,
			&i.OrganizationIsWhole,
			&i.OrganizationChatRoomID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const pluralDeleteMembershipsOnMember = `-- name: PluralDeleteMembershipsOnMember :execrows
DELETE FROM m_memberships WHERE member_id = $1 AND organization_id = ANY($2::uuid[])
`

type PluralDeleteMembershipsOnMemberParams struct {
	MemberID        uuid.UUID   `json:"member_id"`
	OrganizationIds []uuid.UUID `json:"organization_ids"`
}

func (q *Queries) PluralDeleteMembershipsOnMember(ctx context.Context, arg PluralDeleteMembershipsOnMemberParams) (int64, error) {
	result, err := q.db.Exec(ctx, pluralDeleteMembershipsOnMember, arg.MemberID, arg.OrganizationIds)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const pluralDeleteMembershipsOnOrganization = `-- name: PluralDeleteMembershipsOnOrganization :execrows
DELETE FROM m_memberships WHERE member_id = ANY($2::uuid[]) AND organization_id = $1
`

type PluralDeleteMembershipsOnOrganizationParams struct {
	OrganizationID uuid.UUID   `json:"organization_id"`
	MemberIds      []uuid.UUID `json:"member_ids"`
}

func (q *Queries) PluralDeleteMembershipsOnOrganization(ctx context.Context, arg PluralDeleteMembershipsOnOrganizationParams) (int64, error) {
	result, err := q.db.Exec(ctx, pluralDeleteMembershipsOnOrganization, arg.OrganizationID, arg.MemberIds)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
