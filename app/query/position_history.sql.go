// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: position_history.sql

package query

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const countPositionHistories = `-- name: CountPositionHistories :one
SELECT COUNT(*) FROM t_position_histories
WHERE
	CASE WHEN $1::boolean = true THEN member_id = ANY($2::uuid[]) ELSE TRUE END
AND
	CASE WHEN $3::boolean = true THEN sent_at >= $4 ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN sent_at <= $6 ELSE TRUE END
`

type CountPositionHistoriesParams struct {
	WhereInMember      bool        `json:"where_in_member"`
	InMemberIds        []uuid.UUID `json:"in_member_ids"`
	WhereEarlierSentAt bool        `json:"where_earlier_sent_at"`
	EarlierSentAt      time.Time   `json:"earlier_sent_at"`
	WhereLaterSentAt   bool        `json:"where_later_sent_at"`
	LaterSentAt        time.Time   `json:"later_sent_at"`
}

func (q *Queries) CountPositionHistories(ctx context.Context, arg CountPositionHistoriesParams) (int64, error) {
	row := q.db.QueryRow(ctx, countPositionHistories,
		arg.WhereInMember,
		arg.InMemberIds,
		arg.WhereEarlierSentAt,
		arg.EarlierSentAt,
		arg.WhereLaterSentAt,
		arg.LaterSentAt,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

type CreatePositionHistoriesParams struct {
	MemberID uuid.UUID `json:"member_id"`
	XPos     float64   `json:"x_pos"`
	YPos     float64   `json:"y_pos"`
	SentAt   time.Time `json:"sent_at"`
}

const createPositionHistory = `-- name: CreatePositionHistory :one
INSERT INTO t_position_histories (member_id, x_pos, y_pos, sent_at) VALUES ($1, $2, $3, $4) RETURNING t_position_histories_pkey, position_history_id, member_id, x_pos, y_pos, sent_at
`

type CreatePositionHistoryParams struct {
	MemberID uuid.UUID `json:"member_id"`
	XPos     float64   `json:"x_pos"`
	YPos     float64   `json:"y_pos"`
	SentAt   time.Time `json:"sent_at"`
}

func (q *Queries) CreatePositionHistory(ctx context.Context, arg CreatePositionHistoryParams) (PositionHistory, error) {
	row := q.db.QueryRow(ctx, createPositionHistory,
		arg.MemberID,
		arg.XPos,
		arg.YPos,
		arg.SentAt,
	)
	var i PositionHistory
	err := row.Scan(
		&i.TPositionHistoriesPkey,
		&i.PositionHistoryID,
		&i.MemberID,
		&i.XPos,
		&i.YPos,
		&i.SentAt,
	)
	return i, err
}

const deletePositionHistory = `-- name: DeletePositionHistory :exec
DELETE FROM t_position_histories WHERE position_history_id = $1
`

func (q *Queries) DeletePositionHistory(ctx context.Context, positionHistoryID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deletePositionHistory, positionHistoryID)
	return err
}

const findPositionHistoryByID = `-- name: FindPositionHistoryByID :one
SELECT t_position_histories_pkey, position_history_id, member_id, x_pos, y_pos, sent_at FROM t_position_histories WHERE position_history_id = $1
`

func (q *Queries) FindPositionHistoryByID(ctx context.Context, positionHistoryID uuid.UUID) (PositionHistory, error) {
	row := q.db.QueryRow(ctx, findPositionHistoryByID, positionHistoryID)
	var i PositionHistory
	err := row.Scan(
		&i.TPositionHistoriesPkey,
		&i.PositionHistoryID,
		&i.MemberID,
		&i.XPos,
		&i.YPos,
		&i.SentAt,
	)
	return i, err
}

const findPositionHistoryByIDWithMember = `-- name: FindPositionHistoryByIDWithMember :one
SELECT t_position_histories.t_position_histories_pkey, t_position_histories.position_history_id, t_position_histories.member_id, t_position_histories.x_pos, t_position_histories.y_pos, t_position_histories.sent_at, m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at FROM t_position_histories
LEFT JOIN m_members ON t_position_histories.member_id = m_members.member_id
WHERE position_history_id = $1
`

type FindPositionHistoryByIDWithMemberRow struct {
	PositionHistory PositionHistory `json:"position_history"`
	Member          Member          `json:"member"`
}

func (q *Queries) FindPositionHistoryByIDWithMember(ctx context.Context, positionHistoryID uuid.UUID) (FindPositionHistoryByIDWithMemberRow, error) {
	row := q.db.QueryRow(ctx, findPositionHistoryByIDWithMember, positionHistoryID)
	var i FindPositionHistoryByIDWithMemberRow
	err := row.Scan(
		&i.PositionHistory.TPositionHistoriesPkey,
		&i.PositionHistory.PositionHistoryID,
		&i.PositionHistory.MemberID,
		&i.PositionHistory.XPos,
		&i.PositionHistory.YPos,
		&i.PositionHistory.SentAt,
		&i.Member.MMembersPkey,
		&i.Member.MemberID,
		&i.Member.LoginID,
		&i.Member.Password,
		&i.Member.Email,
		&i.Member.Name,
		&i.Member.AttendStatusID,
		&i.Member.ProfileImageID,
		&i.Member.GradeID,
		&i.Member.GroupID,
		&i.Member.PersonalOrganizationID,
		&i.Member.RoleID,
		&i.Member.CreatedAt,
		&i.Member.UpdatedAt,
	)
	return i, err
}

const getPositionHistories = `-- name: GetPositionHistories :many
SELECT t_position_histories_pkey, position_history_id, member_id, x_pos, y_pos, sent_at FROM t_position_histories
WHERE
	CASE WHEN $3::boolean = true THEN member_id = ANY($4::uuid[]) ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN sent_at >= $6 ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN sent_at <= $8 ELSE TRUE END
ORDER BY
	CASE WHEN $9::text = 'old_send' THEN sent_at END ASC,
	CASE WHEN $9::text = 'late_send' THEN sent_at END DESC,
	t_position_histories_pkey DESC
LIMIT $1 OFFSET $2
`

type GetPositionHistoriesParams struct {
	Limit              int32       `json:"limit"`
	Offset             int32       `json:"offset"`
	WhereInMember      bool        `json:"where_in_member"`
	InMemberIds        []uuid.UUID `json:"in_member_ids"`
	WhereEarlierSentAt bool        `json:"where_earlier_sent_at"`
	EarlierSentAt      time.Time   `json:"earlier_sent_at"`
	WhereLaterSentAt   bool        `json:"where_later_sent_at"`
	LaterSentAt        time.Time   `json:"later_sent_at"`
	OrderMethod        string      `json:"order_method"`
}

func (q *Queries) GetPositionHistories(ctx context.Context, arg GetPositionHistoriesParams) ([]PositionHistory, error) {
	rows, err := q.db.Query(ctx, getPositionHistories,
		arg.Limit,
		arg.Offset,
		arg.WhereInMember,
		arg.InMemberIds,
		arg.WhereEarlierSentAt,
		arg.EarlierSentAt,
		arg.WhereLaterSentAt,
		arg.LaterSentAt,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PositionHistory{}
	for rows.Next() {
		var i PositionHistory
		if err := rows.Scan(
			&i.TPositionHistoriesPkey,
			&i.PositionHistoryID,
			&i.MemberID,
			&i.XPos,
			&i.YPos,
			&i.SentAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPositionHistoriesWithMember = `-- name: GetPositionHistoriesWithMember :many
SELECT t_position_histories.t_position_histories_pkey, t_position_histories.position_history_id, t_position_histories.member_id, t_position_histories.x_pos, t_position_histories.y_pos, t_position_histories.sent_at, m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at FROM t_position_histories
LEFT JOIN m_members ON t_position_histories.member_id = m_members.member_id
WHERE
	CASE WHEN $3::boolean = true THEN member_id = ANY($4::uuid[]) ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN sent_at >= $6 ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN sent_at <= $8 ELSE TRUE END
ORDER BY
	CASE WHEN $9::text = 'old_send' THEN sent_at END ASC,
	CASE WHEN $9::text = 'late_send' THEN sent_at END DESC,
	t_position_histories_pkey DESC
LIMIT $1 OFFSET $2
`

type GetPositionHistoriesWithMemberParams struct {
	Limit              int32       `json:"limit"`
	Offset             int32       `json:"offset"`
	WhereInMember      bool        `json:"where_in_member"`
	InMemberIds        []uuid.UUID `json:"in_member_ids"`
	WhereEarlierSentAt bool        `json:"where_earlier_sent_at"`
	EarlierSentAt      time.Time   `json:"earlier_sent_at"`
	WhereLaterSentAt   bool        `json:"where_later_sent_at"`
	LaterSentAt        time.Time   `json:"later_sent_at"`
	OrderMethod        string      `json:"order_method"`
}

type GetPositionHistoriesWithMemberRow struct {
	PositionHistory PositionHistory `json:"position_history"`
	Member          Member          `json:"member"`
}

func (q *Queries) GetPositionHistoriesWithMember(ctx context.Context, arg GetPositionHistoriesWithMemberParams) ([]GetPositionHistoriesWithMemberRow, error) {
	rows, err := q.db.Query(ctx, getPositionHistoriesWithMember,
		arg.Limit,
		arg.Offset,
		arg.WhereInMember,
		arg.InMemberIds,
		arg.WhereEarlierSentAt,
		arg.EarlierSentAt,
		arg.WhereLaterSentAt,
		arg.LaterSentAt,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPositionHistoriesWithMemberRow{}
	for rows.Next() {
		var i GetPositionHistoriesWithMemberRow
		if err := rows.Scan(
			&i.PositionHistory.TPositionHistoriesPkey,
			&i.PositionHistory.PositionHistoryID,
			&i.PositionHistory.MemberID,
			&i.PositionHistory.XPos,
			&i.PositionHistory.YPos,
			&i.PositionHistory.SentAt,
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageID,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePositionHistory = `-- name: UpdatePositionHistory :one
UPDATE t_position_histories SET member_id = $2, x_pos = $3, y_pos = $4, sent_at = $5 WHERE position_history_id = $1 RETURNING t_position_histories_pkey, position_history_id, member_id, x_pos, y_pos, sent_at
`

type UpdatePositionHistoryParams struct {
	PositionHistoryID uuid.UUID `json:"position_history_id"`
	MemberID          uuid.UUID `json:"member_id"`
	XPos              float64   `json:"x_pos"`
	YPos              float64   `json:"y_pos"`
	SentAt            time.Time `json:"sent_at"`
}

func (q *Queries) UpdatePositionHistory(ctx context.Context, arg UpdatePositionHistoryParams) (PositionHistory, error) {
	row := q.db.QueryRow(ctx, updatePositionHistory,
		arg.PositionHistoryID,
		arg.MemberID,
		arg.XPos,
		arg.YPos,
		arg.SentAt,
	)
	var i PositionHistory
	err := row.Scan(
		&i.TPositionHistoriesPkey,
		&i.PositionHistoryID,
		&i.MemberID,
		&i.XPos,
		&i.YPos,
		&i.SentAt,
	)
	return i, err
}
