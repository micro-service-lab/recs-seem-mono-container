// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: member.sql

package query

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countMembers = `-- name: CountMembers :one
SELECT count(*) FROM m_members
WHERE
	CASE WHEN $1::boolean = true THEN name LIKE '%' || $2::text || '%' ELSE TRUE END
AND
	CASE WHEN $3::boolean = true THEN (SELECT COUNT(*) FROM m_role_associations WHERE role_id = role_id AND m_role_associations.policy_id = ANY($4::uuid[])) > 0 ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN attend_status_id = ANY($6::uuid[]) ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN grade_id = ANY($8::uuid[]) ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN group_id = ANY($10::uuid[]) ELSE TRUE END
`

type CountMembersParams struct {
	WhereLikeName      bool        `json:"where_like_name"`
	SearchName         string      `json:"search_name"`
	WhereHasPolicy     bool        `json:"where_has_policy"`
	HasPolicyIds       []uuid.UUID `json:"has_policy_ids"`
	WhenInAttendStatus bool        `json:"when_in_attend_status"`
	InAttendStatusIds  []uuid.UUID `json:"in_attend_status_ids"`
	WhenInGrade        bool        `json:"when_in_grade"`
	InGradeIds         []uuid.UUID `json:"in_grade_ids"`
	WhenInGroup        bool        `json:"when_in_group"`
	InGroupIds         []uuid.UUID `json:"in_group_ids"`
}

func (q *Queries) CountMembers(ctx context.Context, arg CountMembersParams) (int64, error) {
	row := q.db.QueryRow(ctx, countMembers,
		arg.WhereLikeName,
		arg.SearchName,
		arg.WhereHasPolicy,
		arg.HasPolicyIds,
		arg.WhenInAttendStatus,
		arg.InAttendStatusIds,
		arg.WhenInGrade,
		arg.InGradeIds,
		arg.WhenInGroup,
		arg.InGroupIds,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createMember = `-- name: CreateMember :one
INSERT INTO m_members (login_id, password, email, name, first_name, last_name, attend_status_id, grade_id, group_id, profile_image_id, role_id, personal_organization_id, created_at, updated_at) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14) RETURNING m_members_pkey, member_id, login_id, password, email, name, first_name, last_name, attend_status_id, profile_image_id, grade_id, group_id, personal_organization_id, role_id, created_at, updated_at
`

type CreateMemberParams struct {
	LoginID                string      `json:"login_id"`
	Password               string      `json:"password"`
	Email                  string      `json:"email"`
	Name                   string      `json:"name"`
	FirstName              pgtype.Text `json:"first_name"`
	LastName               pgtype.Text `json:"last_name"`
	AttendStatusID         uuid.UUID   `json:"attend_status_id"`
	GradeID                uuid.UUID   `json:"grade_id"`
	GroupID                uuid.UUID   `json:"group_id"`
	ProfileImageID         pgtype.UUID `json:"profile_image_id"`
	RoleID                 pgtype.UUID `json:"role_id"`
	PersonalOrganizationID uuid.UUID   `json:"personal_organization_id"`
	CreatedAt              time.Time   `json:"created_at"`
	UpdatedAt              time.Time   `json:"updated_at"`
}

func (q *Queries) CreateMember(ctx context.Context, arg CreateMemberParams) (Member, error) {
	row := q.db.QueryRow(ctx, createMember,
		arg.LoginID,
		arg.Password,
		arg.Email,
		arg.Name,
		arg.FirstName,
		arg.LastName,
		arg.AttendStatusID,
		arg.GradeID,
		arg.GroupID,
		arg.ProfileImageID,
		arg.RoleID,
		arg.PersonalOrganizationID,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Member
	err := row.Scan(
		&i.MMembersPkey,
		&i.MemberID,
		&i.LoginID,
		&i.Password,
		&i.Email,
		&i.Name,
		&i.FirstName,
		&i.LastName,
		&i.AttendStatusID,
		&i.ProfileImageID,
		&i.GradeID,
		&i.GroupID,
		&i.PersonalOrganizationID,
		&i.RoleID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

type CreateMembersParams struct {
	LoginID                string      `json:"login_id"`
	Password               string      `json:"password"`
	Email                  string      `json:"email"`
	Name                   string      `json:"name"`
	FirstName              pgtype.Text `json:"first_name"`
	LastName               pgtype.Text `json:"last_name"`
	AttendStatusID         uuid.UUID   `json:"attend_status_id"`
	GradeID                uuid.UUID   `json:"grade_id"`
	GroupID                uuid.UUID   `json:"group_id"`
	ProfileImageID         pgtype.UUID `json:"profile_image_id"`
	RoleID                 pgtype.UUID `json:"role_id"`
	PersonalOrganizationID uuid.UUID   `json:"personal_organization_id"`
	CreatedAt              time.Time   `json:"created_at"`
	UpdatedAt              time.Time   `json:"updated_at"`
}

const deleteMember = `-- name: DeleteMember :execrows
DELETE FROM m_members WHERE member_id = $1
`

func (q *Queries) DeleteMember(ctx context.Context, memberID uuid.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, deleteMember, memberID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const findMemberByID = `-- name: FindMemberByID :one
SELECT m_members_pkey, member_id, login_id, password, email, name, first_name, last_name, attend_status_id, profile_image_id, grade_id, group_id, personal_organization_id, role_id, created_at, updated_at FROM m_members WHERE member_id = $1
`

func (q *Queries) FindMemberByID(ctx context.Context, memberID uuid.UUID) (Member, error) {
	row := q.db.QueryRow(ctx, findMemberByID, memberID)
	var i Member
	err := row.Scan(
		&i.MMembersPkey,
		&i.MemberID,
		&i.LoginID,
		&i.Password,
		&i.Email,
		&i.Name,
		&i.FirstName,
		&i.LastName,
		&i.AttendStatusID,
		&i.ProfileImageID,
		&i.GradeID,
		&i.GroupID,
		&i.PersonalOrganizationID,
		&i.RoleID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findMemberByIDWithAttendStatus = `-- name: FindMemberByIDWithAttendStatus :one
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.first_name, m_members.last_name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_attend_statuses.name attend_status_name, m_attend_statuses.key attend_status_key FROM m_members
LEFT JOIN m_attend_statuses ON m_members.attend_status_id = m_attend_statuses.attend_status_id
WHERE member_id = $1
`

type FindMemberByIDWithAttendStatusRow struct {
	MMembersPkey           pgtype.Int8 `json:"m_members_pkey"`
	MemberID               uuid.UUID   `json:"member_id"`
	LoginID                string      `json:"login_id"`
	Password               string      `json:"password"`
	Email                  string      `json:"email"`
	Name                   string      `json:"name"`
	FirstName              pgtype.Text `json:"first_name"`
	LastName               pgtype.Text `json:"last_name"`
	AttendStatusID         uuid.UUID   `json:"attend_status_id"`
	ProfileImageID         pgtype.UUID `json:"profile_image_id"`
	GradeID                uuid.UUID   `json:"grade_id"`
	GroupID                uuid.UUID   `json:"group_id"`
	PersonalOrganizationID uuid.UUID   `json:"personal_organization_id"`
	RoleID                 pgtype.UUID `json:"role_id"`
	CreatedAt              time.Time   `json:"created_at"`
	UpdatedAt              time.Time   `json:"updated_at"`
	AttendStatusName       pgtype.Text `json:"attend_status_name"`
	AttendStatusKey        pgtype.Text `json:"attend_status_key"`
}

func (q *Queries) FindMemberByIDWithAttendStatus(ctx context.Context, memberID uuid.UUID) (FindMemberByIDWithAttendStatusRow, error) {
	row := q.db.QueryRow(ctx, findMemberByIDWithAttendStatus, memberID)
	var i FindMemberByIDWithAttendStatusRow
	err := row.Scan(
		&i.MMembersPkey,
		&i.MemberID,
		&i.LoginID,
		&i.Password,
		&i.Email,
		&i.Name,
		&i.FirstName,
		&i.LastName,
		&i.AttendStatusID,
		&i.ProfileImageID,
		&i.GradeID,
		&i.GroupID,
		&i.PersonalOrganizationID,
		&i.RoleID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AttendStatusName,
		&i.AttendStatusKey,
	)
	return i, err
}

const findMemberByIDWithCrew = `-- name: FindMemberByIDWithCrew :one
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.first_name, m_members.last_name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_grades.key grade_key, m_grades.organization_id grade_organization_id, grag.name grade_organization_name, grag.description grade_organization_description,
grag.color grade_organization_color, grag.is_personal grade_organization_is_personal,
grag.is_whole grade_organization_is_whole, grag.chat_room_id grade_organization_chat_room_id,
m_groups.key group_key, m_groups.organization_id group_organization_id, grog.name group_organization_name, grog.description group_organization_description,
grog.color group_organization_color, grog.is_personal group_organization_is_personal,
grog.is_whole group_organization_is_whole, grog.chat_room_id group_organization_chat_room_id FROM m_members
LEFT JOIN m_grades ON m_members.grade_id = m_grades.grade_id
LEFT JOIN m_organizations grag ON m_grades.organization_id = grag.organization_id
LEFT JOIN m_groups ON m_members.group_id = m_groups.group_id
LEFT JOIN m_organizations grog ON m_groups.organization_id = grog.organization_id
WHERE member_id = $1
`

type FindMemberByIDWithCrewRow struct {
	MMembersPkey                 pgtype.Int8 `json:"m_members_pkey"`
	MemberID                     uuid.UUID   `json:"member_id"`
	LoginID                      string      `json:"login_id"`
	Password                     string      `json:"password"`
	Email                        string      `json:"email"`
	Name                         string      `json:"name"`
	FirstName                    pgtype.Text `json:"first_name"`
	LastName                     pgtype.Text `json:"last_name"`
	AttendStatusID               uuid.UUID   `json:"attend_status_id"`
	ProfileImageID               pgtype.UUID `json:"profile_image_id"`
	GradeID                      uuid.UUID   `json:"grade_id"`
	GroupID                      uuid.UUID   `json:"group_id"`
	PersonalOrganizationID       uuid.UUID   `json:"personal_organization_id"`
	RoleID                       pgtype.UUID `json:"role_id"`
	CreatedAt                    time.Time   `json:"created_at"`
	UpdatedAt                    time.Time   `json:"updated_at"`
	GradeKey                     pgtype.Text `json:"grade_key"`
	GradeOrganizationID          pgtype.UUID `json:"grade_organization_id"`
	GradeOrganizationName        pgtype.Text `json:"grade_organization_name"`
	GradeOrganizationDescription pgtype.Text `json:"grade_organization_description"`
	GradeOrganizationColor       pgtype.Text `json:"grade_organization_color"`
	GradeOrganizationIsPersonal  pgtype.Bool `json:"grade_organization_is_personal"`
	GradeOrganizationIsWhole     pgtype.Bool `json:"grade_organization_is_whole"`
	GradeOrganizationChatRoomID  pgtype.UUID `json:"grade_organization_chat_room_id"`
	GroupKey                     pgtype.Text `json:"group_key"`
	GroupOrganizationID          pgtype.UUID `json:"group_organization_id"`
	GroupOrganizationName        pgtype.Text `json:"group_organization_name"`
	GroupOrganizationDescription pgtype.Text `json:"group_organization_description"`
	GroupOrganizationColor       pgtype.Text `json:"group_organization_color"`
	GroupOrganizationIsPersonal  pgtype.Bool `json:"group_organization_is_personal"`
	GroupOrganizationIsWhole     pgtype.Bool `json:"group_organization_is_whole"`
	GroupOrganizationChatRoomID  pgtype.UUID `json:"group_organization_chat_room_id"`
}

func (q *Queries) FindMemberByIDWithCrew(ctx context.Context, memberID uuid.UUID) (FindMemberByIDWithCrewRow, error) {
	row := q.db.QueryRow(ctx, findMemberByIDWithCrew, memberID)
	var i FindMemberByIDWithCrewRow
	err := row.Scan(
		&i.MMembersPkey,
		&i.MemberID,
		&i.LoginID,
		&i.Password,
		&i.Email,
		&i.Name,
		&i.FirstName,
		&i.LastName,
		&i.AttendStatusID,
		&i.ProfileImageID,
		&i.GradeID,
		&i.GroupID,
		&i.PersonalOrganizationID,
		&i.RoleID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.GradeKey,
		&i.GradeOrganizationID,
		&i.GradeOrganizationName,
		&i.GradeOrganizationDescription,
		&i.GradeOrganizationColor,
		&i.GradeOrganizationIsPersonal,
		&i.GradeOrganizationIsWhole,
		&i.GradeOrganizationChatRoomID,
		&i.GroupKey,
		&i.GroupOrganizationID,
		&i.GroupOrganizationName,
		&i.GroupOrganizationDescription,
		&i.GroupOrganizationColor,
		&i.GroupOrganizationIsPersonal,
		&i.GroupOrganizationIsWhole,
		&i.GroupOrganizationChatRoomID,
	)
	return i, err
}

const findMemberByIDWithDetail = `-- name: FindMemberByIDWithDetail :one
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.first_name, m_members.last_name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_students.student_id, m_professors.professor_id FROM m_members
LEFT JOIN m_students ON m_members.member_id = m_students.member_id
LEFT JOIN m_professors ON m_members.member_id = m_professors.member_id
WHERE m_members.member_id = $1
`

type FindMemberByIDWithDetailRow struct {
	MMembersPkey           pgtype.Int8 `json:"m_members_pkey"`
	MemberID               uuid.UUID   `json:"member_id"`
	LoginID                string      `json:"login_id"`
	Password               string      `json:"password"`
	Email                  string      `json:"email"`
	Name                   string      `json:"name"`
	FirstName              pgtype.Text `json:"first_name"`
	LastName               pgtype.Text `json:"last_name"`
	AttendStatusID         uuid.UUID   `json:"attend_status_id"`
	ProfileImageID         pgtype.UUID `json:"profile_image_id"`
	GradeID                uuid.UUID   `json:"grade_id"`
	GroupID                uuid.UUID   `json:"group_id"`
	PersonalOrganizationID uuid.UUID   `json:"personal_organization_id"`
	RoleID                 pgtype.UUID `json:"role_id"`
	CreatedAt              time.Time   `json:"created_at"`
	UpdatedAt              time.Time   `json:"updated_at"`
	StudentID              pgtype.UUID `json:"student_id"`
	ProfessorID            pgtype.UUID `json:"professor_id"`
}

func (q *Queries) FindMemberByIDWithDetail(ctx context.Context, memberID uuid.UUID) (FindMemberByIDWithDetailRow, error) {
	row := q.db.QueryRow(ctx, findMemberByIDWithDetail, memberID)
	var i FindMemberByIDWithDetailRow
	err := row.Scan(
		&i.MMembersPkey,
		&i.MemberID,
		&i.LoginID,
		&i.Password,
		&i.Email,
		&i.Name,
		&i.FirstName,
		&i.LastName,
		&i.AttendStatusID,
		&i.ProfileImageID,
		&i.GradeID,
		&i.GroupID,
		&i.PersonalOrganizationID,
		&i.RoleID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.StudentID,
		&i.ProfessorID,
	)
	return i, err
}

const findMemberByIDWithPersonalOrganization = `-- name: FindMemberByIDWithPersonalOrganization :one
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.first_name, m_members.last_name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_organizations.name organization_name, m_organizations.description organization_description,
m_organizations.color organization_color, m_organizations.is_personal organization_is_personal,
m_organizations.is_whole organization_is_whole, m_organizations.chat_room_id organization_chat_room_id FROM m_members
LEFT JOIN m_organizations ON m_members.personal_organization_id = m_organizations.organization_id
WHERE member_id = $1
`

type FindMemberByIDWithPersonalOrganizationRow struct {
	MMembersPkey            pgtype.Int8 `json:"m_members_pkey"`
	MemberID                uuid.UUID   `json:"member_id"`
	LoginID                 string      `json:"login_id"`
	Password                string      `json:"password"`
	Email                   string      `json:"email"`
	Name                    string      `json:"name"`
	FirstName               pgtype.Text `json:"first_name"`
	LastName                pgtype.Text `json:"last_name"`
	AttendStatusID          uuid.UUID   `json:"attend_status_id"`
	ProfileImageID          pgtype.UUID `json:"profile_image_id"`
	GradeID                 uuid.UUID   `json:"grade_id"`
	GroupID                 uuid.UUID   `json:"group_id"`
	PersonalOrganizationID  uuid.UUID   `json:"personal_organization_id"`
	RoleID                  pgtype.UUID `json:"role_id"`
	CreatedAt               time.Time   `json:"created_at"`
	UpdatedAt               time.Time   `json:"updated_at"`
	OrganizationName        pgtype.Text `json:"organization_name"`
	OrganizationDescription pgtype.Text `json:"organization_description"`
	OrganizationColor       pgtype.Text `json:"organization_color"`
	OrganizationIsPersonal  pgtype.Bool `json:"organization_is_personal"`
	OrganizationIsWhole     pgtype.Bool `json:"organization_is_whole"`
	OrganizationChatRoomID  pgtype.UUID `json:"organization_chat_room_id"`
}

func (q *Queries) FindMemberByIDWithPersonalOrganization(ctx context.Context, memberID uuid.UUID) (FindMemberByIDWithPersonalOrganizationRow, error) {
	row := q.db.QueryRow(ctx, findMemberByIDWithPersonalOrganization, memberID)
	var i FindMemberByIDWithPersonalOrganizationRow
	err := row.Scan(
		&i.MMembersPkey,
		&i.MemberID,
		&i.LoginID,
		&i.Password,
		&i.Email,
		&i.Name,
		&i.FirstName,
		&i.LastName,
		&i.AttendStatusID,
		&i.ProfileImageID,
		&i.GradeID,
		&i.GroupID,
		&i.PersonalOrganizationID,
		&i.RoleID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.OrganizationName,
		&i.OrganizationDescription,
		&i.OrganizationColor,
		&i.OrganizationIsPersonal,
		&i.OrganizationIsWhole,
		&i.OrganizationChatRoomID,
	)
	return i, err
}

const findMemberByIDWithProfileImage = `-- name: FindMemberByIDWithProfileImage :one
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.first_name, m_members.last_name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, t_images.height profile_image_height,
t_images.width profile_image_width, t_images.attachable_item_id profile_image_attachable_item_id,
t_attachable_items.owner_id profile_image_owner_id, t_attachable_items.from_outer profile_image_from_outer, t_attachable_items.alias profile_image_alias,
t_attachable_items.url profile_image_url, t_attachable_items.size profile_image_size, t_attachable_items.mime_type_id profile_image_mime_type_id
FROM m_members
LEFT JOIN t_images ON m_members.profile_image_id = t_images.image_id
LEFT JOIN t_attachable_items ON t_images.attachable_item_id = t_attachable_items.attachable_item_id
WHERE member_id = $1
`

type FindMemberByIDWithProfileImageRow struct {
	MMembersPkey                 pgtype.Int8   `json:"m_members_pkey"`
	MemberID                     uuid.UUID     `json:"member_id"`
	LoginID                      string        `json:"login_id"`
	Password                     string        `json:"password"`
	Email                        string        `json:"email"`
	Name                         string        `json:"name"`
	FirstName                    pgtype.Text   `json:"first_name"`
	LastName                     pgtype.Text   `json:"last_name"`
	AttendStatusID               uuid.UUID     `json:"attend_status_id"`
	ProfileImageID               pgtype.UUID   `json:"profile_image_id"`
	GradeID                      uuid.UUID     `json:"grade_id"`
	GroupID                      uuid.UUID     `json:"group_id"`
	PersonalOrganizationID       uuid.UUID     `json:"personal_organization_id"`
	RoleID                       pgtype.UUID   `json:"role_id"`
	CreatedAt                    time.Time     `json:"created_at"`
	UpdatedAt                    time.Time     `json:"updated_at"`
	ProfileImageHeight           pgtype.Float8 `json:"profile_image_height"`
	ProfileImageWidth            pgtype.Float8 `json:"profile_image_width"`
	ProfileImageAttachableItemID pgtype.UUID   `json:"profile_image_attachable_item_id"`
	ProfileImageOwnerID          pgtype.UUID   `json:"profile_image_owner_id"`
	ProfileImageFromOuter        pgtype.Bool   `json:"profile_image_from_outer"`
	ProfileImageAlias            pgtype.Text   `json:"profile_image_alias"`
	ProfileImageUrl              pgtype.Text   `json:"profile_image_url"`
	ProfileImageSize             pgtype.Float8 `json:"profile_image_size"`
	ProfileImageMimeTypeID       pgtype.UUID   `json:"profile_image_mime_type_id"`
}

func (q *Queries) FindMemberByIDWithProfileImage(ctx context.Context, memberID uuid.UUID) (FindMemberByIDWithProfileImageRow, error) {
	row := q.db.QueryRow(ctx, findMemberByIDWithProfileImage, memberID)
	var i FindMemberByIDWithProfileImageRow
	err := row.Scan(
		&i.MMembersPkey,
		&i.MemberID,
		&i.LoginID,
		&i.Password,
		&i.Email,
		&i.Name,
		&i.FirstName,
		&i.LastName,
		&i.AttendStatusID,
		&i.ProfileImageID,
		&i.GradeID,
		&i.GroupID,
		&i.PersonalOrganizationID,
		&i.RoleID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProfileImageHeight,
		&i.ProfileImageWidth,
		&i.ProfileImageAttachableItemID,
		&i.ProfileImageOwnerID,
		&i.ProfileImageFromOuter,
		&i.ProfileImageAlias,
		&i.ProfileImageUrl,
		&i.ProfileImageSize,
		&i.ProfileImageMimeTypeID,
	)
	return i, err
}

const findMemberByIDWithRole = `-- name: FindMemberByIDWithRole :one
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.first_name, m_members.last_name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_roles.name role_name, m_roles.description role_description FROM m_members
LEFT JOIN m_roles ON m_members.role_id = m_roles.role_id
WHERE member_id = $1
`

type FindMemberByIDWithRoleRow struct {
	MMembersPkey           pgtype.Int8 `json:"m_members_pkey"`
	MemberID               uuid.UUID   `json:"member_id"`
	LoginID                string      `json:"login_id"`
	Password               string      `json:"password"`
	Email                  string      `json:"email"`
	Name                   string      `json:"name"`
	FirstName              pgtype.Text `json:"first_name"`
	LastName               pgtype.Text `json:"last_name"`
	AttendStatusID         uuid.UUID   `json:"attend_status_id"`
	ProfileImageID         pgtype.UUID `json:"profile_image_id"`
	GradeID                uuid.UUID   `json:"grade_id"`
	GroupID                uuid.UUID   `json:"group_id"`
	PersonalOrganizationID uuid.UUID   `json:"personal_organization_id"`
	RoleID                 pgtype.UUID `json:"role_id"`
	CreatedAt              time.Time   `json:"created_at"`
	UpdatedAt              time.Time   `json:"updated_at"`
	RoleName               pgtype.Text `json:"role_name"`
	RoleDescription        pgtype.Text `json:"role_description"`
}

func (q *Queries) FindMemberByIDWithRole(ctx context.Context, memberID uuid.UUID) (FindMemberByIDWithRoleRow, error) {
	row := q.db.QueryRow(ctx, findMemberByIDWithRole, memberID)
	var i FindMemberByIDWithRoleRow
	err := row.Scan(
		&i.MMembersPkey,
		&i.MemberID,
		&i.LoginID,
		&i.Password,
		&i.Email,
		&i.Name,
		&i.FirstName,
		&i.LastName,
		&i.AttendStatusID,
		&i.ProfileImageID,
		&i.GradeID,
		&i.GroupID,
		&i.PersonalOrganizationID,
		&i.RoleID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RoleName,
		&i.RoleDescription,
	)
	return i, err
}

const findMemberByLoginID = `-- name: FindMemberByLoginID :one
SELECT m_members_pkey, member_id, login_id, password, email, name, first_name, last_name, attend_status_id, profile_image_id, grade_id, group_id, personal_organization_id, role_id, created_at, updated_at FROM m_members WHERE login_id = $1
`

func (q *Queries) FindMemberByLoginID(ctx context.Context, loginID string) (Member, error) {
	row := q.db.QueryRow(ctx, findMemberByLoginID, loginID)
	var i Member
	err := row.Scan(
		&i.MMembersPkey,
		&i.MemberID,
		&i.LoginID,
		&i.Password,
		&i.Email,
		&i.Name,
		&i.FirstName,
		&i.LastName,
		&i.AttendStatusID,
		&i.ProfileImageID,
		&i.GradeID,
		&i.GroupID,
		&i.PersonalOrganizationID,
		&i.RoleID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findMemberWithProfileImage = `-- name: FindMemberWithProfileImage :one
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.first_name, m_members.last_name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, t_images.height profile_image_height,
t_images.width profile_image_width, t_images.attachable_item_id profile_image_attachable_item_id,
t_attachable_items.owner_id profile_image_owner_id, t_attachable_items.from_outer profile_image_from_outer, t_attachable_items.alias profile_image_alias,
t_attachable_items.url profile_image_url, t_attachable_items.size profile_image_size, t_attachable_items.mime_type_id profile_image_mime_type_id
FROM m_members
LEFT JOIN t_images ON m_members.profile_image_id = t_images.image_id
LEFT JOIN t_attachable_items ON t_images.attachable_item_id = t_attachable_items.attachable_item_id
WHERE member_id = $1
`

type FindMemberWithProfileImageRow struct {
	MMembersPkey                 pgtype.Int8   `json:"m_members_pkey"`
	MemberID                     uuid.UUID     `json:"member_id"`
	LoginID                      string        `json:"login_id"`
	Password                     string        `json:"password"`
	Email                        string        `json:"email"`
	Name                         string        `json:"name"`
	FirstName                    pgtype.Text   `json:"first_name"`
	LastName                     pgtype.Text   `json:"last_name"`
	AttendStatusID               uuid.UUID     `json:"attend_status_id"`
	ProfileImageID               pgtype.UUID   `json:"profile_image_id"`
	GradeID                      uuid.UUID     `json:"grade_id"`
	GroupID                      uuid.UUID     `json:"group_id"`
	PersonalOrganizationID       uuid.UUID     `json:"personal_organization_id"`
	RoleID                       pgtype.UUID   `json:"role_id"`
	CreatedAt                    time.Time     `json:"created_at"`
	UpdatedAt                    time.Time     `json:"updated_at"`
	ProfileImageHeight           pgtype.Float8 `json:"profile_image_height"`
	ProfileImageWidth            pgtype.Float8 `json:"profile_image_width"`
	ProfileImageAttachableItemID pgtype.UUID   `json:"profile_image_attachable_item_id"`
	ProfileImageOwnerID          pgtype.UUID   `json:"profile_image_owner_id"`
	ProfileImageFromOuter        pgtype.Bool   `json:"profile_image_from_outer"`
	ProfileImageAlias            pgtype.Text   `json:"profile_image_alias"`
	ProfileImageUrl              pgtype.Text   `json:"profile_image_url"`
	ProfileImageSize             pgtype.Float8 `json:"profile_image_size"`
	ProfileImageMimeTypeID       pgtype.UUID   `json:"profile_image_mime_type_id"`
}

func (q *Queries) FindMemberWithProfileImage(ctx context.Context, memberID uuid.UUID) (FindMemberWithProfileImageRow, error) {
	row := q.db.QueryRow(ctx, findMemberWithProfileImage, memberID)
	var i FindMemberWithProfileImageRow
	err := row.Scan(
		&i.MMembersPkey,
		&i.MemberID,
		&i.LoginID,
		&i.Password,
		&i.Email,
		&i.Name,
		&i.FirstName,
		&i.LastName,
		&i.AttendStatusID,
		&i.ProfileImageID,
		&i.GradeID,
		&i.GroupID,
		&i.PersonalOrganizationID,
		&i.RoleID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProfileImageHeight,
		&i.ProfileImageWidth,
		&i.ProfileImageAttachableItemID,
		&i.ProfileImageOwnerID,
		&i.ProfileImageFromOuter,
		&i.ProfileImageAlias,
		&i.ProfileImageUrl,
		&i.ProfileImageSize,
		&i.ProfileImageMimeTypeID,
	)
	return i, err
}

const getMembers = `-- name: GetMembers :many
SELECT m_members_pkey, member_id, login_id, password, email, name, first_name, last_name, attend_status_id, profile_image_id, grade_id, group_id, personal_organization_id, role_id, created_at, updated_at FROM m_members
WHERE
	CASE WHEN $1::boolean = true THEN m_members.name LIKE '%' || $2::text || '%' ELSE TRUE END
AND
	CASE WHEN $3::boolean = true THEN (SELECT COUNT(*) FROM m_role_associations WHERE role_id = m_members.role_id AND m_role_associations.policy_id = ANY($4::uuid[])) > 0 ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN m_members.attend_status_id = ANY($6::uuid[]) ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN m_members.grade_id = ANY($8::uuid[]) ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN m_members.group_id = ANY($10::uuid[]) ELSE TRUE END
ORDER BY
	CASE WHEN $11::text = 'name' THEN m_members.name END ASC,
	CASE WHEN $11::text = 'r_name' THEN m_members.name END DESC,
	m_members_pkey ASC
`

type GetMembersParams struct {
	WhereLikeName      bool        `json:"where_like_name"`
	SearchName         string      `json:"search_name"`
	WhereHasPolicy     bool        `json:"where_has_policy"`
	HasPolicyIds       []uuid.UUID `json:"has_policy_ids"`
	WhenInAttendStatus bool        `json:"when_in_attend_status"`
	InAttendStatusIds  []uuid.UUID `json:"in_attend_status_ids"`
	WhenInGrade        bool        `json:"when_in_grade"`
	InGradeIds         []uuid.UUID `json:"in_grade_ids"`
	WhenInGroup        bool        `json:"when_in_group"`
	InGroupIds         []uuid.UUID `json:"in_group_ids"`
	OrderMethod        string      `json:"order_method"`
}

func (q *Queries) GetMembers(ctx context.Context, arg GetMembersParams) ([]Member, error) {
	rows, err := q.db.Query(ctx, getMembers,
		arg.WhereLikeName,
		arg.SearchName,
		arg.WhereHasPolicy,
		arg.HasPolicyIds,
		arg.WhenInAttendStatus,
		arg.InAttendStatusIds,
		arg.WhenInGrade,
		arg.InGradeIds,
		arg.WhenInGroup,
		arg.InGroupIds,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Member{}
	for rows.Next() {
		var i Member
		if err := rows.Scan(
			&i.MMembersPkey,
			&i.MemberID,
			&i.LoginID,
			&i.Password,
			&i.Email,
			&i.Name,
			&i.FirstName,
			&i.LastName,
			&i.AttendStatusID,
			&i.ProfileImageID,
			&i.GradeID,
			&i.GroupID,
			&i.PersonalOrganizationID,
			&i.RoleID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMembersUseKeysetPaginate = `-- name: GetMembersUseKeysetPaginate :many
SELECT m_members_pkey, member_id, login_id, password, email, name, first_name, last_name, attend_status_id, profile_image_id, grade_id, group_id, personal_organization_id, role_id, created_at, updated_at FROM m_members
WHERE
	CASE WHEN $2::boolean = true THEN m_members.name LIKE '%' || $3::text || '%' ELSE TRUE END
AND
	CASE WHEN $4::boolean = true THEN (SELECT COUNT(*) FROM m_role_associations WHERE role_id = m_members.role_id AND m_role_associations.policy_id = ANY($5::uuid[])) > 0 ELSE TRUE END
AND
	CASE WHEN $6::boolean = true THEN m_members.attend_status_id = ANY($7::uuid[]) ELSE TRUE END
AND
	CASE WHEN $8::boolean = true THEN m_members.grade_id = ANY($9::uuid[]) ELSE TRUE END
AND
	CASE WHEN $10::boolean = true THEN m_members.group_id = ANY($11::uuid[]) ELSE TRUE END
AND
	CASE $12::text
		WHEN 'next' THEN
			CASE $13::text
				WHEN 'name' THEN m_members.name > $14 OR (m_members.name = $14 AND m_members_pkey > $15::int)
				WHEN 'r_name' THEN m_members.name < $14 OR (m_members.name = $14 AND m_members_pkey > $15::int)
				ELSE m_members_pkey > $15::int
			END
		WHEN 'prev' THEN
			CASE $13::text
				WHEN 'name' THEN m_members.name < $14 OR (m_members.name = $14 AND m_members_pkey < $15::int)
				WHEN 'r_name' THEN m_members.name > $14 OR (m_members.name = $14 AND m_members_pkey < $15::int)
				ELSE m_members_pkey < $15::int
			END
	END
ORDER BY
	CASE WHEN $13::text = 'name' AND $12::text = 'next' THEN m_members.name END ASC,
	CASE WHEN $13::text = 'name' AND $12::text = 'prev' THEN m_members.name END DESC,
	CASE WHEN $13::text = 'r_name' AND $12::text = 'next' THEN m_members.name END DESC,
	CASE WHEN $13::text = 'r_name' AND $12::text = 'prev' THEN m_members.name END ASC,
	CASE WHEN $12::text = 'next' THEN m_members_pkey END ASC,
	CASE WHEN $12::text = 'prev' THEN m_members_pkey END DESC
LIMIT $1
`

type GetMembersUseKeysetPaginateParams struct {
	Limit              int32       `json:"limit"`
	WhereLikeName      bool        `json:"where_like_name"`
	SearchName         string      `json:"search_name"`
	WhereHasPolicy     bool        `json:"where_has_policy"`
	HasPolicyIds       []uuid.UUID `json:"has_policy_ids"`
	WhenInAttendStatus bool        `json:"when_in_attend_status"`
	InAttendStatusIds  []uuid.UUID `json:"in_attend_status_ids"`
	WhenInGrade        bool        `json:"when_in_grade"`
	InGradeIds         []uuid.UUID `json:"in_grade_ids"`
	WhenInGroup        bool        `json:"when_in_group"`
	InGroupIds         []uuid.UUID `json:"in_group_ids"`
	CursorDirection    string      `json:"cursor_direction"`
	OrderMethod        string      `json:"order_method"`
	NameCursor         string      `json:"name_cursor"`
	Cursor             int32       `json:"cursor"`
}

func (q *Queries) GetMembersUseKeysetPaginate(ctx context.Context, arg GetMembersUseKeysetPaginateParams) ([]Member, error) {
	rows, err := q.db.Query(ctx, getMembersUseKeysetPaginate,
		arg.Limit,
		arg.WhereLikeName,
		arg.SearchName,
		arg.WhereHasPolicy,
		arg.HasPolicyIds,
		arg.WhenInAttendStatus,
		arg.InAttendStatusIds,
		arg.WhenInGrade,
		arg.InGradeIds,
		arg.WhenInGroup,
		arg.InGroupIds,
		arg.CursorDirection,
		arg.OrderMethod,
		arg.NameCursor,
		arg.Cursor,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Member{}
	for rows.Next() {
		var i Member
		if err := rows.Scan(
			&i.MMembersPkey,
			&i.MemberID,
			&i.LoginID,
			&i.Password,
			&i.Email,
			&i.Name,
			&i.FirstName,
			&i.LastName,
			&i.AttendStatusID,
			&i.ProfileImageID,
			&i.GradeID,
			&i.GroupID,
			&i.PersonalOrganizationID,
			&i.RoleID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMembersUseNumberedPaginate = `-- name: GetMembersUseNumberedPaginate :many
SELECT m_members_pkey, member_id, login_id, password, email, name, first_name, last_name, attend_status_id, profile_image_id, grade_id, group_id, personal_organization_id, role_id, created_at, updated_at FROM m_members
WHERE
	CASE WHEN $3::boolean = true THEN m_members.name LIKE '%' || $4::text || '%' ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN (SELECT COUNT(*) FROM m_role_associations WHERE role_id = m_members.role_id AND m_role_associations.policy_id = ANY($6::uuid[])) > 0 ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN m_members.attend_status_id = ANY($8::uuid[]) ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN m_members.grade_id = ANY($10::uuid[]) ELSE TRUE END
AND
	CASE WHEN $11::boolean = true THEN m_members.group_id = ANY($12::uuid[]) ELSE TRUE END
ORDER BY
	CASE WHEN $13::text = 'name' THEN m_members.name END ASC,
	CASE WHEN $13::text = 'r_name' THEN m_members.name END DESC,
	m_members_pkey ASC
LIMIT $1 OFFSET $2
`

type GetMembersUseNumberedPaginateParams struct {
	Limit              int32       `json:"limit"`
	Offset             int32       `json:"offset"`
	WhereLikeName      bool        `json:"where_like_name"`
	SearchName         string      `json:"search_name"`
	WhereHasPolicy     bool        `json:"where_has_policy"`
	HasPolicyIds       []uuid.UUID `json:"has_policy_ids"`
	WhenInAttendStatus bool        `json:"when_in_attend_status"`
	InAttendStatusIds  []uuid.UUID `json:"in_attend_status_ids"`
	WhenInGrade        bool        `json:"when_in_grade"`
	InGradeIds         []uuid.UUID `json:"in_grade_ids"`
	WhenInGroup        bool        `json:"when_in_group"`
	InGroupIds         []uuid.UUID `json:"in_group_ids"`
	OrderMethod        string      `json:"order_method"`
}

func (q *Queries) GetMembersUseNumberedPaginate(ctx context.Context, arg GetMembersUseNumberedPaginateParams) ([]Member, error) {
	rows, err := q.db.Query(ctx, getMembersUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.WhereLikeName,
		arg.SearchName,
		arg.WhereHasPolicy,
		arg.HasPolicyIds,
		arg.WhenInAttendStatus,
		arg.InAttendStatusIds,
		arg.WhenInGrade,
		arg.InGradeIds,
		arg.WhenInGroup,
		arg.InGroupIds,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Member{}
	for rows.Next() {
		var i Member
		if err := rows.Scan(
			&i.MMembersPkey,
			&i.MemberID,
			&i.LoginID,
			&i.Password,
			&i.Email,
			&i.Name,
			&i.FirstName,
			&i.LastName,
			&i.AttendStatusID,
			&i.ProfileImageID,
			&i.GradeID,
			&i.GroupID,
			&i.PersonalOrganizationID,
			&i.RoleID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMembersWithAttendStatus = `-- name: GetMembersWithAttendStatus :many
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.first_name, m_members.last_name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_attend_statuses.name attend_status_name, m_attend_statuses.key attend_status_key FROM m_members
LEFT JOIN m_attend_statuses ON m_members.attend_status_id = m_attend_statuses.attend_status_id
WHERE
	CASE WHEN $1::boolean = true THEN m_members.name LIKE '%' || $2::text || '%' ELSE TRUE END
AND
	CASE WHEN $3::boolean = true THEN (SELECT COUNT(*) FROM m_role_associations WHERE role_id = m_members.role_id AND m_role_associations.policy_id = ANY($4::uuid[])) > 0 ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN m_members.attend_status_id = ANY($6::uuid[]) ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN m_members.grade_id = ANY($8::uuid[]) ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN m_members.group_id = ANY($10::uuid[]) ELSE TRUE END
ORDER BY
	CASE WHEN $11::text = 'name' THEN m_members.name END ASC,
	CASE WHEN $11::text = 'r_name' THEN m_members.name END DESC,
	m_members_pkey ASC
`

type GetMembersWithAttendStatusParams struct {
	WhereLikeName      bool        `json:"where_like_name"`
	SearchName         string      `json:"search_name"`
	WhereHasPolicy     bool        `json:"where_has_policy"`
	HasPolicyIds       []uuid.UUID `json:"has_policy_ids"`
	WhenInAttendStatus bool        `json:"when_in_attend_status"`
	InAttendStatusIds  []uuid.UUID `json:"in_attend_status_ids"`
	WhenInGrade        bool        `json:"when_in_grade"`
	InGradeIds         []uuid.UUID `json:"in_grade_ids"`
	WhenInGroup        bool        `json:"when_in_group"`
	InGroupIds         []uuid.UUID `json:"in_group_ids"`
	OrderMethod        string      `json:"order_method"`
}

type GetMembersWithAttendStatusRow struct {
	MMembersPkey           pgtype.Int8 `json:"m_members_pkey"`
	MemberID               uuid.UUID   `json:"member_id"`
	LoginID                string      `json:"login_id"`
	Password               string      `json:"password"`
	Email                  string      `json:"email"`
	Name                   string      `json:"name"`
	FirstName              pgtype.Text `json:"first_name"`
	LastName               pgtype.Text `json:"last_name"`
	AttendStatusID         uuid.UUID   `json:"attend_status_id"`
	ProfileImageID         pgtype.UUID `json:"profile_image_id"`
	GradeID                uuid.UUID   `json:"grade_id"`
	GroupID                uuid.UUID   `json:"group_id"`
	PersonalOrganizationID uuid.UUID   `json:"personal_organization_id"`
	RoleID                 pgtype.UUID `json:"role_id"`
	CreatedAt              time.Time   `json:"created_at"`
	UpdatedAt              time.Time   `json:"updated_at"`
	AttendStatusName       pgtype.Text `json:"attend_status_name"`
	AttendStatusKey        pgtype.Text `json:"attend_status_key"`
}

func (q *Queries) GetMembersWithAttendStatus(ctx context.Context, arg GetMembersWithAttendStatusParams) ([]GetMembersWithAttendStatusRow, error) {
	rows, err := q.db.Query(ctx, getMembersWithAttendStatus,
		arg.WhereLikeName,
		arg.SearchName,
		arg.WhereHasPolicy,
		arg.HasPolicyIds,
		arg.WhenInAttendStatus,
		arg.InAttendStatusIds,
		arg.WhenInGrade,
		arg.InGradeIds,
		arg.WhenInGroup,
		arg.InGroupIds,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMembersWithAttendStatusRow{}
	for rows.Next() {
		var i GetMembersWithAttendStatusRow
		if err := rows.Scan(
			&i.MMembersPkey,
			&i.MemberID,
			&i.LoginID,
			&i.Password,
			&i.Email,
			&i.Name,
			&i.FirstName,
			&i.LastName,
			&i.AttendStatusID,
			&i.ProfileImageID,
			&i.GradeID,
			&i.GroupID,
			&i.PersonalOrganizationID,
			&i.RoleID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AttendStatusName,
			&i.AttendStatusKey,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMembersWithAttendStatusUseKeysetPaginate = `-- name: GetMembersWithAttendStatusUseKeysetPaginate :many
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.first_name, m_members.last_name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_attend_statuses.name attend_status_name, m_attend_statuses.key attend_status_key FROM m_members
LEFT JOIN m_attend_statuses ON m_members.attend_status_id = m_attend_statuses.attend_status_id
WHERE
	CASE WHEN $2::boolean = true THEN m_members.name LIKE '%' || $3::text || '%' ELSE TRUE END
AND
	CASE WHEN $4::boolean = true THEN (SELECT COUNT(*) FROM m_role_associations WHERE role_id = m_members.role_id AND m_role_associations.policy_id = ANY($5::uuid[])) > 0 ELSE TRUE END
AND
	CASE WHEN $6::boolean = true THEN m_members.attend_status_id = ANY($7::uuid[]) ELSE TRUE END
AND
	CASE WHEN $8::boolean = true THEN m_members.grade_id = ANY($9::uuid[]) ELSE TRUE END
AND
	CASE WHEN $10::boolean = true THEN m_members.group_id = ANY($11::uuid[]) ELSE TRUE END
AND
	CASE $12::text
		WHEN 'next' THEN
			CASE $13::text
				WHEN 'name' THEN m_members.name > $14 OR (m_members.name = $14 AND m_members_pkey > $15::int)
				WHEN 'r_name' THEN m_members.name < $14 OR (m_members.name = $14 AND m_members_pkey > $15::int)
				ELSE m_members_pkey > $15::int
			END
		WHEN 'prev' THEN
			CASE $13::text
				WHEN 'name' THEN m_members.name < $14 OR (m_members.name = $14 AND m_members_pkey < $15::int)
				WHEN 'r_name' THEN m_members.name > $14 OR (m_members.name = $14 AND m_members_pkey < $15::int)
				ELSE m_members_pkey < $15::int
			END
	END
ORDER BY
	CASE WHEN $13::text = 'name' AND $12::text = 'next' THEN m_members.name END ASC,
	CASE WHEN $13::text = 'name' AND $12::text = 'prev' THEN m_members.name END DESC,
	CASE WHEN $13::text = 'r_name' AND $12::text = 'next' THEN m_members.name END DESC,
	CASE WHEN $13::text = 'r_name' AND $12::text = 'prev' THEN m_members.name END ASC,
	CASE WHEN $12::text = 'next' THEN m_members_pkey END ASC,
	CASE WHEN $12::text = 'prev' THEN m_members_pkey END DESC
LIMIT $1
`

type GetMembersWithAttendStatusUseKeysetPaginateParams struct {
	Limit              int32       `json:"limit"`
	WhereLikeName      bool        `json:"where_like_name"`
	SearchName         string      `json:"search_name"`
	WhereHasPolicy     bool        `json:"where_has_policy"`
	HasPolicyIds       []uuid.UUID `json:"has_policy_ids"`
	WhenInAttendStatus bool        `json:"when_in_attend_status"`
	InAttendStatusIds  []uuid.UUID `json:"in_attend_status_ids"`
	WhenInGrade        bool        `json:"when_in_grade"`
	InGradeIds         []uuid.UUID `json:"in_grade_ids"`
	WhenInGroup        bool        `json:"when_in_group"`
	InGroupIds         []uuid.UUID `json:"in_group_ids"`
	CursorDirection    string      `json:"cursor_direction"`
	OrderMethod        string      `json:"order_method"`
	NameCursor         string      `json:"name_cursor"`
	Cursor             int32       `json:"cursor"`
}

type GetMembersWithAttendStatusUseKeysetPaginateRow struct {
	MMembersPkey           pgtype.Int8 `json:"m_members_pkey"`
	MemberID               uuid.UUID   `json:"member_id"`
	LoginID                string      `json:"login_id"`
	Password               string      `json:"password"`
	Email                  string      `json:"email"`
	Name                   string      `json:"name"`
	FirstName              pgtype.Text `json:"first_name"`
	LastName               pgtype.Text `json:"last_name"`
	AttendStatusID         uuid.UUID   `json:"attend_status_id"`
	ProfileImageID         pgtype.UUID `json:"profile_image_id"`
	GradeID                uuid.UUID   `json:"grade_id"`
	GroupID                uuid.UUID   `json:"group_id"`
	PersonalOrganizationID uuid.UUID   `json:"personal_organization_id"`
	RoleID                 pgtype.UUID `json:"role_id"`
	CreatedAt              time.Time   `json:"created_at"`
	UpdatedAt              time.Time   `json:"updated_at"`
	AttendStatusName       pgtype.Text `json:"attend_status_name"`
	AttendStatusKey        pgtype.Text `json:"attend_status_key"`
}

func (q *Queries) GetMembersWithAttendStatusUseKeysetPaginate(ctx context.Context, arg GetMembersWithAttendStatusUseKeysetPaginateParams) ([]GetMembersWithAttendStatusUseKeysetPaginateRow, error) {
	rows, err := q.db.Query(ctx, getMembersWithAttendStatusUseKeysetPaginate,
		arg.Limit,
		arg.WhereLikeName,
		arg.SearchName,
		arg.WhereHasPolicy,
		arg.HasPolicyIds,
		arg.WhenInAttendStatus,
		arg.InAttendStatusIds,
		arg.WhenInGrade,
		arg.InGradeIds,
		arg.WhenInGroup,
		arg.InGroupIds,
		arg.CursorDirection,
		arg.OrderMethod,
		arg.NameCursor,
		arg.Cursor,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMembersWithAttendStatusUseKeysetPaginateRow{}
	for rows.Next() {
		var i GetMembersWithAttendStatusUseKeysetPaginateRow
		if err := rows.Scan(
			&i.MMembersPkey,
			&i.MemberID,
			&i.LoginID,
			&i.Password,
			&i.Email,
			&i.Name,
			&i.FirstName,
			&i.LastName,
			&i.AttendStatusID,
			&i.ProfileImageID,
			&i.GradeID,
			&i.GroupID,
			&i.PersonalOrganizationID,
			&i.RoleID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AttendStatusName,
			&i.AttendStatusKey,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMembersWithAttendStatusUseNumberedPaginate = `-- name: GetMembersWithAttendStatusUseNumberedPaginate :many
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.first_name, m_members.last_name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_attend_statuses.name attend_status_name, m_attend_statuses.key attend_status_key FROM m_members
LEFT JOIN m_attend_statuses ON m_members.attend_status_id = m_attend_statuses.attend_status_id
WHERE
	CASE WHEN $3::boolean = true THEN m_members.name LIKE '%' || $4::text || '%' ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN (SELECT COUNT(*) FROM m_role_associations WHERE role_id = m_members.role_id AND m_role_associations.policy_id = ANY($6::uuid[])) > 0 ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN m_members.attend_status_id = ANY($8::uuid[]) ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN m_members.grade_id = ANY($10::uuid[]) ELSE TRUE END
AND
	CASE WHEN $11::boolean = true THEN m_members.group_id = ANY($12::uuid[]) ELSE TRUE END
ORDER BY
	CASE WHEN $13::text = 'name' THEN m_members.name END ASC,
	CASE WHEN $13::text = 'r_name' THEN m_members.name END DESC,
	m_members_pkey ASC
LIMIT $1 OFFSET $2
`

type GetMembersWithAttendStatusUseNumberedPaginateParams struct {
	Limit              int32       `json:"limit"`
	Offset             int32       `json:"offset"`
	WhereLikeName      bool        `json:"where_like_name"`
	SearchName         string      `json:"search_name"`
	WhereHasPolicy     bool        `json:"where_has_policy"`
	HasPolicyIds       []uuid.UUID `json:"has_policy_ids"`
	WhenInAttendStatus bool        `json:"when_in_attend_status"`
	InAttendStatusIds  []uuid.UUID `json:"in_attend_status_ids"`
	WhenInGrade        bool        `json:"when_in_grade"`
	InGradeIds         []uuid.UUID `json:"in_grade_ids"`
	WhenInGroup        bool        `json:"when_in_group"`
	InGroupIds         []uuid.UUID `json:"in_group_ids"`
	OrderMethod        string      `json:"order_method"`
}

type GetMembersWithAttendStatusUseNumberedPaginateRow struct {
	MMembersPkey           pgtype.Int8 `json:"m_members_pkey"`
	MemberID               uuid.UUID   `json:"member_id"`
	LoginID                string      `json:"login_id"`
	Password               string      `json:"password"`
	Email                  string      `json:"email"`
	Name                   string      `json:"name"`
	FirstName              pgtype.Text `json:"first_name"`
	LastName               pgtype.Text `json:"last_name"`
	AttendStatusID         uuid.UUID   `json:"attend_status_id"`
	ProfileImageID         pgtype.UUID `json:"profile_image_id"`
	GradeID                uuid.UUID   `json:"grade_id"`
	GroupID                uuid.UUID   `json:"group_id"`
	PersonalOrganizationID uuid.UUID   `json:"personal_organization_id"`
	RoleID                 pgtype.UUID `json:"role_id"`
	CreatedAt              time.Time   `json:"created_at"`
	UpdatedAt              time.Time   `json:"updated_at"`
	AttendStatusName       pgtype.Text `json:"attend_status_name"`
	AttendStatusKey        pgtype.Text `json:"attend_status_key"`
}

func (q *Queries) GetMembersWithAttendStatusUseNumberedPaginate(ctx context.Context, arg GetMembersWithAttendStatusUseNumberedPaginateParams) ([]GetMembersWithAttendStatusUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getMembersWithAttendStatusUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.WhereLikeName,
		arg.SearchName,
		arg.WhereHasPolicy,
		arg.HasPolicyIds,
		arg.WhenInAttendStatus,
		arg.InAttendStatusIds,
		arg.WhenInGrade,
		arg.InGradeIds,
		arg.WhenInGroup,
		arg.InGroupIds,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMembersWithAttendStatusUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetMembersWithAttendStatusUseNumberedPaginateRow
		if err := rows.Scan(
			&i.MMembersPkey,
			&i.MemberID,
			&i.LoginID,
			&i.Password,
			&i.Email,
			&i.Name,
			&i.FirstName,
			&i.LastName,
			&i.AttendStatusID,
			&i.ProfileImageID,
			&i.GradeID,
			&i.GroupID,
			&i.PersonalOrganizationID,
			&i.RoleID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AttendStatusName,
			&i.AttendStatusKey,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMembersWithCrew = `-- name: GetMembersWithCrew :many
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.first_name, m_members.last_name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_grades.key grade_key, m_grades.organization_id grade_organization_id, grag.name grade_organization_name, grag.description grade_organization_description,
grag.color grade_organization_color, grag.is_personal grade_organization_is_personal,
grag.is_whole grade_organization_is_whole, grag.chat_room_id grade_organization_chat_room_id,
m_groups.key group_key, m_groups.organization_id group_organization_id, grog.name group_organization_name, grog.description group_organization_description,
grog.color group_organization_color, grog.is_personal group_organization_is_personal,
grog.is_whole group_organization_is_whole, grog.chat_room_id group_organization_chat_room_id FROM m_members
LEFT JOIN m_grades ON m_members.grade_id = m_grades.grade_id
LEFT JOIN m_organizations grag ON m_grades.organization_id = grag.organization_id
LEFT JOIN m_groups ON m_members.group_id = m_groups.group_id
LEFT JOIN m_organizations grog ON m_groups.organization_id = grog.organization_id
WHERE
	CASE WHEN $1::boolean = true THEN m_members.name LIKE '%' || $2::text || '%' ELSE TRUE END
AND
	CASE WHEN $3::boolean = true THEN (SELECT COUNT(*) FROM m_role_associations WHERE role_id = m_members.role_id AND m_role_associations.policy_id = ANY($4::uuid[])) > 0 ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN m_members.attend_status_id = ANY($6::uuid[]) ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN m_members.grade_id = ANY($8::uuid[]) ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN m_members.group_id = ANY($10::uuid[]) ELSE TRUE END
ORDER BY
	CASE WHEN $11::text = 'name' THEN m_members.name END ASC,
	CASE WHEN $11::text = 'r_name' THEN m_members.name END DESC,
	m_members_pkey ASC
`

type GetMembersWithCrewParams struct {
	WhereLikeName      bool        `json:"where_like_name"`
	SearchName         string      `json:"search_name"`
	WhereHasPolicy     bool        `json:"where_has_policy"`
	HasPolicyIds       []uuid.UUID `json:"has_policy_ids"`
	WhenInAttendStatus bool        `json:"when_in_attend_status"`
	InAttendStatusIds  []uuid.UUID `json:"in_attend_status_ids"`
	WhenInGrade        bool        `json:"when_in_grade"`
	InGradeIds         []uuid.UUID `json:"in_grade_ids"`
	WhenInGroup        bool        `json:"when_in_group"`
	InGroupIds         []uuid.UUID `json:"in_group_ids"`
	OrderMethod        string      `json:"order_method"`
}

type GetMembersWithCrewRow struct {
	MMembersPkey                 pgtype.Int8 `json:"m_members_pkey"`
	MemberID                     uuid.UUID   `json:"member_id"`
	LoginID                      string      `json:"login_id"`
	Password                     string      `json:"password"`
	Email                        string      `json:"email"`
	Name                         string      `json:"name"`
	FirstName                    pgtype.Text `json:"first_name"`
	LastName                     pgtype.Text `json:"last_name"`
	AttendStatusID               uuid.UUID   `json:"attend_status_id"`
	ProfileImageID               pgtype.UUID `json:"profile_image_id"`
	GradeID                      uuid.UUID   `json:"grade_id"`
	GroupID                      uuid.UUID   `json:"group_id"`
	PersonalOrganizationID       uuid.UUID   `json:"personal_organization_id"`
	RoleID                       pgtype.UUID `json:"role_id"`
	CreatedAt                    time.Time   `json:"created_at"`
	UpdatedAt                    time.Time   `json:"updated_at"`
	GradeKey                     pgtype.Text `json:"grade_key"`
	GradeOrganizationID          pgtype.UUID `json:"grade_organization_id"`
	GradeOrganizationName        pgtype.Text `json:"grade_organization_name"`
	GradeOrganizationDescription pgtype.Text `json:"grade_organization_description"`
	GradeOrganizationColor       pgtype.Text `json:"grade_organization_color"`
	GradeOrganizationIsPersonal  pgtype.Bool `json:"grade_organization_is_personal"`
	GradeOrganizationIsWhole     pgtype.Bool `json:"grade_organization_is_whole"`
	GradeOrganizationChatRoomID  pgtype.UUID `json:"grade_organization_chat_room_id"`
	GroupKey                     pgtype.Text `json:"group_key"`
	GroupOrganizationID          pgtype.UUID `json:"group_organization_id"`
	GroupOrganizationName        pgtype.Text `json:"group_organization_name"`
	GroupOrganizationDescription pgtype.Text `json:"group_organization_description"`
	GroupOrganizationColor       pgtype.Text `json:"group_organization_color"`
	GroupOrganizationIsPersonal  pgtype.Bool `json:"group_organization_is_personal"`
	GroupOrganizationIsWhole     pgtype.Bool `json:"group_organization_is_whole"`
	GroupOrganizationChatRoomID  pgtype.UUID `json:"group_organization_chat_room_id"`
}

func (q *Queries) GetMembersWithCrew(ctx context.Context, arg GetMembersWithCrewParams) ([]GetMembersWithCrewRow, error) {
	rows, err := q.db.Query(ctx, getMembersWithCrew,
		arg.WhereLikeName,
		arg.SearchName,
		arg.WhereHasPolicy,
		arg.HasPolicyIds,
		arg.WhenInAttendStatus,
		arg.InAttendStatusIds,
		arg.WhenInGrade,
		arg.InGradeIds,
		arg.WhenInGroup,
		arg.InGroupIds,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMembersWithCrewRow{}
	for rows.Next() {
		var i GetMembersWithCrewRow
		if err := rows.Scan(
			&i.MMembersPkey,
			&i.MemberID,
			&i.LoginID,
			&i.Password,
			&i.Email,
			&i.Name,
			&i.FirstName,
			&i.LastName,
			&i.AttendStatusID,
			&i.ProfileImageID,
			&i.GradeID,
			&i.GroupID,
			&i.PersonalOrganizationID,
			&i.RoleID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.GradeKey,
			&i.GradeOrganizationID,
			&i.GradeOrganizationName,
			&i.GradeOrganizationDescription,
			&i.GradeOrganizationColor,
			&i.GradeOrganizationIsPersonal,
			&i.GradeOrganizationIsWhole,
			&i.GradeOrganizationChatRoomID,
			&i.GroupKey,
			&i.GroupOrganizationID,
			&i.GroupOrganizationName,
			&i.GroupOrganizationDescription,
			&i.GroupOrganizationColor,
			&i.GroupOrganizationIsPersonal,
			&i.GroupOrganizationIsWhole,
			&i.GroupOrganizationChatRoomID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMembersWithCrewUseKeysetPaginate = `-- name: GetMembersWithCrewUseKeysetPaginate :many
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.first_name, m_members.last_name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_grades.key grade_key, m_grades.organization_id grade_organization_id, grag.name grade_organization_name, grag.description grade_organization_description,
grag.color grade_organization_color, grag.is_personal grade_organization_is_personal,
grag.is_whole grade_organization_is_whole, grag.chat_room_id grade_organization_chat_room_id,
m_groups.key group_key, m_groups.organization_id group_organization_id, grog.name group_organization_name, grog.description group_organization_description,
grog.color group_organization_color, grog.is_personal group_organization_is_personal,
grog.is_whole group_organization_is_whole, grog.chat_room_id group_organization_chat_room_id FROM m_members
LEFT JOIN m_grades ON m_members.grade_id = m_grades.grade_id
LEFT JOIN m_organizations grag ON m_grades.organization_id = grag.organization_id
LEFT JOIN m_groups ON m_members.group_id = m_groups.group_id
LEFT JOIN m_organizations grog ON m_groups.organization_id = grog.organization_id
WHERE
	CASE WHEN $2::boolean = true THEN m_members.name LIKE '%' || $3::text || '%' ELSE TRUE END
AND
	CASE WHEN $4::boolean = true THEN (SELECT COUNT(*) FROM m_role_associations WHERE role_id = m_members.role_id AND m_role_associations.policy_id = ANY($5::uuid[])) > 0 ELSE TRUE END
AND
	CASE WHEN $6::boolean = true THEN m_members.attend_status_id = ANY($7::uuid[]) ELSE TRUE END
AND
	CASE WHEN $8::boolean = true THEN m_members.grade_id = ANY($9::uuid[]) ELSE TRUE END
AND
	CASE WHEN $10::boolean = true THEN m_members.group_id = ANY($11::uuid[]) ELSE TRUE END
AND
	CASE $12::text
		WHEN 'next' THEN
			CASE $13::text
				WHEN 'name' THEN m_members.name > $14 OR (m_members.name = $14 AND m_members_pkey > $15::int)
				WHEN 'r_name' THEN m_members.name < $14 OR (m_members.name = $14 AND m_members_pkey > $15::int)
				ELSE m_members_pkey > $15::int
			END
		WHEN 'prev' THEN
			CASE $13::text
				WHEN 'name' THEN m_members.name < $14 OR (m_members.name = $14 AND m_members_pkey < $15::int)
				WHEN 'r_name' THEN m_members.name > $14 OR (m_members.name = $14 AND m_members_pkey < $15::int)
				ELSE m_members_pkey < $15::int
			END
	END
ORDER BY
	CASE WHEN $13::text = 'name' AND $12::text = 'next' THEN m_members.name END ASC,
	CASE WHEN $13::text = 'name' AND $12::text = 'prev' THEN m_members.name END DESC,
	CASE WHEN $13::text = 'r_name' AND $12::text = 'next' THEN m_members.name END DESC,
	CASE WHEN $13::text = 'r_name' AND $12::text = 'prev' THEN m_members.name END ASC,
	CASE WHEN $12::text = 'next' THEN m_members_pkey END ASC,
	CASE WHEN $12::text = 'prev' THEN m_members_pkey END DESC
LIMIT $1
`

type GetMembersWithCrewUseKeysetPaginateParams struct {
	Limit              int32       `json:"limit"`
	WhereLikeName      bool        `json:"where_like_name"`
	SearchName         string      `json:"search_name"`
	WhereHasPolicy     bool        `json:"where_has_policy"`
	HasPolicyIds       []uuid.UUID `json:"has_policy_ids"`
	WhenInAttendStatus bool        `json:"when_in_attend_status"`
	InAttendStatusIds  []uuid.UUID `json:"in_attend_status_ids"`
	WhenInGrade        bool        `json:"when_in_grade"`
	InGradeIds         []uuid.UUID `json:"in_grade_ids"`
	WhenInGroup        bool        `json:"when_in_group"`
	InGroupIds         []uuid.UUID `json:"in_group_ids"`
	CursorDirection    string      `json:"cursor_direction"`
	OrderMethod        string      `json:"order_method"`
	NameCursor         string      `json:"name_cursor"`
	Cursor             int32       `json:"cursor"`
}

type GetMembersWithCrewUseKeysetPaginateRow struct {
	MMembersPkey                 pgtype.Int8 `json:"m_members_pkey"`
	MemberID                     uuid.UUID   `json:"member_id"`
	LoginID                      string      `json:"login_id"`
	Password                     string      `json:"password"`
	Email                        string      `json:"email"`
	Name                         string      `json:"name"`
	FirstName                    pgtype.Text `json:"first_name"`
	LastName                     pgtype.Text `json:"last_name"`
	AttendStatusID               uuid.UUID   `json:"attend_status_id"`
	ProfileImageID               pgtype.UUID `json:"profile_image_id"`
	GradeID                      uuid.UUID   `json:"grade_id"`
	GroupID                      uuid.UUID   `json:"group_id"`
	PersonalOrganizationID       uuid.UUID   `json:"personal_organization_id"`
	RoleID                       pgtype.UUID `json:"role_id"`
	CreatedAt                    time.Time   `json:"created_at"`
	UpdatedAt                    time.Time   `json:"updated_at"`
	GradeKey                     pgtype.Text `json:"grade_key"`
	GradeOrganizationID          pgtype.UUID `json:"grade_organization_id"`
	GradeOrganizationName        pgtype.Text `json:"grade_organization_name"`
	GradeOrganizationDescription pgtype.Text `json:"grade_organization_description"`
	GradeOrganizationColor       pgtype.Text `json:"grade_organization_color"`
	GradeOrganizationIsPersonal  pgtype.Bool `json:"grade_organization_is_personal"`
	GradeOrganizationIsWhole     pgtype.Bool `json:"grade_organization_is_whole"`
	GradeOrganizationChatRoomID  pgtype.UUID `json:"grade_organization_chat_room_id"`
	GroupKey                     pgtype.Text `json:"group_key"`
	GroupOrganizationID          pgtype.UUID `json:"group_organization_id"`
	GroupOrganizationName        pgtype.Text `json:"group_organization_name"`
	GroupOrganizationDescription pgtype.Text `json:"group_organization_description"`
	GroupOrganizationColor       pgtype.Text `json:"group_organization_color"`
	GroupOrganizationIsPersonal  pgtype.Bool `json:"group_organization_is_personal"`
	GroupOrganizationIsWhole     pgtype.Bool `json:"group_organization_is_whole"`
	GroupOrganizationChatRoomID  pgtype.UUID `json:"group_organization_chat_room_id"`
}

func (q *Queries) GetMembersWithCrewUseKeysetPaginate(ctx context.Context, arg GetMembersWithCrewUseKeysetPaginateParams) ([]GetMembersWithCrewUseKeysetPaginateRow, error) {
	rows, err := q.db.Query(ctx, getMembersWithCrewUseKeysetPaginate,
		arg.Limit,
		arg.WhereLikeName,
		arg.SearchName,
		arg.WhereHasPolicy,
		arg.HasPolicyIds,
		arg.WhenInAttendStatus,
		arg.InAttendStatusIds,
		arg.WhenInGrade,
		arg.InGradeIds,
		arg.WhenInGroup,
		arg.InGroupIds,
		arg.CursorDirection,
		arg.OrderMethod,
		arg.NameCursor,
		arg.Cursor,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMembersWithCrewUseKeysetPaginateRow{}
	for rows.Next() {
		var i GetMembersWithCrewUseKeysetPaginateRow
		if err := rows.Scan(
			&i.MMembersPkey,
			&i.MemberID,
			&i.LoginID,
			&i.Password,
			&i.Email,
			&i.Name,
			&i.FirstName,
			&i.LastName,
			&i.AttendStatusID,
			&i.ProfileImageID,
			&i.GradeID,
			&i.GroupID,
			&i.PersonalOrganizationID,
			&i.RoleID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.GradeKey,
			&i.GradeOrganizationID,
			&i.GradeOrganizationName,
			&i.GradeOrganizationDescription,
			&i.GradeOrganizationColor,
			&i.GradeOrganizationIsPersonal,
			&i.GradeOrganizationIsWhole,
			&i.GradeOrganizationChatRoomID,
			&i.GroupKey,
			&i.GroupOrganizationID,
			&i.GroupOrganizationName,
			&i.GroupOrganizationDescription,
			&i.GroupOrganizationColor,
			&i.GroupOrganizationIsPersonal,
			&i.GroupOrganizationIsWhole,
			&i.GroupOrganizationChatRoomID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMembersWithCrewUseNumberedPaginate = `-- name: GetMembersWithCrewUseNumberedPaginate :many
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.first_name, m_members.last_name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_grades.key grade_key, m_grades.organization_id grade_organization_id, grag.name grade_organization_name, grag.description grade_organization_description,
grag.color grade_organization_color, grag.is_personal grade_organization_is_personal,
grag.is_whole grade_organization_is_whole, grag.chat_room_id grade_organization_chat_room_id,
m_groups.key group_key, m_groups.organization_id group_organization_id, grog.name group_organization_name, grog.description group_organization_description,
grog.color group_organization_color, grog.is_personal group_organization_is_personal,
grog.is_whole group_organization_is_whole, grog.chat_room_id group_organization_chat_room_id FROM m_members
LEFT JOIN m_grades ON m_members.grade_id = m_grades.grade_id
LEFT JOIN m_organizations grag ON m_grades.organization_id = grag.organization_id
LEFT JOIN m_groups ON m_members.group_id = m_groups.group_id
LEFT JOIN m_organizations grog ON m_groups.organization_id = grog.organization_id
WHERE
	CASE WHEN $3::boolean = true THEN m_members.name LIKE '%' || $4::text || '%' ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN (SELECT COUNT(*) FROM m_role_associations WHERE role_id = m_members.role_id AND m_role_associations.policy_id = ANY($6::uuid[])) > 0 ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN m_members.attend_status_id = ANY($8::uuid[]) ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN m_members.grade_id = ANY($10::uuid[]) ELSE TRUE END
AND
	CASE WHEN $11::boolean = true THEN m_members.group_id = ANY($12::uuid[]) ELSE TRUE END
ORDER BY
	CASE WHEN $13::text = 'name' THEN m_members.name END ASC,
	CASE WHEN $13::text = 'r_name' THEN m_members.name END DESC,
	m_members_pkey ASC
LIMIT $1 OFFSET $2
`

type GetMembersWithCrewUseNumberedPaginateParams struct {
	Limit              int32       `json:"limit"`
	Offset             int32       `json:"offset"`
	WhereLikeName      bool        `json:"where_like_name"`
	SearchName         string      `json:"search_name"`
	WhereHasPolicy     bool        `json:"where_has_policy"`
	HasPolicyIds       []uuid.UUID `json:"has_policy_ids"`
	WhenInAttendStatus bool        `json:"when_in_attend_status"`
	InAttendStatusIds  []uuid.UUID `json:"in_attend_status_ids"`
	WhenInGrade        bool        `json:"when_in_grade"`
	InGradeIds         []uuid.UUID `json:"in_grade_ids"`
	WhenInGroup        bool        `json:"when_in_group"`
	InGroupIds         []uuid.UUID `json:"in_group_ids"`
	OrderMethod        string      `json:"order_method"`
}

type GetMembersWithCrewUseNumberedPaginateRow struct {
	MMembersPkey                 pgtype.Int8 `json:"m_members_pkey"`
	MemberID                     uuid.UUID   `json:"member_id"`
	LoginID                      string      `json:"login_id"`
	Password                     string      `json:"password"`
	Email                        string      `json:"email"`
	Name                         string      `json:"name"`
	FirstName                    pgtype.Text `json:"first_name"`
	LastName                     pgtype.Text `json:"last_name"`
	AttendStatusID               uuid.UUID   `json:"attend_status_id"`
	ProfileImageID               pgtype.UUID `json:"profile_image_id"`
	GradeID                      uuid.UUID   `json:"grade_id"`
	GroupID                      uuid.UUID   `json:"group_id"`
	PersonalOrganizationID       uuid.UUID   `json:"personal_organization_id"`
	RoleID                       pgtype.UUID `json:"role_id"`
	CreatedAt                    time.Time   `json:"created_at"`
	UpdatedAt                    time.Time   `json:"updated_at"`
	GradeKey                     pgtype.Text `json:"grade_key"`
	GradeOrganizationID          pgtype.UUID `json:"grade_organization_id"`
	GradeOrganizationName        pgtype.Text `json:"grade_organization_name"`
	GradeOrganizationDescription pgtype.Text `json:"grade_organization_description"`
	GradeOrganizationColor       pgtype.Text `json:"grade_organization_color"`
	GradeOrganizationIsPersonal  pgtype.Bool `json:"grade_organization_is_personal"`
	GradeOrganizationIsWhole     pgtype.Bool `json:"grade_organization_is_whole"`
	GradeOrganizationChatRoomID  pgtype.UUID `json:"grade_organization_chat_room_id"`
	GroupKey                     pgtype.Text `json:"group_key"`
	GroupOrganizationID          pgtype.UUID `json:"group_organization_id"`
	GroupOrganizationName        pgtype.Text `json:"group_organization_name"`
	GroupOrganizationDescription pgtype.Text `json:"group_organization_description"`
	GroupOrganizationColor       pgtype.Text `json:"group_organization_color"`
	GroupOrganizationIsPersonal  pgtype.Bool `json:"group_organization_is_personal"`
	GroupOrganizationIsWhole     pgtype.Bool `json:"group_organization_is_whole"`
	GroupOrganizationChatRoomID  pgtype.UUID `json:"group_organization_chat_room_id"`
}

func (q *Queries) GetMembersWithCrewUseNumberedPaginate(ctx context.Context, arg GetMembersWithCrewUseNumberedPaginateParams) ([]GetMembersWithCrewUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getMembersWithCrewUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.WhereLikeName,
		arg.SearchName,
		arg.WhereHasPolicy,
		arg.HasPolicyIds,
		arg.WhenInAttendStatus,
		arg.InAttendStatusIds,
		arg.WhenInGrade,
		arg.InGradeIds,
		arg.WhenInGroup,
		arg.InGroupIds,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMembersWithCrewUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetMembersWithCrewUseNumberedPaginateRow
		if err := rows.Scan(
			&i.MMembersPkey,
			&i.MemberID,
			&i.LoginID,
			&i.Password,
			&i.Email,
			&i.Name,
			&i.FirstName,
			&i.LastName,
			&i.AttendStatusID,
			&i.ProfileImageID,
			&i.GradeID,
			&i.GroupID,
			&i.PersonalOrganizationID,
			&i.RoleID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.GradeKey,
			&i.GradeOrganizationID,
			&i.GradeOrganizationName,
			&i.GradeOrganizationDescription,
			&i.GradeOrganizationColor,
			&i.GradeOrganizationIsPersonal,
			&i.GradeOrganizationIsWhole,
			&i.GradeOrganizationChatRoomID,
			&i.GroupKey,
			&i.GroupOrganizationID,
			&i.GroupOrganizationName,
			&i.GroupOrganizationDescription,
			&i.GroupOrganizationColor,
			&i.GroupOrganizationIsPersonal,
			&i.GroupOrganizationIsWhole,
			&i.GroupOrganizationChatRoomID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMembersWithDetail = `-- name: GetMembersWithDetail :many
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.first_name, m_members.last_name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_students.student_id, m_professors.professor_id FROM m_members
LEFT JOIN m_students ON m_members.member_id = m_students.member_id
LEFT JOIN m_professors ON m_members.member_id = m_professors.member_id
WHERE
	CASE WHEN $1::boolean = true THEN m_members.name LIKE '%' || $2::text || '%' ELSE TRUE END
AND
	CASE WHEN $3::boolean = true THEN (SELECT COUNT(*) FROM m_role_associations WHERE role_id = m_members.role_id AND m_role_associations.policy_id = ANY($4::uuid[])) > 0 ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN m_members.attend_status_id = ANY($6::uuid[]) ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN m_members.grade_id = ANY($8::uuid[]) ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN m_members.group_id = ANY($10::uuid[]) ELSE TRUE END
ORDER BY
	CASE WHEN $11::text = 'name' THEN m_members.name END ASC,
	CASE WHEN $11::text = 'r_name' THEN m_members.name END DESC,
	m_members_pkey ASC
`

type GetMembersWithDetailParams struct {
	WhereLikeName      bool        `json:"where_like_name"`
	SearchName         string      `json:"search_name"`
	WhereHasPolicy     bool        `json:"where_has_policy"`
	HasPolicyIds       []uuid.UUID `json:"has_policy_ids"`
	WhenInAttendStatus bool        `json:"when_in_attend_status"`
	InAttendStatusIds  []uuid.UUID `json:"in_attend_status_ids"`
	WhenInGrade        bool        `json:"when_in_grade"`
	InGradeIds         []uuid.UUID `json:"in_grade_ids"`
	WhenInGroup        bool        `json:"when_in_group"`
	InGroupIds         []uuid.UUID `json:"in_group_ids"`
	OrderMethod        string      `json:"order_method"`
}

type GetMembersWithDetailRow struct {
	MMembersPkey           pgtype.Int8 `json:"m_members_pkey"`
	MemberID               uuid.UUID   `json:"member_id"`
	LoginID                string      `json:"login_id"`
	Password               string      `json:"password"`
	Email                  string      `json:"email"`
	Name                   string      `json:"name"`
	FirstName              pgtype.Text `json:"first_name"`
	LastName               pgtype.Text `json:"last_name"`
	AttendStatusID         uuid.UUID   `json:"attend_status_id"`
	ProfileImageID         pgtype.UUID `json:"profile_image_id"`
	GradeID                uuid.UUID   `json:"grade_id"`
	GroupID                uuid.UUID   `json:"group_id"`
	PersonalOrganizationID uuid.UUID   `json:"personal_organization_id"`
	RoleID                 pgtype.UUID `json:"role_id"`
	CreatedAt              time.Time   `json:"created_at"`
	UpdatedAt              time.Time   `json:"updated_at"`
	StudentID              pgtype.UUID `json:"student_id"`
	ProfessorID            pgtype.UUID `json:"professor_id"`
}

func (q *Queries) GetMembersWithDetail(ctx context.Context, arg GetMembersWithDetailParams) ([]GetMembersWithDetailRow, error) {
	rows, err := q.db.Query(ctx, getMembersWithDetail,
		arg.WhereLikeName,
		arg.SearchName,
		arg.WhereHasPolicy,
		arg.HasPolicyIds,
		arg.WhenInAttendStatus,
		arg.InAttendStatusIds,
		arg.WhenInGrade,
		arg.InGradeIds,
		arg.WhenInGroup,
		arg.InGroupIds,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMembersWithDetailRow{}
	for rows.Next() {
		var i GetMembersWithDetailRow
		if err := rows.Scan(
			&i.MMembersPkey,
			&i.MemberID,
			&i.LoginID,
			&i.Password,
			&i.Email,
			&i.Name,
			&i.FirstName,
			&i.LastName,
			&i.AttendStatusID,
			&i.ProfileImageID,
			&i.GradeID,
			&i.GroupID,
			&i.PersonalOrganizationID,
			&i.RoleID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StudentID,
			&i.ProfessorID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMembersWithDetailUseKeysetPaginate = `-- name: GetMembersWithDetailUseKeysetPaginate :many
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.first_name, m_members.last_name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_students.student_id, m_professors.professor_id FROM m_members
LEFT JOIN m_students ON m_members.member_id = m_students.member_id
LEFT JOIN m_professors ON m_members.member_id = m_professors.member_id
WHERE
	CASE WHEN $2::boolean = true THEN m_members.name LIKE '%' || $3::text || '%' ELSE TRUE END
AND
	CASE WHEN $4::boolean = true THEN (SELECT COUNT(*) FROM m_role_associations WHERE role_id = m_members.role_id AND m_role_associations.policy_id = ANY($5::uuid[])) > 0 ELSE TRUE END
AND
	CASE WHEN $6::boolean = true THEN m_members.attend_status_id = ANY($7::uuid[]) ELSE TRUE END
AND
	CASE WHEN $8::boolean = true THEN m_members.grade_id = ANY($9::uuid[]) ELSE TRUE END
AND
	CASE WHEN $10::boolean = true THEN m_members.group_id = ANY($11::uuid[]) ELSE TRUE END
AND
	CASE $12::text
		WHEN 'next' THEN
			CASE $13::text
				WHEN 'name' THEN m_members.name > $14 OR (m_members.name = $14 AND m_members_pkey > $15::int)
				WHEN 'r_name' THEN m_members.name < $14 OR (m_members.name = $14 AND m_members_pkey > $15::int)
				ELSE m_members_pkey > $15::int
			END
		WHEN 'prev' THEN
			CASE $13::text
				WHEN 'name' THEN m_members.name < $14 OR (m_members.name = $14 AND m_members_pkey < $15::int)
				WHEN 'r_name' THEN m_members.name > $14 OR (m_members.name = $14 AND m_members_pkey < $15::int)
				ELSE m_members_pkey < $15::int
			END
	END
ORDER BY
	CASE WHEN $13::text = 'name' AND $12::text = 'next' THEN m_members.name END ASC,
	CASE WHEN $13::text = 'name' AND $12::text = 'prev' THEN m_members.name END DESC,
	CASE WHEN $13::text = 'r_name' AND $12::text = 'next' THEN m_members.name END DESC,
	CASE WHEN $13::text = 'r_name' AND $12::text = 'prev' THEN m_members.name END ASC,
	CASE WHEN $12::text = 'next' THEN m_members_pkey END ASC,
	CASE WHEN $12::text = 'prev' THEN m_members_pkey END DESC
LIMIT $1
`

type GetMembersWithDetailUseKeysetPaginateParams struct {
	Limit              int32       `json:"limit"`
	WhereLikeName      bool        `json:"where_like_name"`
	SearchName         string      `json:"search_name"`
	WhereHasPolicy     bool        `json:"where_has_policy"`
	HasPolicyIds       []uuid.UUID `json:"has_policy_ids"`
	WhenInAttendStatus bool        `json:"when_in_attend_status"`
	InAttendStatusIds  []uuid.UUID `json:"in_attend_status_ids"`
	WhenInGrade        bool        `json:"when_in_grade"`
	InGradeIds         []uuid.UUID `json:"in_grade_ids"`
	WhenInGroup        bool        `json:"when_in_group"`
	InGroupIds         []uuid.UUID `json:"in_group_ids"`
	CursorDirection    string      `json:"cursor_direction"`
	OrderMethod        string      `json:"order_method"`
	NameCursor         string      `json:"name_cursor"`
	Cursor             int32       `json:"cursor"`
}

type GetMembersWithDetailUseKeysetPaginateRow struct {
	MMembersPkey           pgtype.Int8 `json:"m_members_pkey"`
	MemberID               uuid.UUID   `json:"member_id"`
	LoginID                string      `json:"login_id"`
	Password               string      `json:"password"`
	Email                  string      `json:"email"`
	Name                   string      `json:"name"`
	FirstName              pgtype.Text `json:"first_name"`
	LastName               pgtype.Text `json:"last_name"`
	AttendStatusID         uuid.UUID   `json:"attend_status_id"`
	ProfileImageID         pgtype.UUID `json:"profile_image_id"`
	GradeID                uuid.UUID   `json:"grade_id"`
	GroupID                uuid.UUID   `json:"group_id"`
	PersonalOrganizationID uuid.UUID   `json:"personal_organization_id"`
	RoleID                 pgtype.UUID `json:"role_id"`
	CreatedAt              time.Time   `json:"created_at"`
	UpdatedAt              time.Time   `json:"updated_at"`
	StudentID              pgtype.UUID `json:"student_id"`
	ProfessorID            pgtype.UUID `json:"professor_id"`
}

func (q *Queries) GetMembersWithDetailUseKeysetPaginate(ctx context.Context, arg GetMembersWithDetailUseKeysetPaginateParams) ([]GetMembersWithDetailUseKeysetPaginateRow, error) {
	rows, err := q.db.Query(ctx, getMembersWithDetailUseKeysetPaginate,
		arg.Limit,
		arg.WhereLikeName,
		arg.SearchName,
		arg.WhereHasPolicy,
		arg.HasPolicyIds,
		arg.WhenInAttendStatus,
		arg.InAttendStatusIds,
		arg.WhenInGrade,
		arg.InGradeIds,
		arg.WhenInGroup,
		arg.InGroupIds,
		arg.CursorDirection,
		arg.OrderMethod,
		arg.NameCursor,
		arg.Cursor,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMembersWithDetailUseKeysetPaginateRow{}
	for rows.Next() {
		var i GetMembersWithDetailUseKeysetPaginateRow
		if err := rows.Scan(
			&i.MMembersPkey,
			&i.MemberID,
			&i.LoginID,
			&i.Password,
			&i.Email,
			&i.Name,
			&i.FirstName,
			&i.LastName,
			&i.AttendStatusID,
			&i.ProfileImageID,
			&i.GradeID,
			&i.GroupID,
			&i.PersonalOrganizationID,
			&i.RoleID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StudentID,
			&i.ProfessorID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMembersWithDetailUseNumberedPaginate = `-- name: GetMembersWithDetailUseNumberedPaginate :many
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.first_name, m_members.last_name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_students.student_id, m_professors.professor_id FROM m_members
LEFT JOIN m_students ON m_members.member_id = m_students.member_id
LEFT JOIN m_professors ON m_members.member_id = m_professors.member_id
WHERE
	CASE WHEN $3::boolean = true THEN m_members.name LIKE '%' || $4::text || '%' ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN (SELECT COUNT(*) FROM m_role_associations WHERE role_id = m_members.role_id AND m_role_associations.policy_id = ANY($6::uuid[])) > 0 ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN m_members.attend_status_id = ANY($8::uuid[]) ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN m_members.grade_id = ANY($10::uuid[]) ELSE TRUE END
AND
	CASE WHEN $11::boolean = true THEN m_members.group_id = ANY($12::uuid[]) ELSE TRUE END
ORDER BY
	CASE WHEN $13::text = 'name' THEN m_members.name END ASC,
	CASE WHEN $13::text = 'r_name' THEN m_members.name END DESC,
	m_members_pkey ASC
LIMIT $1 OFFSET $2
`

type GetMembersWithDetailUseNumberedPaginateParams struct {
	Limit              int32       `json:"limit"`
	Offset             int32       `json:"offset"`
	WhereLikeName      bool        `json:"where_like_name"`
	SearchName         string      `json:"search_name"`
	WhereHasPolicy     bool        `json:"where_has_policy"`
	HasPolicyIds       []uuid.UUID `json:"has_policy_ids"`
	WhenInAttendStatus bool        `json:"when_in_attend_status"`
	InAttendStatusIds  []uuid.UUID `json:"in_attend_status_ids"`
	WhenInGrade        bool        `json:"when_in_grade"`
	InGradeIds         []uuid.UUID `json:"in_grade_ids"`
	WhenInGroup        bool        `json:"when_in_group"`
	InGroupIds         []uuid.UUID `json:"in_group_ids"`
	OrderMethod        string      `json:"order_method"`
}

type GetMembersWithDetailUseNumberedPaginateRow struct {
	MMembersPkey           pgtype.Int8 `json:"m_members_pkey"`
	MemberID               uuid.UUID   `json:"member_id"`
	LoginID                string      `json:"login_id"`
	Password               string      `json:"password"`
	Email                  string      `json:"email"`
	Name                   string      `json:"name"`
	FirstName              pgtype.Text `json:"first_name"`
	LastName               pgtype.Text `json:"last_name"`
	AttendStatusID         uuid.UUID   `json:"attend_status_id"`
	ProfileImageID         pgtype.UUID `json:"profile_image_id"`
	GradeID                uuid.UUID   `json:"grade_id"`
	GroupID                uuid.UUID   `json:"group_id"`
	PersonalOrganizationID uuid.UUID   `json:"personal_organization_id"`
	RoleID                 pgtype.UUID `json:"role_id"`
	CreatedAt              time.Time   `json:"created_at"`
	UpdatedAt              time.Time   `json:"updated_at"`
	StudentID              pgtype.UUID `json:"student_id"`
	ProfessorID            pgtype.UUID `json:"professor_id"`
}

func (q *Queries) GetMembersWithDetailUseNumberedPaginate(ctx context.Context, arg GetMembersWithDetailUseNumberedPaginateParams) ([]GetMembersWithDetailUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getMembersWithDetailUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.WhereLikeName,
		arg.SearchName,
		arg.WhereHasPolicy,
		arg.HasPolicyIds,
		arg.WhenInAttendStatus,
		arg.InAttendStatusIds,
		arg.WhenInGrade,
		arg.InGradeIds,
		arg.WhenInGroup,
		arg.InGroupIds,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMembersWithDetailUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetMembersWithDetailUseNumberedPaginateRow
		if err := rows.Scan(
			&i.MMembersPkey,
			&i.MemberID,
			&i.LoginID,
			&i.Password,
			&i.Email,
			&i.Name,
			&i.FirstName,
			&i.LastName,
			&i.AttendStatusID,
			&i.ProfileImageID,
			&i.GradeID,
			&i.GroupID,
			&i.PersonalOrganizationID,
			&i.RoleID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StudentID,
			&i.ProfessorID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMembersWithPersonalOrganization = `-- name: GetMembersWithPersonalOrganization :many
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.first_name, m_members.last_name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_organizations.name organization_name, m_organizations.description organization_description,
m_organizations.color organization_color, m_organizations.is_personal organization_is_personal,
m_organizations.is_whole organization_is_whole, m_organizations.chat_room_id organization_chat_room_id FROM m_members
LEFT JOIN m_organizations ON m_members.personal_organization_id = m_organizations.organization_id
WHERE
	CASE WHEN $1::boolean = true THEN m_members.name LIKE '%' || $2::text || '%' ELSE TRUE END
AND
	CASE WHEN $3::boolean = true THEN (SELECT COUNT(*) FROM m_role_associations WHERE role_id = m_members.role_id AND m_role_associations.policy_id = ANY($4::uuid[])) > 0 ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN m_members.attend_status_id = ANY($6::uuid[]) ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN m_members.grade_id = ANY($8::uuid[]) ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN m_members.group_id = ANY($10::uuid[]) ELSE TRUE END
ORDER BY
	CASE WHEN $11::text = 'name' THEN m_members.name END ASC,
	CASE WHEN $11::text = 'r_name' THEN m_members.name END DESC,
	m_members_pkey ASC
`

type GetMembersWithPersonalOrganizationParams struct {
	WhereLikeName      bool        `json:"where_like_name"`
	SearchName         string      `json:"search_name"`
	WhereHasPolicy     bool        `json:"where_has_policy"`
	HasPolicyIds       []uuid.UUID `json:"has_policy_ids"`
	WhenInAttendStatus bool        `json:"when_in_attend_status"`
	InAttendStatusIds  []uuid.UUID `json:"in_attend_status_ids"`
	WhenInGrade        bool        `json:"when_in_grade"`
	InGradeIds         []uuid.UUID `json:"in_grade_ids"`
	WhenInGroup        bool        `json:"when_in_group"`
	InGroupIds         []uuid.UUID `json:"in_group_ids"`
	OrderMethod        string      `json:"order_method"`
}

type GetMembersWithPersonalOrganizationRow struct {
	MMembersPkey            pgtype.Int8 `json:"m_members_pkey"`
	MemberID                uuid.UUID   `json:"member_id"`
	LoginID                 string      `json:"login_id"`
	Password                string      `json:"password"`
	Email                   string      `json:"email"`
	Name                    string      `json:"name"`
	FirstName               pgtype.Text `json:"first_name"`
	LastName                pgtype.Text `json:"last_name"`
	AttendStatusID          uuid.UUID   `json:"attend_status_id"`
	ProfileImageID          pgtype.UUID `json:"profile_image_id"`
	GradeID                 uuid.UUID   `json:"grade_id"`
	GroupID                 uuid.UUID   `json:"group_id"`
	PersonalOrganizationID  uuid.UUID   `json:"personal_organization_id"`
	RoleID                  pgtype.UUID `json:"role_id"`
	CreatedAt               time.Time   `json:"created_at"`
	UpdatedAt               time.Time   `json:"updated_at"`
	OrganizationName        pgtype.Text `json:"organization_name"`
	OrganizationDescription pgtype.Text `json:"organization_description"`
	OrganizationColor       pgtype.Text `json:"organization_color"`
	OrganizationIsPersonal  pgtype.Bool `json:"organization_is_personal"`
	OrganizationIsWhole     pgtype.Bool `json:"organization_is_whole"`
	OrganizationChatRoomID  pgtype.UUID `json:"organization_chat_room_id"`
}

func (q *Queries) GetMembersWithPersonalOrganization(ctx context.Context, arg GetMembersWithPersonalOrganizationParams) ([]GetMembersWithPersonalOrganizationRow, error) {
	rows, err := q.db.Query(ctx, getMembersWithPersonalOrganization,
		arg.WhereLikeName,
		arg.SearchName,
		arg.WhereHasPolicy,
		arg.HasPolicyIds,
		arg.WhenInAttendStatus,
		arg.InAttendStatusIds,
		arg.WhenInGrade,
		arg.InGradeIds,
		arg.WhenInGroup,
		arg.InGroupIds,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMembersWithPersonalOrganizationRow{}
	for rows.Next() {
		var i GetMembersWithPersonalOrganizationRow
		if err := rows.Scan(
			&i.MMembersPkey,
			&i.MemberID,
			&i.LoginID,
			&i.Password,
			&i.Email,
			&i.Name,
			&i.FirstName,
			&i.LastName,
			&i.AttendStatusID,
			&i.ProfileImageID,
			&i.GradeID,
			&i.GroupID,
			&i.PersonalOrganizationID,
			&i.RoleID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.OrganizationName,
			&i.OrganizationDescription,
			&i.OrganizationColor,
			&i.OrganizationIsPersonal,
			&i.OrganizationIsWhole,
			&i.OrganizationChatRoomID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMembersWithPersonalOrganizationUseKeysetPaginate = `-- name: GetMembersWithPersonalOrganizationUseKeysetPaginate :many
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.first_name, m_members.last_name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_organizations.name organization_name, m_organizations.description organization_description,
m_organizations.color organization_color, m_organizations.is_personal organization_is_personal,
m_organizations.is_whole organization_is_whole, m_organizations.chat_room_id organization_chat_room_id FROM m_members
LEFT JOIN m_organizations ON m_members.personal_organization_id = m_organizations.organization_id
WHERE
	CASE WHEN $2::boolean = true THEN m_members.name LIKE '%' || $3::text || '%' ELSE TRUE END
AND
	CASE WHEN $4::boolean = true THEN (SELECT COUNT(*) FROM m_role_associations WHERE role_id = m_members.role_id AND m_role_associations.policy_id = ANY($5::uuid[])) > 0 ELSE TRUE END
AND
	CASE WHEN $6::boolean = true THEN m_members.attend_status_id = ANY($7::uuid[]) ELSE TRUE END
AND
	CASE WHEN $8::boolean = true THEN m_members.grade_id = ANY($9::uuid[]) ELSE TRUE END
AND
	CASE WHEN $10::boolean = true THEN m_members.group_id = ANY($11::uuid[]) ELSE TRUE END
AND
	CASE $12::text
		WHEN 'next' THEN
			CASE $13::text
				WHEN 'name' THEN m_members.name > $14 OR (m_members.name = $14 AND m_members_pkey > $15::int)
				WHEN 'r_name' THEN m_members.name < $14 OR (m_members.name = $14 AND m_members_pkey > $15::int)
				ELSE m_members_pkey > $15::int
			END
		WHEN 'prev' THEN
			CASE $13::text
				WHEN 'name' THEN m_members.name < $14 OR (m_members.name = $14 AND m_members_pkey < $15::int)
				WHEN 'r_name' THEN m_members.name > $14 OR (m_members.name = $14 AND m_members_pkey < $15::int)
				ELSE m_members_pkey < $15::int
			END
	END
ORDER BY
	CASE WHEN $13::text = 'name' AND $12::text = 'next' THEN m_members.name END ASC,
	CASE WHEN $13::text = 'name' AND $12::text = 'prev' THEN m_members.name END DESC,
	CASE WHEN $13::text = 'r_name' AND $12::text = 'next' THEN m_members.name END DESC,
	CASE WHEN $13::text = 'r_name' AND $12::text = 'prev' THEN m_members.name END ASC,
	CASE WHEN $12::text = 'next' THEN m_members_pkey END ASC,
	CASE WHEN $12::text = 'prev' THEN m_members_pkey END DESC
LIMIT $1
`

type GetMembersWithPersonalOrganizationUseKeysetPaginateParams struct {
	Limit              int32       `json:"limit"`
	WhereLikeName      bool        `json:"where_like_name"`
	SearchName         string      `json:"search_name"`
	WhereHasPolicy     bool        `json:"where_has_policy"`
	HasPolicyIds       []uuid.UUID `json:"has_policy_ids"`
	WhenInAttendStatus bool        `json:"when_in_attend_status"`
	InAttendStatusIds  []uuid.UUID `json:"in_attend_status_ids"`
	WhenInGrade        bool        `json:"when_in_grade"`
	InGradeIds         []uuid.UUID `json:"in_grade_ids"`
	WhenInGroup        bool        `json:"when_in_group"`
	InGroupIds         []uuid.UUID `json:"in_group_ids"`
	CursorDirection    string      `json:"cursor_direction"`
	OrderMethod        string      `json:"order_method"`
	NameCursor         string      `json:"name_cursor"`
	Cursor             int32       `json:"cursor"`
}

type GetMembersWithPersonalOrganizationUseKeysetPaginateRow struct {
	MMembersPkey            pgtype.Int8 `json:"m_members_pkey"`
	MemberID                uuid.UUID   `json:"member_id"`
	LoginID                 string      `json:"login_id"`
	Password                string      `json:"password"`
	Email                   string      `json:"email"`
	Name                    string      `json:"name"`
	FirstName               pgtype.Text `json:"first_name"`
	LastName                pgtype.Text `json:"last_name"`
	AttendStatusID          uuid.UUID   `json:"attend_status_id"`
	ProfileImageID          pgtype.UUID `json:"profile_image_id"`
	GradeID                 uuid.UUID   `json:"grade_id"`
	GroupID                 uuid.UUID   `json:"group_id"`
	PersonalOrganizationID  uuid.UUID   `json:"personal_organization_id"`
	RoleID                  pgtype.UUID `json:"role_id"`
	CreatedAt               time.Time   `json:"created_at"`
	UpdatedAt               time.Time   `json:"updated_at"`
	OrganizationName        pgtype.Text `json:"organization_name"`
	OrganizationDescription pgtype.Text `json:"organization_description"`
	OrganizationColor       pgtype.Text `json:"organization_color"`
	OrganizationIsPersonal  pgtype.Bool `json:"organization_is_personal"`
	OrganizationIsWhole     pgtype.Bool `json:"organization_is_whole"`
	OrganizationChatRoomID  pgtype.UUID `json:"organization_chat_room_id"`
}

func (q *Queries) GetMembersWithPersonalOrganizationUseKeysetPaginate(ctx context.Context, arg GetMembersWithPersonalOrganizationUseKeysetPaginateParams) ([]GetMembersWithPersonalOrganizationUseKeysetPaginateRow, error) {
	rows, err := q.db.Query(ctx, getMembersWithPersonalOrganizationUseKeysetPaginate,
		arg.Limit,
		arg.WhereLikeName,
		arg.SearchName,
		arg.WhereHasPolicy,
		arg.HasPolicyIds,
		arg.WhenInAttendStatus,
		arg.InAttendStatusIds,
		arg.WhenInGrade,
		arg.InGradeIds,
		arg.WhenInGroup,
		arg.InGroupIds,
		arg.CursorDirection,
		arg.OrderMethod,
		arg.NameCursor,
		arg.Cursor,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMembersWithPersonalOrganizationUseKeysetPaginateRow{}
	for rows.Next() {
		var i GetMembersWithPersonalOrganizationUseKeysetPaginateRow
		if err := rows.Scan(
			&i.MMembersPkey,
			&i.MemberID,
			&i.LoginID,
			&i.Password,
			&i.Email,
			&i.Name,
			&i.FirstName,
			&i.LastName,
			&i.AttendStatusID,
			&i.ProfileImageID,
			&i.GradeID,
			&i.GroupID,
			&i.PersonalOrganizationID,
			&i.RoleID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.OrganizationName,
			&i.OrganizationDescription,
			&i.OrganizationColor,
			&i.OrganizationIsPersonal,
			&i.OrganizationIsWhole,
			&i.OrganizationChatRoomID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMembersWithPersonalOrganizationUseNumberedPaginate = `-- name: GetMembersWithPersonalOrganizationUseNumberedPaginate :many
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.first_name, m_members.last_name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_organizations.name organization_name, m_organizations.description organization_description,
m_organizations.color organization_color, m_organizations.is_personal organization_is_personal,
m_organizations.is_whole organization_is_whole, m_organizations.chat_room_id organization_chat_room_id FROM m_members
LEFT JOIN m_organizations ON m_members.personal_organization_id = m_organizations.organization_id
WHERE
	CASE WHEN $3::boolean = true THEN m_members.name LIKE '%' || $4::text || '%' ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN (SELECT COUNT(*) FROM m_role_associations WHERE role_id = m_members.role_id AND m_role_associations.policy_id = ANY($6::uuid[])) > 0 ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN m_members.attend_status_id = ANY($8::uuid[]) ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN m_members.grade_id = ANY($10::uuid[]) ELSE TRUE END
AND
	CASE WHEN $11::boolean = true THEN m_members.group_id = ANY($12::uuid[]) ELSE TRUE END
ORDER BY
	CASE WHEN $13::text = 'name' THEN m_members.name END ASC,
	CASE WHEN $13::text = 'r_name' THEN m_members.name END DESC,
	m_members_pkey ASC
LIMIT $1 OFFSET $2
`

type GetMembersWithPersonalOrganizationUseNumberedPaginateParams struct {
	Limit              int32       `json:"limit"`
	Offset             int32       `json:"offset"`
	WhereLikeName      bool        `json:"where_like_name"`
	SearchName         string      `json:"search_name"`
	WhereHasPolicy     bool        `json:"where_has_policy"`
	HasPolicyIds       []uuid.UUID `json:"has_policy_ids"`
	WhenInAttendStatus bool        `json:"when_in_attend_status"`
	InAttendStatusIds  []uuid.UUID `json:"in_attend_status_ids"`
	WhenInGrade        bool        `json:"when_in_grade"`
	InGradeIds         []uuid.UUID `json:"in_grade_ids"`
	WhenInGroup        bool        `json:"when_in_group"`
	InGroupIds         []uuid.UUID `json:"in_group_ids"`
	OrderMethod        string      `json:"order_method"`
}

type GetMembersWithPersonalOrganizationUseNumberedPaginateRow struct {
	MMembersPkey            pgtype.Int8 `json:"m_members_pkey"`
	MemberID                uuid.UUID   `json:"member_id"`
	LoginID                 string      `json:"login_id"`
	Password                string      `json:"password"`
	Email                   string      `json:"email"`
	Name                    string      `json:"name"`
	FirstName               pgtype.Text `json:"first_name"`
	LastName                pgtype.Text `json:"last_name"`
	AttendStatusID          uuid.UUID   `json:"attend_status_id"`
	ProfileImageID          pgtype.UUID `json:"profile_image_id"`
	GradeID                 uuid.UUID   `json:"grade_id"`
	GroupID                 uuid.UUID   `json:"group_id"`
	PersonalOrganizationID  uuid.UUID   `json:"personal_organization_id"`
	RoleID                  pgtype.UUID `json:"role_id"`
	CreatedAt               time.Time   `json:"created_at"`
	UpdatedAt               time.Time   `json:"updated_at"`
	OrganizationName        pgtype.Text `json:"organization_name"`
	OrganizationDescription pgtype.Text `json:"organization_description"`
	OrganizationColor       pgtype.Text `json:"organization_color"`
	OrganizationIsPersonal  pgtype.Bool `json:"organization_is_personal"`
	OrganizationIsWhole     pgtype.Bool `json:"organization_is_whole"`
	OrganizationChatRoomID  pgtype.UUID `json:"organization_chat_room_id"`
}

func (q *Queries) GetMembersWithPersonalOrganizationUseNumberedPaginate(ctx context.Context, arg GetMembersWithPersonalOrganizationUseNumberedPaginateParams) ([]GetMembersWithPersonalOrganizationUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getMembersWithPersonalOrganizationUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.WhereLikeName,
		arg.SearchName,
		arg.WhereHasPolicy,
		arg.HasPolicyIds,
		arg.WhenInAttendStatus,
		arg.InAttendStatusIds,
		arg.WhenInGrade,
		arg.InGradeIds,
		arg.WhenInGroup,
		arg.InGroupIds,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMembersWithPersonalOrganizationUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetMembersWithPersonalOrganizationUseNumberedPaginateRow
		if err := rows.Scan(
			&i.MMembersPkey,
			&i.MemberID,
			&i.LoginID,
			&i.Password,
			&i.Email,
			&i.Name,
			&i.FirstName,
			&i.LastName,
			&i.AttendStatusID,
			&i.ProfileImageID,
			&i.GradeID,
			&i.GroupID,
			&i.PersonalOrganizationID,
			&i.RoleID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.OrganizationName,
			&i.OrganizationDescription,
			&i.OrganizationColor,
			&i.OrganizationIsPersonal,
			&i.OrganizationIsWhole,
			&i.OrganizationChatRoomID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMembersWithProfileImage = `-- name: GetMembersWithProfileImage :many
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.first_name, m_members.last_name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, t_images.height profile_image_height,
t_images.width profile_image_width, t_images.attachable_item_id profile_image_attachable_item_id,
t_attachable_items.owner_id profile_image_owner_id, t_attachable_items.from_outer profile_image_from_outer, t_attachable_items.alias profile_image_alias,
t_attachable_items.url profile_image_url, t_attachable_items.size profile_image_size, t_attachable_items.mime_type_id profile_image_mime_type_id
FROM m_members
LEFT JOIN t_images ON m_members.profile_image_id = t_images.image_id
LEFT JOIN t_attachable_items ON t_images.attachable_item_id = t_attachable_items.attachable_item_id
WHERE
	CASE WHEN $1::boolean = true THEN m_members.name LIKE '%' || $2::text || '%' ELSE TRUE END
AND
	CASE WHEN $3::boolean = true THEN (SELECT COUNT(*) FROM m_role_associations WHERE role_id = m_members.role_id AND m_role_associations.policy_id = ANY($4::uuid[])) > 0 ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN m_members.attend_status_id = ANY($6::uuid[]) ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN m_members.grade_id = ANY($8::uuid[]) ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN m_members.group_id = ANY($10::uuid[]) ELSE TRUE END
ORDER BY
	CASE WHEN $11::text = 'name' THEN m_members.name END ASC,
	CASE WHEN $11::text = 'r_name' THEN m_members.name END DESC,
	m_members_pkey ASC
`

type GetMembersWithProfileImageParams struct {
	WhereLikeName      bool        `json:"where_like_name"`
	SearchName         string      `json:"search_name"`
	WhereHasPolicy     bool        `json:"where_has_policy"`
	HasPolicyIds       []uuid.UUID `json:"has_policy_ids"`
	WhenInAttendStatus bool        `json:"when_in_attend_status"`
	InAttendStatusIds  []uuid.UUID `json:"in_attend_status_ids"`
	WhenInGrade        bool        `json:"when_in_grade"`
	InGradeIds         []uuid.UUID `json:"in_grade_ids"`
	WhenInGroup        bool        `json:"when_in_group"`
	InGroupIds         []uuid.UUID `json:"in_group_ids"`
	OrderMethod        string      `json:"order_method"`
}

type GetMembersWithProfileImageRow struct {
	MMembersPkey                 pgtype.Int8   `json:"m_members_pkey"`
	MemberID                     uuid.UUID     `json:"member_id"`
	LoginID                      string        `json:"login_id"`
	Password                     string        `json:"password"`
	Email                        string        `json:"email"`
	Name                         string        `json:"name"`
	FirstName                    pgtype.Text   `json:"first_name"`
	LastName                     pgtype.Text   `json:"last_name"`
	AttendStatusID               uuid.UUID     `json:"attend_status_id"`
	ProfileImageID               pgtype.UUID   `json:"profile_image_id"`
	GradeID                      uuid.UUID     `json:"grade_id"`
	GroupID                      uuid.UUID     `json:"group_id"`
	PersonalOrganizationID       uuid.UUID     `json:"personal_organization_id"`
	RoleID                       pgtype.UUID   `json:"role_id"`
	CreatedAt                    time.Time     `json:"created_at"`
	UpdatedAt                    time.Time     `json:"updated_at"`
	ProfileImageHeight           pgtype.Float8 `json:"profile_image_height"`
	ProfileImageWidth            pgtype.Float8 `json:"profile_image_width"`
	ProfileImageAttachableItemID pgtype.UUID   `json:"profile_image_attachable_item_id"`
	ProfileImageOwnerID          pgtype.UUID   `json:"profile_image_owner_id"`
	ProfileImageFromOuter        pgtype.Bool   `json:"profile_image_from_outer"`
	ProfileImageAlias            pgtype.Text   `json:"profile_image_alias"`
	ProfileImageUrl              pgtype.Text   `json:"profile_image_url"`
	ProfileImageSize             pgtype.Float8 `json:"profile_image_size"`
	ProfileImageMimeTypeID       pgtype.UUID   `json:"profile_image_mime_type_id"`
}

func (q *Queries) GetMembersWithProfileImage(ctx context.Context, arg GetMembersWithProfileImageParams) ([]GetMembersWithProfileImageRow, error) {
	rows, err := q.db.Query(ctx, getMembersWithProfileImage,
		arg.WhereLikeName,
		arg.SearchName,
		arg.WhereHasPolicy,
		arg.HasPolicyIds,
		arg.WhenInAttendStatus,
		arg.InAttendStatusIds,
		arg.WhenInGrade,
		arg.InGradeIds,
		arg.WhenInGroup,
		arg.InGroupIds,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMembersWithProfileImageRow{}
	for rows.Next() {
		var i GetMembersWithProfileImageRow
		if err := rows.Scan(
			&i.MMembersPkey,
			&i.MemberID,
			&i.LoginID,
			&i.Password,
			&i.Email,
			&i.Name,
			&i.FirstName,
			&i.LastName,
			&i.AttendStatusID,
			&i.ProfileImageID,
			&i.GradeID,
			&i.GroupID,
			&i.PersonalOrganizationID,
			&i.RoleID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProfileImageHeight,
			&i.ProfileImageWidth,
			&i.ProfileImageAttachableItemID,
			&i.ProfileImageOwnerID,
			&i.ProfileImageFromOuter,
			&i.ProfileImageAlias,
			&i.ProfileImageUrl,
			&i.ProfileImageSize,
			&i.ProfileImageMimeTypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMembersWithProfileImageUseKeysetPaginate = `-- name: GetMembersWithProfileImageUseKeysetPaginate :many
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.first_name, m_members.last_name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, t_images.height profile_image_height,
t_images.width profile_image_width, t_images.attachable_item_id profile_image_attachable_item_id,
t_attachable_items.owner_id profile_image_owner_id, t_attachable_items.from_outer profile_image_from_outer, t_attachable_items.alias profile_image_alias,
t_attachable_items.url profile_image_url, t_attachable_items.size profile_image_size, t_attachable_items.mime_type_id profile_image_mime_type_id
FROM m_members
LEFT JOIN t_images ON m_members.profile_image_id = t_images.image_id
LEFT JOIN t_attachable_items ON t_images.attachable_item_id = t_attachable_items.attachable_item_id
WHERE
	CASE WHEN $2::boolean = true THEN m_members.name LIKE '%' || $3::text || '%' ELSE TRUE END
AND
	CASE WHEN $4::boolean = true THEN (SELECT COUNT(*) FROM m_role_associations WHERE role_id = m_members.role_id AND m_role_associations.policy_id = ANY($5::uuid[])) > 0 ELSE TRUE END
AND
	CASE WHEN $6::boolean = true THEN m_members.attend_status_id = ANY($7::uuid[]) ELSE TRUE END
AND
	CASE WHEN $8::boolean = true THEN m_members.grade_id = ANY($9::uuid[]) ELSE TRUE END
AND
	CASE WHEN $10::boolean = true THEN m_members.group_id = ANY($11::uuid[]) ELSE TRUE END
AND
	CASE $12::text
		WHEN 'next' THEN
			CASE $13::text
				WHEN 'name' THEN m_members.name > $14 OR (m_members.name = $14 AND m_members_pkey > $15::int)
				WHEN 'r_name' THEN m_members.name < $14 OR (m_members.name = $14 AND m_members_pkey > $15::int)
				ELSE m_members_pkey > $15::int
			END
		WHEN 'prev' THEN
			CASE $13::text
				WHEN 'name' THEN m_members.name < $14 OR (m_members.name = $14 AND m_members_pkey < $15::int)
				WHEN 'r_name' THEN m_members.name > $14 OR (m_members.name = $14 AND m_members_pkey < $15::int)
				ELSE m_members_pkey < $15::int
			END
	END
ORDER BY
	CASE WHEN $13::text = 'name' AND $12::text = 'next' THEN m_members.name END ASC,
	CASE WHEN $13::text = 'name' AND $12::text = 'prev' THEN m_members.name END DESC,
	CASE WHEN $13::text = 'r_name' AND $12::text = 'next' THEN m_members.name END DESC,
	CASE WHEN $13::text = 'r_name' AND $12::text = 'prev' THEN m_members.name END ASC,
	CASE WHEN $12::text = 'next' THEN m_members_pkey END ASC,
	CASE WHEN $12::text = 'prev' THEN m_members_pkey END DESC
LIMIT $1
`

type GetMembersWithProfileImageUseKeysetPaginateParams struct {
	Limit              int32       `json:"limit"`
	WhereLikeName      bool        `json:"where_like_name"`
	SearchName         string      `json:"search_name"`
	WhereHasPolicy     bool        `json:"where_has_policy"`
	HasPolicyIds       []uuid.UUID `json:"has_policy_ids"`
	WhenInAttendStatus bool        `json:"when_in_attend_status"`
	InAttendStatusIds  []uuid.UUID `json:"in_attend_status_ids"`
	WhenInGrade        bool        `json:"when_in_grade"`
	InGradeIds         []uuid.UUID `json:"in_grade_ids"`
	WhenInGroup        bool        `json:"when_in_group"`
	InGroupIds         []uuid.UUID `json:"in_group_ids"`
	CursorDirection    string      `json:"cursor_direction"`
	OrderMethod        string      `json:"order_method"`
	NameCursor         string      `json:"name_cursor"`
	Cursor             int32       `json:"cursor"`
}

type GetMembersWithProfileImageUseKeysetPaginateRow struct {
	MMembersPkey                 pgtype.Int8   `json:"m_members_pkey"`
	MemberID                     uuid.UUID     `json:"member_id"`
	LoginID                      string        `json:"login_id"`
	Password                     string        `json:"password"`
	Email                        string        `json:"email"`
	Name                         string        `json:"name"`
	FirstName                    pgtype.Text   `json:"first_name"`
	LastName                     pgtype.Text   `json:"last_name"`
	AttendStatusID               uuid.UUID     `json:"attend_status_id"`
	ProfileImageID               pgtype.UUID   `json:"profile_image_id"`
	GradeID                      uuid.UUID     `json:"grade_id"`
	GroupID                      uuid.UUID     `json:"group_id"`
	PersonalOrganizationID       uuid.UUID     `json:"personal_organization_id"`
	RoleID                       pgtype.UUID   `json:"role_id"`
	CreatedAt                    time.Time     `json:"created_at"`
	UpdatedAt                    time.Time     `json:"updated_at"`
	ProfileImageHeight           pgtype.Float8 `json:"profile_image_height"`
	ProfileImageWidth            pgtype.Float8 `json:"profile_image_width"`
	ProfileImageAttachableItemID pgtype.UUID   `json:"profile_image_attachable_item_id"`
	ProfileImageOwnerID          pgtype.UUID   `json:"profile_image_owner_id"`
	ProfileImageFromOuter        pgtype.Bool   `json:"profile_image_from_outer"`
	ProfileImageAlias            pgtype.Text   `json:"profile_image_alias"`
	ProfileImageUrl              pgtype.Text   `json:"profile_image_url"`
	ProfileImageSize             pgtype.Float8 `json:"profile_image_size"`
	ProfileImageMimeTypeID       pgtype.UUID   `json:"profile_image_mime_type_id"`
}

func (q *Queries) GetMembersWithProfileImageUseKeysetPaginate(ctx context.Context, arg GetMembersWithProfileImageUseKeysetPaginateParams) ([]GetMembersWithProfileImageUseKeysetPaginateRow, error) {
	rows, err := q.db.Query(ctx, getMembersWithProfileImageUseKeysetPaginate,
		arg.Limit,
		arg.WhereLikeName,
		arg.SearchName,
		arg.WhereHasPolicy,
		arg.HasPolicyIds,
		arg.WhenInAttendStatus,
		arg.InAttendStatusIds,
		arg.WhenInGrade,
		arg.InGradeIds,
		arg.WhenInGroup,
		arg.InGroupIds,
		arg.CursorDirection,
		arg.OrderMethod,
		arg.NameCursor,
		arg.Cursor,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMembersWithProfileImageUseKeysetPaginateRow{}
	for rows.Next() {
		var i GetMembersWithProfileImageUseKeysetPaginateRow
		if err := rows.Scan(
			&i.MMembersPkey,
			&i.MemberID,
			&i.LoginID,
			&i.Password,
			&i.Email,
			&i.Name,
			&i.FirstName,
			&i.LastName,
			&i.AttendStatusID,
			&i.ProfileImageID,
			&i.GradeID,
			&i.GroupID,
			&i.PersonalOrganizationID,
			&i.RoleID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProfileImageHeight,
			&i.ProfileImageWidth,
			&i.ProfileImageAttachableItemID,
			&i.ProfileImageOwnerID,
			&i.ProfileImageFromOuter,
			&i.ProfileImageAlias,
			&i.ProfileImageUrl,
			&i.ProfileImageSize,
			&i.ProfileImageMimeTypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMembersWithProfileImageUseNumberedPaginate = `-- name: GetMembersWithProfileImageUseNumberedPaginate :many
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.first_name, m_members.last_name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, t_images.height profile_image_height,
t_images.width profile_image_width, t_images.attachable_item_id profile_image_attachable_item_id,
t_attachable_items.owner_id profile_image_owner_id, t_attachable_items.from_outer profile_image_from_outer, t_attachable_items.alias profile_image_alias,
t_attachable_items.url profile_image_url, t_attachable_items.size profile_image_size, t_attachable_items.mime_type_id profile_image_mime_type_id
FROM m_members
LEFT JOIN t_images ON m_members.profile_image_id = t_images.image_id
LEFT JOIN t_attachable_items ON t_images.attachable_item_id = t_attachable_items.attachable_item_id
WHERE
	CASE WHEN $3::boolean = true THEN m_members.name LIKE '%' || $4::text || '%' ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN (SELECT COUNT(*) FROM m_role_associations WHERE role_id = m_members.role_id AND m_role_associations.policy_id = ANY($6::uuid[])) > 0 ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN m_members.attend_status_id = ANY($8::uuid[]) ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN m_members.grade_id = ANY($10::uuid[]) ELSE TRUE END
AND
	CASE WHEN $11::boolean = true THEN m_members.group_id = ANY($12::uuid[]) ELSE TRUE END
ORDER BY
	CASE WHEN $13::text = 'name' THEN m_members.name END ASC,
	CASE WHEN $13::text = 'r_name' THEN m_members.name END DESC,
	m_members_pkey ASC
LIMIT $1 OFFSET $2
`

type GetMembersWithProfileImageUseNumberedPaginateParams struct {
	Limit              int32       `json:"limit"`
	Offset             int32       `json:"offset"`
	WhereLikeName      bool        `json:"where_like_name"`
	SearchName         string      `json:"search_name"`
	WhereHasPolicy     bool        `json:"where_has_policy"`
	HasPolicyIds       []uuid.UUID `json:"has_policy_ids"`
	WhenInAttendStatus bool        `json:"when_in_attend_status"`
	InAttendStatusIds  []uuid.UUID `json:"in_attend_status_ids"`
	WhenInGrade        bool        `json:"when_in_grade"`
	InGradeIds         []uuid.UUID `json:"in_grade_ids"`
	WhenInGroup        bool        `json:"when_in_group"`
	InGroupIds         []uuid.UUID `json:"in_group_ids"`
	OrderMethod        string      `json:"order_method"`
}

type GetMembersWithProfileImageUseNumberedPaginateRow struct {
	MMembersPkey                 pgtype.Int8   `json:"m_members_pkey"`
	MemberID                     uuid.UUID     `json:"member_id"`
	LoginID                      string        `json:"login_id"`
	Password                     string        `json:"password"`
	Email                        string        `json:"email"`
	Name                         string        `json:"name"`
	FirstName                    pgtype.Text   `json:"first_name"`
	LastName                     pgtype.Text   `json:"last_name"`
	AttendStatusID               uuid.UUID     `json:"attend_status_id"`
	ProfileImageID               pgtype.UUID   `json:"profile_image_id"`
	GradeID                      uuid.UUID     `json:"grade_id"`
	GroupID                      uuid.UUID     `json:"group_id"`
	PersonalOrganizationID       uuid.UUID     `json:"personal_organization_id"`
	RoleID                       pgtype.UUID   `json:"role_id"`
	CreatedAt                    time.Time     `json:"created_at"`
	UpdatedAt                    time.Time     `json:"updated_at"`
	ProfileImageHeight           pgtype.Float8 `json:"profile_image_height"`
	ProfileImageWidth            pgtype.Float8 `json:"profile_image_width"`
	ProfileImageAttachableItemID pgtype.UUID   `json:"profile_image_attachable_item_id"`
	ProfileImageOwnerID          pgtype.UUID   `json:"profile_image_owner_id"`
	ProfileImageFromOuter        pgtype.Bool   `json:"profile_image_from_outer"`
	ProfileImageAlias            pgtype.Text   `json:"profile_image_alias"`
	ProfileImageUrl              pgtype.Text   `json:"profile_image_url"`
	ProfileImageSize             pgtype.Float8 `json:"profile_image_size"`
	ProfileImageMimeTypeID       pgtype.UUID   `json:"profile_image_mime_type_id"`
}

func (q *Queries) GetMembersWithProfileImageUseNumberedPaginate(ctx context.Context, arg GetMembersWithProfileImageUseNumberedPaginateParams) ([]GetMembersWithProfileImageUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getMembersWithProfileImageUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.WhereLikeName,
		arg.SearchName,
		arg.WhereHasPolicy,
		arg.HasPolicyIds,
		arg.WhenInAttendStatus,
		arg.InAttendStatusIds,
		arg.WhenInGrade,
		arg.InGradeIds,
		arg.WhenInGroup,
		arg.InGroupIds,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMembersWithProfileImageUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetMembersWithProfileImageUseNumberedPaginateRow
		if err := rows.Scan(
			&i.MMembersPkey,
			&i.MemberID,
			&i.LoginID,
			&i.Password,
			&i.Email,
			&i.Name,
			&i.FirstName,
			&i.LastName,
			&i.AttendStatusID,
			&i.ProfileImageID,
			&i.GradeID,
			&i.GroupID,
			&i.PersonalOrganizationID,
			&i.RoleID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProfileImageHeight,
			&i.ProfileImageWidth,
			&i.ProfileImageAttachableItemID,
			&i.ProfileImageOwnerID,
			&i.ProfileImageFromOuter,
			&i.ProfileImageAlias,
			&i.ProfileImageUrl,
			&i.ProfileImageSize,
			&i.ProfileImageMimeTypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMembersWithRole = `-- name: GetMembersWithRole :many
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.first_name, m_members.last_name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_roles.name role_name, m_roles.description role_description FROM m_members
LEFT JOIN m_roles ON m_members.role_id = m_roles.role_id
WHERE
	CASE WHEN $1::boolean = true THEN m_members.name LIKE '%' || $2::text || '%' ELSE TRUE END
AND
	CASE WHEN $3::boolean = true THEN (SELECT COUNT(*) FROM m_role_associations WHERE role_id = m_members.role_id AND m_role_associations.policy_id = ANY($4::uuid[])) > 0 ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN m_members.attend_status_id = ANY($6::uuid[]) ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN m_members.grade_id = ANY($8::uuid[]) ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN m_members.group_id = ANY($10::uuid[]) ELSE TRUE END
ORDER BY
	CASE WHEN $11::text = 'name' THEN m_members.name END ASC,
	CASE WHEN $11::text = 'r_name' THEN m_members.name END DESC,
	m_members_pkey ASC
`

type GetMembersWithRoleParams struct {
	WhereLikeName      bool        `json:"where_like_name"`
	SearchName         string      `json:"search_name"`
	WhereHasPolicy     bool        `json:"where_has_policy"`
	HasPolicyIds       []uuid.UUID `json:"has_policy_ids"`
	WhenInAttendStatus bool        `json:"when_in_attend_status"`
	InAttendStatusIds  []uuid.UUID `json:"in_attend_status_ids"`
	WhenInGrade        bool        `json:"when_in_grade"`
	InGradeIds         []uuid.UUID `json:"in_grade_ids"`
	WhenInGroup        bool        `json:"when_in_group"`
	InGroupIds         []uuid.UUID `json:"in_group_ids"`
	OrderMethod        string      `json:"order_method"`
}

type GetMembersWithRoleRow struct {
	MMembersPkey           pgtype.Int8 `json:"m_members_pkey"`
	MemberID               uuid.UUID   `json:"member_id"`
	LoginID                string      `json:"login_id"`
	Password               string      `json:"password"`
	Email                  string      `json:"email"`
	Name                   string      `json:"name"`
	FirstName              pgtype.Text `json:"first_name"`
	LastName               pgtype.Text `json:"last_name"`
	AttendStatusID         uuid.UUID   `json:"attend_status_id"`
	ProfileImageID         pgtype.UUID `json:"profile_image_id"`
	GradeID                uuid.UUID   `json:"grade_id"`
	GroupID                uuid.UUID   `json:"group_id"`
	PersonalOrganizationID uuid.UUID   `json:"personal_organization_id"`
	RoleID                 pgtype.UUID `json:"role_id"`
	CreatedAt              time.Time   `json:"created_at"`
	UpdatedAt              time.Time   `json:"updated_at"`
	RoleName               pgtype.Text `json:"role_name"`
	RoleDescription        pgtype.Text `json:"role_description"`
}

func (q *Queries) GetMembersWithRole(ctx context.Context, arg GetMembersWithRoleParams) ([]GetMembersWithRoleRow, error) {
	rows, err := q.db.Query(ctx, getMembersWithRole,
		arg.WhereLikeName,
		arg.SearchName,
		arg.WhereHasPolicy,
		arg.HasPolicyIds,
		arg.WhenInAttendStatus,
		arg.InAttendStatusIds,
		arg.WhenInGrade,
		arg.InGradeIds,
		arg.WhenInGroup,
		arg.InGroupIds,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMembersWithRoleRow{}
	for rows.Next() {
		var i GetMembersWithRoleRow
		if err := rows.Scan(
			&i.MMembersPkey,
			&i.MemberID,
			&i.LoginID,
			&i.Password,
			&i.Email,
			&i.Name,
			&i.FirstName,
			&i.LastName,
			&i.AttendStatusID,
			&i.ProfileImageID,
			&i.GradeID,
			&i.GroupID,
			&i.PersonalOrganizationID,
			&i.RoleID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RoleName,
			&i.RoleDescription,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMembersWithRoleUseKeysetPaginate = `-- name: GetMembersWithRoleUseKeysetPaginate :many
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.first_name, m_members.last_name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_roles.name role_name, m_roles.description role_description FROM m_members
LEFT JOIN m_roles ON m_members.role_id = m_roles.role_id
WHERE
	CASE WHEN $2::boolean = true THEN m_members.name LIKE '%' || $3::text || '%' ELSE TRUE END
AND
	CASE WHEN $4::boolean = true THEN (SELECT COUNT(*) FROM m_role_associations WHERE role_id = m_members.role_id AND m_role_associations.policy_id = ANY($5::uuid[])) > 0 ELSE TRUE END
AND
	CASE WHEN $6::boolean = true THEN m_members.attend_status_id = ANY($7::uuid[]) ELSE TRUE END
AND
	CASE WHEN $8::boolean = true THEN m_members.grade_id = ANY($9::uuid[]) ELSE TRUE END
AND
	CASE WHEN $10::boolean = true THEN m_members.group_id = ANY($11::uuid[]) ELSE TRUE END
AND
	CASE $12::text
		WHEN 'next' THEN
			CASE $13::text
				WHEN 'name' THEN m_members.name > $14 OR (m_members.name = $14 AND m_members_pkey > $15::int)
				WHEN 'r_name' THEN m_members.name < $14 OR (m_members.name = $14 AND m_members_pkey > $15::int)
				ELSE m_members_pkey > $15::int
			END
		WHEN 'prev' THEN
			CASE $13::text
				WHEN 'name' THEN m_members.name < $14 OR (m_members.name = $14 AND m_members_pkey < $15::int)
				WHEN 'r_name' THEN m_members.name > $14 OR (m_members.name = $14 AND m_members_pkey < $15::int)
				ELSE m_members_pkey < $15::int
			END
	END
ORDER BY
	CASE WHEN $13::text = 'name' AND $12::text = 'next' THEN m_members.name END ASC,
	CASE WHEN $13::text = 'name' AND $12::text = 'prev' THEN m_members.name END DESC,
	CASE WHEN $13::text = 'r_name' AND $12::text = 'next' THEN m_members.name END DESC,
	CASE WHEN $13::text = 'r_name' AND $12::text = 'prev' THEN m_members.name END ASC,
	CASE WHEN $12::text = 'next' THEN m_members_pkey END ASC,
	CASE WHEN $12::text = 'prev' THEN m_members_pkey END DESC
LIMIT $1
`

type GetMembersWithRoleUseKeysetPaginateParams struct {
	Limit              int32       `json:"limit"`
	WhereLikeName      bool        `json:"where_like_name"`
	SearchName         string      `json:"search_name"`
	WhereHasPolicy     bool        `json:"where_has_policy"`
	HasPolicyIds       []uuid.UUID `json:"has_policy_ids"`
	WhenInAttendStatus bool        `json:"when_in_attend_status"`
	InAttendStatusIds  []uuid.UUID `json:"in_attend_status_ids"`
	WhenInGrade        bool        `json:"when_in_grade"`
	InGradeIds         []uuid.UUID `json:"in_grade_ids"`
	WhenInGroup        bool        `json:"when_in_group"`
	InGroupIds         []uuid.UUID `json:"in_group_ids"`
	CursorDirection    string      `json:"cursor_direction"`
	OrderMethod        string      `json:"order_method"`
	NameCursor         string      `json:"name_cursor"`
	Cursor             int32       `json:"cursor"`
}

type GetMembersWithRoleUseKeysetPaginateRow struct {
	MMembersPkey           pgtype.Int8 `json:"m_members_pkey"`
	MemberID               uuid.UUID   `json:"member_id"`
	LoginID                string      `json:"login_id"`
	Password               string      `json:"password"`
	Email                  string      `json:"email"`
	Name                   string      `json:"name"`
	FirstName              pgtype.Text `json:"first_name"`
	LastName               pgtype.Text `json:"last_name"`
	AttendStatusID         uuid.UUID   `json:"attend_status_id"`
	ProfileImageID         pgtype.UUID `json:"profile_image_id"`
	GradeID                uuid.UUID   `json:"grade_id"`
	GroupID                uuid.UUID   `json:"group_id"`
	PersonalOrganizationID uuid.UUID   `json:"personal_organization_id"`
	RoleID                 pgtype.UUID `json:"role_id"`
	CreatedAt              time.Time   `json:"created_at"`
	UpdatedAt              time.Time   `json:"updated_at"`
	RoleName               pgtype.Text `json:"role_name"`
	RoleDescription        pgtype.Text `json:"role_description"`
}

func (q *Queries) GetMembersWithRoleUseKeysetPaginate(ctx context.Context, arg GetMembersWithRoleUseKeysetPaginateParams) ([]GetMembersWithRoleUseKeysetPaginateRow, error) {
	rows, err := q.db.Query(ctx, getMembersWithRoleUseKeysetPaginate,
		arg.Limit,
		arg.WhereLikeName,
		arg.SearchName,
		arg.WhereHasPolicy,
		arg.HasPolicyIds,
		arg.WhenInAttendStatus,
		arg.InAttendStatusIds,
		arg.WhenInGrade,
		arg.InGradeIds,
		arg.WhenInGroup,
		arg.InGroupIds,
		arg.CursorDirection,
		arg.OrderMethod,
		arg.NameCursor,
		arg.Cursor,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMembersWithRoleUseKeysetPaginateRow{}
	for rows.Next() {
		var i GetMembersWithRoleUseKeysetPaginateRow
		if err := rows.Scan(
			&i.MMembersPkey,
			&i.MemberID,
			&i.LoginID,
			&i.Password,
			&i.Email,
			&i.Name,
			&i.FirstName,
			&i.LastName,
			&i.AttendStatusID,
			&i.ProfileImageID,
			&i.GradeID,
			&i.GroupID,
			&i.PersonalOrganizationID,
			&i.RoleID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RoleName,
			&i.RoleDescription,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMembersWithRoleUseNumberedPaginate = `-- name: GetMembersWithRoleUseNumberedPaginate :many
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.first_name, m_members.last_name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_roles.name role_name, m_roles.description role_description FROM m_members
LEFT JOIN m_roles ON m_members.role_id = m_roles.role_id
WHERE
	CASE WHEN $3::boolean = true THEN m_members.name LIKE '%' || $4::text || '%' ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN (SELECT COUNT(*) FROM m_role_associations WHERE role_id = m_members.role_id AND m_role_associations.policy_id = ANY($6::uuid[])) > 0 ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN m_members.attend_status_id = ANY($8::uuid[]) ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN m_members.grade_id = ANY($10::uuid[]) ELSE TRUE END
AND
	CASE WHEN $11::boolean = true THEN m_members.group_id = ANY($12::uuid[]) ELSE TRUE END
ORDER BY
	CASE WHEN $13::text = 'name' THEN m_members.name END ASC,
	CASE WHEN $13::text = 'r_name' THEN m_members.name END DESC,
	m_members_pkey ASC
LIMIT $1 OFFSET $2
`

type GetMembersWithRoleUseNumberedPaginateParams struct {
	Limit              int32       `json:"limit"`
	Offset             int32       `json:"offset"`
	WhereLikeName      bool        `json:"where_like_name"`
	SearchName         string      `json:"search_name"`
	WhereHasPolicy     bool        `json:"where_has_policy"`
	HasPolicyIds       []uuid.UUID `json:"has_policy_ids"`
	WhenInAttendStatus bool        `json:"when_in_attend_status"`
	InAttendStatusIds  []uuid.UUID `json:"in_attend_status_ids"`
	WhenInGrade        bool        `json:"when_in_grade"`
	InGradeIds         []uuid.UUID `json:"in_grade_ids"`
	WhenInGroup        bool        `json:"when_in_group"`
	InGroupIds         []uuid.UUID `json:"in_group_ids"`
	OrderMethod        string      `json:"order_method"`
}

type GetMembersWithRoleUseNumberedPaginateRow struct {
	MMembersPkey           pgtype.Int8 `json:"m_members_pkey"`
	MemberID               uuid.UUID   `json:"member_id"`
	LoginID                string      `json:"login_id"`
	Password               string      `json:"password"`
	Email                  string      `json:"email"`
	Name                   string      `json:"name"`
	FirstName              pgtype.Text `json:"first_name"`
	LastName               pgtype.Text `json:"last_name"`
	AttendStatusID         uuid.UUID   `json:"attend_status_id"`
	ProfileImageID         pgtype.UUID `json:"profile_image_id"`
	GradeID                uuid.UUID   `json:"grade_id"`
	GroupID                uuid.UUID   `json:"group_id"`
	PersonalOrganizationID uuid.UUID   `json:"personal_organization_id"`
	RoleID                 pgtype.UUID `json:"role_id"`
	CreatedAt              time.Time   `json:"created_at"`
	UpdatedAt              time.Time   `json:"updated_at"`
	RoleName               pgtype.Text `json:"role_name"`
	RoleDescription        pgtype.Text `json:"role_description"`
}

func (q *Queries) GetMembersWithRoleUseNumberedPaginate(ctx context.Context, arg GetMembersWithRoleUseNumberedPaginateParams) ([]GetMembersWithRoleUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getMembersWithRoleUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.WhereLikeName,
		arg.SearchName,
		arg.WhereHasPolicy,
		arg.HasPolicyIds,
		arg.WhenInAttendStatus,
		arg.InAttendStatusIds,
		arg.WhenInGrade,
		arg.InGradeIds,
		arg.WhenInGroup,
		arg.InGroupIds,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMembersWithRoleUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetMembersWithRoleUseNumberedPaginateRow
		if err := rows.Scan(
			&i.MMembersPkey,
			&i.MemberID,
			&i.LoginID,
			&i.Password,
			&i.Email,
			&i.Name,
			&i.FirstName,
			&i.LastName,
			&i.AttendStatusID,
			&i.ProfileImageID,
			&i.GradeID,
			&i.GroupID,
			&i.PersonalOrganizationID,
			&i.RoleID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RoleName,
			&i.RoleDescription,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralMembers = `-- name: GetPluralMembers :many
SELECT m_members_pkey, member_id, login_id, password, email, name, first_name, last_name, attend_status_id, profile_image_id, grade_id, group_id, personal_organization_id, role_id, created_at, updated_at FROM m_members WHERE member_id = ANY($1::uuid[])
ORDER BY
	CASE WHEN $2::text = 'name' THEN m_members.name END ASC,
	CASE WHEN $2::text = 'r_name' THEN m_members.name END DESC,
	m_members_pkey ASC
`

type GetPluralMembersParams struct {
	MemberIds   []uuid.UUID `json:"member_ids"`
	OrderMethod string      `json:"order_method"`
}

func (q *Queries) GetPluralMembers(ctx context.Context, arg GetPluralMembersParams) ([]Member, error) {
	rows, err := q.db.Query(ctx, getPluralMembers, arg.MemberIds, arg.OrderMethod)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Member{}
	for rows.Next() {
		var i Member
		if err := rows.Scan(
			&i.MMembersPkey,
			&i.MemberID,
			&i.LoginID,
			&i.Password,
			&i.Email,
			&i.Name,
			&i.FirstName,
			&i.LastName,
			&i.AttendStatusID,
			&i.ProfileImageID,
			&i.GradeID,
			&i.GroupID,
			&i.PersonalOrganizationID,
			&i.RoleID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralMembersUseNumberedPaginate = `-- name: GetPluralMembersUseNumberedPaginate :many
SELECT m_members_pkey, member_id, login_id, password, email, name, first_name, last_name, attend_status_id, profile_image_id, grade_id, group_id, personal_organization_id, role_id, created_at, updated_at FROM m_members WHERE member_id = ANY($3::uuid[])
ORDER BY
	CASE WHEN $4::text = 'name' THEN m_members.name END ASC,
	CASE WHEN $4::text = 'r_name' THEN m_members.name END DESC,
	m_members_pkey ASC
LIMIT $1 OFFSET $2
`

type GetPluralMembersUseNumberedPaginateParams struct {
	Limit       int32       `json:"limit"`
	Offset      int32       `json:"offset"`
	MemberIds   []uuid.UUID `json:"member_ids"`
	OrderMethod string      `json:"order_method"`
}

func (q *Queries) GetPluralMembersUseNumberedPaginate(ctx context.Context, arg GetPluralMembersUseNumberedPaginateParams) ([]Member, error) {
	rows, err := q.db.Query(ctx, getPluralMembersUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.MemberIds,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Member{}
	for rows.Next() {
		var i Member
		if err := rows.Scan(
			&i.MMembersPkey,
			&i.MemberID,
			&i.LoginID,
			&i.Password,
			&i.Email,
			&i.Name,
			&i.FirstName,
			&i.LastName,
			&i.AttendStatusID,
			&i.ProfileImageID,
			&i.GradeID,
			&i.GroupID,
			&i.PersonalOrganizationID,
			&i.RoleID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralMembersWithAttendStatus = `-- name: GetPluralMembersWithAttendStatus :many
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.first_name, m_members.last_name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_attend_statuses.name attend_status_name, m_attend_statuses.key attend_status_key FROM m_members
LEFT JOIN m_attend_statuses ON m_members.attend_status_id = m_attend_statuses.attend_status_id
WHERE member_id = ANY($1::uuid[])
ORDER BY
	CASE WHEN $2::text = 'name' THEN m_members.name END ASC,
	CASE WHEN $2::text = 'r_name' THEN m_members.name END DESC,
	m_members_pkey ASC
`

type GetPluralMembersWithAttendStatusParams struct {
	MemberIds   []uuid.UUID `json:"member_ids"`
	OrderMethod string      `json:"order_method"`
}

type GetPluralMembersWithAttendStatusRow struct {
	MMembersPkey           pgtype.Int8 `json:"m_members_pkey"`
	MemberID               uuid.UUID   `json:"member_id"`
	LoginID                string      `json:"login_id"`
	Password               string      `json:"password"`
	Email                  string      `json:"email"`
	Name                   string      `json:"name"`
	FirstName              pgtype.Text `json:"first_name"`
	LastName               pgtype.Text `json:"last_name"`
	AttendStatusID         uuid.UUID   `json:"attend_status_id"`
	ProfileImageID         pgtype.UUID `json:"profile_image_id"`
	GradeID                uuid.UUID   `json:"grade_id"`
	GroupID                uuid.UUID   `json:"group_id"`
	PersonalOrganizationID uuid.UUID   `json:"personal_organization_id"`
	RoleID                 pgtype.UUID `json:"role_id"`
	CreatedAt              time.Time   `json:"created_at"`
	UpdatedAt              time.Time   `json:"updated_at"`
	AttendStatusName       pgtype.Text `json:"attend_status_name"`
	AttendStatusKey        pgtype.Text `json:"attend_status_key"`
}

func (q *Queries) GetPluralMembersWithAttendStatus(ctx context.Context, arg GetPluralMembersWithAttendStatusParams) ([]GetPluralMembersWithAttendStatusRow, error) {
	rows, err := q.db.Query(ctx, getPluralMembersWithAttendStatus, arg.MemberIds, arg.OrderMethod)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralMembersWithAttendStatusRow{}
	for rows.Next() {
		var i GetPluralMembersWithAttendStatusRow
		if err := rows.Scan(
			&i.MMembersPkey,
			&i.MemberID,
			&i.LoginID,
			&i.Password,
			&i.Email,
			&i.Name,
			&i.FirstName,
			&i.LastName,
			&i.AttendStatusID,
			&i.ProfileImageID,
			&i.GradeID,
			&i.GroupID,
			&i.PersonalOrganizationID,
			&i.RoleID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AttendStatusName,
			&i.AttendStatusKey,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralMembersWithAttendStatusUseNumberedPaginate = `-- name: GetPluralMembersWithAttendStatusUseNumberedPaginate :many
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.first_name, m_members.last_name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_attend_statuses.name attend_status_name, m_attend_statuses.key attend_status_key FROM m_members
LEFT JOIN m_attend_statuses ON m_members.attend_status_id = m_attend_statuses.attend_status_id
WHERE member_id = ANY($3::uuid[])
ORDER BY
	CASE WHEN $4::text = 'name' THEN m_members.name END ASC,
	CASE WHEN $4::text = 'r_name' THEN m_members.name END DESC,
	m_members_pkey ASC
LIMIT $1 OFFSET $2
`

type GetPluralMembersWithAttendStatusUseNumberedPaginateParams struct {
	Limit       int32       `json:"limit"`
	Offset      int32       `json:"offset"`
	MemberIds   []uuid.UUID `json:"member_ids"`
	OrderMethod string      `json:"order_method"`
}

type GetPluralMembersWithAttendStatusUseNumberedPaginateRow struct {
	MMembersPkey           pgtype.Int8 `json:"m_members_pkey"`
	MemberID               uuid.UUID   `json:"member_id"`
	LoginID                string      `json:"login_id"`
	Password               string      `json:"password"`
	Email                  string      `json:"email"`
	Name                   string      `json:"name"`
	FirstName              pgtype.Text `json:"first_name"`
	LastName               pgtype.Text `json:"last_name"`
	AttendStatusID         uuid.UUID   `json:"attend_status_id"`
	ProfileImageID         pgtype.UUID `json:"profile_image_id"`
	GradeID                uuid.UUID   `json:"grade_id"`
	GroupID                uuid.UUID   `json:"group_id"`
	PersonalOrganizationID uuid.UUID   `json:"personal_organization_id"`
	RoleID                 pgtype.UUID `json:"role_id"`
	CreatedAt              time.Time   `json:"created_at"`
	UpdatedAt              time.Time   `json:"updated_at"`
	AttendStatusName       pgtype.Text `json:"attend_status_name"`
	AttendStatusKey        pgtype.Text `json:"attend_status_key"`
}

func (q *Queries) GetPluralMembersWithAttendStatusUseNumberedPaginate(ctx context.Context, arg GetPluralMembersWithAttendStatusUseNumberedPaginateParams) ([]GetPluralMembersWithAttendStatusUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getPluralMembersWithAttendStatusUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.MemberIds,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralMembersWithAttendStatusUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetPluralMembersWithAttendStatusUseNumberedPaginateRow
		if err := rows.Scan(
			&i.MMembersPkey,
			&i.MemberID,
			&i.LoginID,
			&i.Password,
			&i.Email,
			&i.Name,
			&i.FirstName,
			&i.LastName,
			&i.AttendStatusID,
			&i.ProfileImageID,
			&i.GradeID,
			&i.GroupID,
			&i.PersonalOrganizationID,
			&i.RoleID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AttendStatusName,
			&i.AttendStatusKey,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralMembersWithCrew = `-- name: GetPluralMembersWithCrew :many
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.first_name, m_members.last_name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_grades.key grade_key, m_grades.organization_id grade_organization_id, grag.name grade_organization_name, grag.description grade_organization_description,
grag.color grade_organization_color, grag.is_personal grade_organization_is_personal,
grag.is_whole grade_organization_is_whole, grag.chat_room_id grade_organization_chat_room_id,
m_groups.key group_key, m_groups.organization_id group_organization_id, grog.name group_organization_name, grog.description group_organization_description,
grog.color group_organization_color, grog.is_personal group_organization_is_personal,
grog.is_whole group_organization_is_whole, grog.chat_room_id group_organization_chat_room_id FROM m_members
LEFT JOIN m_grades ON m_members.grade_id = m_grades.grade_id
LEFT JOIN m_organizations grag ON m_grades.organization_id = grag.organization_id
LEFT JOIN m_groups ON m_members.group_id = m_groups.group_id
LEFT JOIN m_organizations grog ON m_groups.organization_id = grog.organization_id
WHERE member_id = ANY($1::uuid[])
ORDER BY
	CASE WHEN $2::text = 'name' THEN m_members.name END ASC,
	CASE WHEN $2::text = 'r_name' THEN m_members.name END DESC,
	m_members_pkey ASC
`

type GetPluralMembersWithCrewParams struct {
	MemberIds   []uuid.UUID `json:"member_ids"`
	OrderMethod string      `json:"order_method"`
}

type GetPluralMembersWithCrewRow struct {
	MMembersPkey                 pgtype.Int8 `json:"m_members_pkey"`
	MemberID                     uuid.UUID   `json:"member_id"`
	LoginID                      string      `json:"login_id"`
	Password                     string      `json:"password"`
	Email                        string      `json:"email"`
	Name                         string      `json:"name"`
	FirstName                    pgtype.Text `json:"first_name"`
	LastName                     pgtype.Text `json:"last_name"`
	AttendStatusID               uuid.UUID   `json:"attend_status_id"`
	ProfileImageID               pgtype.UUID `json:"profile_image_id"`
	GradeID                      uuid.UUID   `json:"grade_id"`
	GroupID                      uuid.UUID   `json:"group_id"`
	PersonalOrganizationID       uuid.UUID   `json:"personal_organization_id"`
	RoleID                       pgtype.UUID `json:"role_id"`
	CreatedAt                    time.Time   `json:"created_at"`
	UpdatedAt                    time.Time   `json:"updated_at"`
	GradeKey                     pgtype.Text `json:"grade_key"`
	GradeOrganizationID          pgtype.UUID `json:"grade_organization_id"`
	GradeOrganizationName        pgtype.Text `json:"grade_organization_name"`
	GradeOrganizationDescription pgtype.Text `json:"grade_organization_description"`
	GradeOrganizationColor       pgtype.Text `json:"grade_organization_color"`
	GradeOrganizationIsPersonal  pgtype.Bool `json:"grade_organization_is_personal"`
	GradeOrganizationIsWhole     pgtype.Bool `json:"grade_organization_is_whole"`
	GradeOrganizationChatRoomID  pgtype.UUID `json:"grade_organization_chat_room_id"`
	GroupKey                     pgtype.Text `json:"group_key"`
	GroupOrganizationID          pgtype.UUID `json:"group_organization_id"`
	GroupOrganizationName        pgtype.Text `json:"group_organization_name"`
	GroupOrganizationDescription pgtype.Text `json:"group_organization_description"`
	GroupOrganizationColor       pgtype.Text `json:"group_organization_color"`
	GroupOrganizationIsPersonal  pgtype.Bool `json:"group_organization_is_personal"`
	GroupOrganizationIsWhole     pgtype.Bool `json:"group_organization_is_whole"`
	GroupOrganizationChatRoomID  pgtype.UUID `json:"group_organization_chat_room_id"`
}

func (q *Queries) GetPluralMembersWithCrew(ctx context.Context, arg GetPluralMembersWithCrewParams) ([]GetPluralMembersWithCrewRow, error) {
	rows, err := q.db.Query(ctx, getPluralMembersWithCrew, arg.MemberIds, arg.OrderMethod)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralMembersWithCrewRow{}
	for rows.Next() {
		var i GetPluralMembersWithCrewRow
		if err := rows.Scan(
			&i.MMembersPkey,
			&i.MemberID,
			&i.LoginID,
			&i.Password,
			&i.Email,
			&i.Name,
			&i.FirstName,
			&i.LastName,
			&i.AttendStatusID,
			&i.ProfileImageID,
			&i.GradeID,
			&i.GroupID,
			&i.PersonalOrganizationID,
			&i.RoleID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.GradeKey,
			&i.GradeOrganizationID,
			&i.GradeOrganizationName,
			&i.GradeOrganizationDescription,
			&i.GradeOrganizationColor,
			&i.GradeOrganizationIsPersonal,
			&i.GradeOrganizationIsWhole,
			&i.GradeOrganizationChatRoomID,
			&i.GroupKey,
			&i.GroupOrganizationID,
			&i.GroupOrganizationName,
			&i.GroupOrganizationDescription,
			&i.GroupOrganizationColor,
			&i.GroupOrganizationIsPersonal,
			&i.GroupOrganizationIsWhole,
			&i.GroupOrganizationChatRoomID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralMembersWithCrewUseNumberedPaginate = `-- name: GetPluralMembersWithCrewUseNumberedPaginate :many
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.first_name, m_members.last_name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_grades.key grade_key, m_grades.organization_id grade_organization_id, grag.name grade_organization_name, grag.description grade_organization_description,
grag.color grade_organization_color, grag.is_personal grade_organization_is_personal,
grag.is_whole grade_organization_is_whole, grag.chat_room_id grade_organization_chat_room_id,
m_groups.key group_key, m_groups.organization_id group_organization_id, grog.name group_organization_name, grog.description group_organization_description,
grog.color group_organization_color, grog.is_personal group_organization_is_personal,
grog.is_whole group_organization_is_whole, grog.chat_room_id group_organization_chat_room_id FROM m_members
LEFT JOIN m_grades ON m_members.grade_id = m_grades.grade_id
LEFT JOIN m_organizations grag ON m_grades.organization_id = grag.organization_id
LEFT JOIN m_groups ON m_members.group_id = m_groups.group_id
LEFT JOIN m_organizations grog ON m_groups.organization_id = grog.organization_id
WHERE member_id = ANY($3::uuid[])
ORDER BY
	CASE WHEN $4::text = 'name' THEN m_members.name END ASC,
	CASE WHEN $4::text = 'r_name' THEN m_members.name END DESC,
	m_members_pkey ASC
LIMIT $1 OFFSET $2
`

type GetPluralMembersWithCrewUseNumberedPaginateParams struct {
	Limit       int32       `json:"limit"`
	Offset      int32       `json:"offset"`
	MemberIds   []uuid.UUID `json:"member_ids"`
	OrderMethod string      `json:"order_method"`
}

type GetPluralMembersWithCrewUseNumberedPaginateRow struct {
	MMembersPkey                 pgtype.Int8 `json:"m_members_pkey"`
	MemberID                     uuid.UUID   `json:"member_id"`
	LoginID                      string      `json:"login_id"`
	Password                     string      `json:"password"`
	Email                        string      `json:"email"`
	Name                         string      `json:"name"`
	FirstName                    pgtype.Text `json:"first_name"`
	LastName                     pgtype.Text `json:"last_name"`
	AttendStatusID               uuid.UUID   `json:"attend_status_id"`
	ProfileImageID               pgtype.UUID `json:"profile_image_id"`
	GradeID                      uuid.UUID   `json:"grade_id"`
	GroupID                      uuid.UUID   `json:"group_id"`
	PersonalOrganizationID       uuid.UUID   `json:"personal_organization_id"`
	RoleID                       pgtype.UUID `json:"role_id"`
	CreatedAt                    time.Time   `json:"created_at"`
	UpdatedAt                    time.Time   `json:"updated_at"`
	GradeKey                     pgtype.Text `json:"grade_key"`
	GradeOrganizationID          pgtype.UUID `json:"grade_organization_id"`
	GradeOrganizationName        pgtype.Text `json:"grade_organization_name"`
	GradeOrganizationDescription pgtype.Text `json:"grade_organization_description"`
	GradeOrganizationColor       pgtype.Text `json:"grade_organization_color"`
	GradeOrganizationIsPersonal  pgtype.Bool `json:"grade_organization_is_personal"`
	GradeOrganizationIsWhole     pgtype.Bool `json:"grade_organization_is_whole"`
	GradeOrganizationChatRoomID  pgtype.UUID `json:"grade_organization_chat_room_id"`
	GroupKey                     pgtype.Text `json:"group_key"`
	GroupOrganizationID          pgtype.UUID `json:"group_organization_id"`
	GroupOrganizationName        pgtype.Text `json:"group_organization_name"`
	GroupOrganizationDescription pgtype.Text `json:"group_organization_description"`
	GroupOrganizationColor       pgtype.Text `json:"group_organization_color"`
	GroupOrganizationIsPersonal  pgtype.Bool `json:"group_organization_is_personal"`
	GroupOrganizationIsWhole     pgtype.Bool `json:"group_organization_is_whole"`
	GroupOrganizationChatRoomID  pgtype.UUID `json:"group_organization_chat_room_id"`
}

func (q *Queries) GetPluralMembersWithCrewUseNumberedPaginate(ctx context.Context, arg GetPluralMembersWithCrewUseNumberedPaginateParams) ([]GetPluralMembersWithCrewUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getPluralMembersWithCrewUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.MemberIds,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralMembersWithCrewUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetPluralMembersWithCrewUseNumberedPaginateRow
		if err := rows.Scan(
			&i.MMembersPkey,
			&i.MemberID,
			&i.LoginID,
			&i.Password,
			&i.Email,
			&i.Name,
			&i.FirstName,
			&i.LastName,
			&i.AttendStatusID,
			&i.ProfileImageID,
			&i.GradeID,
			&i.GroupID,
			&i.PersonalOrganizationID,
			&i.RoleID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.GradeKey,
			&i.GradeOrganizationID,
			&i.GradeOrganizationName,
			&i.GradeOrganizationDescription,
			&i.GradeOrganizationColor,
			&i.GradeOrganizationIsPersonal,
			&i.GradeOrganizationIsWhole,
			&i.GradeOrganizationChatRoomID,
			&i.GroupKey,
			&i.GroupOrganizationID,
			&i.GroupOrganizationName,
			&i.GroupOrganizationDescription,
			&i.GroupOrganizationColor,
			&i.GroupOrganizationIsPersonal,
			&i.GroupOrganizationIsWhole,
			&i.GroupOrganizationChatRoomID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralMembersWithDetail = `-- name: GetPluralMembersWithDetail :many
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.first_name, m_members.last_name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_students.student_id, m_professors.professor_id FROM m_members
LEFT JOIN m_students ON m_members.member_id = m_students.member_id
LEFT JOIN m_professors ON m_members.member_id = m_professors.member_id
WHERE member_id = ANY($1::uuid[])
ORDER BY
	CASE WHEN $2::text = 'name' THEN m_members.name END ASC,
	CASE WHEN $2::text = 'r_name' THEN m_members.name END DESC,
	m_members_pkey ASC
`

type GetPluralMembersWithDetailParams struct {
	MemberIds   []uuid.UUID `json:"member_ids"`
	OrderMethod string      `json:"order_method"`
}

type GetPluralMembersWithDetailRow struct {
	MMembersPkey           pgtype.Int8 `json:"m_members_pkey"`
	MemberID               uuid.UUID   `json:"member_id"`
	LoginID                string      `json:"login_id"`
	Password               string      `json:"password"`
	Email                  string      `json:"email"`
	Name                   string      `json:"name"`
	FirstName              pgtype.Text `json:"first_name"`
	LastName               pgtype.Text `json:"last_name"`
	AttendStatusID         uuid.UUID   `json:"attend_status_id"`
	ProfileImageID         pgtype.UUID `json:"profile_image_id"`
	GradeID                uuid.UUID   `json:"grade_id"`
	GroupID                uuid.UUID   `json:"group_id"`
	PersonalOrganizationID uuid.UUID   `json:"personal_organization_id"`
	RoleID                 pgtype.UUID `json:"role_id"`
	CreatedAt              time.Time   `json:"created_at"`
	UpdatedAt              time.Time   `json:"updated_at"`
	StudentID              pgtype.UUID `json:"student_id"`
	ProfessorID            pgtype.UUID `json:"professor_id"`
}

func (q *Queries) GetPluralMembersWithDetail(ctx context.Context, arg GetPluralMembersWithDetailParams) ([]GetPluralMembersWithDetailRow, error) {
	rows, err := q.db.Query(ctx, getPluralMembersWithDetail, arg.MemberIds, arg.OrderMethod)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralMembersWithDetailRow{}
	for rows.Next() {
		var i GetPluralMembersWithDetailRow
		if err := rows.Scan(
			&i.MMembersPkey,
			&i.MemberID,
			&i.LoginID,
			&i.Password,
			&i.Email,
			&i.Name,
			&i.FirstName,
			&i.LastName,
			&i.AttendStatusID,
			&i.ProfileImageID,
			&i.GradeID,
			&i.GroupID,
			&i.PersonalOrganizationID,
			&i.RoleID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StudentID,
			&i.ProfessorID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralMembersWithDetailUseNumberedPaginate = `-- name: GetPluralMembersWithDetailUseNumberedPaginate :many
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.first_name, m_members.last_name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_students.student_id, m_professors.professor_id FROM m_members
LEFT JOIN m_students ON m_members.member_id = m_students.member_id
LEFT JOIN m_professors ON m_members.member_id = m_professors.member_id
WHERE member_id = ANY($3::uuid[])
ORDER BY
	CASE WHEN $4::text = 'name' THEN m_members.name END ASC,
	CASE WHEN $4::text = 'r_name' THEN m_members.name END DESC,
	m_members_pkey ASC
LIMIT $1 OFFSET $2
`

type GetPluralMembersWithDetailUseNumberedPaginateParams struct {
	Limit       int32       `json:"limit"`
	Offset      int32       `json:"offset"`
	MemberIds   []uuid.UUID `json:"member_ids"`
	OrderMethod string      `json:"order_method"`
}

type GetPluralMembersWithDetailUseNumberedPaginateRow struct {
	MMembersPkey           pgtype.Int8 `json:"m_members_pkey"`
	MemberID               uuid.UUID   `json:"member_id"`
	LoginID                string      `json:"login_id"`
	Password               string      `json:"password"`
	Email                  string      `json:"email"`
	Name                   string      `json:"name"`
	FirstName              pgtype.Text `json:"first_name"`
	LastName               pgtype.Text `json:"last_name"`
	AttendStatusID         uuid.UUID   `json:"attend_status_id"`
	ProfileImageID         pgtype.UUID `json:"profile_image_id"`
	GradeID                uuid.UUID   `json:"grade_id"`
	GroupID                uuid.UUID   `json:"group_id"`
	PersonalOrganizationID uuid.UUID   `json:"personal_organization_id"`
	RoleID                 pgtype.UUID `json:"role_id"`
	CreatedAt              time.Time   `json:"created_at"`
	UpdatedAt              time.Time   `json:"updated_at"`
	StudentID              pgtype.UUID `json:"student_id"`
	ProfessorID            pgtype.UUID `json:"professor_id"`
}

func (q *Queries) GetPluralMembersWithDetailUseNumberedPaginate(ctx context.Context, arg GetPluralMembersWithDetailUseNumberedPaginateParams) ([]GetPluralMembersWithDetailUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getPluralMembersWithDetailUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.MemberIds,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralMembersWithDetailUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetPluralMembersWithDetailUseNumberedPaginateRow
		if err := rows.Scan(
			&i.MMembersPkey,
			&i.MemberID,
			&i.LoginID,
			&i.Password,
			&i.Email,
			&i.Name,
			&i.FirstName,
			&i.LastName,
			&i.AttendStatusID,
			&i.ProfileImageID,
			&i.GradeID,
			&i.GroupID,
			&i.PersonalOrganizationID,
			&i.RoleID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StudentID,
			&i.ProfessorID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralMembersWithPersonalOrganization = `-- name: GetPluralMembersWithPersonalOrganization :many
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.first_name, m_members.last_name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_organizations.name organization_name, m_organizations.description organization_description,
m_organizations.color organization_color, m_organizations.is_personal organization_is_personal,
m_organizations.is_whole organization_is_whole, m_organizations.chat_room_id organization_chat_room_id FROM m_members
LEFT JOIN m_organizations ON m_members.personal_organization_id = m_organizations.organization_id
WHERE member_id = ANY($1::uuid[])
ORDER BY
	CASE WHEN $2::text = 'name' THEN m_members.name END ASC,
	CASE WHEN $2::text = 'r_name' THEN m_members.name END DESC,
	m_members_pkey ASC
`

type GetPluralMembersWithPersonalOrganizationParams struct {
	MemberIds   []uuid.UUID `json:"member_ids"`
	OrderMethod string      `json:"order_method"`
}

type GetPluralMembersWithPersonalOrganizationRow struct {
	MMembersPkey            pgtype.Int8 `json:"m_members_pkey"`
	MemberID                uuid.UUID   `json:"member_id"`
	LoginID                 string      `json:"login_id"`
	Password                string      `json:"password"`
	Email                   string      `json:"email"`
	Name                    string      `json:"name"`
	FirstName               pgtype.Text `json:"first_name"`
	LastName                pgtype.Text `json:"last_name"`
	AttendStatusID          uuid.UUID   `json:"attend_status_id"`
	ProfileImageID          pgtype.UUID `json:"profile_image_id"`
	GradeID                 uuid.UUID   `json:"grade_id"`
	GroupID                 uuid.UUID   `json:"group_id"`
	PersonalOrganizationID  uuid.UUID   `json:"personal_organization_id"`
	RoleID                  pgtype.UUID `json:"role_id"`
	CreatedAt               time.Time   `json:"created_at"`
	UpdatedAt               time.Time   `json:"updated_at"`
	OrganizationName        pgtype.Text `json:"organization_name"`
	OrganizationDescription pgtype.Text `json:"organization_description"`
	OrganizationColor       pgtype.Text `json:"organization_color"`
	OrganizationIsPersonal  pgtype.Bool `json:"organization_is_personal"`
	OrganizationIsWhole     pgtype.Bool `json:"organization_is_whole"`
	OrganizationChatRoomID  pgtype.UUID `json:"organization_chat_room_id"`
}

func (q *Queries) GetPluralMembersWithPersonalOrganization(ctx context.Context, arg GetPluralMembersWithPersonalOrganizationParams) ([]GetPluralMembersWithPersonalOrganizationRow, error) {
	rows, err := q.db.Query(ctx, getPluralMembersWithPersonalOrganization, arg.MemberIds, arg.OrderMethod)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralMembersWithPersonalOrganizationRow{}
	for rows.Next() {
		var i GetPluralMembersWithPersonalOrganizationRow
		if err := rows.Scan(
			&i.MMembersPkey,
			&i.MemberID,
			&i.LoginID,
			&i.Password,
			&i.Email,
			&i.Name,
			&i.FirstName,
			&i.LastName,
			&i.AttendStatusID,
			&i.ProfileImageID,
			&i.GradeID,
			&i.GroupID,
			&i.PersonalOrganizationID,
			&i.RoleID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.OrganizationName,
			&i.OrganizationDescription,
			&i.OrganizationColor,
			&i.OrganizationIsPersonal,
			&i.OrganizationIsWhole,
			&i.OrganizationChatRoomID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralMembersWithPersonalOrganizationUseNumberedPaginate = `-- name: GetPluralMembersWithPersonalOrganizationUseNumberedPaginate :many
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.first_name, m_members.last_name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_organizations.name organization_name, m_organizations.description organization_description,
m_organizations.color organization_color, m_organizations.is_personal organization_is_personal,
m_organizations.is_whole organization_is_whole, m_organizations.chat_room_id organization_chat_room_id FROM m_members
LEFT JOIN m_organizations ON m_members.personal_organization_id = m_organizations.organization_id
WHERE member_id = ANY($3::uuid[])
ORDER BY
	CASE WHEN $4::text = 'name' THEN m_members.name END ASC,
	CASE WHEN $4::text = 'r_name' THEN m_members.name END DESC,
	m_members_pkey ASC
LIMIT $1 OFFSET $2
`

type GetPluralMembersWithPersonalOrganizationUseNumberedPaginateParams struct {
	Limit       int32       `json:"limit"`
	Offset      int32       `json:"offset"`
	MemberIds   []uuid.UUID `json:"member_ids"`
	OrderMethod string      `json:"order_method"`
}

type GetPluralMembersWithPersonalOrganizationUseNumberedPaginateRow struct {
	MMembersPkey            pgtype.Int8 `json:"m_members_pkey"`
	MemberID                uuid.UUID   `json:"member_id"`
	LoginID                 string      `json:"login_id"`
	Password                string      `json:"password"`
	Email                   string      `json:"email"`
	Name                    string      `json:"name"`
	FirstName               pgtype.Text `json:"first_name"`
	LastName                pgtype.Text `json:"last_name"`
	AttendStatusID          uuid.UUID   `json:"attend_status_id"`
	ProfileImageID          pgtype.UUID `json:"profile_image_id"`
	GradeID                 uuid.UUID   `json:"grade_id"`
	GroupID                 uuid.UUID   `json:"group_id"`
	PersonalOrganizationID  uuid.UUID   `json:"personal_organization_id"`
	RoleID                  pgtype.UUID `json:"role_id"`
	CreatedAt               time.Time   `json:"created_at"`
	UpdatedAt               time.Time   `json:"updated_at"`
	OrganizationName        pgtype.Text `json:"organization_name"`
	OrganizationDescription pgtype.Text `json:"organization_description"`
	OrganizationColor       pgtype.Text `json:"organization_color"`
	OrganizationIsPersonal  pgtype.Bool `json:"organization_is_personal"`
	OrganizationIsWhole     pgtype.Bool `json:"organization_is_whole"`
	OrganizationChatRoomID  pgtype.UUID `json:"organization_chat_room_id"`
}

func (q *Queries) GetPluralMembersWithPersonalOrganizationUseNumberedPaginate(ctx context.Context, arg GetPluralMembersWithPersonalOrganizationUseNumberedPaginateParams) ([]GetPluralMembersWithPersonalOrganizationUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getPluralMembersWithPersonalOrganizationUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.MemberIds,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralMembersWithPersonalOrganizationUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetPluralMembersWithPersonalOrganizationUseNumberedPaginateRow
		if err := rows.Scan(
			&i.MMembersPkey,
			&i.MemberID,
			&i.LoginID,
			&i.Password,
			&i.Email,
			&i.Name,
			&i.FirstName,
			&i.LastName,
			&i.AttendStatusID,
			&i.ProfileImageID,
			&i.GradeID,
			&i.GroupID,
			&i.PersonalOrganizationID,
			&i.RoleID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.OrganizationName,
			&i.OrganizationDescription,
			&i.OrganizationColor,
			&i.OrganizationIsPersonal,
			&i.OrganizationIsWhole,
			&i.OrganizationChatRoomID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralMembersWithProfileImage = `-- name: GetPluralMembersWithProfileImage :many
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.first_name, m_members.last_name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, t_images.height profile_image_height,
t_images.width profile_image_width, t_images.attachable_item_id profile_image_attachable_item_id,
t_attachable_items.owner_id profile_image_owner_id, t_attachable_items.from_outer profile_image_from_outer, t_attachable_items.alias profile_image_alias,
t_attachable_items.url profile_image_url, t_attachable_items.size profile_image_size, t_attachable_items.mime_type_id profile_image_mime_type_id
FROM m_members
LEFT JOIN t_images ON m_members.profile_image_id = t_images.image_id
LEFT JOIN t_attachable_items ON t_images.attachable_item_id = t_attachable_items.attachable_item_id
WHERE member_id = ANY($1::uuid[])
ORDER BY
	CASE WHEN $2::text = 'name' THEN m_members.name END ASC,
	CASE WHEN $2::text = 'r_name' THEN m_members.name END DESC,
	m_members_pkey ASC
`

type GetPluralMembersWithProfileImageParams struct {
	MemberIds   []uuid.UUID `json:"member_ids"`
	OrderMethod string      `json:"order_method"`
}

type GetPluralMembersWithProfileImageRow struct {
	MMembersPkey                 pgtype.Int8   `json:"m_members_pkey"`
	MemberID                     uuid.UUID     `json:"member_id"`
	LoginID                      string        `json:"login_id"`
	Password                     string        `json:"password"`
	Email                        string        `json:"email"`
	Name                         string        `json:"name"`
	FirstName                    pgtype.Text   `json:"first_name"`
	LastName                     pgtype.Text   `json:"last_name"`
	AttendStatusID               uuid.UUID     `json:"attend_status_id"`
	ProfileImageID               pgtype.UUID   `json:"profile_image_id"`
	GradeID                      uuid.UUID     `json:"grade_id"`
	GroupID                      uuid.UUID     `json:"group_id"`
	PersonalOrganizationID       uuid.UUID     `json:"personal_organization_id"`
	RoleID                       pgtype.UUID   `json:"role_id"`
	CreatedAt                    time.Time     `json:"created_at"`
	UpdatedAt                    time.Time     `json:"updated_at"`
	ProfileImageHeight           pgtype.Float8 `json:"profile_image_height"`
	ProfileImageWidth            pgtype.Float8 `json:"profile_image_width"`
	ProfileImageAttachableItemID pgtype.UUID   `json:"profile_image_attachable_item_id"`
	ProfileImageOwnerID          pgtype.UUID   `json:"profile_image_owner_id"`
	ProfileImageFromOuter        pgtype.Bool   `json:"profile_image_from_outer"`
	ProfileImageAlias            pgtype.Text   `json:"profile_image_alias"`
	ProfileImageUrl              pgtype.Text   `json:"profile_image_url"`
	ProfileImageSize             pgtype.Float8 `json:"profile_image_size"`
	ProfileImageMimeTypeID       pgtype.UUID   `json:"profile_image_mime_type_id"`
}

func (q *Queries) GetPluralMembersWithProfileImage(ctx context.Context, arg GetPluralMembersWithProfileImageParams) ([]GetPluralMembersWithProfileImageRow, error) {
	rows, err := q.db.Query(ctx, getPluralMembersWithProfileImage, arg.MemberIds, arg.OrderMethod)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralMembersWithProfileImageRow{}
	for rows.Next() {
		var i GetPluralMembersWithProfileImageRow
		if err := rows.Scan(
			&i.MMembersPkey,
			&i.MemberID,
			&i.LoginID,
			&i.Password,
			&i.Email,
			&i.Name,
			&i.FirstName,
			&i.LastName,
			&i.AttendStatusID,
			&i.ProfileImageID,
			&i.GradeID,
			&i.GroupID,
			&i.PersonalOrganizationID,
			&i.RoleID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProfileImageHeight,
			&i.ProfileImageWidth,
			&i.ProfileImageAttachableItemID,
			&i.ProfileImageOwnerID,
			&i.ProfileImageFromOuter,
			&i.ProfileImageAlias,
			&i.ProfileImageUrl,
			&i.ProfileImageSize,
			&i.ProfileImageMimeTypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralMembersWithProfileImageUseNumberedPaginate = `-- name: GetPluralMembersWithProfileImageUseNumberedPaginate :many
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.first_name, m_members.last_name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, t_images.height profile_image_height,
t_images.width profile_image_width, t_images.attachable_item_id profile_image_attachable_item_id,
t_attachable_items.owner_id profile_image_owner_id, t_attachable_items.from_outer profile_image_from_outer, t_attachable_items.alias profile_image_alias,
t_attachable_items.url profile_image_url, t_attachable_items.size profile_image_size, t_attachable_items.mime_type_id profile_image_mime_type_id
FROM m_members
LEFT JOIN t_images ON m_members.profile_image_id = t_images.image_id
LEFT JOIN t_attachable_items ON t_images.attachable_item_id = t_attachable_items.attachable_item_id
WHERE member_id = ANY($3::uuid[])
ORDER BY
	CASE WHEN $4::text = 'name' THEN m_members.name END ASC,
	CASE WHEN $4::text = 'r_name' THEN m_members.name END DESC,
	m_members_pkey ASC
LIMIT $1 OFFSET $2
`

type GetPluralMembersWithProfileImageUseNumberedPaginateParams struct {
	Limit       int32       `json:"limit"`
	Offset      int32       `json:"offset"`
	MemberIds   []uuid.UUID `json:"member_ids"`
	OrderMethod string      `json:"order_method"`
}

type GetPluralMembersWithProfileImageUseNumberedPaginateRow struct {
	MMembersPkey                 pgtype.Int8   `json:"m_members_pkey"`
	MemberID                     uuid.UUID     `json:"member_id"`
	LoginID                      string        `json:"login_id"`
	Password                     string        `json:"password"`
	Email                        string        `json:"email"`
	Name                         string        `json:"name"`
	FirstName                    pgtype.Text   `json:"first_name"`
	LastName                     pgtype.Text   `json:"last_name"`
	AttendStatusID               uuid.UUID     `json:"attend_status_id"`
	ProfileImageID               pgtype.UUID   `json:"profile_image_id"`
	GradeID                      uuid.UUID     `json:"grade_id"`
	GroupID                      uuid.UUID     `json:"group_id"`
	PersonalOrganizationID       uuid.UUID     `json:"personal_organization_id"`
	RoleID                       pgtype.UUID   `json:"role_id"`
	CreatedAt                    time.Time     `json:"created_at"`
	UpdatedAt                    time.Time     `json:"updated_at"`
	ProfileImageHeight           pgtype.Float8 `json:"profile_image_height"`
	ProfileImageWidth            pgtype.Float8 `json:"profile_image_width"`
	ProfileImageAttachableItemID pgtype.UUID   `json:"profile_image_attachable_item_id"`
	ProfileImageOwnerID          pgtype.UUID   `json:"profile_image_owner_id"`
	ProfileImageFromOuter        pgtype.Bool   `json:"profile_image_from_outer"`
	ProfileImageAlias            pgtype.Text   `json:"profile_image_alias"`
	ProfileImageUrl              pgtype.Text   `json:"profile_image_url"`
	ProfileImageSize             pgtype.Float8 `json:"profile_image_size"`
	ProfileImageMimeTypeID       pgtype.UUID   `json:"profile_image_mime_type_id"`
}

func (q *Queries) GetPluralMembersWithProfileImageUseNumberedPaginate(ctx context.Context, arg GetPluralMembersWithProfileImageUseNumberedPaginateParams) ([]GetPluralMembersWithProfileImageUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getPluralMembersWithProfileImageUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.MemberIds,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralMembersWithProfileImageUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetPluralMembersWithProfileImageUseNumberedPaginateRow
		if err := rows.Scan(
			&i.MMembersPkey,
			&i.MemberID,
			&i.LoginID,
			&i.Password,
			&i.Email,
			&i.Name,
			&i.FirstName,
			&i.LastName,
			&i.AttendStatusID,
			&i.ProfileImageID,
			&i.GradeID,
			&i.GroupID,
			&i.PersonalOrganizationID,
			&i.RoleID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProfileImageHeight,
			&i.ProfileImageWidth,
			&i.ProfileImageAttachableItemID,
			&i.ProfileImageOwnerID,
			&i.ProfileImageFromOuter,
			&i.ProfileImageAlias,
			&i.ProfileImageUrl,
			&i.ProfileImageSize,
			&i.ProfileImageMimeTypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralMembersWithRole = `-- name: GetPluralMembersWithRole :many
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.first_name, m_members.last_name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_roles.name role_name, m_roles.description role_description FROM m_members
LEFT JOIN m_roles ON m_members.role_id = m_roles.role_id
WHERE member_id = ANY($1::uuid[])
ORDER BY
	CASE WHEN $2::text = 'name' THEN m_members.name END ASC,
	CASE WHEN $2::text = 'r_name' THEN m_members.name END DESC,
	m_members_pkey ASC
`

type GetPluralMembersWithRoleParams struct {
	MemberIds   []uuid.UUID `json:"member_ids"`
	OrderMethod string      `json:"order_method"`
}

type GetPluralMembersWithRoleRow struct {
	MMembersPkey           pgtype.Int8 `json:"m_members_pkey"`
	MemberID               uuid.UUID   `json:"member_id"`
	LoginID                string      `json:"login_id"`
	Password               string      `json:"password"`
	Email                  string      `json:"email"`
	Name                   string      `json:"name"`
	FirstName              pgtype.Text `json:"first_name"`
	LastName               pgtype.Text `json:"last_name"`
	AttendStatusID         uuid.UUID   `json:"attend_status_id"`
	ProfileImageID         pgtype.UUID `json:"profile_image_id"`
	GradeID                uuid.UUID   `json:"grade_id"`
	GroupID                uuid.UUID   `json:"group_id"`
	PersonalOrganizationID uuid.UUID   `json:"personal_organization_id"`
	RoleID                 pgtype.UUID `json:"role_id"`
	CreatedAt              time.Time   `json:"created_at"`
	UpdatedAt              time.Time   `json:"updated_at"`
	RoleName               pgtype.Text `json:"role_name"`
	RoleDescription        pgtype.Text `json:"role_description"`
}

func (q *Queries) GetPluralMembersWithRole(ctx context.Context, arg GetPluralMembersWithRoleParams) ([]GetPluralMembersWithRoleRow, error) {
	rows, err := q.db.Query(ctx, getPluralMembersWithRole, arg.MemberIds, arg.OrderMethod)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralMembersWithRoleRow{}
	for rows.Next() {
		var i GetPluralMembersWithRoleRow
		if err := rows.Scan(
			&i.MMembersPkey,
			&i.MemberID,
			&i.LoginID,
			&i.Password,
			&i.Email,
			&i.Name,
			&i.FirstName,
			&i.LastName,
			&i.AttendStatusID,
			&i.ProfileImageID,
			&i.GradeID,
			&i.GroupID,
			&i.PersonalOrganizationID,
			&i.RoleID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RoleName,
			&i.RoleDescription,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralMembersWithRoleUseNumberedPaginate = `-- name: GetPluralMembersWithRoleUseNumberedPaginate :many
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.first_name, m_members.last_name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_roles.name role_name, m_roles.description role_description FROM m_members
LEFT JOIN m_roles ON m_members.role_id = m_roles.role_id
WHERE member_id = ANY($3::uuid[])
ORDER BY
	CASE WHEN $4::text = 'name' THEN m_members.name END ASC,
	CASE WHEN $4::text = 'r_name' THEN m_members.name END DESC,
	m_members_pkey ASC
LIMIT $1 OFFSET $2
`

type GetPluralMembersWithRoleUseNumberedPaginateParams struct {
	Limit       int32       `json:"limit"`
	Offset      int32       `json:"offset"`
	MemberIds   []uuid.UUID `json:"member_ids"`
	OrderMethod string      `json:"order_method"`
}

type GetPluralMembersWithRoleUseNumberedPaginateRow struct {
	MMembersPkey           pgtype.Int8 `json:"m_members_pkey"`
	MemberID               uuid.UUID   `json:"member_id"`
	LoginID                string      `json:"login_id"`
	Password               string      `json:"password"`
	Email                  string      `json:"email"`
	Name                   string      `json:"name"`
	FirstName              pgtype.Text `json:"first_name"`
	LastName               pgtype.Text `json:"last_name"`
	AttendStatusID         uuid.UUID   `json:"attend_status_id"`
	ProfileImageID         pgtype.UUID `json:"profile_image_id"`
	GradeID                uuid.UUID   `json:"grade_id"`
	GroupID                uuid.UUID   `json:"group_id"`
	PersonalOrganizationID uuid.UUID   `json:"personal_organization_id"`
	RoleID                 pgtype.UUID `json:"role_id"`
	CreatedAt              time.Time   `json:"created_at"`
	UpdatedAt              time.Time   `json:"updated_at"`
	RoleName               pgtype.Text `json:"role_name"`
	RoleDescription        pgtype.Text `json:"role_description"`
}

func (q *Queries) GetPluralMembersWithRoleUseNumberedPaginate(ctx context.Context, arg GetPluralMembersWithRoleUseNumberedPaginateParams) ([]GetPluralMembersWithRoleUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getPluralMembersWithRoleUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.MemberIds,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralMembersWithRoleUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetPluralMembersWithRoleUseNumberedPaginateRow
		if err := rows.Scan(
			&i.MMembersPkey,
			&i.MemberID,
			&i.LoginID,
			&i.Password,
			&i.Email,
			&i.Name,
			&i.FirstName,
			&i.LastName,
			&i.AttendStatusID,
			&i.ProfileImageID,
			&i.GradeID,
			&i.GroupID,
			&i.PersonalOrganizationID,
			&i.RoleID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RoleName,
			&i.RoleDescription,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const pluralDeleteMembers = `-- name: PluralDeleteMembers :execrows
DELETE FROM m_members WHERE member_id = ANY($1::uuid[])
`

func (q *Queries) PluralDeleteMembers(ctx context.Context, memberIds []uuid.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, pluralDeleteMembers, memberIds)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateMember = `-- name: UpdateMember :one
UPDATE m_members SET email = $2, name = $3, first_name = $4, last_name = $5, profile_image_id = $6, updated_at = $7 WHERE member_id = $1 RETURNING m_members_pkey, member_id, login_id, password, email, name, first_name, last_name, attend_status_id, profile_image_id, grade_id, group_id, personal_organization_id, role_id, created_at, updated_at
`

type UpdateMemberParams struct {
	MemberID       uuid.UUID   `json:"member_id"`
	Email          string      `json:"email"`
	Name           string      `json:"name"`
	FirstName      pgtype.Text `json:"first_name"`
	LastName       pgtype.Text `json:"last_name"`
	ProfileImageID pgtype.UUID `json:"profile_image_id"`
	UpdatedAt      time.Time   `json:"updated_at"`
}

func (q *Queries) UpdateMember(ctx context.Context, arg UpdateMemberParams) (Member, error) {
	row := q.db.QueryRow(ctx, updateMember,
		arg.MemberID,
		arg.Email,
		arg.Name,
		arg.FirstName,
		arg.LastName,
		arg.ProfileImageID,
		arg.UpdatedAt,
	)
	var i Member
	err := row.Scan(
		&i.MMembersPkey,
		&i.MemberID,
		&i.LoginID,
		&i.Password,
		&i.Email,
		&i.Name,
		&i.FirstName,
		&i.LastName,
		&i.AttendStatusID,
		&i.ProfileImageID,
		&i.GradeID,
		&i.GroupID,
		&i.PersonalOrganizationID,
		&i.RoleID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateMemberAttendStatus = `-- name: UpdateMemberAttendStatus :one
UPDATE m_members SET attend_status_id = $2, updated_at = $3 WHERE member_id = $1 RETURNING m_members_pkey, member_id, login_id, password, email, name, first_name, last_name, attend_status_id, profile_image_id, grade_id, group_id, personal_organization_id, role_id, created_at, updated_at
`

type UpdateMemberAttendStatusParams struct {
	MemberID       uuid.UUID `json:"member_id"`
	AttendStatusID uuid.UUID `json:"attend_status_id"`
	UpdatedAt      time.Time `json:"updated_at"`
}

func (q *Queries) UpdateMemberAttendStatus(ctx context.Context, arg UpdateMemberAttendStatusParams) (Member, error) {
	row := q.db.QueryRow(ctx, updateMemberAttendStatus, arg.MemberID, arg.AttendStatusID, arg.UpdatedAt)
	var i Member
	err := row.Scan(
		&i.MMembersPkey,
		&i.MemberID,
		&i.LoginID,
		&i.Password,
		&i.Email,
		&i.Name,
		&i.FirstName,
		&i.LastName,
		&i.AttendStatusID,
		&i.ProfileImageID,
		&i.GradeID,
		&i.GroupID,
		&i.PersonalOrganizationID,
		&i.RoleID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateMemberGrade = `-- name: UpdateMemberGrade :one
UPDATE m_members SET grade_id = $2, updated_at = $3 WHERE member_id = $1 RETURNING m_members_pkey, member_id, login_id, password, email, name, first_name, last_name, attend_status_id, profile_image_id, grade_id, group_id, personal_organization_id, role_id, created_at, updated_at
`

type UpdateMemberGradeParams struct {
	MemberID  uuid.UUID `json:"member_id"`
	GradeID   uuid.UUID `json:"grade_id"`
	UpdatedAt time.Time `json:"updated_at"`
}

func (q *Queries) UpdateMemberGrade(ctx context.Context, arg UpdateMemberGradeParams) (Member, error) {
	row := q.db.QueryRow(ctx, updateMemberGrade, arg.MemberID, arg.GradeID, arg.UpdatedAt)
	var i Member
	err := row.Scan(
		&i.MMembersPkey,
		&i.MemberID,
		&i.LoginID,
		&i.Password,
		&i.Email,
		&i.Name,
		&i.FirstName,
		&i.LastName,
		&i.AttendStatusID,
		&i.ProfileImageID,
		&i.GradeID,
		&i.GroupID,
		&i.PersonalOrganizationID,
		&i.RoleID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateMemberGroup = `-- name: UpdateMemberGroup :one
UPDATE m_members SET group_id = $2, updated_at = $3 WHERE member_id = $1 RETURNING m_members_pkey, member_id, login_id, password, email, name, first_name, last_name, attend_status_id, profile_image_id, grade_id, group_id, personal_organization_id, role_id, created_at, updated_at
`

type UpdateMemberGroupParams struct {
	MemberID  uuid.UUID `json:"member_id"`
	GroupID   uuid.UUID `json:"group_id"`
	UpdatedAt time.Time `json:"updated_at"`
}

func (q *Queries) UpdateMemberGroup(ctx context.Context, arg UpdateMemberGroupParams) (Member, error) {
	row := q.db.QueryRow(ctx, updateMemberGroup, arg.MemberID, arg.GroupID, arg.UpdatedAt)
	var i Member
	err := row.Scan(
		&i.MMembersPkey,
		&i.MemberID,
		&i.LoginID,
		&i.Password,
		&i.Email,
		&i.Name,
		&i.FirstName,
		&i.LastName,
		&i.AttendStatusID,
		&i.ProfileImageID,
		&i.GradeID,
		&i.GroupID,
		&i.PersonalOrganizationID,
		&i.RoleID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateMemberLoginID = `-- name: UpdateMemberLoginID :one
UPDATE m_members SET login_id = $2, updated_at = $3 WHERE member_id = $1 RETURNING m_members_pkey, member_id, login_id, password, email, name, first_name, last_name, attend_status_id, profile_image_id, grade_id, group_id, personal_organization_id, role_id, created_at, updated_at
`

type UpdateMemberLoginIDParams struct {
	MemberID  uuid.UUID `json:"member_id"`
	LoginID   string    `json:"login_id"`
	UpdatedAt time.Time `json:"updated_at"`
}

func (q *Queries) UpdateMemberLoginID(ctx context.Context, arg UpdateMemberLoginIDParams) (Member, error) {
	row := q.db.QueryRow(ctx, updateMemberLoginID, arg.MemberID, arg.LoginID, arg.UpdatedAt)
	var i Member
	err := row.Scan(
		&i.MMembersPkey,
		&i.MemberID,
		&i.LoginID,
		&i.Password,
		&i.Email,
		&i.Name,
		&i.FirstName,
		&i.LastName,
		&i.AttendStatusID,
		&i.ProfileImageID,
		&i.GradeID,
		&i.GroupID,
		&i.PersonalOrganizationID,
		&i.RoleID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateMemberPassword = `-- name: UpdateMemberPassword :one
UPDATE m_members SET password = $2, updated_at = $3 WHERE member_id = $1 RETURNING m_members_pkey, member_id, login_id, password, email, name, first_name, last_name, attend_status_id, profile_image_id, grade_id, group_id, personal_organization_id, role_id, created_at, updated_at
`

type UpdateMemberPasswordParams struct {
	MemberID  uuid.UUID `json:"member_id"`
	Password  string    `json:"password"`
	UpdatedAt time.Time `json:"updated_at"`
}

func (q *Queries) UpdateMemberPassword(ctx context.Context, arg UpdateMemberPasswordParams) (Member, error) {
	row := q.db.QueryRow(ctx, updateMemberPassword, arg.MemberID, arg.Password, arg.UpdatedAt)
	var i Member
	err := row.Scan(
		&i.MMembersPkey,
		&i.MemberID,
		&i.LoginID,
		&i.Password,
		&i.Email,
		&i.Name,
		&i.FirstName,
		&i.LastName,
		&i.AttendStatusID,
		&i.ProfileImageID,
		&i.GradeID,
		&i.GroupID,
		&i.PersonalOrganizationID,
		&i.RoleID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateMemberRole = `-- name: UpdateMemberRole :one
UPDATE m_members SET role_id = $2, updated_at = $3 WHERE member_id = $1 RETURNING m_members_pkey, member_id, login_id, password, email, name, first_name, last_name, attend_status_id, profile_image_id, grade_id, group_id, personal_organization_id, role_id, created_at, updated_at
`

type UpdateMemberRoleParams struct {
	MemberID  uuid.UUID   `json:"member_id"`
	RoleID    pgtype.UUID `json:"role_id"`
	UpdatedAt time.Time   `json:"updated_at"`
}

func (q *Queries) UpdateMemberRole(ctx context.Context, arg UpdateMemberRoleParams) (Member, error) {
	row := q.db.QueryRow(ctx, updateMemberRole, arg.MemberID, arg.RoleID, arg.UpdatedAt)
	var i Member
	err := row.Scan(
		&i.MMembersPkey,
		&i.MemberID,
		&i.LoginID,
		&i.Password,
		&i.Email,
		&i.Name,
		&i.FirstName,
		&i.LastName,
		&i.AttendStatusID,
		&i.ProfileImageID,
		&i.GradeID,
		&i.GroupID,
		&i.PersonalOrganizationID,
		&i.RoleID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
