// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: attachable_item.sql

package query

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countAttachableItems = `-- name: CountAttachableItems :one
SELECT COUNT(*) FROM t_attachable_items
WHERE
	CASE WHEN $1::boolean = true THEN mime_type_id = $2 ELSE TRUE END
`

type CountAttachableItemsParams struct {
	WhereMimeTypeID bool      `json:"where_mime_type_id"`
	MimeTypeID      uuid.UUID `json:"mime_type_id"`
}

func (q *Queries) CountAttachableItems(ctx context.Context, arg CountAttachableItemsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countAttachableItems, arg.WhereMimeTypeID, arg.MimeTypeID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAttachableItem = `-- name: CreateAttachableItem :one
INSERT INTO t_attachable_items (url, size, mime_type_id) VALUES ($1, $2, $3) RETURNING t_attachable_items_pkey, attachable_item_id, url, size, mime_type_id
`

type CreateAttachableItemParams struct {
	Url        string        `json:"url"`
	Size       pgtype.Float8 `json:"size"`
	MimeTypeID uuid.UUID     `json:"mime_type_id"`
}

func (q *Queries) CreateAttachableItem(ctx context.Context, arg CreateAttachableItemParams) (AttachableItem, error) {
	row := q.db.QueryRow(ctx, createAttachableItem, arg.Url, arg.Size, arg.MimeTypeID)
	var i AttachableItem
	err := row.Scan(
		&i.TAttachableItemsPkey,
		&i.AttachableItemID,
		&i.Url,
		&i.Size,
		&i.MimeTypeID,
	)
	return i, err
}

type CreateAttachableItemsParams struct {
	Url        string        `json:"url"`
	Size       pgtype.Float8 `json:"size"`
	MimeTypeID uuid.UUID     `json:"mime_type_id"`
}

const deleteAttachableItem = `-- name: DeleteAttachableItem :exec
DELETE FROM t_attachable_items WHERE attachable_item_id = $1
`

func (q *Queries) DeleteAttachableItem(ctx context.Context, attachableItemID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteAttachableItem, attachableItemID)
	return err
}

const findAttachableItemByID = `-- name: FindAttachableItemByID :one
SELECT t_attachable_items.t_attachable_items_pkey, t_attachable_items.attachable_item_id, t_attachable_items.url, t_attachable_items.size, t_attachable_items.mime_type_id, t_images.image_id, t_images.height as image_height, t_images.width as image_width, t_files.file_id FROM t_attachable_items
LEFT JOIN t_images ON t_attachable_items.attachable_item_id = t_images.attachable_item_id
LEFT JOIN t_files ON t_attachable_items.attachable_item_id = t_files.attachable_item_id
WHERE t_attachable_items.attachable_item_id = $1
`

type FindAttachableItemByIDRow struct {
	TAttachableItemsPkey pgtype.Int8   `json:"t_attachable_items_pkey"`
	AttachableItemID     uuid.UUID     `json:"attachable_item_id"`
	Url                  string        `json:"url"`
	Size                 pgtype.Float8 `json:"size"`
	MimeTypeID           uuid.UUID     `json:"mime_type_id"`
	ImageID              pgtype.UUID   `json:"image_id"`
	ImageHeight          pgtype.Float8 `json:"image_height"`
	ImageWidth           pgtype.Float8 `json:"image_width"`
	FileID               pgtype.UUID   `json:"file_id"`
}

func (q *Queries) FindAttachableItemByID(ctx context.Context, attachableItemID uuid.UUID) (FindAttachableItemByIDRow, error) {
	row := q.db.QueryRow(ctx, findAttachableItemByID, attachableItemID)
	var i FindAttachableItemByIDRow
	err := row.Scan(
		&i.TAttachableItemsPkey,
		&i.AttachableItemID,
		&i.Url,
		&i.Size,
		&i.MimeTypeID,
		&i.ImageID,
		&i.ImageHeight,
		&i.ImageWidth,
		&i.FileID,
	)
	return i, err
}

const findAttachableItemByIDWithMimeType = `-- name: FindAttachableItemByIDWithMimeType :one
SELECT t_attachable_items.t_attachable_items_pkey, t_attachable_items.attachable_item_id, t_attachable_items.url, t_attachable_items.size, t_attachable_items.mime_type_id, m_mime_types.mime_type_id, m_mime_types.name as mime_type_name, m_mime_types.key as mime_type_key, t_images.image_id, t_images.height as image_height, t_images.width as image_width, t_files.file_id FROM t_attachable_items
LEFT JOIN m_mime_types ON t_attachable_items.mime_type_id = m_mime_types.mime_type_id
LEFT JOIN t_images ON t_attachable_items.attachable_item_id = t_images.attachable_item_id
LEFT JOIN t_files ON t_attachable_items.attachable_item_id = t_files.attachable_item_id
WHERE t_attachable_items.attachable_item_id = $1
`

type FindAttachableItemByIDWithMimeTypeRow struct {
	TAttachableItemsPkey pgtype.Int8   `json:"t_attachable_items_pkey"`
	AttachableItemID     uuid.UUID     `json:"attachable_item_id"`
	Url                  string        `json:"url"`
	Size                 pgtype.Float8 `json:"size"`
	MimeTypeID           uuid.UUID     `json:"mime_type_id"`
	MimeTypeID_2         pgtype.UUID   `json:"mime_type_id_2"`
	MimeTypeName         pgtype.Text   `json:"mime_type_name"`
	MimeTypeKey          pgtype.Text   `json:"mime_type_key"`
	ImageID              pgtype.UUID   `json:"image_id"`
	ImageHeight          pgtype.Float8 `json:"image_height"`
	ImageWidth           pgtype.Float8 `json:"image_width"`
	FileID               pgtype.UUID   `json:"file_id"`
}

func (q *Queries) FindAttachableItemByIDWithMimeType(ctx context.Context, attachableItemID uuid.UUID) (FindAttachableItemByIDWithMimeTypeRow, error) {
	row := q.db.QueryRow(ctx, findAttachableItemByIDWithMimeType, attachableItemID)
	var i FindAttachableItemByIDWithMimeTypeRow
	err := row.Scan(
		&i.TAttachableItemsPkey,
		&i.AttachableItemID,
		&i.Url,
		&i.Size,
		&i.MimeTypeID,
		&i.MimeTypeID_2,
		&i.MimeTypeName,
		&i.MimeTypeKey,
		&i.ImageID,
		&i.ImageHeight,
		&i.ImageWidth,
		&i.FileID,
	)
	return i, err
}

const getAttachableItems = `-- name: GetAttachableItems :many
SELECT t_attachable_items.t_attachable_items_pkey, t_attachable_items.attachable_item_id, t_attachable_items.url, t_attachable_items.size, t_attachable_items.mime_type_id, t_images.image_id, t_images.height as image_height, t_images.width as image_width, t_files.file_id FROM t_attachable_items
LEFT JOIN t_images ON t_attachable_items.attachable_item_id = t_images.attachable_item_id
LEFT JOIN t_files ON t_attachable_items.attachable_item_id = t_files.attachable_item_id
WHERE
	CASE WHEN $1::boolean = true THEN mime_type_id = $2 ELSE TRUE END
ORDER BY
	t_attachable_items_pkey ASC
`

type GetAttachableItemsParams struct {
	WhereMimeTypeID bool      `json:"where_mime_type_id"`
	MimeTypeID      uuid.UUID `json:"mime_type_id"`
}

type GetAttachableItemsRow struct {
	TAttachableItemsPkey pgtype.Int8   `json:"t_attachable_items_pkey"`
	AttachableItemID     uuid.UUID     `json:"attachable_item_id"`
	Url                  string        `json:"url"`
	Size                 pgtype.Float8 `json:"size"`
	MimeTypeID           uuid.UUID     `json:"mime_type_id"`
	ImageID              pgtype.UUID   `json:"image_id"`
	ImageHeight          pgtype.Float8 `json:"image_height"`
	ImageWidth           pgtype.Float8 `json:"image_width"`
	FileID               pgtype.UUID   `json:"file_id"`
}

func (q *Queries) GetAttachableItems(ctx context.Context, arg GetAttachableItemsParams) ([]GetAttachableItemsRow, error) {
	rows, err := q.db.Query(ctx, getAttachableItems, arg.WhereMimeTypeID, arg.MimeTypeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAttachableItemsRow{}
	for rows.Next() {
		var i GetAttachableItemsRow
		if err := rows.Scan(
			&i.TAttachableItemsPkey,
			&i.AttachableItemID,
			&i.Url,
			&i.Size,
			&i.MimeTypeID,
			&i.ImageID,
			&i.ImageHeight,
			&i.ImageWidth,
			&i.FileID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAttachableItemsUseKeysetPaginate = `-- name: GetAttachableItemsUseKeysetPaginate :many
SELECT t_attachable_items.t_attachable_items_pkey, t_attachable_items.attachable_item_id, t_attachable_items.url, t_attachable_items.size, t_attachable_items.mime_type_id, t_images.image_id, t_images.height as image_height, t_images.width as image_width, t_files.file_id FROM t_attachable_items
LEFT JOIN t_images ON t_attachable_items.attachable_item_id = t_images.attachable_item_id
LEFT JOIN t_files ON t_attachable_items.attachable_item_id = t_files.attachable_item_id
WHERE
	CASE $2::text
		WHEN 'next' THEN
			t_attachable_items_pkey < $3
		WHEN 'prev' THEN
			t_attachable_items_pkey > $3
	END
ORDER BY
	t_attachable_items_pkey ASC
LIMIT $1
`

type GetAttachableItemsUseKeysetPaginateParams struct {
	Limit           int32       `json:"limit"`
	CursorDirection string      `json:"cursor_direction"`
	Cursor          pgtype.Int8 `json:"cursor"`
}

type GetAttachableItemsUseKeysetPaginateRow struct {
	TAttachableItemsPkey pgtype.Int8   `json:"t_attachable_items_pkey"`
	AttachableItemID     uuid.UUID     `json:"attachable_item_id"`
	Url                  string        `json:"url"`
	Size                 pgtype.Float8 `json:"size"`
	MimeTypeID           uuid.UUID     `json:"mime_type_id"`
	ImageID              pgtype.UUID   `json:"image_id"`
	ImageHeight          pgtype.Float8 `json:"image_height"`
	ImageWidth           pgtype.Float8 `json:"image_width"`
	FileID               pgtype.UUID   `json:"file_id"`
}

func (q *Queries) GetAttachableItemsUseKeysetPaginate(ctx context.Context, arg GetAttachableItemsUseKeysetPaginateParams) ([]GetAttachableItemsUseKeysetPaginateRow, error) {
	rows, err := q.db.Query(ctx, getAttachableItemsUseKeysetPaginate, arg.Limit, arg.CursorDirection, arg.Cursor)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAttachableItemsUseKeysetPaginateRow{}
	for rows.Next() {
		var i GetAttachableItemsUseKeysetPaginateRow
		if err := rows.Scan(
			&i.TAttachableItemsPkey,
			&i.AttachableItemID,
			&i.Url,
			&i.Size,
			&i.MimeTypeID,
			&i.ImageID,
			&i.ImageHeight,
			&i.ImageWidth,
			&i.FileID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAttachableItemsUseNumberedPaginate = `-- name: GetAttachableItemsUseNumberedPaginate :many
SELECT t_attachable_items.t_attachable_items_pkey, t_attachable_items.attachable_item_id, t_attachable_items.url, t_attachable_items.size, t_attachable_items.mime_type_id, t_images.image_id, t_images.height as image_height, t_images.width as image_width, t_files.file_id FROM t_attachable_items
LEFT JOIN t_images ON t_attachable_items.attachable_item_id = t_images.attachable_item_id
LEFT JOIN t_files ON t_attachable_items.attachable_item_id = t_files.attachable_item_id
WHERE
	CASE WHEN $3::boolean = true THEN mime_type_id = $4 ELSE TRUE END
ORDER BY
	t_attachable_items_pkey ASC
LIMIT $1 OFFSET $2
`

type GetAttachableItemsUseNumberedPaginateParams struct {
	Limit           int32     `json:"limit"`
	Offset          int32     `json:"offset"`
	WhereMimeTypeID bool      `json:"where_mime_type_id"`
	MimeTypeID      uuid.UUID `json:"mime_type_id"`
}

type GetAttachableItemsUseNumberedPaginateRow struct {
	TAttachableItemsPkey pgtype.Int8   `json:"t_attachable_items_pkey"`
	AttachableItemID     uuid.UUID     `json:"attachable_item_id"`
	Url                  string        `json:"url"`
	Size                 pgtype.Float8 `json:"size"`
	MimeTypeID           uuid.UUID     `json:"mime_type_id"`
	ImageID              pgtype.UUID   `json:"image_id"`
	ImageHeight          pgtype.Float8 `json:"image_height"`
	ImageWidth           pgtype.Float8 `json:"image_width"`
	FileID               pgtype.UUID   `json:"file_id"`
}

func (q *Queries) GetAttachableItemsUseNumberedPaginate(ctx context.Context, arg GetAttachableItemsUseNumberedPaginateParams) ([]GetAttachableItemsUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getAttachableItemsUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.WhereMimeTypeID,
		arg.MimeTypeID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAttachableItemsUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetAttachableItemsUseNumberedPaginateRow
		if err := rows.Scan(
			&i.TAttachableItemsPkey,
			&i.AttachableItemID,
			&i.Url,
			&i.Size,
			&i.MimeTypeID,
			&i.ImageID,
			&i.ImageHeight,
			&i.ImageWidth,
			&i.FileID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAttachableItemsWithMimeType = `-- name: GetAttachableItemsWithMimeType :many
SELECT t_attachable_items.t_attachable_items_pkey, t_attachable_items.attachable_item_id, t_attachable_items.url, t_attachable_items.size, t_attachable_items.mime_type_id, m_mime_types.mime_type_id, m_mime_types.name as mime_type_name, m_mime_types.key as mime_type_key, t_images.image_id, t_images.height as image_height, t_images.width as image_width, t_files.file_id FROM t_attachable_items
LEFT JOIN m_mime_types ON t_attachable_items.mime_type_id = m_mime_types.where_mime_type_id
LEFT JOIN t_images ON t_attachable_items.attachable_item_id = t_images.attachable_item_id
LEFT JOIN t_files ON t_attachable_items.attachable_item_id = t_files.attachable_item_id
WHERE
	CASE WHEN $1::boolean = true THEN t_attachable_items.mime_type_id = $2 ELSE TRUE END
ORDER BY
	t_attachable_items_pkey ASC
`

type GetAttachableItemsWithMimeTypeParams struct {
	WhereMimeTypeID bool      `json:"where_mime_type_id"`
	MimeTypeID      uuid.UUID `json:"mime_type_id"`
}

type GetAttachableItemsWithMimeTypeRow struct {
	TAttachableItemsPkey pgtype.Int8   `json:"t_attachable_items_pkey"`
	AttachableItemID     uuid.UUID     `json:"attachable_item_id"`
	Url                  string        `json:"url"`
	Size                 pgtype.Float8 `json:"size"`
	MimeTypeID           uuid.UUID     `json:"mime_type_id"`
	MimeTypeID_2         pgtype.UUID   `json:"mime_type_id_2"`
	MimeTypeName         pgtype.Text   `json:"mime_type_name"`
	MimeTypeKey          pgtype.Text   `json:"mime_type_key"`
	ImageID              pgtype.UUID   `json:"image_id"`
	ImageHeight          pgtype.Float8 `json:"image_height"`
	ImageWidth           pgtype.Float8 `json:"image_width"`
	FileID               pgtype.UUID   `json:"file_id"`
}

func (q *Queries) GetAttachableItemsWithMimeType(ctx context.Context, arg GetAttachableItemsWithMimeTypeParams) ([]GetAttachableItemsWithMimeTypeRow, error) {
	rows, err := q.db.Query(ctx, getAttachableItemsWithMimeType, arg.WhereMimeTypeID, arg.MimeTypeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAttachableItemsWithMimeTypeRow{}
	for rows.Next() {
		var i GetAttachableItemsWithMimeTypeRow
		if err := rows.Scan(
			&i.TAttachableItemsPkey,
			&i.AttachableItemID,
			&i.Url,
			&i.Size,
			&i.MimeTypeID,
			&i.MimeTypeID_2,
			&i.MimeTypeName,
			&i.MimeTypeKey,
			&i.ImageID,
			&i.ImageHeight,
			&i.ImageWidth,
			&i.FileID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAttachableItemsWithMimeTypeUseKeysetPaginate = `-- name: GetAttachableItemsWithMimeTypeUseKeysetPaginate :many
SELECT t_attachable_items.t_attachable_items_pkey, t_attachable_items.attachable_item_id, t_attachable_items.url, t_attachable_items.size, t_attachable_items.mime_type_id, m_mime_types.mime_type_id, m_mime_types.name as mime_type_name, m_mime_types.key as mime_type_key, t_images.image_id, t_images.height as image_height, t_images.width as image_width, t_files.file_id FROM t_attachable_items
LEFT JOIN m_mime_types ON t_attachable_items.mime_type_id = m_mime_types.mime_type_id
LEFT JOIN t_images ON t_attachable_items.attachable_item_id = t_images.attachable_item_id
LEFT JOIN t_files ON t_attachable_items.attachable_item_id = t_files.attachable_item_id
WHERE
	CASE $2::text
		WHEN 'next' THEN
			t_attachable_items_pkey > $3::int
		WHEN 'prev' THEN
			t_attachable_items_pkey < $3::int
	END
ORDER BY
	t_attachable_items_pkey ASC
LIMIT $1
`

type GetAttachableItemsWithMimeTypeUseKeysetPaginateParams struct {
	Limit           int32  `json:"limit"`
	CursorDirection string `json:"cursor_direction"`
	Cursor          int32  `json:"cursor"`
}

type GetAttachableItemsWithMimeTypeUseKeysetPaginateRow struct {
	TAttachableItemsPkey pgtype.Int8   `json:"t_attachable_items_pkey"`
	AttachableItemID     uuid.UUID     `json:"attachable_item_id"`
	Url                  string        `json:"url"`
	Size                 pgtype.Float8 `json:"size"`
	MimeTypeID           uuid.UUID     `json:"mime_type_id"`
	MimeTypeID_2         pgtype.UUID   `json:"mime_type_id_2"`
	MimeTypeName         pgtype.Text   `json:"mime_type_name"`
	MimeTypeKey          pgtype.Text   `json:"mime_type_key"`
	ImageID              pgtype.UUID   `json:"image_id"`
	ImageHeight          pgtype.Float8 `json:"image_height"`
	ImageWidth           pgtype.Float8 `json:"image_width"`
	FileID               pgtype.UUID   `json:"file_id"`
}

func (q *Queries) GetAttachableItemsWithMimeTypeUseKeysetPaginate(ctx context.Context, arg GetAttachableItemsWithMimeTypeUseKeysetPaginateParams) ([]GetAttachableItemsWithMimeTypeUseKeysetPaginateRow, error) {
	rows, err := q.db.Query(ctx, getAttachableItemsWithMimeTypeUseKeysetPaginate, arg.Limit, arg.CursorDirection, arg.Cursor)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAttachableItemsWithMimeTypeUseKeysetPaginateRow{}
	for rows.Next() {
		var i GetAttachableItemsWithMimeTypeUseKeysetPaginateRow
		if err := rows.Scan(
			&i.TAttachableItemsPkey,
			&i.AttachableItemID,
			&i.Url,
			&i.Size,
			&i.MimeTypeID,
			&i.MimeTypeID_2,
			&i.MimeTypeName,
			&i.MimeTypeKey,
			&i.ImageID,
			&i.ImageHeight,
			&i.ImageWidth,
			&i.FileID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAttachableItemsWithMimeTypeUseNumberedPaginate = `-- name: GetAttachableItemsWithMimeTypeUseNumberedPaginate :many
SELECT t_attachable_items.t_attachable_items_pkey, t_attachable_items.attachable_item_id, t_attachable_items.url, t_attachable_items.size, t_attachable_items.mime_type_id, m_mime_types.mime_type_id, m_mime_types.name as mime_type_name, m_mime_types.key as mime_type_key, t_images.image_id, t_images.height as image_height, t_images.width as image_width, t_files.file_id FROM t_attachable_items
LEFT JOIN m_mime_types ON t_attachable_items.mime_type_id = m_mime_types.mime_type_id
LEFT JOIN t_images ON t_attachable_items.attachable_item_id = t_images.attachable_item_id
LEFT JOIN t_files ON t_attachable_items.attachable_item_id = t_files.attachable_item_id
WHERE
	CASE WHEN $3::boolean = true THEN t_attachable_items.mime_type_id = $4 ELSE TRUE END
ORDER BY
	t_attachable_items_pkey ASC
LIMIT $1 OFFSET $2
`

type GetAttachableItemsWithMimeTypeUseNumberedPaginateParams struct {
	Limit           int32     `json:"limit"`
	Offset          int32     `json:"offset"`
	WhereMimeTypeID bool      `json:"where_mime_type_id"`
	MimeTypeID      uuid.UUID `json:"mime_type_id"`
}

type GetAttachableItemsWithMimeTypeUseNumberedPaginateRow struct {
	TAttachableItemsPkey pgtype.Int8   `json:"t_attachable_items_pkey"`
	AttachableItemID     uuid.UUID     `json:"attachable_item_id"`
	Url                  string        `json:"url"`
	Size                 pgtype.Float8 `json:"size"`
	MimeTypeID           uuid.UUID     `json:"mime_type_id"`
	MimeTypeID_2         pgtype.UUID   `json:"mime_type_id_2"`
	MimeTypeName         pgtype.Text   `json:"mime_type_name"`
	MimeTypeKey          pgtype.Text   `json:"mime_type_key"`
	ImageID              pgtype.UUID   `json:"image_id"`
	ImageHeight          pgtype.Float8 `json:"image_height"`
	ImageWidth           pgtype.Float8 `json:"image_width"`
	FileID               pgtype.UUID   `json:"file_id"`
}

func (q *Queries) GetAttachableItemsWithMimeTypeUseNumberedPaginate(ctx context.Context, arg GetAttachableItemsWithMimeTypeUseNumberedPaginateParams) ([]GetAttachableItemsWithMimeTypeUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getAttachableItemsWithMimeTypeUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.WhereMimeTypeID,
		arg.MimeTypeID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAttachableItemsWithMimeTypeUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetAttachableItemsWithMimeTypeUseNumberedPaginateRow
		if err := rows.Scan(
			&i.TAttachableItemsPkey,
			&i.AttachableItemID,
			&i.Url,
			&i.Size,
			&i.MimeTypeID,
			&i.MimeTypeID_2,
			&i.MimeTypeName,
			&i.MimeTypeKey,
			&i.ImageID,
			&i.ImageHeight,
			&i.ImageWidth,
			&i.FileID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralAttachableItems = `-- name: GetPluralAttachableItems :many
SELECT t_attachable_items.t_attachable_items_pkey, t_attachable_items.attachable_item_id, t_attachable_items.url, t_attachable_items.size, t_attachable_items.mime_type_id, t_images.image_id, t_images.height as image_height, t_images.width as image_width, t_files.file_id FROM t_attachable_items
LEFT JOIN t_images ON t_attachable_items.attachable_item_id = t_images.attachable_item_id
LEFT JOIN t_files ON t_attachable_items.attachable_item_id = t_files.attachable_item_id
WHERE attachable_item_id = ANY($3::uuid[])
ORDER BY
	t_attachable_items_pkey ASC
LIMIT $1 OFFSET $2
`

type GetPluralAttachableItemsParams struct {
	Limit             int32       `json:"limit"`
	Offset            int32       `json:"offset"`
	AttachableItemIds []uuid.UUID `json:"attachable_item_ids"`
}

type GetPluralAttachableItemsRow struct {
	TAttachableItemsPkey pgtype.Int8   `json:"t_attachable_items_pkey"`
	AttachableItemID     uuid.UUID     `json:"attachable_item_id"`
	Url                  string        `json:"url"`
	Size                 pgtype.Float8 `json:"size"`
	MimeTypeID           uuid.UUID     `json:"mime_type_id"`
	ImageID              pgtype.UUID   `json:"image_id"`
	ImageHeight          pgtype.Float8 `json:"image_height"`
	ImageWidth           pgtype.Float8 `json:"image_width"`
	FileID               pgtype.UUID   `json:"file_id"`
}

func (q *Queries) GetPluralAttachableItems(ctx context.Context, arg GetPluralAttachableItemsParams) ([]GetPluralAttachableItemsRow, error) {
	rows, err := q.db.Query(ctx, getPluralAttachableItems, arg.Limit, arg.Offset, arg.AttachableItemIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralAttachableItemsRow{}
	for rows.Next() {
		var i GetPluralAttachableItemsRow
		if err := rows.Scan(
			&i.TAttachableItemsPkey,
			&i.AttachableItemID,
			&i.Url,
			&i.Size,
			&i.MimeTypeID,
			&i.ImageID,
			&i.ImageHeight,
			&i.ImageWidth,
			&i.FileID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralAttachableItemsWithMimeType = `-- name: GetPluralAttachableItemsWithMimeType :many
SELECT t_attachable_items.t_attachable_items_pkey, t_attachable_items.attachable_item_id, t_attachable_items.url, t_attachable_items.size, t_attachable_items.mime_type_id, m_mime_types.mime_type_id, m_mime_types.name as mime_type_name, m_mime_types.key as mime_type_key, t_images.image_id, t_images.height as image_height, t_images.width as image_width, t_files.file_id FROM t_attachable_items
LEFT JOIN m_mime_types ON t_attachable_items.mime_type_id = m_mime_types.mime_type_id
LEFT JOIN t_images ON t_attachable_items.attachable_item_id = t_images.attachable_item_id
LEFT JOIN t_files ON t_attachable_items.attachable_item_id = t_files.attachable_item_id
WHERE attachable_item_id = ANY($3::uuid[])
ORDER BY
	t_attachable_items_pkey ASC
LIMIT $1 OFFSET $2
`

type GetPluralAttachableItemsWithMimeTypeParams struct {
	Limit             int32       `json:"limit"`
	Offset            int32       `json:"offset"`
	AttachableItemIds []uuid.UUID `json:"attachable_item_ids"`
}

type GetPluralAttachableItemsWithMimeTypeRow struct {
	TAttachableItemsPkey pgtype.Int8   `json:"t_attachable_items_pkey"`
	AttachableItemID     uuid.UUID     `json:"attachable_item_id"`
	Url                  string        `json:"url"`
	Size                 pgtype.Float8 `json:"size"`
	MimeTypeID           uuid.UUID     `json:"mime_type_id"`
	MimeTypeID_2         pgtype.UUID   `json:"mime_type_id_2"`
	MimeTypeName         pgtype.Text   `json:"mime_type_name"`
	MimeTypeKey          pgtype.Text   `json:"mime_type_key"`
	ImageID              pgtype.UUID   `json:"image_id"`
	ImageHeight          pgtype.Float8 `json:"image_height"`
	ImageWidth           pgtype.Float8 `json:"image_width"`
	FileID               pgtype.UUID   `json:"file_id"`
}

func (q *Queries) GetPluralAttachableItemsWithMimeType(ctx context.Context, arg GetPluralAttachableItemsWithMimeTypeParams) ([]GetPluralAttachableItemsWithMimeTypeRow, error) {
	rows, err := q.db.Query(ctx, getPluralAttachableItemsWithMimeType, arg.Limit, arg.Offset, arg.AttachableItemIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralAttachableItemsWithMimeTypeRow{}
	for rows.Next() {
		var i GetPluralAttachableItemsWithMimeTypeRow
		if err := rows.Scan(
			&i.TAttachableItemsPkey,
			&i.AttachableItemID,
			&i.Url,
			&i.Size,
			&i.MimeTypeID,
			&i.MimeTypeID_2,
			&i.MimeTypeName,
			&i.MimeTypeKey,
			&i.ImageID,
			&i.ImageHeight,
			&i.ImageWidth,
			&i.FileID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
