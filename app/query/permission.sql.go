// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: permission.sql

package query

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countPermissions = `-- name: CountPermissions :one
SELECT COUNT(*) FROM m_permissions
WHERE
	CASE WHEN $1::boolean = true THEN name LIKE '%' || $2::text || '%' ELSE TRUE END
AND
	CASE WHEN $3::boolean = true THEN permission_category_id = ANY($4::uuid[]) ELSE TRUE END
`

type CountPermissionsParams struct {
	WhereLikeName   bool        `json:"where_like_name"`
	SearchName      string      `json:"search_name"`
	WhereInCategory bool        `json:"where_in_category"`
	InCategories    []uuid.UUID `json:"in_categories"`
}

func (q *Queries) CountPermissions(ctx context.Context, arg CountPermissionsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countPermissions,
		arg.WhereLikeName,
		arg.SearchName,
		arg.WhereInCategory,
		arg.InCategories,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createPermission = `-- name: CreatePermission :one
INSERT INTO m_permissions (name, description, key, permission_category_id) VALUES ($1, $2, $3, $4) RETURNING m_permissions_pkey, permission_id, name, description, key, permission_category_id
`

type CreatePermissionParams struct {
	Name                 string    `json:"name"`
	Description          string    `json:"description"`
	Key                  string    `json:"key"`
	PermissionCategoryID uuid.UUID `json:"permission_category_id"`
}

func (q *Queries) CreatePermission(ctx context.Context, arg CreatePermissionParams) (Permission, error) {
	row := q.db.QueryRow(ctx, createPermission,
		arg.Name,
		arg.Description,
		arg.Key,
		arg.PermissionCategoryID,
	)
	var i Permission
	err := row.Scan(
		&i.MPermissionsPkey,
		&i.PermissionID,
		&i.Name,
		&i.Description,
		&i.Key,
		&i.PermissionCategoryID,
	)
	return i, err
}

type CreatePermissionsParams struct {
	Name                 string    `json:"name"`
	Description          string    `json:"description"`
	Key                  string    `json:"key"`
	PermissionCategoryID uuid.UUID `json:"permission_category_id"`
}

const deletePermission = `-- name: DeletePermission :execrows
DELETE FROM m_permissions WHERE permission_id = $1
`

func (q *Queries) DeletePermission(ctx context.Context, permissionID uuid.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, deletePermission, permissionID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deletePermissionByKey = `-- name: DeletePermissionByKey :execrows
DELETE FROM m_permissions WHERE key = $1
`

func (q *Queries) DeletePermissionByKey(ctx context.Context, key string) (int64, error) {
	result, err := q.db.Exec(ctx, deletePermissionByKey, key)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const findPermissionByID = `-- name: FindPermissionByID :one
SELECT m_permissions_pkey, permission_id, name, description, key, permission_category_id FROM m_permissions WHERE permission_id = $1
`

func (q *Queries) FindPermissionByID(ctx context.Context, permissionID uuid.UUID) (Permission, error) {
	row := q.db.QueryRow(ctx, findPermissionByID, permissionID)
	var i Permission
	err := row.Scan(
		&i.MPermissionsPkey,
		&i.PermissionID,
		&i.Name,
		&i.Description,
		&i.Key,
		&i.PermissionCategoryID,
	)
	return i, err
}

const findPermissionByIDWithCategory = `-- name: FindPermissionByIDWithCategory :one
SELECT m_permissions.m_permissions_pkey, m_permissions.permission_id, m_permissions.name, m_permissions.description, m_permissions.key, m_permissions.permission_category_id,  m_permission_categories.name permission_category_name, m_permission_categories.key permission_category_key, m_permission_categories.description permission_category_description FROM m_permissions
JOIN m_permission_categories ON m_permissions.permission_category_id = m_permission_categories.permission_category_id
WHERE m_permissions.permission_id = $1
`

type FindPermissionByIDWithCategoryRow struct {
	MPermissionsPkey              pgtype.Int8 `json:"m_permissions_pkey"`
	PermissionID                  uuid.UUID   `json:"permission_id"`
	Name                          string      `json:"name"`
	Description                   string      `json:"description"`
	Key                           string      `json:"key"`
	PermissionCategoryID          uuid.UUID   `json:"permission_category_id"`
	PermissionCategoryName        string      `json:"permission_category_name"`
	PermissionCategoryKey         string      `json:"permission_category_key"`
	PermissionCategoryDescription string      `json:"permission_category_description"`
}

func (q *Queries) FindPermissionByIDWithCategory(ctx context.Context, permissionID uuid.UUID) (FindPermissionByIDWithCategoryRow, error) {
	row := q.db.QueryRow(ctx, findPermissionByIDWithCategory, permissionID)
	var i FindPermissionByIDWithCategoryRow
	err := row.Scan(
		&i.MPermissionsPkey,
		&i.PermissionID,
		&i.Name,
		&i.Description,
		&i.Key,
		&i.PermissionCategoryID,
		&i.PermissionCategoryName,
		&i.PermissionCategoryKey,
		&i.PermissionCategoryDescription,
	)
	return i, err
}

const findPermissionByKey = `-- name: FindPermissionByKey :one
SELECT m_permissions_pkey, permission_id, name, description, key, permission_category_id FROM m_permissions WHERE key = $1
`

func (q *Queries) FindPermissionByKey(ctx context.Context, key string) (Permission, error) {
	row := q.db.QueryRow(ctx, findPermissionByKey, key)
	var i Permission
	err := row.Scan(
		&i.MPermissionsPkey,
		&i.PermissionID,
		&i.Name,
		&i.Description,
		&i.Key,
		&i.PermissionCategoryID,
	)
	return i, err
}

const findPermissionByKeyWithCategory = `-- name: FindPermissionByKeyWithCategory :one
SELECT m_permissions.m_permissions_pkey, m_permissions.permission_id, m_permissions.name, m_permissions.description, m_permissions.key, m_permissions.permission_category_id,  m_permission_categories.name permission_category_name, m_permission_categories.key permission_category_key, m_permission_categories.description permission_category_description FROM m_permissions
JOIN m_permission_categories ON m_permissions.permission_category_id = m_permission_categories.permission_category_id
WHERE m_permissions.key = $1
`

type FindPermissionByKeyWithCategoryRow struct {
	MPermissionsPkey              pgtype.Int8 `json:"m_permissions_pkey"`
	PermissionID                  uuid.UUID   `json:"permission_id"`
	Name                          string      `json:"name"`
	Description                   string      `json:"description"`
	Key                           string      `json:"key"`
	PermissionCategoryID          uuid.UUID   `json:"permission_category_id"`
	PermissionCategoryName        string      `json:"permission_category_name"`
	PermissionCategoryKey         string      `json:"permission_category_key"`
	PermissionCategoryDescription string      `json:"permission_category_description"`
}

func (q *Queries) FindPermissionByKeyWithCategory(ctx context.Context, key string) (FindPermissionByKeyWithCategoryRow, error) {
	row := q.db.QueryRow(ctx, findPermissionByKeyWithCategory, key)
	var i FindPermissionByKeyWithCategoryRow
	err := row.Scan(
		&i.MPermissionsPkey,
		&i.PermissionID,
		&i.Name,
		&i.Description,
		&i.Key,
		&i.PermissionCategoryID,
		&i.PermissionCategoryName,
		&i.PermissionCategoryKey,
		&i.PermissionCategoryDescription,
	)
	return i, err
}

const getPermissions = `-- name: GetPermissions :many
SELECT m_permissions_pkey, permission_id, name, description, key, permission_category_id FROM m_permissions
WHERE
	CASE WHEN $1::boolean = true THEN m_permissions.name LIKE '%' || $2::text || '%' ELSE TRUE END
AND
	CASE WHEN $3::boolean = true THEN permission_category_id = ANY($4::uuid[]) ELSE TRUE END
ORDER BY
	CASE WHEN $5::text = 'name' THEN m_permissions.name END ASC,
	CASE WHEN $5::text = 'r_name' THEN m_permissions.name END DESC,
	m_permissions_pkey ASC
`

type GetPermissionsParams struct {
	WhereLikeName   bool        `json:"where_like_name"`
	SearchName      string      `json:"search_name"`
	WhereInCategory bool        `json:"where_in_category"`
	InCategories    []uuid.UUID `json:"in_categories"`
	OrderMethod     string      `json:"order_method"`
}

func (q *Queries) GetPermissions(ctx context.Context, arg GetPermissionsParams) ([]Permission, error) {
	rows, err := q.db.Query(ctx, getPermissions,
		arg.WhereLikeName,
		arg.SearchName,
		arg.WhereInCategory,
		arg.InCategories,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Permission{}
	for rows.Next() {
		var i Permission
		if err := rows.Scan(
			&i.MPermissionsPkey,
			&i.PermissionID,
			&i.Name,
			&i.Description,
			&i.Key,
			&i.PermissionCategoryID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPermissionsUseKeysetPaginate = `-- name: GetPermissionsUseKeysetPaginate :many
SELECT m_permissions_pkey, permission_id, name, description, key, permission_category_id FROM m_permissions
WHERE
	CASE WHEN $2::boolean = true THEN m_permissions.name LIKE '%' || $3::text || '%' ELSE TRUE END
AND
	CASE WHEN $4::boolean = true THEN permission_category_id = ANY($5::uuid[]) ELSE TRUE END
AND
	CASE $6::text
		WHEN 'next' THEN
			CASE $7::text
				WHEN 'name' THEN m_permissions.name > $8 OR (m_permissions.name = $8 AND m_permissions_pkey > $9::int)
				WHEN 'r_name' THEN m_permissions.name < $8 OR (m_permissions.name = $8 AND m_permissions_pkey > $9::int)
				ELSE m_permissions_pkey > $9::int
			END
		WHEN 'prev' THEN
			CASE $7::text
				WHEN 'name' THEN m_permissions.name < $8 OR (m_permissions.name = $8 AND m_permissions_pkey < $9::int)
				WHEN 'r_name' THEN m_permissions.name > $8 OR (m_permissions.name = $8 AND m_permissions_pkey < $9::int)
				ELSE m_permissions_pkey < $9::int
			END
	END
ORDER BY
	CASE WHEN $7::text = 'name' AND $6::text = 'next' THEN m_permissions.name END ASC,
	CASE WHEN $7::text = 'name' AND $6::text = 'prev' THEN m_permissions.name END DESC,
	CASE WHEN $7::text = 'r_name' AND $6::text = 'next' THEN m_permissions.name END DESC,
	CASE WHEN $7::text = 'r_name' AND $6::text = 'prev' THEN m_permissions.name END ASC,
	CASE WHEN $6::text = 'next' THEN m_permissions_pkey END ASC,
	CASE WHEN $6::text = 'prev' THEN m_permissions_pkey END DESC
LIMIT $1
`

type GetPermissionsUseKeysetPaginateParams struct {
	Limit           int32       `json:"limit"`
	WhereLikeName   bool        `json:"where_like_name"`
	SearchName      string      `json:"search_name"`
	WhereInCategory bool        `json:"where_in_category"`
	InCategories    []uuid.UUID `json:"in_categories"`
	CursorDirection string      `json:"cursor_direction"`
	OrderMethod     string      `json:"order_method"`
	NameCursor      string      `json:"name_cursor"`
	Cursor          int32       `json:"cursor"`
}

func (q *Queries) GetPermissionsUseKeysetPaginate(ctx context.Context, arg GetPermissionsUseKeysetPaginateParams) ([]Permission, error) {
	rows, err := q.db.Query(ctx, getPermissionsUseKeysetPaginate,
		arg.Limit,
		arg.WhereLikeName,
		arg.SearchName,
		arg.WhereInCategory,
		arg.InCategories,
		arg.CursorDirection,
		arg.OrderMethod,
		arg.NameCursor,
		arg.Cursor,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Permission{}
	for rows.Next() {
		var i Permission
		if err := rows.Scan(
			&i.MPermissionsPkey,
			&i.PermissionID,
			&i.Name,
			&i.Description,
			&i.Key,
			&i.PermissionCategoryID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPermissionsUseNumberedPaginate = `-- name: GetPermissionsUseNumberedPaginate :many
SELECT m_permissions_pkey, permission_id, name, description, key, permission_category_id FROM m_permissions
WHERE
	CASE WHEN $3::boolean = true THEN m_permissions.name LIKE '%' || $4::text || '%' ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN permission_category_id = ANY($6::uuid[]) ELSE TRUE END
ORDER BY
	CASE WHEN $7::text = 'name' THEN m_permissions.name END ASC,
	CASE WHEN $7::text = 'r_name' THEN m_permissions.name END DESC,
	m_permissions_pkey ASC
LIMIT $1 OFFSET $2
`

type GetPermissionsUseNumberedPaginateParams struct {
	Limit           int32       `json:"limit"`
	Offset          int32       `json:"offset"`
	WhereLikeName   bool        `json:"where_like_name"`
	SearchName      string      `json:"search_name"`
	WhereInCategory bool        `json:"where_in_category"`
	InCategories    []uuid.UUID `json:"in_categories"`
	OrderMethod     string      `json:"order_method"`
}

func (q *Queries) GetPermissionsUseNumberedPaginate(ctx context.Context, arg GetPermissionsUseNumberedPaginateParams) ([]Permission, error) {
	rows, err := q.db.Query(ctx, getPermissionsUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.WhereLikeName,
		arg.SearchName,
		arg.WhereInCategory,
		arg.InCategories,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Permission{}
	for rows.Next() {
		var i Permission
		if err := rows.Scan(
			&i.MPermissionsPkey,
			&i.PermissionID,
			&i.Name,
			&i.Description,
			&i.Key,
			&i.PermissionCategoryID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPermissionsWithCategory = `-- name: GetPermissionsWithCategory :many
SELECT m_permissions.m_permissions_pkey, m_permissions.permission_id, m_permissions.name, m_permissions.description, m_permissions.key, m_permissions.permission_category_id, m_permission_categories.name permission_category_name, m_permission_categories.key permission_category_key, m_permission_categories.description permission_category_description FROM m_permissions
JOIN m_permission_categories ON m_permissions.permission_category_id = m_permission_categories.permission_category_id
WHERE
	CASE WHEN $1::boolean = true THEN m_permissions.name LIKE '%' || $2::text || '%' ELSE TRUE END
AND
	CASE WHEN $3::boolean = true THEN m_permissions.permission_category_id = ANY($4::uuid[]) ELSE TRUE END
ORDER BY
	CASE WHEN $5::text = 'name' THEN m_permissions.name END ASC,
	CASE WHEN $5::text = 'r_name' THEN m_permissions.name END DESC,
	m_permissions_pkey ASC
`

type GetPermissionsWithCategoryParams struct {
	WhereLikeName   bool        `json:"where_like_name"`
	SearchName      string      `json:"search_name"`
	WhereInCategory bool        `json:"where_in_category"`
	InCategories    []uuid.UUID `json:"in_categories"`
	OrderMethod     string      `json:"order_method"`
}

type GetPermissionsWithCategoryRow struct {
	MPermissionsPkey              pgtype.Int8 `json:"m_permissions_pkey"`
	PermissionID                  uuid.UUID   `json:"permission_id"`
	Name                          string      `json:"name"`
	Description                   string      `json:"description"`
	Key                           string      `json:"key"`
	PermissionCategoryID          uuid.UUID   `json:"permission_category_id"`
	PermissionCategoryName        string      `json:"permission_category_name"`
	PermissionCategoryKey         string      `json:"permission_category_key"`
	PermissionCategoryDescription string      `json:"permission_category_description"`
}

func (q *Queries) GetPermissionsWithCategory(ctx context.Context, arg GetPermissionsWithCategoryParams) ([]GetPermissionsWithCategoryRow, error) {
	rows, err := q.db.Query(ctx, getPermissionsWithCategory,
		arg.WhereLikeName,
		arg.SearchName,
		arg.WhereInCategory,
		arg.InCategories,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPermissionsWithCategoryRow{}
	for rows.Next() {
		var i GetPermissionsWithCategoryRow
		if err := rows.Scan(
			&i.MPermissionsPkey,
			&i.PermissionID,
			&i.Name,
			&i.Description,
			&i.Key,
			&i.PermissionCategoryID,
			&i.PermissionCategoryName,
			&i.PermissionCategoryKey,
			&i.PermissionCategoryDescription,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPermissionsWithCategoryUseKeysetPaginate = `-- name: GetPermissionsWithCategoryUseKeysetPaginate :many
SELECT m_permissions.m_permissions_pkey, m_permissions.permission_id, m_permissions.name, m_permissions.description, m_permissions.key, m_permissions.permission_category_id, m_permission_categories.name permission_category_name, m_permission_categories.key permission_category_key, m_permission_categories.description permission_category_description FROM m_permissions
JOIN m_permission_categories ON m_permissions.permission_category_id = m_permission_categories.permission_category_id
WHERE
	CASE WHEN $2::boolean = true THEN m_permissions.name LIKE '%' || $3::text || '%' ELSE TRUE END
AND
	CASE WHEN $4::boolean = true THEN m_permissions.permission_category_id = ANY($5::uuid[]) ELSE TRUE END
AND
	CASE $6::text
		WHEN 'next' THEN
			CASE $7::text
				WHEN 'name' THEN m_permissions.name > $8 OR (m_permissions.name = $8 AND m_permissions_pkey > $9::int)
				WHEN 'r_name' THEN m_permissions.name < $8 OR (m_permissions.name = $8 AND m_permissions_pkey > $9::int)
				ELSE m_permissions_pkey > $9::int
			END
		WHEN 'prev' THEN
			CASE $7::text
				WHEN 'name' THEN m_permissions.name < $8 OR (m_permissions.name = $8 AND m_permissions_pkey < $9::int)
				WHEN 'r_name' THEN m_permissions.name > $8 OR (m_permissions.name = $8 AND m_permissions_pkey < $9::int)
				ELSE m_permissions_pkey < $9::int
			END
	END
ORDER BY
	CASE WHEN $7::text = 'name' AND $6::text = 'next' THEN m_permissions.name END ASC,
	CASE WHEN $7::text = 'name' AND $6::text = 'prev' THEN m_permissions.name END DESC,
	CASE WHEN $7::text = 'r_name' AND $6::text = 'next' THEN m_permissions.name END DESC,
	CASE WHEN $7::text = 'r_name' AND $6::text = 'prev' THEN m_permissions.name END ASC,
	CASE WHEN $6::text = 'next' THEN m_permissions_pkey END ASC,
	CASE WHEN $6::text = 'prev' THEN m_permissions_pkey END DESC
LIMIT $1
`

type GetPermissionsWithCategoryUseKeysetPaginateParams struct {
	Limit           int32       `json:"limit"`
	WhereLikeName   bool        `json:"where_like_name"`
	SearchName      string      `json:"search_name"`
	WhereInCategory bool        `json:"where_in_category"`
	InCategories    []uuid.UUID `json:"in_categories"`
	CursorDirection string      `json:"cursor_direction"`
	OrderMethod     string      `json:"order_method"`
	NameCursor      string      `json:"name_cursor"`
	Cursor          int32       `json:"cursor"`
}

type GetPermissionsWithCategoryUseKeysetPaginateRow struct {
	MPermissionsPkey              pgtype.Int8 `json:"m_permissions_pkey"`
	PermissionID                  uuid.UUID   `json:"permission_id"`
	Name                          string      `json:"name"`
	Description                   string      `json:"description"`
	Key                           string      `json:"key"`
	PermissionCategoryID          uuid.UUID   `json:"permission_category_id"`
	PermissionCategoryName        string      `json:"permission_category_name"`
	PermissionCategoryKey         string      `json:"permission_category_key"`
	PermissionCategoryDescription string      `json:"permission_category_description"`
}

func (q *Queries) GetPermissionsWithCategoryUseKeysetPaginate(ctx context.Context, arg GetPermissionsWithCategoryUseKeysetPaginateParams) ([]GetPermissionsWithCategoryUseKeysetPaginateRow, error) {
	rows, err := q.db.Query(ctx, getPermissionsWithCategoryUseKeysetPaginate,
		arg.Limit,
		arg.WhereLikeName,
		arg.SearchName,
		arg.WhereInCategory,
		arg.InCategories,
		arg.CursorDirection,
		arg.OrderMethod,
		arg.NameCursor,
		arg.Cursor,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPermissionsWithCategoryUseKeysetPaginateRow{}
	for rows.Next() {
		var i GetPermissionsWithCategoryUseKeysetPaginateRow
		if err := rows.Scan(
			&i.MPermissionsPkey,
			&i.PermissionID,
			&i.Name,
			&i.Description,
			&i.Key,
			&i.PermissionCategoryID,
			&i.PermissionCategoryName,
			&i.PermissionCategoryKey,
			&i.PermissionCategoryDescription,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPermissionsWithCategoryUseNumberedPaginate = `-- name: GetPermissionsWithCategoryUseNumberedPaginate :many
SELECT m_permissions.m_permissions_pkey, m_permissions.permission_id, m_permissions.name, m_permissions.description, m_permissions.key, m_permissions.permission_category_id, m_permission_categories.name permission_category_name, m_permission_categories.key permission_category_key, m_permission_categories.description permission_category_description FROM m_permissions
JOIN m_permission_categories ON m_permissions.permission_category_id = m_permission_categories.permission_category_id
WHERE
	CASE WHEN $3::boolean = true THEN m_permissions.name LIKE '%' || $4::text || '%' ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN m_permissions.permission_category_id = ANY($6::uuid[]) ELSE TRUE END
ORDER BY
	CASE WHEN $7::text = 'name' THEN m_permissions.name END ASC,
	CASE WHEN $7::text = 'r_name' THEN m_permissions.name END DESC,
	m_permissions_pkey ASC
LIMIT $1 OFFSET $2
`

type GetPermissionsWithCategoryUseNumberedPaginateParams struct {
	Limit           int32       `json:"limit"`
	Offset          int32       `json:"offset"`
	WhereLikeName   bool        `json:"where_like_name"`
	SearchName      string      `json:"search_name"`
	WhereInCategory bool        `json:"where_in_category"`
	InCategories    []uuid.UUID `json:"in_categories"`
	OrderMethod     string      `json:"order_method"`
}

type GetPermissionsWithCategoryUseNumberedPaginateRow struct {
	MPermissionsPkey              pgtype.Int8 `json:"m_permissions_pkey"`
	PermissionID                  uuid.UUID   `json:"permission_id"`
	Name                          string      `json:"name"`
	Description                   string      `json:"description"`
	Key                           string      `json:"key"`
	PermissionCategoryID          uuid.UUID   `json:"permission_category_id"`
	PermissionCategoryName        string      `json:"permission_category_name"`
	PermissionCategoryKey         string      `json:"permission_category_key"`
	PermissionCategoryDescription string      `json:"permission_category_description"`
}

func (q *Queries) GetPermissionsWithCategoryUseNumberedPaginate(ctx context.Context, arg GetPermissionsWithCategoryUseNumberedPaginateParams) ([]GetPermissionsWithCategoryUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getPermissionsWithCategoryUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.WhereLikeName,
		arg.SearchName,
		arg.WhereInCategory,
		arg.InCategories,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPermissionsWithCategoryUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetPermissionsWithCategoryUseNumberedPaginateRow
		if err := rows.Scan(
			&i.MPermissionsPkey,
			&i.PermissionID,
			&i.Name,
			&i.Description,
			&i.Key,
			&i.PermissionCategoryID,
			&i.PermissionCategoryName,
			&i.PermissionCategoryKey,
			&i.PermissionCategoryDescription,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralPermissions = `-- name: GetPluralPermissions :many
SELECT m_permissions_pkey, permission_id, name, description, key, permission_category_id FROM m_permissions WHERE permission_id = ANY($1::uuid[])
ORDER BY
	CASE WHEN $2::text = 'name' THEN m_permissions.name END ASC,
	CASE WHEN $2::text = 'r_name' THEN m_permissions.name END DESC,
	m_permissions_pkey ASC
`

type GetPluralPermissionsParams struct {
	PermissionIds []uuid.UUID `json:"permission_ids"`
	OrderMethod   string      `json:"order_method"`
}

func (q *Queries) GetPluralPermissions(ctx context.Context, arg GetPluralPermissionsParams) ([]Permission, error) {
	rows, err := q.db.Query(ctx, getPluralPermissions, arg.PermissionIds, arg.OrderMethod)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Permission{}
	for rows.Next() {
		var i Permission
		if err := rows.Scan(
			&i.MPermissionsPkey,
			&i.PermissionID,
			&i.Name,
			&i.Description,
			&i.Key,
			&i.PermissionCategoryID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralPermissionsUseNumberedPaginate = `-- name: GetPluralPermissionsUseNumberedPaginate :many
SELECT m_permissions_pkey, permission_id, name, description, key, permission_category_id FROM m_permissions WHERE permission_id = ANY($3::uuid[])
ORDER BY
	CASE WHEN $4::text = 'name' THEN m_permissions.name END ASC,
	CASE WHEN $4::text = 'r_name' THEN m_permissions.name END DESC,
	m_permissions_pkey ASC
LIMIT $1 OFFSET $2
`

type GetPluralPermissionsUseNumberedPaginateParams struct {
	Limit         int32       `json:"limit"`
	Offset        int32       `json:"offset"`
	PermissionIds []uuid.UUID `json:"permission_ids"`
	OrderMethod   string      `json:"order_method"`
}

func (q *Queries) GetPluralPermissionsUseNumberedPaginate(ctx context.Context, arg GetPluralPermissionsUseNumberedPaginateParams) ([]Permission, error) {
	rows, err := q.db.Query(ctx, getPluralPermissionsUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.PermissionIds,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Permission{}
	for rows.Next() {
		var i Permission
		if err := rows.Scan(
			&i.MPermissionsPkey,
			&i.PermissionID,
			&i.Name,
			&i.Description,
			&i.Key,
			&i.PermissionCategoryID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralPermissionsWithCategory = `-- name: GetPluralPermissionsWithCategory :many
SELECT m_permissions.m_permissions_pkey, m_permissions.permission_id, m_permissions.name, m_permissions.description, m_permissions.key, m_permissions.permission_category_id,  m_permission_categories.name permission_category_name, m_permission_categories.key permission_category_key, m_permission_categories.description permission_category_description FROM m_permissions
JOIN m_permission_categories ON m_permissions.permission_category_id = m_permission_categories.permission_category_id
WHERE permission_id = ANY($1::uuid[])
ORDER BY
	CASE WHEN $2::text = 'name' THEN m_permissions.name END ASC,
	CASE WHEN $2::text = 'r_name' THEN m_permissions.name END DESC,
	m_permissions_pkey ASC
`

type GetPluralPermissionsWithCategoryParams struct {
	PermissionIds []uuid.UUID `json:"permission_ids"`
	OrderMethod   string      `json:"order_method"`
}

type GetPluralPermissionsWithCategoryRow struct {
	MPermissionsPkey              pgtype.Int8 `json:"m_permissions_pkey"`
	PermissionID                  uuid.UUID   `json:"permission_id"`
	Name                          string      `json:"name"`
	Description                   string      `json:"description"`
	Key                           string      `json:"key"`
	PermissionCategoryID          uuid.UUID   `json:"permission_category_id"`
	PermissionCategoryName        string      `json:"permission_category_name"`
	PermissionCategoryKey         string      `json:"permission_category_key"`
	PermissionCategoryDescription string      `json:"permission_category_description"`
}

func (q *Queries) GetPluralPermissionsWithCategory(ctx context.Context, arg GetPluralPermissionsWithCategoryParams) ([]GetPluralPermissionsWithCategoryRow, error) {
	rows, err := q.db.Query(ctx, getPluralPermissionsWithCategory, arg.PermissionIds, arg.OrderMethod)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralPermissionsWithCategoryRow{}
	for rows.Next() {
		var i GetPluralPermissionsWithCategoryRow
		if err := rows.Scan(
			&i.MPermissionsPkey,
			&i.PermissionID,
			&i.Name,
			&i.Description,
			&i.Key,
			&i.PermissionCategoryID,
			&i.PermissionCategoryName,
			&i.PermissionCategoryKey,
			&i.PermissionCategoryDescription,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralPermissionsWithCategoryUseNumberedPaginate = `-- name: GetPluralPermissionsWithCategoryUseNumberedPaginate :many
SELECT m_permissions.m_permissions_pkey, m_permissions.permission_id, m_permissions.name, m_permissions.description, m_permissions.key, m_permissions.permission_category_id,  m_permission_categories.name permission_category_name, m_permission_categories.key permission_category_key, m_permission_categories.description permission_category_description FROM m_permissions
JOIN m_permission_categories ON m_permissions.permission_category_id = m_permission_categories.permission_category_id
WHERE permission_id = ANY($3::uuid[])
ORDER BY
	CASE WHEN $4::text = 'name' THEN m_permissions.name END ASC,
	CASE WHEN $4::text = 'r_name' THEN m_permissions.name END DESC,
	m_permissions_pkey ASC
LIMIT $1 OFFSET $2
`

type GetPluralPermissionsWithCategoryUseNumberedPaginateParams struct {
	Limit         int32       `json:"limit"`
	Offset        int32       `json:"offset"`
	PermissionIds []uuid.UUID `json:"permission_ids"`
	OrderMethod   string      `json:"order_method"`
}

type GetPluralPermissionsWithCategoryUseNumberedPaginateRow struct {
	MPermissionsPkey              pgtype.Int8 `json:"m_permissions_pkey"`
	PermissionID                  uuid.UUID   `json:"permission_id"`
	Name                          string      `json:"name"`
	Description                   string      `json:"description"`
	Key                           string      `json:"key"`
	PermissionCategoryID          uuid.UUID   `json:"permission_category_id"`
	PermissionCategoryName        string      `json:"permission_category_name"`
	PermissionCategoryKey         string      `json:"permission_category_key"`
	PermissionCategoryDescription string      `json:"permission_category_description"`
}

func (q *Queries) GetPluralPermissionsWithCategoryUseNumberedPaginate(ctx context.Context, arg GetPluralPermissionsWithCategoryUseNumberedPaginateParams) ([]GetPluralPermissionsWithCategoryUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getPluralPermissionsWithCategoryUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.PermissionIds,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralPermissionsWithCategoryUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetPluralPermissionsWithCategoryUseNumberedPaginateRow
		if err := rows.Scan(
			&i.MPermissionsPkey,
			&i.PermissionID,
			&i.Name,
			&i.Description,
			&i.Key,
			&i.PermissionCategoryID,
			&i.PermissionCategoryName,
			&i.PermissionCategoryKey,
			&i.PermissionCategoryDescription,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const pluralDeletePermissions = `-- name: PluralDeletePermissions :execrows
DELETE FROM m_permissions WHERE permission_id = ANY($1::uuid[])
`

func (q *Queries) PluralDeletePermissions(ctx context.Context, dollar_1 []uuid.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, pluralDeletePermissions, dollar_1)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updatePermission = `-- name: UpdatePermission :one
UPDATE m_permissions SET name = $2, description = $3, key = $4, permission_category_id = $5 WHERE permission_id = $1 RETURNING m_permissions_pkey, permission_id, name, description, key, permission_category_id
`

type UpdatePermissionParams struct {
	PermissionID         uuid.UUID `json:"permission_id"`
	Name                 string    `json:"name"`
	Description          string    `json:"description"`
	Key                  string    `json:"key"`
	PermissionCategoryID uuid.UUID `json:"permission_category_id"`
}

func (q *Queries) UpdatePermission(ctx context.Context, arg UpdatePermissionParams) (Permission, error) {
	row := q.db.QueryRow(ctx, updatePermission,
		arg.PermissionID,
		arg.Name,
		arg.Description,
		arg.Key,
		arg.PermissionCategoryID,
	)
	var i Permission
	err := row.Scan(
		&i.MPermissionsPkey,
		&i.PermissionID,
		&i.Name,
		&i.Description,
		&i.Key,
		&i.PermissionCategoryID,
	)
	return i, err
}

const updatePermissionByKey = `-- name: UpdatePermissionByKey :one
UPDATE m_permissions SET name = $2, description = $3, permission_category_id = $4 WHERE key = $1 RETURNING m_permissions_pkey, permission_id, name, description, key, permission_category_id
`

type UpdatePermissionByKeyParams struct {
	Key                  string    `json:"key"`
	Name                 string    `json:"name"`
	Description          string    `json:"description"`
	PermissionCategoryID uuid.UUID `json:"permission_category_id"`
}

func (q *Queries) UpdatePermissionByKey(ctx context.Context, arg UpdatePermissionByKeyParams) (Permission, error) {
	row := q.db.QueryRow(ctx, updatePermissionByKey,
		arg.Key,
		arg.Name,
		arg.Description,
		arg.PermissionCategoryID,
	)
	var i Permission
	err := row.Scan(
		&i.MPermissionsPkey,
		&i.PermissionID,
		&i.Name,
		&i.Description,
		&i.Key,
		&i.PermissionCategoryID,
	)
	return i, err
}
