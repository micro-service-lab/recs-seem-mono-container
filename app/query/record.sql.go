// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: record.sql

package query

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countRecords = `-- name: CountRecords :one
SELECT COUNT(*) FROM t_records
WHERE
	CASE WHEN $1::boolean = true THEN record_type_id = ANY($2) ELSE TRUE END
AND
	CASE WHEN $3::boolean = true THEN title LIKE '%' || $4::text || '%' ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN organization_id = ANY($6) ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN posted_by = ANY($8) ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN last_edited_by = ANY($10) ELSE TRUE END
`

type CountRecordsParams struct {
	WhereInRecordType   bool        `json:"where_in_record_type"`
	InRecordType        uuid.UUID   `json:"in_record_type"`
	WhereLikeTitle      bool        `json:"where_like_title"`
	SearchTitle         string      `json:"search_title"`
	WhereInOrganization bool        `json:"where_in_organization"`
	InOrganization      pgtype.UUID `json:"in_organization"`
	WhereInPostedBy     bool        `json:"where_in_posted_by"`
	InPostedBy          pgtype.UUID `json:"in_posted_by"`
	WhereInLastEditedBy bool        `json:"where_in_last_edited_by"`
	InLastEditedBy      pgtype.UUID `json:"in_last_edited_by"`
}

func (q *Queries) CountRecords(ctx context.Context, arg CountRecordsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countRecords,
		arg.WhereInRecordType,
		arg.InRecordType,
		arg.WhereLikeTitle,
		arg.SearchTitle,
		arg.WhereInOrganization,
		arg.InOrganization,
		arg.WhereInPostedBy,
		arg.InPostedBy,
		arg.WhereInLastEditedBy,
		arg.InLastEditedBy,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createRecord = `-- name: CreateRecord :one
INSERT INTO t_records (record_type_id, title, body, organization_id, posted_by, last_edited_by, posted_at, last_edited_at) VALUES ($1, $2, $3, $4, $5, $6, $7, $8) RETURNING t_records_pkey, record_id, record_type_id, title, body, organization_id, posted_by, last_edited_by, posted_at, last_edited_at
`

type CreateRecordParams struct {
	RecordTypeID   uuid.UUID   `json:"record_type_id"`
	Title          string      `json:"title"`
	Body           pgtype.Text `json:"body"`
	OrganizationID pgtype.UUID `json:"organization_id"`
	PostedBy       pgtype.UUID `json:"posted_by"`
	LastEditedBy   pgtype.UUID `json:"last_edited_by"`
	PostedAt       time.Time   `json:"posted_at"`
	LastEditedAt   time.Time   `json:"last_edited_at"`
}

func (q *Queries) CreateRecord(ctx context.Context, arg CreateRecordParams) (Record, error) {
	row := q.db.QueryRow(ctx, createRecord,
		arg.RecordTypeID,
		arg.Title,
		arg.Body,
		arg.OrganizationID,
		arg.PostedBy,
		arg.LastEditedBy,
		arg.PostedAt,
		arg.LastEditedAt,
	)
	var i Record
	err := row.Scan(
		&i.TRecordsPkey,
		&i.RecordID,
		&i.RecordTypeID,
		&i.Title,
		&i.Body,
		&i.OrganizationID,
		&i.PostedBy,
		&i.LastEditedBy,
		&i.PostedAt,
		&i.LastEditedAt,
	)
	return i, err
}

type CreateRecordsParams struct {
	RecordTypeID   uuid.UUID   `json:"record_type_id"`
	Title          string      `json:"title"`
	Body           pgtype.Text `json:"body"`
	OrganizationID pgtype.UUID `json:"organization_id"`
	PostedBy       pgtype.UUID `json:"posted_by"`
	LastEditedBy   pgtype.UUID `json:"last_edited_by"`
	PostedAt       time.Time   `json:"posted_at"`
	LastEditedAt   time.Time   `json:"last_edited_at"`
}

const deleteRecord = `-- name: DeleteRecord :execrows
DELETE FROM t_records WHERE record_id = $1
`

func (q *Queries) DeleteRecord(ctx context.Context, recordID uuid.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, deleteRecord, recordID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteRecordOnOrganization = `-- name: DeleteRecordOnOrganization :execrows
DELETE FROM t_records WHERE organization_id = $1
`

func (q *Queries) DeleteRecordOnOrganization(ctx context.Context, organizationID pgtype.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, deleteRecordOnOrganization, organizationID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const findRecordByID = `-- name: FindRecordByID :one
SELECT t_records_pkey, record_id, record_type_id, title, body, organization_id, posted_by, last_edited_by, posted_at, last_edited_at FROM t_records WHERE record_id = $1
`

func (q *Queries) FindRecordByID(ctx context.Context, recordID uuid.UUID) (Record, error) {
	row := q.db.QueryRow(ctx, findRecordByID, recordID)
	var i Record
	err := row.Scan(
		&i.TRecordsPkey,
		&i.RecordID,
		&i.RecordTypeID,
		&i.Title,
		&i.Body,
		&i.OrganizationID,
		&i.PostedBy,
		&i.LastEditedBy,
		&i.PostedAt,
		&i.LastEditedAt,
	)
	return i, err
}

const findRecordByIDWithAll = `-- name: FindRecordByIDWithAll :one
SELECT t_records.t_records_pkey, t_records.record_id, t_records.record_type_id, t_records.title, t_records.body, t_records.organization_id, t_records.posted_by, t_records.last_edited_by, t_records.posted_at, t_records.last_edited_at, m_record_types.m_record_types_pkey, m_record_types.record_type_id, m_record_types.name, m_record_types.key, m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.color, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at, m_organizations.chat_room_id, m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at FROM t_records
LEFT JOIN m_record_types ON t_records.record_type_id = m_record_types.record_type_id
LEFT JOIN m_organizations ON t_records.organization_id = m_organizations.organization_id
LEFT JOIN m_members ON t_records.posted_by = m_members.member_id
LEFT JOIN m_members AS m_members_2 ON t_records.last_edited_by = m_members_2.member_id
WHERE record_id = $1
`

type FindRecordByIDWithAllRow struct {
	Record       Record       `json:"record"`
	RecordType   RecordType   `json:"record_type"`
	Organization Organization `json:"organization"`
	Member       Member       `json:"member"`
}

func (q *Queries) FindRecordByIDWithAll(ctx context.Context, recordID uuid.UUID) (FindRecordByIDWithAllRow, error) {
	row := q.db.QueryRow(ctx, findRecordByIDWithAll, recordID)
	var i FindRecordByIDWithAllRow
	err := row.Scan(
		&i.Record.TRecordsPkey,
		&i.Record.RecordID,
		&i.Record.RecordTypeID,
		&i.Record.Title,
		&i.Record.Body,
		&i.Record.OrganizationID,
		&i.Record.PostedBy,
		&i.Record.LastEditedBy,
		&i.Record.PostedAt,
		&i.Record.LastEditedAt,
		&i.RecordType.MRecordTypesPkey,
		&i.RecordType.RecordTypeID,
		&i.RecordType.Name,
		&i.RecordType.Key,
		&i.Organization.MOrganizationsPkey,
		&i.Organization.OrganizationID,
		&i.Organization.Name,
		&i.Organization.Description,
		&i.Organization.Color,
		&i.Organization.IsPersonal,
		&i.Organization.IsWhole,
		&i.Organization.CreatedAt,
		&i.Organization.UpdatedAt,
		&i.Organization.ChatRoomID,
		&i.Member.MMembersPkey,
		&i.Member.MemberID,
		&i.Member.LoginID,
		&i.Member.Password,
		&i.Member.Email,
		&i.Member.Name,
		&i.Member.AttendStatusID,
		&i.Member.ProfileImageID,
		&i.Member.GradeID,
		&i.Member.GroupID,
		&i.Member.PersonalOrganizationID,
		&i.Member.RoleID,
		&i.Member.CreatedAt,
		&i.Member.UpdatedAt,
	)
	return i, err
}

const findRecordByIDWithLastEditedBy = `-- name: FindRecordByIDWithLastEditedBy :one
SELECT t_records.t_records_pkey, t_records.record_id, t_records.record_type_id, t_records.title, t_records.body, t_records.organization_id, t_records.posted_by, t_records.last_edited_by, t_records.posted_at, t_records.last_edited_at, m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at FROM t_records
LEFT JOIN m_members ON t_records.last_edited_by = m_members.member_id
WHERE record_id = $1
`

type FindRecordByIDWithLastEditedByRow struct {
	Record Record `json:"record"`
	Member Member `json:"member"`
}

func (q *Queries) FindRecordByIDWithLastEditedBy(ctx context.Context, recordID uuid.UUID) (FindRecordByIDWithLastEditedByRow, error) {
	row := q.db.QueryRow(ctx, findRecordByIDWithLastEditedBy, recordID)
	var i FindRecordByIDWithLastEditedByRow
	err := row.Scan(
		&i.Record.TRecordsPkey,
		&i.Record.RecordID,
		&i.Record.RecordTypeID,
		&i.Record.Title,
		&i.Record.Body,
		&i.Record.OrganizationID,
		&i.Record.PostedBy,
		&i.Record.LastEditedBy,
		&i.Record.PostedAt,
		&i.Record.LastEditedAt,
		&i.Member.MMembersPkey,
		&i.Member.MemberID,
		&i.Member.LoginID,
		&i.Member.Password,
		&i.Member.Email,
		&i.Member.Name,
		&i.Member.AttendStatusID,
		&i.Member.ProfileImageID,
		&i.Member.GradeID,
		&i.Member.GroupID,
		&i.Member.PersonalOrganizationID,
		&i.Member.RoleID,
		&i.Member.CreatedAt,
		&i.Member.UpdatedAt,
	)
	return i, err
}

const findRecordByIDWithOrganization = `-- name: FindRecordByIDWithOrganization :one
SELECT t_records.t_records_pkey, t_records.record_id, t_records.record_type_id, t_records.title, t_records.body, t_records.organization_id, t_records.posted_by, t_records.last_edited_by, t_records.posted_at, t_records.last_edited_at, m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.color, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at, m_organizations.chat_room_id FROM t_records
LEFT JOIN m_organizations ON t_records.organization_id = m_organizations.organization_id
WHERE record_id = $1
`

type FindRecordByIDWithOrganizationRow struct {
	Record       Record       `json:"record"`
	Organization Organization `json:"organization"`
}

func (q *Queries) FindRecordByIDWithOrganization(ctx context.Context, recordID uuid.UUID) (FindRecordByIDWithOrganizationRow, error) {
	row := q.db.QueryRow(ctx, findRecordByIDWithOrganization, recordID)
	var i FindRecordByIDWithOrganizationRow
	err := row.Scan(
		&i.Record.TRecordsPkey,
		&i.Record.RecordID,
		&i.Record.RecordTypeID,
		&i.Record.Title,
		&i.Record.Body,
		&i.Record.OrganizationID,
		&i.Record.PostedBy,
		&i.Record.LastEditedBy,
		&i.Record.PostedAt,
		&i.Record.LastEditedAt,
		&i.Organization.MOrganizationsPkey,
		&i.Organization.OrganizationID,
		&i.Organization.Name,
		&i.Organization.Description,
		&i.Organization.Color,
		&i.Organization.IsPersonal,
		&i.Organization.IsWhole,
		&i.Organization.CreatedAt,
		&i.Organization.UpdatedAt,
		&i.Organization.ChatRoomID,
	)
	return i, err
}

const findRecordByIDWithPostedBy = `-- name: FindRecordByIDWithPostedBy :one
SELECT t_records.t_records_pkey, t_records.record_id, t_records.record_type_id, t_records.title, t_records.body, t_records.organization_id, t_records.posted_by, t_records.last_edited_by, t_records.posted_at, t_records.last_edited_at, m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at FROM t_records
LEFT JOIN m_members ON t_records.posted_by = m_members.member_id
WHERE record_id = $1
`

type FindRecordByIDWithPostedByRow struct {
	Record Record `json:"record"`
	Member Member `json:"member"`
}

func (q *Queries) FindRecordByIDWithPostedBy(ctx context.Context, recordID uuid.UUID) (FindRecordByIDWithPostedByRow, error) {
	row := q.db.QueryRow(ctx, findRecordByIDWithPostedBy, recordID)
	var i FindRecordByIDWithPostedByRow
	err := row.Scan(
		&i.Record.TRecordsPkey,
		&i.Record.RecordID,
		&i.Record.RecordTypeID,
		&i.Record.Title,
		&i.Record.Body,
		&i.Record.OrganizationID,
		&i.Record.PostedBy,
		&i.Record.LastEditedBy,
		&i.Record.PostedAt,
		&i.Record.LastEditedAt,
		&i.Member.MMembersPkey,
		&i.Member.MemberID,
		&i.Member.LoginID,
		&i.Member.Password,
		&i.Member.Email,
		&i.Member.Name,
		&i.Member.AttendStatusID,
		&i.Member.ProfileImageID,
		&i.Member.GradeID,
		&i.Member.GroupID,
		&i.Member.PersonalOrganizationID,
		&i.Member.RoleID,
		&i.Member.CreatedAt,
		&i.Member.UpdatedAt,
	)
	return i, err
}

const findRecordByIDWithRecordType = `-- name: FindRecordByIDWithRecordType :one
SELECT t_records.t_records_pkey, t_records.record_id, t_records.record_type_id, t_records.title, t_records.body, t_records.organization_id, t_records.posted_by, t_records.last_edited_by, t_records.posted_at, t_records.last_edited_at, m_record_types.m_record_types_pkey, m_record_types.record_type_id, m_record_types.name, m_record_types.key FROM t_records
LEFT JOIN m_record_types ON t_records.record_type_id = m_record_types.record_type_id
WHERE record_id = $1
`

type FindRecordByIDWithRecordTypeRow struct {
	Record     Record     `json:"record"`
	RecordType RecordType `json:"record_type"`
}

func (q *Queries) FindRecordByIDWithRecordType(ctx context.Context, recordID uuid.UUID) (FindRecordByIDWithRecordTypeRow, error) {
	row := q.db.QueryRow(ctx, findRecordByIDWithRecordType, recordID)
	var i FindRecordByIDWithRecordTypeRow
	err := row.Scan(
		&i.Record.TRecordsPkey,
		&i.Record.RecordID,
		&i.Record.RecordTypeID,
		&i.Record.Title,
		&i.Record.Body,
		&i.Record.OrganizationID,
		&i.Record.PostedBy,
		&i.Record.LastEditedBy,
		&i.Record.PostedAt,
		&i.Record.LastEditedAt,
		&i.RecordType.MRecordTypesPkey,
		&i.RecordType.RecordTypeID,
		&i.RecordType.Name,
		&i.RecordType.Key,
	)
	return i, err
}

const getPluralRecords = `-- name: GetPluralRecords :many
SELECT t_records_pkey, record_id, record_type_id, title, body, organization_id, posted_by, last_edited_by, posted_at, last_edited_at FROM t_records WHERE record_id = ANY($1::uuid[])
ORDER BY
	t_records_pkey ASC
`

func (q *Queries) GetPluralRecords(ctx context.Context, recordIds []uuid.UUID) ([]Record, error) {
	rows, err := q.db.Query(ctx, getPluralRecords, recordIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Record{}
	for rows.Next() {
		var i Record
		if err := rows.Scan(
			&i.TRecordsPkey,
			&i.RecordID,
			&i.RecordTypeID,
			&i.Title,
			&i.Body,
			&i.OrganizationID,
			&i.PostedBy,
			&i.LastEditedBy,
			&i.PostedAt,
			&i.LastEditedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralRecordsUseNumberedPaginate = `-- name: GetPluralRecordsUseNumberedPaginate :many
SELECT t_records_pkey, record_id, record_type_id, title, body, organization_id, posted_by, last_edited_by, posted_at, last_edited_at FROM t_records WHERE record_id = ANY($3::uuid[])
ORDER BY
	t_records_pkey ASC
LIMIT $1 OFFSET $2
`

type GetPluralRecordsUseNumberedPaginateParams struct {
	Limit     int32       `json:"limit"`
	Offset    int32       `json:"offset"`
	RecordIds []uuid.UUID `json:"record_ids"`
}

func (q *Queries) GetPluralRecordsUseNumberedPaginate(ctx context.Context, arg GetPluralRecordsUseNumberedPaginateParams) ([]Record, error) {
	rows, err := q.db.Query(ctx, getPluralRecordsUseNumberedPaginate, arg.Limit, arg.Offset, arg.RecordIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Record{}
	for rows.Next() {
		var i Record
		if err := rows.Scan(
			&i.TRecordsPkey,
			&i.RecordID,
			&i.RecordTypeID,
			&i.Title,
			&i.Body,
			&i.OrganizationID,
			&i.PostedBy,
			&i.LastEditedBy,
			&i.PostedAt,
			&i.LastEditedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralRecordsWithAll = `-- name: GetPluralRecordsWithAll :many
SELECT t_records.t_records_pkey, t_records.record_id, t_records.record_type_id, t_records.title, t_records.body, t_records.organization_id, t_records.posted_by, t_records.last_edited_by, t_records.posted_at, t_records.last_edited_at, m_record_types.m_record_types_pkey, m_record_types.record_type_id, m_record_types.name, m_record_types.key, m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.color, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at, m_organizations.chat_room_id, m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at FROM t_records
LEFT JOIN m_record_types ON t_records.record_type_id = m_record_types.record_type_id
LEFT JOIN m_organizations ON t_records.organization_id = m_organizations.organization_id
LEFT JOIN m_members ON t_records.posted_by = m_members.member_id
LEFT JOIN m_members AS m_members_2 ON t_records.last_edited_by = m_members_2.member_id
WHERE record_id = ANY($1::uuid[])
ORDER BY
	t_records_pkey ASC
`

type GetPluralRecordsWithAllRow struct {
	Record       Record       `json:"record"`
	RecordType   RecordType   `json:"record_type"`
	Organization Organization `json:"organization"`
	Member       Member       `json:"member"`
	Member_2     Member       `json:"member_2"`
}

func (q *Queries) GetPluralRecordsWithAll(ctx context.Context, recordIds []uuid.UUID) ([]GetPluralRecordsWithAllRow, error) {
	rows, err := q.db.Query(ctx, getPluralRecordsWithAll, recordIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralRecordsWithAllRow{}
	for rows.Next() {
		var i GetPluralRecordsWithAllRow
		if err := rows.Scan(
			&i.Record.TRecordsPkey,
			&i.Record.RecordID,
			&i.Record.RecordTypeID,
			&i.Record.Title,
			&i.Record.Body,
			&i.Record.OrganizationID,
			&i.Record.PostedBy,
			&i.Record.LastEditedBy,
			&i.Record.PostedAt,
			&i.Record.LastEditedAt,
			&i.RecordType.MRecordTypesPkey,
			&i.RecordType.RecordTypeID,
			&i.RecordType.Name,
			&i.RecordType.Key,
			&i.Organization.MOrganizationsPkey,
			&i.Organization.OrganizationID,
			&i.Organization.Name,
			&i.Organization.Description,
			&i.Organization.Color,
			&i.Organization.IsPersonal,
			&i.Organization.IsWhole,
			&i.Organization.CreatedAt,
			&i.Organization.UpdatedAt,
			&i.Organization.ChatRoomID,
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageID,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
			&i.Member_2.MMembersPkey,
			&i.Member_2.MemberID,
			&i.Member_2.LoginID,
			&i.Member_2.Password,
			&i.Member_2.Email,
			&i.Member_2.Name,
			&i.Member_2.AttendStatusID,
			&i.Member_2.ProfileImageID,
			&i.Member_2.GradeID,
			&i.Member_2.GroupID,
			&i.Member_2.PersonalOrganizationID,
			&i.Member_2.RoleID,
			&i.Member_2.CreatedAt,
			&i.Member_2.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralRecordsWithAllUseNumberedPaginate = `-- name: GetPluralRecordsWithAllUseNumberedPaginate :many
SELECT t_records.t_records_pkey, t_records.record_id, t_records.record_type_id, t_records.title, t_records.body, t_records.organization_id, t_records.posted_by, t_records.last_edited_by, t_records.posted_at, t_records.last_edited_at, m_record_types.m_record_types_pkey, m_record_types.record_type_id, m_record_types.name, m_record_types.key, m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.color, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at, m_organizations.chat_room_id, m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at FROM t_records
LEFT JOIN m_record_types ON t_records.record_type_id = m_record_types.record_type_id
LEFT JOIN m_organizations ON t_records.organization_id = m_organizations.organization_id
LEFT JOIN m_members ON t_records.posted_by = m_members.member_id
LEFT JOIN m_members AS m_members_2 ON t_records.last_edited_by = m_members_2.member_id
WHERE record_id = ANY($3::uuid[])
ORDER BY
	t_records_pkey ASC
LIMIT $1 OFFSET $2
`

type GetPluralRecordsWithAllUseNumberedPaginateParams struct {
	Limit     int32       `json:"limit"`
	Offset    int32       `json:"offset"`
	RecordIds []uuid.UUID `json:"record_ids"`
}

type GetPluralRecordsWithAllUseNumberedPaginateRow struct {
	Record       Record       `json:"record"`
	RecordType   RecordType   `json:"record_type"`
	Organization Organization `json:"organization"`
	Member       Member       `json:"member"`
	Member_2     Member       `json:"member_2"`
}

func (q *Queries) GetPluralRecordsWithAllUseNumberedPaginate(ctx context.Context, arg GetPluralRecordsWithAllUseNumberedPaginateParams) ([]GetPluralRecordsWithAllUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getPluralRecordsWithAllUseNumberedPaginate, arg.Limit, arg.Offset, arg.RecordIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralRecordsWithAllUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetPluralRecordsWithAllUseNumberedPaginateRow
		if err := rows.Scan(
			&i.Record.TRecordsPkey,
			&i.Record.RecordID,
			&i.Record.RecordTypeID,
			&i.Record.Title,
			&i.Record.Body,
			&i.Record.OrganizationID,
			&i.Record.PostedBy,
			&i.Record.LastEditedBy,
			&i.Record.PostedAt,
			&i.Record.LastEditedAt,
			&i.RecordType.MRecordTypesPkey,
			&i.RecordType.RecordTypeID,
			&i.RecordType.Name,
			&i.RecordType.Key,
			&i.Organization.MOrganizationsPkey,
			&i.Organization.OrganizationID,
			&i.Organization.Name,
			&i.Organization.Description,
			&i.Organization.Color,
			&i.Organization.IsPersonal,
			&i.Organization.IsWhole,
			&i.Organization.CreatedAt,
			&i.Organization.UpdatedAt,
			&i.Organization.ChatRoomID,
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageID,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
			&i.Member_2.MMembersPkey,
			&i.Member_2.MemberID,
			&i.Member_2.LoginID,
			&i.Member_2.Password,
			&i.Member_2.Email,
			&i.Member_2.Name,
			&i.Member_2.AttendStatusID,
			&i.Member_2.ProfileImageID,
			&i.Member_2.GradeID,
			&i.Member_2.GroupID,
			&i.Member_2.PersonalOrganizationID,
			&i.Member_2.RoleID,
			&i.Member_2.CreatedAt,
			&i.Member_2.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralRecordsWithLastEditedBy = `-- name: GetPluralRecordsWithLastEditedBy :many
SELECT t_records.t_records_pkey, t_records.record_id, t_records.record_type_id, t_records.title, t_records.body, t_records.organization_id, t_records.posted_by, t_records.last_edited_by, t_records.posted_at, t_records.last_edited_at, m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at FROM t_records
LEFT JOIN m_members ON t_records.last_edited_by = m_members.member_id
WHERE record_id = ANY($1::uuid[])
ORDER BY
	t_records_pkey ASC
`

type GetPluralRecordsWithLastEditedByRow struct {
	Record Record `json:"record"`
	Member Member `json:"member"`
}

func (q *Queries) GetPluralRecordsWithLastEditedBy(ctx context.Context, recordIds []uuid.UUID) ([]GetPluralRecordsWithLastEditedByRow, error) {
	rows, err := q.db.Query(ctx, getPluralRecordsWithLastEditedBy, recordIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralRecordsWithLastEditedByRow{}
	for rows.Next() {
		var i GetPluralRecordsWithLastEditedByRow
		if err := rows.Scan(
			&i.Record.TRecordsPkey,
			&i.Record.RecordID,
			&i.Record.RecordTypeID,
			&i.Record.Title,
			&i.Record.Body,
			&i.Record.OrganizationID,
			&i.Record.PostedBy,
			&i.Record.LastEditedBy,
			&i.Record.PostedAt,
			&i.Record.LastEditedAt,
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageID,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralRecordsWithLastEditedByUseNumberedPaginate = `-- name: GetPluralRecordsWithLastEditedByUseNumberedPaginate :many
SELECT t_records.t_records_pkey, t_records.record_id, t_records.record_type_id, t_records.title, t_records.body, t_records.organization_id, t_records.posted_by, t_records.last_edited_by, t_records.posted_at, t_records.last_edited_at, m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at FROM t_records
LEFT JOIN m_members ON t_records.last_edited_by = m_members.member_id
WHERE record_id = ANY($3::uuid[])
ORDER BY
	t_records_pkey ASC
LIMIT $1 OFFSET $2
`

type GetPluralRecordsWithLastEditedByUseNumberedPaginateParams struct {
	Limit     int32       `json:"limit"`
	Offset    int32       `json:"offset"`
	RecordIds []uuid.UUID `json:"record_ids"`
}

type GetPluralRecordsWithLastEditedByUseNumberedPaginateRow struct {
	Record Record `json:"record"`
	Member Member `json:"member"`
}

func (q *Queries) GetPluralRecordsWithLastEditedByUseNumberedPaginate(ctx context.Context, arg GetPluralRecordsWithLastEditedByUseNumberedPaginateParams) ([]GetPluralRecordsWithLastEditedByUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getPluralRecordsWithLastEditedByUseNumberedPaginate, arg.Limit, arg.Offset, arg.RecordIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralRecordsWithLastEditedByUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetPluralRecordsWithLastEditedByUseNumberedPaginateRow
		if err := rows.Scan(
			&i.Record.TRecordsPkey,
			&i.Record.RecordID,
			&i.Record.RecordTypeID,
			&i.Record.Title,
			&i.Record.Body,
			&i.Record.OrganizationID,
			&i.Record.PostedBy,
			&i.Record.LastEditedBy,
			&i.Record.PostedAt,
			&i.Record.LastEditedAt,
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageID,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralRecordsWithOrganization = `-- name: GetPluralRecordsWithOrganization :many
SELECT t_records.t_records_pkey, t_records.record_id, t_records.record_type_id, t_records.title, t_records.body, t_records.organization_id, t_records.posted_by, t_records.last_edited_by, t_records.posted_at, t_records.last_edited_at, m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.color, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at, m_organizations.chat_room_id FROM t_records
LEFT JOIN m_organizations ON t_records.organization_id = m_organizations.organization_id
WHERE record_id = ANY($1::uuid[])
ORDER BY
	t_records_pkey ASC
`

type GetPluralRecordsWithOrganizationRow struct {
	Record       Record       `json:"record"`
	Organization Organization `json:"organization"`
}

func (q *Queries) GetPluralRecordsWithOrganization(ctx context.Context, recordIds []uuid.UUID) ([]GetPluralRecordsWithOrganizationRow, error) {
	rows, err := q.db.Query(ctx, getPluralRecordsWithOrganization, recordIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralRecordsWithOrganizationRow{}
	for rows.Next() {
		var i GetPluralRecordsWithOrganizationRow
		if err := rows.Scan(
			&i.Record.TRecordsPkey,
			&i.Record.RecordID,
			&i.Record.RecordTypeID,
			&i.Record.Title,
			&i.Record.Body,
			&i.Record.OrganizationID,
			&i.Record.PostedBy,
			&i.Record.LastEditedBy,
			&i.Record.PostedAt,
			&i.Record.LastEditedAt,
			&i.Organization.MOrganizationsPkey,
			&i.Organization.OrganizationID,
			&i.Organization.Name,
			&i.Organization.Description,
			&i.Organization.Color,
			&i.Organization.IsPersonal,
			&i.Organization.IsWhole,
			&i.Organization.CreatedAt,
			&i.Organization.UpdatedAt,
			&i.Organization.ChatRoomID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralRecordsWithOrganizationUseNumberedPaginate = `-- name: GetPluralRecordsWithOrganizationUseNumberedPaginate :many
SELECT t_records.t_records_pkey, t_records.record_id, t_records.record_type_id, t_records.title, t_records.body, t_records.organization_id, t_records.posted_by, t_records.last_edited_by, t_records.posted_at, t_records.last_edited_at, m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.color, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at, m_organizations.chat_room_id FROM t_records
LEFT JOIN m_organizations ON t_records.organization_id = m_organizations.organization_id
WHERE record_id = ANY($3::uuid[])
ORDER BY
	t_records_pkey ASC
LIMIT $1 OFFSET $2
`

type GetPluralRecordsWithOrganizationUseNumberedPaginateParams struct {
	Limit     int32       `json:"limit"`
	Offset    int32       `json:"offset"`
	RecordIds []uuid.UUID `json:"record_ids"`
}

type GetPluralRecordsWithOrganizationUseNumberedPaginateRow struct {
	Record       Record       `json:"record"`
	Organization Organization `json:"organization"`
}

func (q *Queries) GetPluralRecordsWithOrganizationUseNumberedPaginate(ctx context.Context, arg GetPluralRecordsWithOrganizationUseNumberedPaginateParams) ([]GetPluralRecordsWithOrganizationUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getPluralRecordsWithOrganizationUseNumberedPaginate, arg.Limit, arg.Offset, arg.RecordIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralRecordsWithOrganizationUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetPluralRecordsWithOrganizationUseNumberedPaginateRow
		if err := rows.Scan(
			&i.Record.TRecordsPkey,
			&i.Record.RecordID,
			&i.Record.RecordTypeID,
			&i.Record.Title,
			&i.Record.Body,
			&i.Record.OrganizationID,
			&i.Record.PostedBy,
			&i.Record.LastEditedBy,
			&i.Record.PostedAt,
			&i.Record.LastEditedAt,
			&i.Organization.MOrganizationsPkey,
			&i.Organization.OrganizationID,
			&i.Organization.Name,
			&i.Organization.Description,
			&i.Organization.Color,
			&i.Organization.IsPersonal,
			&i.Organization.IsWhole,
			&i.Organization.CreatedAt,
			&i.Organization.UpdatedAt,
			&i.Organization.ChatRoomID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralRecordsWithPostedBy = `-- name: GetPluralRecordsWithPostedBy :many
SELECT t_records.t_records_pkey, t_records.record_id, t_records.record_type_id, t_records.title, t_records.body, t_records.organization_id, t_records.posted_by, t_records.last_edited_by, t_records.posted_at, t_records.last_edited_at, m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at FROM t_records
LEFT JOIN m_members ON t_records.posted_by = m_members.member_id
WHERE record_id = ANY($1::uuid[])
ORDER BY
	t_records_pkey ASC
`

type GetPluralRecordsWithPostedByRow struct {
	Record Record `json:"record"`
	Member Member `json:"member"`
}

func (q *Queries) GetPluralRecordsWithPostedBy(ctx context.Context, recordIds []uuid.UUID) ([]GetPluralRecordsWithPostedByRow, error) {
	rows, err := q.db.Query(ctx, getPluralRecordsWithPostedBy, recordIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralRecordsWithPostedByRow{}
	for rows.Next() {
		var i GetPluralRecordsWithPostedByRow
		if err := rows.Scan(
			&i.Record.TRecordsPkey,
			&i.Record.RecordID,
			&i.Record.RecordTypeID,
			&i.Record.Title,
			&i.Record.Body,
			&i.Record.OrganizationID,
			&i.Record.PostedBy,
			&i.Record.LastEditedBy,
			&i.Record.PostedAt,
			&i.Record.LastEditedAt,
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageID,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralRecordsWithPostedByUseNumberedPaginate = `-- name: GetPluralRecordsWithPostedByUseNumberedPaginate :many
SELECT t_records.t_records_pkey, t_records.record_id, t_records.record_type_id, t_records.title, t_records.body, t_records.organization_id, t_records.posted_by, t_records.last_edited_by, t_records.posted_at, t_records.last_edited_at, m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at FROM t_records
LEFT JOIN m_members ON t_records.posted_by = m_members.member_id
WHERE record_id = ANY($3::uuid[])
ORDER BY
	t_records_pkey ASC
LIMIT $1 OFFSET $2
`

type GetPluralRecordsWithPostedByUseNumberedPaginateParams struct {
	Limit     int32       `json:"limit"`
	Offset    int32       `json:"offset"`
	RecordIds []uuid.UUID `json:"record_ids"`
}

type GetPluralRecordsWithPostedByUseNumberedPaginateRow struct {
	Record Record `json:"record"`
	Member Member `json:"member"`
}

func (q *Queries) GetPluralRecordsWithPostedByUseNumberedPaginate(ctx context.Context, arg GetPluralRecordsWithPostedByUseNumberedPaginateParams) ([]GetPluralRecordsWithPostedByUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getPluralRecordsWithPostedByUseNumberedPaginate, arg.Limit, arg.Offset, arg.RecordIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralRecordsWithPostedByUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetPluralRecordsWithPostedByUseNumberedPaginateRow
		if err := rows.Scan(
			&i.Record.TRecordsPkey,
			&i.Record.RecordID,
			&i.Record.RecordTypeID,
			&i.Record.Title,
			&i.Record.Body,
			&i.Record.OrganizationID,
			&i.Record.PostedBy,
			&i.Record.LastEditedBy,
			&i.Record.PostedAt,
			&i.Record.LastEditedAt,
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageID,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralRecordsWithRecordType = `-- name: GetPluralRecordsWithRecordType :many
SELECT t_records.t_records_pkey, t_records.record_id, t_records.record_type_id, t_records.title, t_records.body, t_records.organization_id, t_records.posted_by, t_records.last_edited_by, t_records.posted_at, t_records.last_edited_at, m_record_types.m_record_types_pkey, m_record_types.record_type_id, m_record_types.name, m_record_types.key FROM t_records
LEFT JOIN m_record_types ON t_records.record_type_id = m_record_types.record_type_id
WHERE record_id = ANY($1::uuid[])
ORDER BY
	t_records_pkey ASC
`

type GetPluralRecordsWithRecordTypeRow struct {
	Record     Record     `json:"record"`
	RecordType RecordType `json:"record_type"`
}

func (q *Queries) GetPluralRecordsWithRecordType(ctx context.Context, recordIds []uuid.UUID) ([]GetPluralRecordsWithRecordTypeRow, error) {
	rows, err := q.db.Query(ctx, getPluralRecordsWithRecordType, recordIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralRecordsWithRecordTypeRow{}
	for rows.Next() {
		var i GetPluralRecordsWithRecordTypeRow
		if err := rows.Scan(
			&i.Record.TRecordsPkey,
			&i.Record.RecordID,
			&i.Record.RecordTypeID,
			&i.Record.Title,
			&i.Record.Body,
			&i.Record.OrganizationID,
			&i.Record.PostedBy,
			&i.Record.LastEditedBy,
			&i.Record.PostedAt,
			&i.Record.LastEditedAt,
			&i.RecordType.MRecordTypesPkey,
			&i.RecordType.RecordTypeID,
			&i.RecordType.Name,
			&i.RecordType.Key,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralRecordsWithRecordTypeUseNumberedPaginate = `-- name: GetPluralRecordsWithRecordTypeUseNumberedPaginate :many
SELECT t_records.t_records_pkey, t_records.record_id, t_records.record_type_id, t_records.title, t_records.body, t_records.organization_id, t_records.posted_by, t_records.last_edited_by, t_records.posted_at, t_records.last_edited_at, m_record_types.m_record_types_pkey, m_record_types.record_type_id, m_record_types.name, m_record_types.key FROM t_records
LEFT JOIN m_record_types ON t_records.record_type_id = m_record_types.record_type_id
WHERE record_id = ANY($3::uuid[])
ORDER BY
	t_records_pkey ASC
LIMIT $1 OFFSET $2
`

type GetPluralRecordsWithRecordTypeUseNumberedPaginateParams struct {
	Limit     int32       `json:"limit"`
	Offset    int32       `json:"offset"`
	RecordIds []uuid.UUID `json:"record_ids"`
}

type GetPluralRecordsWithRecordTypeUseNumberedPaginateRow struct {
	Record     Record     `json:"record"`
	RecordType RecordType `json:"record_type"`
}

func (q *Queries) GetPluralRecordsWithRecordTypeUseNumberedPaginate(ctx context.Context, arg GetPluralRecordsWithRecordTypeUseNumberedPaginateParams) ([]GetPluralRecordsWithRecordTypeUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getPluralRecordsWithRecordTypeUseNumberedPaginate, arg.Limit, arg.Offset, arg.RecordIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralRecordsWithRecordTypeUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetPluralRecordsWithRecordTypeUseNumberedPaginateRow
		if err := rows.Scan(
			&i.Record.TRecordsPkey,
			&i.Record.RecordID,
			&i.Record.RecordTypeID,
			&i.Record.Title,
			&i.Record.Body,
			&i.Record.OrganizationID,
			&i.Record.PostedBy,
			&i.Record.LastEditedBy,
			&i.Record.PostedAt,
			&i.Record.LastEditedAt,
			&i.RecordType.MRecordTypesPkey,
			&i.RecordType.RecordTypeID,
			&i.RecordType.Name,
			&i.RecordType.Key,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecords = `-- name: GetRecords :many
SELECT t_records_pkey, record_id, record_type_id, title, body, organization_id, posted_by, last_edited_by, posted_at, last_edited_at FROM t_records
WHERE
	CASE WHEN $1::boolean = true THEN record_type_id = ANY($2) ELSE TRUE END
AND
	CASE WHEN $3::boolean = true THEN title LIKE '%' || $4::text || '%' ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN organization_id = ANY($6) ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN posted_by = ANY($8) ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN last_edited_by = ANY($10) ELSE TRUE END
ORDER BY
	CASE WHEN $11::text = 'title' THEN title END ASC,
	CASE WHEN $11::text = 'r_title' THEN title END DESC,
	CASE WHEN $11::text = 'posted_at' THEN posted_at END ASC,
	CASE WHEN $11::text = 'r_posted_at' THEN posted_at END DESC,
	CASE WHEN $11::text = 'last_edited_at' THEN last_edited_at END ASC,
	CASE WHEN $11::text = 'r_last_edited_at' THEN last_edited_at END DESC,
	t_records_pkey ASC
`

type GetRecordsParams struct {
	WhereInRecordType   bool        `json:"where_in_record_type"`
	InRecordType        uuid.UUID   `json:"in_record_type"`
	WhereLikeTitle      bool        `json:"where_like_title"`
	SearchTitle         string      `json:"search_title"`
	WhereInOrganization bool        `json:"where_in_organization"`
	InOrganization      pgtype.UUID `json:"in_organization"`
	WhereInPostedBy     bool        `json:"where_in_posted_by"`
	InPostedBy          pgtype.UUID `json:"in_posted_by"`
	WhereInLastEditedBy bool        `json:"where_in_last_edited_by"`
	InLastEditedBy      pgtype.UUID `json:"in_last_edited_by"`
	OrderMethod         string      `json:"order_method"`
}

func (q *Queries) GetRecords(ctx context.Context, arg GetRecordsParams) ([]Record, error) {
	rows, err := q.db.Query(ctx, getRecords,
		arg.WhereInRecordType,
		arg.InRecordType,
		arg.WhereLikeTitle,
		arg.SearchTitle,
		arg.WhereInOrganization,
		arg.InOrganization,
		arg.WhereInPostedBy,
		arg.InPostedBy,
		arg.WhereInLastEditedBy,
		arg.InLastEditedBy,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Record{}
	for rows.Next() {
		var i Record
		if err := rows.Scan(
			&i.TRecordsPkey,
			&i.RecordID,
			&i.RecordTypeID,
			&i.Title,
			&i.Body,
			&i.OrganizationID,
			&i.PostedBy,
			&i.LastEditedBy,
			&i.PostedAt,
			&i.LastEditedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecordsUseKeysetPaginate = `-- name: GetRecordsUseKeysetPaginate :many
SELECT t_records_pkey, record_id, record_type_id, title, body, organization_id, posted_by, last_edited_by, posted_at, last_edited_at FROM t_records
WHERE
	CASE WHEN $2::boolean = true THEN record_type_id = ANY($3) ELSE TRUE END
AND
	CASE WHEN $4::boolean = true THEN title LIKE '%' || $5::text || '%' ELSE TRUE END
AND
	CASE WHEN $6::boolean = true THEN organization_id = ANY($7) ELSE TRUE END
AND
	CASE WHEN $8::boolean = true THEN posted_by = ANY($9) ELSE TRUE END
AND
	CASE WHEN $10::boolean = true THEN last_edited_by = ANY($11) ELSE TRUE END
AND
	CASE $12::text
		WHEN 'next' THEN
			CASE $13::text
				WHEN 'title' THEN title > $14 OR (title = $14 AND t_records_pkey > $15::int)
				WHEN 'r_title' THEN title < $14 OR (title = $14 AND t_records_pkey > $15::int)
				WHEN 'posted_at' THEN posted_at > $16 OR (posted_at = $16 AND t_records_pkey > $15::int)
				WHEN 'r_posted_at' THEN posted_at < $16 OR (posted_at = $16 AND t_records_pkey > $15::int)
				WHEN 'last_edited_at' THEN last_edited_at > $17 OR (last_edited_at = $17 AND t_records_pkey > $15::int)
				WHEN 'r_last_edited_at' THEN last_edited_at < $17 OR (last_edited_at = $17 AND t_records_pkey > $15::int)
				ELSE t_records_pkey > $15::int
			END
		WHEN 'prev' THEN
			CASE $13::text
				WHEN 'title' THEN title < $14 OR (title = $14 AND t_records_pkey < $15::int)
				WHEN 'r_title' THEN title > $14 OR (title = $14 AND t_records_pkey < $15::int)
				WHEN 'posted_at' THEN posted_at < $16 OR (posted_at = $16 AND t_records_pkey < $15::int)
				WHEN 'r_posted_at' THEN posted_at > $16 OR (posted_at = $16 AND t_records_pkey < $15::int)
				WHEN 'last_edited_at' THEN last_edited_at < $17 OR (last_edited_at = $17 AND t_records_pkey < $15::int)
				WHEN 'r_last_edited_at' THEN last_edited_at > $17 OR (last_edited_at = $17 AND t_records_pkey < $15::int)
				ELSE t_records_pkey < $15::int
			END
	END
ORDER BY
	CASE WHEN $13::text = 'title' AND $12::text = 'next' THEN title END ASC,
	CASE WHEN $13::text = 'title' AND $12::text = 'prev' THEN title END DESC,
	CASE WHEN $13::text = 'r_title' AND $12::text = 'next' THEN title END DESC,
	CASE WHEN $13::text = 'r_title' AND $12::text = 'prev' THEN title END ASC,
	CASE WHEN $13::text = 'posted_at' AND $12::text = 'next' THEN posted_at END ASC,
	CASE WHEN $13::text = 'posted_at' AND $12::text = 'prev' THEN posted_at END DESC,
	CASE WHEN $13::text = 'r_posted_at' AND $12::text = 'next' THEN posted_at END DESC,
	CASE WHEN $13::text = 'r_posted_at' AND $12::text = 'prev' THEN posted_at END ASC,
	CASE WHEN $13::text = 'last_edited_at' AND $12::text = 'next' THEN last_edited_at END ASC,
	CASE WHEN $13::text = 'last_edited_at' AND $12::text = 'prev' THEN last_edited_at END DESC,
	CASE WHEN $13::text = 'r_last_edited_at' AND $12::text = 'next' THEN last_edited_at END DESC,
	CASE WHEN $13::text = 'r_last_edited_at' AND $12::text = 'prev' THEN last_edited_at END ASC,
	CASE WHEN $12::text = 'next' THEN t_records_pkey END ASC,
	CASE WHEN $12::text = 'prev' THEN t_records_pkey END DESC
LIMIT $1
`

type GetRecordsUseKeysetPaginateParams struct {
	Limit               int32       `json:"limit"`
	WhereInRecordType   bool        `json:"where_in_record_type"`
	InRecordType        uuid.UUID   `json:"in_record_type"`
	WhereLikeTitle      bool        `json:"where_like_title"`
	SearchTitle         string      `json:"search_title"`
	WhereInOrganization bool        `json:"where_in_organization"`
	InOrganization      pgtype.UUID `json:"in_organization"`
	WhereInPostedBy     bool        `json:"where_in_posted_by"`
	InPostedBy          pgtype.UUID `json:"in_posted_by"`
	WhereInLastEditedBy bool        `json:"where_in_last_edited_by"`
	InLastEditedBy      pgtype.UUID `json:"in_last_edited_by"`
	CursorDirection     string      `json:"cursor_direction"`
	OrderMethod         string      `json:"order_method"`
	TitleCursor         string      `json:"title_cursor"`
	Cursor              int32       `json:"cursor"`
	PostedAtCursor      time.Time   `json:"posted_at_cursor"`
	LastEditedAtCursor  time.Time   `json:"last_edited_at_cursor"`
}

func (q *Queries) GetRecordsUseKeysetPaginate(ctx context.Context, arg GetRecordsUseKeysetPaginateParams) ([]Record, error) {
	rows, err := q.db.Query(ctx, getRecordsUseKeysetPaginate,
		arg.Limit,
		arg.WhereInRecordType,
		arg.InRecordType,
		arg.WhereLikeTitle,
		arg.SearchTitle,
		arg.WhereInOrganization,
		arg.InOrganization,
		arg.WhereInPostedBy,
		arg.InPostedBy,
		arg.WhereInLastEditedBy,
		arg.InLastEditedBy,
		arg.CursorDirection,
		arg.OrderMethod,
		arg.TitleCursor,
		arg.Cursor,
		arg.PostedAtCursor,
		arg.LastEditedAtCursor,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Record{}
	for rows.Next() {
		var i Record
		if err := rows.Scan(
			&i.TRecordsPkey,
			&i.RecordID,
			&i.RecordTypeID,
			&i.Title,
			&i.Body,
			&i.OrganizationID,
			&i.PostedBy,
			&i.LastEditedBy,
			&i.PostedAt,
			&i.LastEditedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecordsUseNumberedPaginate = `-- name: GetRecordsUseNumberedPaginate :many
SELECT t_records_pkey, record_id, record_type_id, title, body, organization_id, posted_by, last_edited_by, posted_at, last_edited_at FROM t_records
WHERE
	CASE WHEN $3::boolean = true THEN record_type_id = ANY($4) ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN title LIKE '%' || $6::text || '%' ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN organization_id = ANY($8) ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN posted_by = ANY($10) ELSE TRUE END
AND
	CASE WHEN $11::boolean = true THEN last_edited_by = ANY($12) ELSE TRUE END
ORDER BY
	CASE WHEN $13::text = 'title' THEN title END ASC,
	CASE WHEN $13::text = 'r_title' THEN title END DESC,
	CASE WHEN $13::text = 'posted_at' THEN posted_at END ASC,
	CASE WHEN $13::text = 'r_posted_at' THEN posted_at END DESC,
	CASE WHEN $13::text = 'last_edited_at' THEN last_edited_at END ASC,
	CASE WHEN $13::text = 'r_last_edited_at' THEN last_edited_at END DESC,
	t_records_pkey ASC
LIMIT $1 OFFSET $2
`

type GetRecordsUseNumberedPaginateParams struct {
	Limit               int32       `json:"limit"`
	Offset              int32       `json:"offset"`
	WhereInRecordType   bool        `json:"where_in_record_type"`
	InRecordType        uuid.UUID   `json:"in_record_type"`
	WhereLikeTitle      bool        `json:"where_like_title"`
	SearchTitle         string      `json:"search_title"`
	WhereInOrganization bool        `json:"where_in_organization"`
	InOrganization      pgtype.UUID `json:"in_organization"`
	WhereInPostedBy     bool        `json:"where_in_posted_by"`
	InPostedBy          pgtype.UUID `json:"in_posted_by"`
	WhereInLastEditedBy bool        `json:"where_in_last_edited_by"`
	InLastEditedBy      pgtype.UUID `json:"in_last_edited_by"`
	OrderMethod         string      `json:"order_method"`
}

func (q *Queries) GetRecordsUseNumberedPaginate(ctx context.Context, arg GetRecordsUseNumberedPaginateParams) ([]Record, error) {
	rows, err := q.db.Query(ctx, getRecordsUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.WhereInRecordType,
		arg.InRecordType,
		arg.WhereLikeTitle,
		arg.SearchTitle,
		arg.WhereInOrganization,
		arg.InOrganization,
		arg.WhereInPostedBy,
		arg.InPostedBy,
		arg.WhereInLastEditedBy,
		arg.InLastEditedBy,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Record{}
	for rows.Next() {
		var i Record
		if err := rows.Scan(
			&i.TRecordsPkey,
			&i.RecordID,
			&i.RecordTypeID,
			&i.Title,
			&i.Body,
			&i.OrganizationID,
			&i.PostedBy,
			&i.LastEditedBy,
			&i.PostedAt,
			&i.LastEditedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecordsWithAll = `-- name: GetRecordsWithAll :many
SELECT t_records.t_records_pkey, t_records.record_id, t_records.record_type_id, t_records.title, t_records.body, t_records.organization_id, t_records.posted_by, t_records.last_edited_by, t_records.posted_at, t_records.last_edited_at, m_record_types.m_record_types_pkey, m_record_types.record_type_id, m_record_types.name, m_record_types.key, m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.color, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at, m_organizations.chat_room_id, m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at FROM t_records
LEFT JOIN m_record_types ON t_records.record_type_id = m_record_types.record_type_id
LEFT JOIN m_organizations ON t_records.organization_id = m_organizations.organization_id
LEFT JOIN m_members ON t_records.posted_by = m_members.member_id
LEFT JOIN m_members AS m_members_2 ON t_records.last_edited_by = m_members_2.member_id
WHERE
	CASE WHEN $1::boolean = true THEN t_records.record_type_id = ANY($2) ELSE TRUE END
AND
	CASE WHEN $3::boolean = true THEN title LIKE '%' || $4::text || '%' ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN t_records.organization_id = ANY($6) ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN t_records.posted_by = ANY($8) ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN t_records.last_edited_by = ANY($10) ELSE TRUE END
ORDER BY
	CASE WHEN $11::text = 'title' THEN title END ASC,
	CASE WHEN $11::text = 'r_title' THEN title END DESC,
	CASE WHEN $11::text = 'posted_at' THEN posted_at END ASC,
	CASE WHEN $11::text = 'r_posted_at' THEN posted_at END DESC,
	CASE WHEN $11::text = 'last_edited_at' THEN last_edited_at END ASC,
	CASE WHEN $11::text = 'r_last_edited_at' THEN last_edited_at END DESC,
	t_records_pkey ASC
`

type GetRecordsWithAllParams struct {
	WhereInRecordType   bool        `json:"where_in_record_type"`
	InRecordType        uuid.UUID   `json:"in_record_type"`
	WhereLikeTitle      bool        `json:"where_like_title"`
	SearchTitle         string      `json:"search_title"`
	WhereInOrganization bool        `json:"where_in_organization"`
	InOrganization      pgtype.UUID `json:"in_organization"`
	WhereInPostedBy     bool        `json:"where_in_posted_by"`
	InPostedBy          pgtype.UUID `json:"in_posted_by"`
	WhereInLastEditedBy bool        `json:"where_in_last_edited_by"`
	InLastEditedBy      pgtype.UUID `json:"in_last_edited_by"`
	OrderMethod         string      `json:"order_method"`
}

type GetRecordsWithAllRow struct {
	Record       Record       `json:"record"`
	RecordType   RecordType   `json:"record_type"`
	Organization Organization `json:"organization"`
	Member       Member       `json:"member"`
	Member_2     Member       `json:"member_2"`
}

func (q *Queries) GetRecordsWithAll(ctx context.Context, arg GetRecordsWithAllParams) ([]GetRecordsWithAllRow, error) {
	rows, err := q.db.Query(ctx, getRecordsWithAll,
		arg.WhereInRecordType,
		arg.InRecordType,
		arg.WhereLikeTitle,
		arg.SearchTitle,
		arg.WhereInOrganization,
		arg.InOrganization,
		arg.WhereInPostedBy,
		arg.InPostedBy,
		arg.WhereInLastEditedBy,
		arg.InLastEditedBy,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecordsWithAllRow{}
	for rows.Next() {
		var i GetRecordsWithAllRow
		if err := rows.Scan(
			&i.Record.TRecordsPkey,
			&i.Record.RecordID,
			&i.Record.RecordTypeID,
			&i.Record.Title,
			&i.Record.Body,
			&i.Record.OrganizationID,
			&i.Record.PostedBy,
			&i.Record.LastEditedBy,
			&i.Record.PostedAt,
			&i.Record.LastEditedAt,
			&i.RecordType.MRecordTypesPkey,
			&i.RecordType.RecordTypeID,
			&i.RecordType.Name,
			&i.RecordType.Key,
			&i.Organization.MOrganizationsPkey,
			&i.Organization.OrganizationID,
			&i.Organization.Name,
			&i.Organization.Description,
			&i.Organization.Color,
			&i.Organization.IsPersonal,
			&i.Organization.IsWhole,
			&i.Organization.CreatedAt,
			&i.Organization.UpdatedAt,
			&i.Organization.ChatRoomID,
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageID,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
			&i.Member_2.MMembersPkey,
			&i.Member_2.MemberID,
			&i.Member_2.LoginID,
			&i.Member_2.Password,
			&i.Member_2.Email,
			&i.Member_2.Name,
			&i.Member_2.AttendStatusID,
			&i.Member_2.ProfileImageID,
			&i.Member_2.GradeID,
			&i.Member_2.GroupID,
			&i.Member_2.PersonalOrganizationID,
			&i.Member_2.RoleID,
			&i.Member_2.CreatedAt,
			&i.Member_2.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecordsWithAllUseKeysetPaginate = `-- name: GetRecordsWithAllUseKeysetPaginate :many
SELECT t_records.t_records_pkey, t_records.record_id, t_records.record_type_id, t_records.title, t_records.body, t_records.organization_id, t_records.posted_by, t_records.last_edited_by, t_records.posted_at, t_records.last_edited_at, m_record_types.m_record_types_pkey, m_record_types.record_type_id, m_record_types.name, m_record_types.key, m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.color, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at, m_organizations.chat_room_id, m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at FROM t_records
LEFT JOIN m_record_types ON t_records.record_type_id = m_record_types.record_type_id
LEFT JOIN m_organizations ON t_records.organization_id = m_organizations.organization_id
LEFT JOIN m_members ON t_records.posted_by = m_members.member_id
LEFT JOIN m_members AS m_members_2 ON t_records.last_edited_by = m_members_2.member_id
WHERE
	CASE WHEN $2::boolean = true THEN t_records.record_type_id = ANY($3) ELSE TRUE END
AND
	CASE WHEN $4::boolean = true THEN title LIKE '%' || $5::text || '%' ELSE TRUE END
AND
	CASE WHEN $6::boolean = true THEN t_records.organization_id = ANY($7) ELSE TRUE END
AND
	CASE WHEN $8::boolean = true THEN t_records.posted_by = ANY($9) ELSE TRUE END
AND
	CASE WHEN $10::boolean = true THEN t_records.last_edited_by = ANY($11) ELSE TRUE END
AND
	CASE $12::text
		WHEN 'next' THEN
			CASE $13::text
				WHEN 'title' THEN title > $14 OR (title = $14 AND t_records_pkey > $15::int)
				WHEN 'r_title' THEN title < $14 OR (title = $14 AND t_records_pkey > $15::int)
				WHEN 'posted_at' THEN posted_at > $16 OR (posted_at = $16 AND t_records_pkey > $15::int)
				WHEN 'r_posted_at' THEN posted_at < $16 OR (posted_at = $16 AND t_records_pkey > $15::int)
				WHEN 'last_edited_at' THEN last_edited_at > $17 OR (last_edited_at = $17 AND t_records_pkey > $15::int)
				WHEN 'r_last_edited_at' THEN last_edited_at < $17 OR (last_edited_at = $17 AND t_records_pkey > $15::int)
				ELSE t_records_pkey > $15::int
			END
		WHEN 'prev' THEN
			CASE $13::text
				WHEN 'title' THEN title < $14 OR (title = $14 AND t_records_pkey < $15::int)
				WHEN 'r_title' THEN title > $14 OR (title = $14 AND t_records_pkey < $15::int)
				WHEN 'posted_at' THEN posted_at < $16 OR (posted_at = $16 AND t_records_pkey < $15::int)
				WHEN 'r_posted_at' THEN posted_at > $16 OR (posted_at = $16 AND t_records_pkey < $15::int)
				WHEN 'last_edited_at' THEN last_edited_at < $17 OR (last_edited_at = $17 AND t_records_pkey < $15::int)
				WHEN 'r_last_edited_at' THEN last_edited_at > $17 OR (last_edited_at = $17 AND t_records_pkey < $15::int)
				ELSE t_records_pkey < $15::int
			END
	END
ORDER BY
	CASE WHEN $13::text = 'title' AND $12::text = 'next' THEN title END ASC,
	CASE WHEN $13::text = 'title' AND $12::text = 'prev' THEN title END DESC,
	CASE WHEN $13::text = 'r_title' AND $12::text = 'next' THEN title END DESC,
	CASE WHEN $13::text = 'r_title' AND $12::text = 'prev' THEN title END ASC,
	CASE WHEN $13::text = 'posted_at' AND $12::text = 'next' THEN posted_at END ASC,
	CASE WHEN $13::text = 'posted_at' AND $12::text = 'prev' THEN posted_at END DESC,
	CASE WHEN $13::text = 'r_posted_at' AND $12::text = 'next' THEN posted_at END DESC,
	CASE WHEN $13::text = 'r_posted_at' AND $12::text = 'prev' THEN posted_at END ASC,
	CASE WHEN $13::text = 'last_edited_at' AND $12::text = 'next' THEN last_edited_at END ASC,
	CASE WHEN $13::text = 'last_edited_at' AND $12::text = 'prev' THEN last_edited_at END DESC,
	CASE WHEN $13::text = 'r_last_edited_at' AND $12::text = 'next' THEN last_edited_at END DESC,
	CASE WHEN $13::text = 'r_last_edited_at' AND $12::text = 'prev' THEN last_edited_at END ASC,
	CASE WHEN $12::text = 'next' THEN t_records_pkey END ASC,
	CASE WHEN $12::text = 'prev' THEN t_records_pkey END DESC
LIMIT $1
`

type GetRecordsWithAllUseKeysetPaginateParams struct {
	Limit               int32       `json:"limit"`
	WhereInRecordType   bool        `json:"where_in_record_type"`
	InRecordType        uuid.UUID   `json:"in_record_type"`
	WhereLikeTitle      bool        `json:"where_like_title"`
	SearchTitle         string      `json:"search_title"`
	WhereInOrganization bool        `json:"where_in_organization"`
	InOrganization      pgtype.UUID `json:"in_organization"`
	WhereInPostedBy     bool        `json:"where_in_posted_by"`
	InPostedBy          pgtype.UUID `json:"in_posted_by"`
	WhereInLastEditedBy bool        `json:"where_in_last_edited_by"`
	InLastEditedBy      pgtype.UUID `json:"in_last_edited_by"`
	CursorDirection     string      `json:"cursor_direction"`
	OrderMethod         string      `json:"order_method"`
	TitleCursor         string      `json:"title_cursor"`
	Cursor              int32       `json:"cursor"`
	PostedAtCursor      time.Time   `json:"posted_at_cursor"`
	LastEditedAtCursor  time.Time   `json:"last_edited_at_cursor"`
}

type GetRecordsWithAllUseKeysetPaginateRow struct {
	Record       Record       `json:"record"`
	RecordType   RecordType   `json:"record_type"`
	Organization Organization `json:"organization"`
	Member       Member       `json:"member"`
	Member_2     Member       `json:"member_2"`
}

func (q *Queries) GetRecordsWithAllUseKeysetPaginate(ctx context.Context, arg GetRecordsWithAllUseKeysetPaginateParams) ([]GetRecordsWithAllUseKeysetPaginateRow, error) {
	rows, err := q.db.Query(ctx, getRecordsWithAllUseKeysetPaginate,
		arg.Limit,
		arg.WhereInRecordType,
		arg.InRecordType,
		arg.WhereLikeTitle,
		arg.SearchTitle,
		arg.WhereInOrganization,
		arg.InOrganization,
		arg.WhereInPostedBy,
		arg.InPostedBy,
		arg.WhereInLastEditedBy,
		arg.InLastEditedBy,
		arg.CursorDirection,
		arg.OrderMethod,
		arg.TitleCursor,
		arg.Cursor,
		arg.PostedAtCursor,
		arg.LastEditedAtCursor,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecordsWithAllUseKeysetPaginateRow{}
	for rows.Next() {
		var i GetRecordsWithAllUseKeysetPaginateRow
		if err := rows.Scan(
			&i.Record.TRecordsPkey,
			&i.Record.RecordID,
			&i.Record.RecordTypeID,
			&i.Record.Title,
			&i.Record.Body,
			&i.Record.OrganizationID,
			&i.Record.PostedBy,
			&i.Record.LastEditedBy,
			&i.Record.PostedAt,
			&i.Record.LastEditedAt,
			&i.RecordType.MRecordTypesPkey,
			&i.RecordType.RecordTypeID,
			&i.RecordType.Name,
			&i.RecordType.Key,
			&i.Organization.MOrganizationsPkey,
			&i.Organization.OrganizationID,
			&i.Organization.Name,
			&i.Organization.Description,
			&i.Organization.Color,
			&i.Organization.IsPersonal,
			&i.Organization.IsWhole,
			&i.Organization.CreatedAt,
			&i.Organization.UpdatedAt,
			&i.Organization.ChatRoomID,
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageID,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
			&i.Member_2.MMembersPkey,
			&i.Member_2.MemberID,
			&i.Member_2.LoginID,
			&i.Member_2.Password,
			&i.Member_2.Email,
			&i.Member_2.Name,
			&i.Member_2.AttendStatusID,
			&i.Member_2.ProfileImageID,
			&i.Member_2.GradeID,
			&i.Member_2.GroupID,
			&i.Member_2.PersonalOrganizationID,
			&i.Member_2.RoleID,
			&i.Member_2.CreatedAt,
			&i.Member_2.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecordsWithAllUseNumberedPaginate = `-- name: GetRecordsWithAllUseNumberedPaginate :many
SELECT t_records.t_records_pkey, t_records.record_id, t_records.record_type_id, t_records.title, t_records.body, t_records.organization_id, t_records.posted_by, t_records.last_edited_by, t_records.posted_at, t_records.last_edited_at, m_record_types.m_record_types_pkey, m_record_types.record_type_id, m_record_types.name, m_record_types.key, m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.color, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at, m_organizations.chat_room_id, m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at FROM t_records
LEFT JOIN m_record_types ON t_records.record_type_id = m_record_types.record_type_id
LEFT JOIN m_organizations ON t_records.organization_id = m_organizations.organization_id
LEFT JOIN m_members ON t_records.posted_by = m_members.member_id
LEFT JOIN m_members AS m_members_2 ON t_records.last_edited_by = m_members_2.member_id
WHERE
	CASE WHEN $3::boolean = true THEN t_records.record_type_id = ANY($4) ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN title LIKE '%' || $6::text || '%' ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN t_records.organization_id = ANY($8) ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN t_records.posted_by = ANY($10) ELSE TRUE END
AND
	CASE WHEN $11::boolean = true THEN t_records.last_edited_by = ANY($12) ELSE TRUE END
ORDER BY
	CASE WHEN $13::text = 'title' THEN title END ASC,
	CASE WHEN $13::text = 'r_title' THEN title END DESC,
	CASE WHEN $13::text = 'posted_at' THEN posted_at END ASC,
	CASE WHEN $13::text = 'r_posted_at' THEN posted_at END DESC,
	CASE WHEN $13::text = 'last_edited_at' THEN last_edited_at END ASC,
	CASE WHEN $13::text = 'r_last_edited_at' THEN last_edited_at END DESC,
	t_records_pkey ASC
LIMIT $1 OFFSET $2
`

type GetRecordsWithAllUseNumberedPaginateParams struct {
	Limit               int32       `json:"limit"`
	Offset              int32       `json:"offset"`
	WhereInRecordType   bool        `json:"where_in_record_type"`
	InRecordType        uuid.UUID   `json:"in_record_type"`
	WhereLikeTitle      bool        `json:"where_like_title"`
	SearchTitle         string      `json:"search_title"`
	WhereInOrganization bool        `json:"where_in_organization"`
	InOrganization      pgtype.UUID `json:"in_organization"`
	WhereInPostedBy     bool        `json:"where_in_posted_by"`
	InPostedBy          pgtype.UUID `json:"in_posted_by"`
	WhereInLastEditedBy bool        `json:"where_in_last_edited_by"`
	InLastEditedBy      pgtype.UUID `json:"in_last_edited_by"`
	OrderMethod         string      `json:"order_method"`
}

type GetRecordsWithAllUseNumberedPaginateRow struct {
	Record       Record       `json:"record"`
	RecordType   RecordType   `json:"record_type"`
	Organization Organization `json:"organization"`
	Member       Member       `json:"member"`
	Member_2     Member       `json:"member_2"`
}

func (q *Queries) GetRecordsWithAllUseNumberedPaginate(ctx context.Context, arg GetRecordsWithAllUseNumberedPaginateParams) ([]GetRecordsWithAllUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getRecordsWithAllUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.WhereInRecordType,
		arg.InRecordType,
		arg.WhereLikeTitle,
		arg.SearchTitle,
		arg.WhereInOrganization,
		arg.InOrganization,
		arg.WhereInPostedBy,
		arg.InPostedBy,
		arg.WhereInLastEditedBy,
		arg.InLastEditedBy,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecordsWithAllUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetRecordsWithAllUseNumberedPaginateRow
		if err := rows.Scan(
			&i.Record.TRecordsPkey,
			&i.Record.RecordID,
			&i.Record.RecordTypeID,
			&i.Record.Title,
			&i.Record.Body,
			&i.Record.OrganizationID,
			&i.Record.PostedBy,
			&i.Record.LastEditedBy,
			&i.Record.PostedAt,
			&i.Record.LastEditedAt,
			&i.RecordType.MRecordTypesPkey,
			&i.RecordType.RecordTypeID,
			&i.RecordType.Name,
			&i.RecordType.Key,
			&i.Organization.MOrganizationsPkey,
			&i.Organization.OrganizationID,
			&i.Organization.Name,
			&i.Organization.Description,
			&i.Organization.Color,
			&i.Organization.IsPersonal,
			&i.Organization.IsWhole,
			&i.Organization.CreatedAt,
			&i.Organization.UpdatedAt,
			&i.Organization.ChatRoomID,
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageID,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
			&i.Member_2.MMembersPkey,
			&i.Member_2.MemberID,
			&i.Member_2.LoginID,
			&i.Member_2.Password,
			&i.Member_2.Email,
			&i.Member_2.Name,
			&i.Member_2.AttendStatusID,
			&i.Member_2.ProfileImageID,
			&i.Member_2.GradeID,
			&i.Member_2.GroupID,
			&i.Member_2.PersonalOrganizationID,
			&i.Member_2.RoleID,
			&i.Member_2.CreatedAt,
			&i.Member_2.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecordsWithLastEditedBy = `-- name: GetRecordsWithLastEditedBy :many
SELECT t_records.t_records_pkey, t_records.record_id, t_records.record_type_id, t_records.title, t_records.body, t_records.organization_id, t_records.posted_by, t_records.last_edited_by, t_records.posted_at, t_records.last_edited_at, m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at FROM t_records
LEFT JOIN m_members ON t_records.last_edited_by = m_members.member_id
WHERE
	CASE WHEN $1::boolean = true THEN record_type_id = ANY($2) ELSE TRUE END
AND
	CASE WHEN $3::boolean = true THEN title LIKE '%' || $4::text || '%' ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN organization_id = ANY($6) ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN posted_by = ANY($8) ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN t_records.last_edited_by = ANY($10) ELSE TRUE END
ORDER BY
	CASE WHEN $11::text = 'title' THEN title END ASC,
	CASE WHEN $11::text = 'r_title' THEN title END DESC,
	CASE WHEN $11::text = 'posted_at' THEN posted_at END ASC,
	CASE WHEN $11::text = 'r_posted_at' THEN posted_at END DESC,
	CASE WHEN $11::text = 'last_edited_at' THEN last_edited_at END ASC,
	CASE WHEN $11::text = 'r_last_edited_at' THEN last_edited_at END DESC,
	t_records_pkey ASC
`

type GetRecordsWithLastEditedByParams struct {
	WhereInRecordType   bool        `json:"where_in_record_type"`
	InRecordType        uuid.UUID   `json:"in_record_type"`
	WhereLikeTitle      bool        `json:"where_like_title"`
	SearchTitle         string      `json:"search_title"`
	WhereInOrganization bool        `json:"where_in_organization"`
	InOrganization      pgtype.UUID `json:"in_organization"`
	WhereInPostedBy     bool        `json:"where_in_posted_by"`
	InPostedBy          pgtype.UUID `json:"in_posted_by"`
	WhereInLastEditedBy bool        `json:"where_in_last_edited_by"`
	InLastEditedBy      pgtype.UUID `json:"in_last_edited_by"`
	OrderMethod         string      `json:"order_method"`
}

type GetRecordsWithLastEditedByRow struct {
	Record Record `json:"record"`
	Member Member `json:"member"`
}

func (q *Queries) GetRecordsWithLastEditedBy(ctx context.Context, arg GetRecordsWithLastEditedByParams) ([]GetRecordsWithLastEditedByRow, error) {
	rows, err := q.db.Query(ctx, getRecordsWithLastEditedBy,
		arg.WhereInRecordType,
		arg.InRecordType,
		arg.WhereLikeTitle,
		arg.SearchTitle,
		arg.WhereInOrganization,
		arg.InOrganization,
		arg.WhereInPostedBy,
		arg.InPostedBy,
		arg.WhereInLastEditedBy,
		arg.InLastEditedBy,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecordsWithLastEditedByRow{}
	for rows.Next() {
		var i GetRecordsWithLastEditedByRow
		if err := rows.Scan(
			&i.Record.TRecordsPkey,
			&i.Record.RecordID,
			&i.Record.RecordTypeID,
			&i.Record.Title,
			&i.Record.Body,
			&i.Record.OrganizationID,
			&i.Record.PostedBy,
			&i.Record.LastEditedBy,
			&i.Record.PostedAt,
			&i.Record.LastEditedAt,
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageID,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecordsWithLastEditedByUseKeysetPaginate = `-- name: GetRecordsWithLastEditedByUseKeysetPaginate :many
SELECT t_records.t_records_pkey, t_records.record_id, t_records.record_type_id, t_records.title, t_records.body, t_records.organization_id, t_records.posted_by, t_records.last_edited_by, t_records.posted_at, t_records.last_edited_at, m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at FROM t_records
LEFT JOIN m_members ON t_records.last_edited_by = m_members.member_id
WHERE
	CASE WHEN $2::boolean = true THEN record_type_id = ANY($3) ELSE TRUE END
AND
	CASE WHEN $4::boolean = true THEN title LIKE '%' || $5::text || '%' ELSE TRUE END
AND
	CASE WHEN $6::boolean = true THEN organization_id = ANY($7) ELSE TRUE END
AND
	CASE WHEN $8::boolean = true THEN posted_by = ANY($9) ELSE TRUE END
AND
	CASE WHEN $10::boolean = true THEN t_records.last_edited_by = ANY($11) ELSE TRUE END
AND
	CASE $12::text
		WHEN 'next' THEN
			CASE $13::text
				WHEN 'title' THEN title > $14 OR (title = $14 AND t_records_pkey > $15::int)
				WHEN 'r_title' THEN title < $14 OR (title = $14 AND t_records_pkey > $15::int)
				WHEN 'posted_at' THEN posted_at > $16 OR (posted_at = $16 AND t_records_pkey > $15::int)
				WHEN 'r_posted_at' THEN posted_at < $16 OR (posted_at = $16 AND t_records_pkey > $15::int)
				WHEN 'last_edited_at' THEN last_edited_at > $17 OR (last_edited_at = $17 AND t_records_pkey > $15::int)
				WHEN 'r_last_edited_at' THEN last_edited_at < $17 OR (last_edited_at = $17 AND t_records_pkey > $15::int)
				ELSE t_records_pkey > $15::int
			END
		WHEN 'prev' THEN
			CASE $13::text
				WHEN 'title' THEN title < $14 OR (title = $14 AND t_records_pkey < $15::int)
				WHEN 'r_title' THEN title > $14 OR (title = $14 AND t_records_pkey < $15::int)
				WHEN 'posted_at' THEN posted_at < $16 OR (posted_at = $16 AND t_records_pkey < $15::int)
				WHEN 'r_posted_at' THEN posted_at > $16 OR (posted_at = $16 AND t_records_pkey < $15::int)
				WHEN 'last_edited_at' THEN last_edited_at < $17 OR (last_edited_at = $17 AND t_records_pkey < $15::int)
				WHEN 'r_last_edited_at' THEN last_edited_at > $17 OR (last_edited_at = $17 AND t_records_pkey < $15::int)
				ELSE t_records_pkey < $15::int
			END
	END
ORDER BY
	CASE WHEN $13::text = 'title' AND $12::text = 'next' THEN title END ASC,
	CASE WHEN $13::text = 'title' AND $12::text = 'prev' THEN title END DESC,
	CASE WHEN $13::text = 'r_title' AND $12::text = 'next' THEN title END DESC,
	CASE WHEN $13::text = 'r_title' AND $12::text = 'prev' THEN title END ASC,
	CASE WHEN $13::text = 'posted_at' AND $12::text = 'next' THEN posted_at END ASC,
	CASE WHEN $13::text = 'posted_at' AND $12::text = 'prev' THEN posted_at END DESC,
	CASE WHEN $13::text = 'r_posted_at' AND $12::text = 'next' THEN posted_at END DESC,
	CASE WHEN $13::text = 'r_posted_at' AND $12::text = 'prev' THEN posted_at END ASC,
	CASE WHEN $13::text = 'last_edited_at' AND $12::text = 'next' THEN last_edited_at END ASC,
	CASE WHEN $13::text = 'last_edited_at' AND $12::text = 'prev' THEN last_edited_at END DESC,
	CASE WHEN $13::text = 'r_last_edited_at' AND $12::text = 'next' THEN last_edited_at END DESC,
	CASE WHEN $13::text = 'r_last_edited_at' AND $12::text = 'prev' THEN last_edited_at END ASC,
	CASE WHEN $12::text = 'next' THEN t_records_pkey END ASC,
	CASE WHEN $12::text = 'prev' THEN t_records_pkey END DESC
LIMIT $1
`

type GetRecordsWithLastEditedByUseKeysetPaginateParams struct {
	Limit               int32       `json:"limit"`
	WhereInRecordType   bool        `json:"where_in_record_type"`
	InRecordType        uuid.UUID   `json:"in_record_type"`
	WhereLikeTitle      bool        `json:"where_like_title"`
	SearchTitle         string      `json:"search_title"`
	WhereInOrganization bool        `json:"where_in_organization"`
	InOrganization      pgtype.UUID `json:"in_organization"`
	WhereInPostedBy     bool        `json:"where_in_posted_by"`
	InPostedBy          pgtype.UUID `json:"in_posted_by"`
	WhereInLastEditedBy bool        `json:"where_in_last_edited_by"`
	InLastEditedBy      pgtype.UUID `json:"in_last_edited_by"`
	CursorDirection     string      `json:"cursor_direction"`
	OrderMethod         string      `json:"order_method"`
	TitleCursor         string      `json:"title_cursor"`
	Cursor              int32       `json:"cursor"`
	PostedAtCursor      time.Time   `json:"posted_at_cursor"`
	LastEditedAtCursor  time.Time   `json:"last_edited_at_cursor"`
}

type GetRecordsWithLastEditedByUseKeysetPaginateRow struct {
	Record Record `json:"record"`
	Member Member `json:"member"`
}

func (q *Queries) GetRecordsWithLastEditedByUseKeysetPaginate(ctx context.Context, arg GetRecordsWithLastEditedByUseKeysetPaginateParams) ([]GetRecordsWithLastEditedByUseKeysetPaginateRow, error) {
	rows, err := q.db.Query(ctx, getRecordsWithLastEditedByUseKeysetPaginate,
		arg.Limit,
		arg.WhereInRecordType,
		arg.InRecordType,
		arg.WhereLikeTitle,
		arg.SearchTitle,
		arg.WhereInOrganization,
		arg.InOrganization,
		arg.WhereInPostedBy,
		arg.InPostedBy,
		arg.WhereInLastEditedBy,
		arg.InLastEditedBy,
		arg.CursorDirection,
		arg.OrderMethod,
		arg.TitleCursor,
		arg.Cursor,
		arg.PostedAtCursor,
		arg.LastEditedAtCursor,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecordsWithLastEditedByUseKeysetPaginateRow{}
	for rows.Next() {
		var i GetRecordsWithLastEditedByUseKeysetPaginateRow
		if err := rows.Scan(
			&i.Record.TRecordsPkey,
			&i.Record.RecordID,
			&i.Record.RecordTypeID,
			&i.Record.Title,
			&i.Record.Body,
			&i.Record.OrganizationID,
			&i.Record.PostedBy,
			&i.Record.LastEditedBy,
			&i.Record.PostedAt,
			&i.Record.LastEditedAt,
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageID,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecordsWithLastEditedByUseNumberedPaginate = `-- name: GetRecordsWithLastEditedByUseNumberedPaginate :many
SELECT t_records.t_records_pkey, t_records.record_id, t_records.record_type_id, t_records.title, t_records.body, t_records.organization_id, t_records.posted_by, t_records.last_edited_by, t_records.posted_at, t_records.last_edited_at, m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at FROM t_records
LEFT JOIN m_members ON t_records.last_edited_by = m_members.member_id
WHERE
	CASE WHEN $3::boolean = true THEN record_type_id = ANY($4) ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN title LIKE '%' || $6::text || '%' ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN organization_id = ANY($8) ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN posted_by = ANY($10) ELSE TRUE END
AND
	CASE WHEN $11::boolean = true THEN t_records.last_edited_by = ANY($12) ELSE TRUE END
ORDER BY
	CASE WHEN $13::text = 'title' THEN title END ASC,
	CASE WHEN $13::text = 'r_title' THEN title END DESC,
	CASE WHEN $13::text = 'posted_at' THEN posted_at END ASC,
	CASE WHEN $13::text = 'r_posted_at' THEN posted_at END DESC,
	CASE WHEN $13::text = 'last_edited_at' THEN last_edited_at END ASC,
	CASE WHEN $13::text = 'r_last_edited_at' THEN last_edited_at END DESC,
	t_records_pkey ASC
LIMIT $1 OFFSET $2
`

type GetRecordsWithLastEditedByUseNumberedPaginateParams struct {
	Limit               int32       `json:"limit"`
	Offset              int32       `json:"offset"`
	WhereInRecordType   bool        `json:"where_in_record_type"`
	InRecordType        uuid.UUID   `json:"in_record_type"`
	WhereLikeTitle      bool        `json:"where_like_title"`
	SearchTitle         string      `json:"search_title"`
	WhereInOrganization bool        `json:"where_in_organization"`
	InOrganization      pgtype.UUID `json:"in_organization"`
	WhereInPostedBy     bool        `json:"where_in_posted_by"`
	InPostedBy          pgtype.UUID `json:"in_posted_by"`
	WhereInLastEditedBy bool        `json:"where_in_last_edited_by"`
	InLastEditedBy      pgtype.UUID `json:"in_last_edited_by"`
	OrderMethod         string      `json:"order_method"`
}

type GetRecordsWithLastEditedByUseNumberedPaginateRow struct {
	Record Record `json:"record"`
	Member Member `json:"member"`
}

func (q *Queries) GetRecordsWithLastEditedByUseNumberedPaginate(ctx context.Context, arg GetRecordsWithLastEditedByUseNumberedPaginateParams) ([]GetRecordsWithLastEditedByUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getRecordsWithLastEditedByUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.WhereInRecordType,
		arg.InRecordType,
		arg.WhereLikeTitle,
		arg.SearchTitle,
		arg.WhereInOrganization,
		arg.InOrganization,
		arg.WhereInPostedBy,
		arg.InPostedBy,
		arg.WhereInLastEditedBy,
		arg.InLastEditedBy,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecordsWithLastEditedByUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetRecordsWithLastEditedByUseNumberedPaginateRow
		if err := rows.Scan(
			&i.Record.TRecordsPkey,
			&i.Record.RecordID,
			&i.Record.RecordTypeID,
			&i.Record.Title,
			&i.Record.Body,
			&i.Record.OrganizationID,
			&i.Record.PostedBy,
			&i.Record.LastEditedBy,
			&i.Record.PostedAt,
			&i.Record.LastEditedAt,
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageID,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecordsWithOrganization = `-- name: GetRecordsWithOrganization :many
SELECT t_records.t_records_pkey, t_records.record_id, t_records.record_type_id, t_records.title, t_records.body, t_records.organization_id, t_records.posted_by, t_records.last_edited_by, t_records.posted_at, t_records.last_edited_at, m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.color, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at, m_organizations.chat_room_id FROM t_records
LEFT JOIN m_organizations ON t_records.organization_id = m_organizations.organization_id
WHERE
	CASE WHEN $1::boolean = true THEN record_type_id = ANY($2) ELSE TRUE END
AND
	CASE WHEN $3::boolean = true THEN title LIKE '%' || $4::text || '%' ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN t_records.organization_id = ANY($6) ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN posted_by = ANY($8) ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN last_edited_by = ANY($10) ELSE TRUE END
ORDER BY
	CASE WHEN $11::text = 'title' THEN title END ASC,
	CASE WHEN $11::text = 'r_title' THEN title END DESC,
	CASE WHEN $11::text = 'posted_at' THEN posted_at END ASC,
	CASE WHEN $11::text = 'r_posted_at' THEN posted_at END DESC,
	CASE WHEN $11::text = 'last_edited_at' THEN last_edited_at END ASC,
	CASE WHEN $11::text = 'r_last_edited_at' THEN last_edited_at END DESC,
	t_records_pkey ASC
`

type GetRecordsWithOrganizationParams struct {
	WhereInRecordType   bool        `json:"where_in_record_type"`
	InRecordType        uuid.UUID   `json:"in_record_type"`
	WhereLikeTitle      bool        `json:"where_like_title"`
	SearchTitle         string      `json:"search_title"`
	WhereInOrganization bool        `json:"where_in_organization"`
	InOrganization      pgtype.UUID `json:"in_organization"`
	WhereInPostedBy     bool        `json:"where_in_posted_by"`
	InPostedBy          pgtype.UUID `json:"in_posted_by"`
	WhereInLastEditedBy bool        `json:"where_in_last_edited_by"`
	InLastEditedBy      pgtype.UUID `json:"in_last_edited_by"`
	OrderMethod         string      `json:"order_method"`
}

type GetRecordsWithOrganizationRow struct {
	Record       Record       `json:"record"`
	Organization Organization `json:"organization"`
}

func (q *Queries) GetRecordsWithOrganization(ctx context.Context, arg GetRecordsWithOrganizationParams) ([]GetRecordsWithOrganizationRow, error) {
	rows, err := q.db.Query(ctx, getRecordsWithOrganization,
		arg.WhereInRecordType,
		arg.InRecordType,
		arg.WhereLikeTitle,
		arg.SearchTitle,
		arg.WhereInOrganization,
		arg.InOrganization,
		arg.WhereInPostedBy,
		arg.InPostedBy,
		arg.WhereInLastEditedBy,
		arg.InLastEditedBy,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecordsWithOrganizationRow{}
	for rows.Next() {
		var i GetRecordsWithOrganizationRow
		if err := rows.Scan(
			&i.Record.TRecordsPkey,
			&i.Record.RecordID,
			&i.Record.RecordTypeID,
			&i.Record.Title,
			&i.Record.Body,
			&i.Record.OrganizationID,
			&i.Record.PostedBy,
			&i.Record.LastEditedBy,
			&i.Record.PostedAt,
			&i.Record.LastEditedAt,
			&i.Organization.MOrganizationsPkey,
			&i.Organization.OrganizationID,
			&i.Organization.Name,
			&i.Organization.Description,
			&i.Organization.Color,
			&i.Organization.IsPersonal,
			&i.Organization.IsWhole,
			&i.Organization.CreatedAt,
			&i.Organization.UpdatedAt,
			&i.Organization.ChatRoomID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecordsWithOrganizationUseKeysetPaginate = `-- name: GetRecordsWithOrganizationUseKeysetPaginate :many
SELECT t_records.t_records_pkey, t_records.record_id, t_records.record_type_id, t_records.title, t_records.body, t_records.organization_id, t_records.posted_by, t_records.last_edited_by, t_records.posted_at, t_records.last_edited_at, m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.color, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at, m_organizations.chat_room_id FROM t_records
LEFT JOIN m_organizations ON t_records.organization_id = m_organizations.organization_id
WHERE
	CASE WHEN $2::boolean = true THEN record_type_id = ANY($3) ELSE TRUE END
AND
	CASE WHEN $4::boolean = true THEN title LIKE '%' || $5::text || '%' ELSE TRUE END
AND
	CASE WHEN $6::boolean = true THEN t_records.organization_id = ANY($7) ELSE TRUE END
AND
	CASE WHEN $8::boolean = true THEN posted_by = ANY($9) ELSE TRUE END
AND
	CASE WHEN $10::boolean = true THEN last_edited_by = ANY($11) ELSE TRUE END
AND
	CASE $12::text
		WHEN 'next' THEN
			CASE $13::text
				WHEN 'title' THEN title > $14 OR (title = $14 AND t_records_pkey > $15::int)
				WHEN 'r_title' THEN title < $14 OR (title = $14 AND t_records_pkey > $15::int)
				WHEN 'posted_at' THEN posted_at > $16 OR (posted_at = $16 AND t_records_pkey > $15::int)
				WHEN 'r_posted_at' THEN posted_at < $16 OR (posted_at = $16 AND t_records_pkey > $15::int)
				WHEN 'last_edited_at' THEN last_edited_at > $17 OR (last_edited_at = $17 AND t_records_pkey > $15::int)
				WHEN 'r_last_edited_at' THEN last_edited_at < $17 OR (last_edited_at = $17 AND t_records_pkey > $15::int)
				ELSE t_records_pkey > $15::int
			END
		WHEN 'prev' THEN
			CASE $13::text
				WHEN 'title' THEN title < $14 OR (title = $14 AND t_records_pkey < $15::int)
				WHEN 'r_title' THEN title > $14 OR (title = $14 AND t_records_pkey < $15::int)
				WHEN 'posted_at' THEN posted_at < $16 OR (posted_at = $16 AND t_records_pkey < $15::int)
				WHEN 'r_posted_at' THEN posted_at > $16 OR (posted_at = $16 AND t_records_pkey < $15::int)
				WHEN 'last_edited_at' THEN last_edited_at < $17 OR (last_edited_at = $17 AND t_records_pkey < $15::int)
				WHEN 'r_last_edited_at' THEN last_edited_at > $17 OR (last_edited_at = $17 AND t_records_pkey < $15::int)
				ELSE t_records_pkey < $15::int
			END
	END
ORDER BY
	CASE WHEN $13::text = 'title' AND $12::text = 'next' THEN title END ASC,
	CASE WHEN $13::text = 'title' AND $12::text = 'prev' THEN title END DESC,
	CASE WHEN $13::text = 'r_title' AND $12::text = 'next' THEN title END DESC,
	CASE WHEN $13::text = 'r_title' AND $12::text = 'prev' THEN title END ASC,
	CASE WHEN $13::text = 'posted_at' AND $12::text = 'next' THEN posted_at END ASC,
	CASE WHEN $13::text = 'posted_at' AND $12::text = 'prev' THEN posted_at END DESC,
	CASE WHEN $13::text = 'r_posted_at' AND $12::text = 'next' THEN posted_at END DESC,
	CASE WHEN $13::text = 'r_posted_at' AND $12::text = 'prev' THEN posted_at END ASC,
	CASE WHEN $13::text = 'last_edited_at' AND $12::text = 'next' THEN last_edited_at END ASC,
	CASE WHEN $13::text = 'last_edited_at' AND $12::text = 'prev' THEN last_edited_at END DESC,
	CASE WHEN $13::text = 'r_last_edited_at' AND $12::text = 'next' THEN last_edited_at END DESC,
	CASE WHEN $13::text = 'r_last_edited_at' AND $12::text = 'prev' THEN last_edited_at END ASC,
	CASE WHEN $12::text = 'next' THEN t_records_pkey END ASC,
	CASE WHEN $12::text = 'prev' THEN t_records_pkey END DESC
LIMIT $1
`

type GetRecordsWithOrganizationUseKeysetPaginateParams struct {
	Limit               int32       `json:"limit"`
	WhereInRecordType   bool        `json:"where_in_record_type"`
	InRecordType        uuid.UUID   `json:"in_record_type"`
	WhereLikeTitle      bool        `json:"where_like_title"`
	SearchTitle         string      `json:"search_title"`
	WhereInOrganization bool        `json:"where_in_organization"`
	InOrganization      pgtype.UUID `json:"in_organization"`
	WhereInPostedBy     bool        `json:"where_in_posted_by"`
	InPostedBy          pgtype.UUID `json:"in_posted_by"`
	WhereInLastEditedBy bool        `json:"where_in_last_edited_by"`
	InLastEditedBy      pgtype.UUID `json:"in_last_edited_by"`
	CursorDirection     string      `json:"cursor_direction"`
	OrderMethod         string      `json:"order_method"`
	TitleCursor         string      `json:"title_cursor"`
	Cursor              int32       `json:"cursor"`
	PostedAtCursor      time.Time   `json:"posted_at_cursor"`
	LastEditedAtCursor  time.Time   `json:"last_edited_at_cursor"`
}

type GetRecordsWithOrganizationUseKeysetPaginateRow struct {
	Record       Record       `json:"record"`
	Organization Organization `json:"organization"`
}

func (q *Queries) GetRecordsWithOrganizationUseKeysetPaginate(ctx context.Context, arg GetRecordsWithOrganizationUseKeysetPaginateParams) ([]GetRecordsWithOrganizationUseKeysetPaginateRow, error) {
	rows, err := q.db.Query(ctx, getRecordsWithOrganizationUseKeysetPaginate,
		arg.Limit,
		arg.WhereInRecordType,
		arg.InRecordType,
		arg.WhereLikeTitle,
		arg.SearchTitle,
		arg.WhereInOrganization,
		arg.InOrganization,
		arg.WhereInPostedBy,
		arg.InPostedBy,
		arg.WhereInLastEditedBy,
		arg.InLastEditedBy,
		arg.CursorDirection,
		arg.OrderMethod,
		arg.TitleCursor,
		arg.Cursor,
		arg.PostedAtCursor,
		arg.LastEditedAtCursor,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecordsWithOrganizationUseKeysetPaginateRow{}
	for rows.Next() {
		var i GetRecordsWithOrganizationUseKeysetPaginateRow
		if err := rows.Scan(
			&i.Record.TRecordsPkey,
			&i.Record.RecordID,
			&i.Record.RecordTypeID,
			&i.Record.Title,
			&i.Record.Body,
			&i.Record.OrganizationID,
			&i.Record.PostedBy,
			&i.Record.LastEditedBy,
			&i.Record.PostedAt,
			&i.Record.LastEditedAt,
			&i.Organization.MOrganizationsPkey,
			&i.Organization.OrganizationID,
			&i.Organization.Name,
			&i.Organization.Description,
			&i.Organization.Color,
			&i.Organization.IsPersonal,
			&i.Organization.IsWhole,
			&i.Organization.CreatedAt,
			&i.Organization.UpdatedAt,
			&i.Organization.ChatRoomID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecordsWithOrganizationUseNumberedPaginate = `-- name: GetRecordsWithOrganizationUseNumberedPaginate :many
SELECT t_records.t_records_pkey, t_records.record_id, t_records.record_type_id, t_records.title, t_records.body, t_records.organization_id, t_records.posted_by, t_records.last_edited_by, t_records.posted_at, t_records.last_edited_at, m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.color, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at, m_organizations.chat_room_id FROM t_records
LEFT JOIN m_organizations ON t_records.organization_id = m_organizations.organization_id
WHERE
	CASE WHEN $3::boolean = true THEN record_type_id = ANY($4) ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN title LIKE '%' || $6::text || '%' ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN t_records.organization_id = ANY($8) ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN posted_by = ANY($10) ELSE TRUE END
AND
	CASE WHEN $11::boolean = true THEN last_edited_by = ANY($12) ELSE TRUE END
ORDER BY
	CASE WHEN $13::text = 'title' THEN title END ASC,
	CASE WHEN $13::text = 'r_title' THEN title END DESC,
	CASE WHEN $13::text = 'posted_at' THEN posted_at END ASC,
	CASE WHEN $13::text = 'r_posted_at' THEN posted_at END DESC,
	CASE WHEN $13::text = 'last_edited_at' THEN last_edited_at END ASC,
	CASE WHEN $13::text = 'r_last_edited_at' THEN last_edited_at END DESC,
	t_records_pkey ASC
LIMIT $1 OFFSET $2
`

type GetRecordsWithOrganizationUseNumberedPaginateParams struct {
	Limit               int32       `json:"limit"`
	Offset              int32       `json:"offset"`
	WhereInRecordType   bool        `json:"where_in_record_type"`
	InRecordType        uuid.UUID   `json:"in_record_type"`
	WhereLikeTitle      bool        `json:"where_like_title"`
	SearchTitle         string      `json:"search_title"`
	WhereInOrganization bool        `json:"where_in_organization"`
	InOrganization      pgtype.UUID `json:"in_organization"`
	WhereInPostedBy     bool        `json:"where_in_posted_by"`
	InPostedBy          pgtype.UUID `json:"in_posted_by"`
	WhereInLastEditedBy bool        `json:"where_in_last_edited_by"`
	InLastEditedBy      pgtype.UUID `json:"in_last_edited_by"`
	OrderMethod         string      `json:"order_method"`
}

type GetRecordsWithOrganizationUseNumberedPaginateRow struct {
	Record       Record       `json:"record"`
	Organization Organization `json:"organization"`
}

func (q *Queries) GetRecordsWithOrganizationUseNumberedPaginate(ctx context.Context, arg GetRecordsWithOrganizationUseNumberedPaginateParams) ([]GetRecordsWithOrganizationUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getRecordsWithOrganizationUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.WhereInRecordType,
		arg.InRecordType,
		arg.WhereLikeTitle,
		arg.SearchTitle,
		arg.WhereInOrganization,
		arg.InOrganization,
		arg.WhereInPostedBy,
		arg.InPostedBy,
		arg.WhereInLastEditedBy,
		arg.InLastEditedBy,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecordsWithOrganizationUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetRecordsWithOrganizationUseNumberedPaginateRow
		if err := rows.Scan(
			&i.Record.TRecordsPkey,
			&i.Record.RecordID,
			&i.Record.RecordTypeID,
			&i.Record.Title,
			&i.Record.Body,
			&i.Record.OrganizationID,
			&i.Record.PostedBy,
			&i.Record.LastEditedBy,
			&i.Record.PostedAt,
			&i.Record.LastEditedAt,
			&i.Organization.MOrganizationsPkey,
			&i.Organization.OrganizationID,
			&i.Organization.Name,
			&i.Organization.Description,
			&i.Organization.Color,
			&i.Organization.IsPersonal,
			&i.Organization.IsWhole,
			&i.Organization.CreatedAt,
			&i.Organization.UpdatedAt,
			&i.Organization.ChatRoomID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecordsWithPostedBy = `-- name: GetRecordsWithPostedBy :many
SELECT t_records.t_records_pkey, t_records.record_id, t_records.record_type_id, t_records.title, t_records.body, t_records.organization_id, t_records.posted_by, t_records.last_edited_by, t_records.posted_at, t_records.last_edited_at, m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at FROM t_records
LEFT JOIN m_members ON t_records.posted_by = m_members.member_id
WHERE
	CASE WHEN $1::boolean = true THEN record_type_id = ANY($2) ELSE TRUE END
AND
	CASE WHEN $3::boolean = true THEN title LIKE '%' || $4::text || '%' ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN organization_id = ANY($6) ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN t_records.posted_by = ANY($8) ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN last_edited_by = ANY($10) ELSE TRUE END
ORDER BY
	CASE WHEN $11::text = 'title' THEN title END ASC,
	CASE WHEN $11::text = 'r_title' THEN title END DESC,
	CASE WHEN $11::text = 'posted_at' THEN posted_at END ASC,
	CASE WHEN $11::text = 'r_posted_at' THEN posted_at END DESC,
	CASE WHEN $11::text = 'last_edited_at' THEN last_edited_at END ASC,
	CASE WHEN $11::text = 'r_last_edited_at' THEN last_edited_at END DESC,
	t_records_pkey ASC
`

type GetRecordsWithPostedByParams struct {
	WhereInRecordType   bool        `json:"where_in_record_type"`
	InRecordType        uuid.UUID   `json:"in_record_type"`
	WhereLikeTitle      bool        `json:"where_like_title"`
	SearchTitle         string      `json:"search_title"`
	WhereInOrganization bool        `json:"where_in_organization"`
	InOrganization      pgtype.UUID `json:"in_organization"`
	WhereInPostedBy     bool        `json:"where_in_posted_by"`
	InPostedBy          pgtype.UUID `json:"in_posted_by"`
	WhereInLastEditedBy bool        `json:"where_in_last_edited_by"`
	InLastEditedBy      pgtype.UUID `json:"in_last_edited_by"`
	OrderMethod         string      `json:"order_method"`
}

type GetRecordsWithPostedByRow struct {
	Record Record `json:"record"`
	Member Member `json:"member"`
}

func (q *Queries) GetRecordsWithPostedBy(ctx context.Context, arg GetRecordsWithPostedByParams) ([]GetRecordsWithPostedByRow, error) {
	rows, err := q.db.Query(ctx, getRecordsWithPostedBy,
		arg.WhereInRecordType,
		arg.InRecordType,
		arg.WhereLikeTitle,
		arg.SearchTitle,
		arg.WhereInOrganization,
		arg.InOrganization,
		arg.WhereInPostedBy,
		arg.InPostedBy,
		arg.WhereInLastEditedBy,
		arg.InLastEditedBy,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecordsWithPostedByRow{}
	for rows.Next() {
		var i GetRecordsWithPostedByRow
		if err := rows.Scan(
			&i.Record.TRecordsPkey,
			&i.Record.RecordID,
			&i.Record.RecordTypeID,
			&i.Record.Title,
			&i.Record.Body,
			&i.Record.OrganizationID,
			&i.Record.PostedBy,
			&i.Record.LastEditedBy,
			&i.Record.PostedAt,
			&i.Record.LastEditedAt,
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageID,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecordsWithPostedByUseKeysetPaginate = `-- name: GetRecordsWithPostedByUseKeysetPaginate :many
SELECT t_records.t_records_pkey, t_records.record_id, t_records.record_type_id, t_records.title, t_records.body, t_records.organization_id, t_records.posted_by, t_records.last_edited_by, t_records.posted_at, t_records.last_edited_at, m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at FROM t_records
LEFT JOIN m_members ON t_records.posted_by = m_members.member_id
WHERE
	CASE WHEN $2::boolean = true THEN record_type_id = ANY($3) ELSE TRUE END
AND
	CASE WHEN $4::boolean = true THEN title LIKE '%' || $5::text || '%' ELSE TRUE END
AND
	CASE WHEN $6::boolean = true THEN organization_id = ANY($7) ELSE TRUE END
AND
	CASE WHEN $8::boolean = true THEN t_records.posted_by = ANY($9) ELSE TRUE END
AND
	CASE WHEN $10::boolean = true THEN last_edited_by = ANY($11) ELSE TRUE END
AND
	CASE $12::text
		WHEN 'next' THEN
			CASE $13::text
				WHEN 'title' THEN title > $14 OR (title = $14 AND t_records_pkey > $15::int)
				WHEN 'r_title' THEN title < $14 OR (title = $14 AND t_records_pkey > $15::int)
				WHEN 'posted_at' THEN posted_at > $16 OR (posted_at = $16 AND t_records_pkey > $15::int)
				WHEN 'r_posted_at' THEN posted_at < $16 OR (posted_at = $16 AND t_records_pkey > $15::int)
				WHEN 'last_edited_at' THEN last_edited_at > $17 OR (last_edited_at = $17 AND t_records_pkey > $15::int)
				WHEN 'r_last_edited_at' THEN last_edited_at < $17 OR (last_edited_at = $17 AND t_records_pkey > $15::int)
				ELSE t_records_pkey > $15::int
			END
		WHEN 'prev' THEN
			CASE $13::text
				WHEN 'title' THEN title < $14 OR (title = $14 AND t_records_pkey < $15::int)
				WHEN 'r_title' THEN title > $14 OR (title = $14 AND t_records_pkey < $15::int)
				WHEN 'posted_at' THEN posted_at < $16 OR (posted_at = $16 AND t_records_pkey < $15::int)
				WHEN 'r_posted_at' THEN posted_at > $16 OR (posted_at = $16 AND t_records_pkey < $15::int)
				WHEN 'last_edited_at' THEN last_edited_at < $17 OR (last_edited_at = $17 AND t_records_pkey < $15::int)
				WHEN 'r_last_edited_at' THEN last_edited_at > $17 OR (last_edited_at = $17 AND t_records_pkey < $15::int)
				ELSE t_records_pkey < $15::int
			END
	END
ORDER BY
	CASE WHEN $13::text = 'title' AND $12::text = 'next' THEN title END ASC,
	CASE WHEN $13::text = 'title' AND $12::text = 'prev' THEN title END DESC,
	CASE WHEN $13::text = 'r_title' AND $12::text = 'next' THEN title END DESC,
	CASE WHEN $13::text = 'r_title' AND $12::text = 'prev' THEN title END ASC,
	CASE WHEN $13::text = 'posted_at' AND $12::text = 'next' THEN posted_at END ASC,
	CASE WHEN $13::text = 'posted_at' AND $12::text = 'prev' THEN posted_at END DESC,
	CASE WHEN $13::text = 'r_posted_at' AND $12::text = 'next' THEN posted_at END DESC,
	CASE WHEN $13::text = 'r_posted_at' AND $12::text = 'prev' THEN posted_at END ASC,
	CASE WHEN $13::text = 'last_edited_at' AND $12::text = 'next' THEN last_edited_at END ASC,
	CASE WHEN $13::text = 'last_edited_at' AND $12::text = 'prev' THEN last_edited_at END DESC,
	CASE WHEN $13::text = 'r_last_edited_at' AND $12::text = 'next' THEN last_edited_at END DESC,
	CASE WHEN $13::text = 'r_last_edited_at' AND $12::text = 'prev' THEN last_edited_at END ASC,
	CASE WHEN $12::text = 'next' THEN t_records_pkey END ASC,
	CASE WHEN $12::text = 'prev' THEN t_records_pkey END DESC
LIMIT $1
`

type GetRecordsWithPostedByUseKeysetPaginateParams struct {
	Limit               int32       `json:"limit"`
	WhereInRecordType   bool        `json:"where_in_record_type"`
	InRecordType        uuid.UUID   `json:"in_record_type"`
	WhereLikeTitle      bool        `json:"where_like_title"`
	SearchTitle         string      `json:"search_title"`
	WhereInOrganization bool        `json:"where_in_organization"`
	InOrganization      pgtype.UUID `json:"in_organization"`
	WhereInPostedBy     bool        `json:"where_in_posted_by"`
	InPostedBy          pgtype.UUID `json:"in_posted_by"`
	WhereInLastEditedBy bool        `json:"where_in_last_edited_by"`
	InLastEditedBy      pgtype.UUID `json:"in_last_edited_by"`
	CursorDirection     string      `json:"cursor_direction"`
	OrderMethod         string      `json:"order_method"`
	TitleCursor         string      `json:"title_cursor"`
	Cursor              int32       `json:"cursor"`
	PostedAtCursor      time.Time   `json:"posted_at_cursor"`
	LastEditedAtCursor  time.Time   `json:"last_edited_at_cursor"`
}

type GetRecordsWithPostedByUseKeysetPaginateRow struct {
	Record Record `json:"record"`
	Member Member `json:"member"`
}

func (q *Queries) GetRecordsWithPostedByUseKeysetPaginate(ctx context.Context, arg GetRecordsWithPostedByUseKeysetPaginateParams) ([]GetRecordsWithPostedByUseKeysetPaginateRow, error) {
	rows, err := q.db.Query(ctx, getRecordsWithPostedByUseKeysetPaginate,
		arg.Limit,
		arg.WhereInRecordType,
		arg.InRecordType,
		arg.WhereLikeTitle,
		arg.SearchTitle,
		arg.WhereInOrganization,
		arg.InOrganization,
		arg.WhereInPostedBy,
		arg.InPostedBy,
		arg.WhereInLastEditedBy,
		arg.InLastEditedBy,
		arg.CursorDirection,
		arg.OrderMethod,
		arg.TitleCursor,
		arg.Cursor,
		arg.PostedAtCursor,
		arg.LastEditedAtCursor,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecordsWithPostedByUseKeysetPaginateRow{}
	for rows.Next() {
		var i GetRecordsWithPostedByUseKeysetPaginateRow
		if err := rows.Scan(
			&i.Record.TRecordsPkey,
			&i.Record.RecordID,
			&i.Record.RecordTypeID,
			&i.Record.Title,
			&i.Record.Body,
			&i.Record.OrganizationID,
			&i.Record.PostedBy,
			&i.Record.LastEditedBy,
			&i.Record.PostedAt,
			&i.Record.LastEditedAt,
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageID,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecordsWithPostedByUseNumberedPaginate = `-- name: GetRecordsWithPostedByUseNumberedPaginate :many
SELECT t_records.t_records_pkey, t_records.record_id, t_records.record_type_id, t_records.title, t_records.body, t_records.organization_id, t_records.posted_by, t_records.last_edited_by, t_records.posted_at, t_records.last_edited_at, m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at FROM t_records
LEFT JOIN m_members ON t_records.posted_by = m_members.member_id
WHERE
	CASE WHEN $3::boolean = true THEN record_type_id = ANY($4) ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN title LIKE '%' || $6::text || '%' ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN organization_id = ANY($8) ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN t_records.posted_by = ANY($10) ELSE TRUE END
AND
	CASE WHEN $11::boolean = true THEN last_edited_by = ANY($12) ELSE TRUE END
ORDER BY
	CASE WHEN $13::text = 'title' THEN title END ASC,
	CASE WHEN $13::text = 'r_title' THEN title END DESC,
	CASE WHEN $13::text = 'posted_at' THEN posted_at END ASC,
	CASE WHEN $13::text = 'r_posted_at' THEN posted_at END DESC,
	CASE WHEN $13::text = 'last_edited_at' THEN last_edited_at END ASC,
	CASE WHEN $13::text = 'r_last_edited_at' THEN last_edited_at END DESC,
	t_records_pkey ASC
LIMIT $1 OFFSET $2
`

type GetRecordsWithPostedByUseNumberedPaginateParams struct {
	Limit               int32       `json:"limit"`
	Offset              int32       `json:"offset"`
	WhereInRecordType   bool        `json:"where_in_record_type"`
	InRecordType        uuid.UUID   `json:"in_record_type"`
	WhereLikeTitle      bool        `json:"where_like_title"`
	SearchTitle         string      `json:"search_title"`
	WhereInOrganization bool        `json:"where_in_organization"`
	InOrganization      pgtype.UUID `json:"in_organization"`
	WhereInPostedBy     bool        `json:"where_in_posted_by"`
	InPostedBy          pgtype.UUID `json:"in_posted_by"`
	WhereInLastEditedBy bool        `json:"where_in_last_edited_by"`
	InLastEditedBy      pgtype.UUID `json:"in_last_edited_by"`
	OrderMethod         string      `json:"order_method"`
}

type GetRecordsWithPostedByUseNumberedPaginateRow struct {
	Record Record `json:"record"`
	Member Member `json:"member"`
}

func (q *Queries) GetRecordsWithPostedByUseNumberedPaginate(ctx context.Context, arg GetRecordsWithPostedByUseNumberedPaginateParams) ([]GetRecordsWithPostedByUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getRecordsWithPostedByUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.WhereInRecordType,
		arg.InRecordType,
		arg.WhereLikeTitle,
		arg.SearchTitle,
		arg.WhereInOrganization,
		arg.InOrganization,
		arg.WhereInPostedBy,
		arg.InPostedBy,
		arg.WhereInLastEditedBy,
		arg.InLastEditedBy,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecordsWithPostedByUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetRecordsWithPostedByUseNumberedPaginateRow
		if err := rows.Scan(
			&i.Record.TRecordsPkey,
			&i.Record.RecordID,
			&i.Record.RecordTypeID,
			&i.Record.Title,
			&i.Record.Body,
			&i.Record.OrganizationID,
			&i.Record.PostedBy,
			&i.Record.LastEditedBy,
			&i.Record.PostedAt,
			&i.Record.LastEditedAt,
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageID,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecordsWithRecordType = `-- name: GetRecordsWithRecordType :many
SELECT t_records.t_records_pkey, t_records.record_id, t_records.record_type_id, t_records.title, t_records.body, t_records.organization_id, t_records.posted_by, t_records.last_edited_by, t_records.posted_at, t_records.last_edited_at, m_record_types.m_record_types_pkey, m_record_types.record_type_id, m_record_types.name, m_record_types.key FROM t_records
LEFT JOIN m_record_types ON t_records.record_type_id = m_record_types.record_type_id
WHERE
	CASE WHEN $1::boolean = true THEN t_records.record_type_id = ANY($2) ELSE TRUE END
AND
	CASE WHEN $3::boolean = true THEN title LIKE '%' || $4::text || '%' ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN organization_id = ANY($6) ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN posted_by = ANY($8) ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN last_edited_by = ANY($10) ELSE TRUE END
ORDER BY
	CASE WHEN $11::text = 'title' THEN title END ASC,
	CASE WHEN $11::text = 'r_title' THEN title END DESC,
	CASE WHEN $11::text = 'posted_at' THEN posted_at END ASC,
	CASE WHEN $11::text = 'r_posted_at' THEN posted_at END DESC,
	CASE WHEN $11::text = 'last_edited_at' THEN last_edited_at END ASC,
	CASE WHEN $11::text = 'r_last_edited_at' THEN last_edited_at END DESC,
	t_records_pkey ASC
`

type GetRecordsWithRecordTypeParams struct {
	WhereInRecordType   bool        `json:"where_in_record_type"`
	InRecordType        uuid.UUID   `json:"in_record_type"`
	WhereLikeTitle      bool        `json:"where_like_title"`
	SearchTitle         string      `json:"search_title"`
	WhereInOrganization bool        `json:"where_in_organization"`
	InOrganization      pgtype.UUID `json:"in_organization"`
	WhereInPostedBy     bool        `json:"where_in_posted_by"`
	InPostedBy          pgtype.UUID `json:"in_posted_by"`
	WhereInLastEditedBy bool        `json:"where_in_last_edited_by"`
	InLastEditedBy      pgtype.UUID `json:"in_last_edited_by"`
	OrderMethod         string      `json:"order_method"`
}

type GetRecordsWithRecordTypeRow struct {
	Record     Record     `json:"record"`
	RecordType RecordType `json:"record_type"`
}

func (q *Queries) GetRecordsWithRecordType(ctx context.Context, arg GetRecordsWithRecordTypeParams) ([]GetRecordsWithRecordTypeRow, error) {
	rows, err := q.db.Query(ctx, getRecordsWithRecordType,
		arg.WhereInRecordType,
		arg.InRecordType,
		arg.WhereLikeTitle,
		arg.SearchTitle,
		arg.WhereInOrganization,
		arg.InOrganization,
		arg.WhereInPostedBy,
		arg.InPostedBy,
		arg.WhereInLastEditedBy,
		arg.InLastEditedBy,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecordsWithRecordTypeRow{}
	for rows.Next() {
		var i GetRecordsWithRecordTypeRow
		if err := rows.Scan(
			&i.Record.TRecordsPkey,
			&i.Record.RecordID,
			&i.Record.RecordTypeID,
			&i.Record.Title,
			&i.Record.Body,
			&i.Record.OrganizationID,
			&i.Record.PostedBy,
			&i.Record.LastEditedBy,
			&i.Record.PostedAt,
			&i.Record.LastEditedAt,
			&i.RecordType.MRecordTypesPkey,
			&i.RecordType.RecordTypeID,
			&i.RecordType.Name,
			&i.RecordType.Key,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecordsWithRecordTypeUseKeysetPaginate = `-- name: GetRecordsWithRecordTypeUseKeysetPaginate :many
SELECT t_records.t_records_pkey, t_records.record_id, t_records.record_type_id, t_records.title, t_records.body, t_records.organization_id, t_records.posted_by, t_records.last_edited_by, t_records.posted_at, t_records.last_edited_at, m_record_types.m_record_types_pkey, m_record_types.record_type_id, m_record_types.name, m_record_types.key FROM t_records
LEFT JOIN m_record_types ON t_records.record_type_id = m_record_types.record_type_id
WHERE
	CASE WHEN $2::boolean = true THEN t_records.record_type_id = ANY($3) ELSE TRUE END
AND
	CASE WHEN $4::boolean = true THEN title LIKE '%' || $5::text || '%' ELSE TRUE END
AND
	CASE WHEN $6::boolean = true THEN organization_id = ANY($7) ELSE TRUE END
AND
	CASE WHEN $8::boolean = true THEN posted_by = ANY($9) ELSE TRUE END
AND
	CASE WHEN $10::boolean = true THEN last_edited_by = ANY($11) ELSE TRUE END
AND
	CASE $12::text
		WHEN 'next' THEN
			CASE $13::text
				WHEN 'title' THEN title > $14 OR (title = $14 AND t_records_pkey > $15::int)
				WHEN 'r_title' THEN title < $14 OR (title = $14 AND t_records_pkey > $15::int)
				WHEN 'posted_at' THEN posted_at > $16 OR (posted_at = $16 AND t_records_pkey > $15::int)
				WHEN 'r_posted_at' THEN posted_at < $16 OR (posted_at = $16 AND t_records_pkey > $15::int)
				WHEN 'last_edited_at' THEN last_edited_at > $17 OR (last_edited_at = $17 AND t_records_pkey > $15::int)
				WHEN 'r_last_edited_at' THEN last_edited_at < $17 OR (last_edited_at = $17 AND t_records_pkey > $15::int)
				ELSE t_records_pkey > $15::int
			END
		WHEN 'prev' THEN
			CASE $13::text
				WHEN 'title' THEN title < $14 OR (title = $14 AND t_records_pkey < $15::int)
				WHEN 'r_title' THEN title > $14 OR (title = $14 AND t_records_pkey < $15::int)
				WHEN 'posted_at' THEN posted_at < $16 OR (posted_at = $16 AND t_records_pkey < $15::int)
				WHEN 'r_posted_at' THEN posted_at > $16 OR (posted_at = $16 AND t_records_pkey < $15::int)
				WHEN 'last_edited_at' THEN last_edited_at < $17 OR (last_edited_at = $17 AND t_records_pkey < $15::int)
				WHEN 'r_last_edited_at' THEN last_edited_at > $17 OR (last_edited_at = $17 AND t_records_pkey < $15::int)
				ELSE t_records_pkey < $15::int
			END
	END
ORDER BY
	CASE WHEN $13::text = 'title' AND $12::text = 'next' THEN title END ASC,
	CASE WHEN $13::text = 'title' AND $12::text = 'prev' THEN title END DESC,
	CASE WHEN $13::text = 'r_title' AND $12::text = 'next' THEN title END DESC,
	CASE WHEN $13::text = 'r_title' AND $12::text = 'prev' THEN title END ASC,
	CASE WHEN $13::text = 'posted_at' AND $12::text = 'next' THEN posted_at END ASC,
	CASE WHEN $13::text = 'posted_at' AND $12::text = 'prev' THEN posted_at END DESC,
	CASE WHEN $13::text = 'r_posted_at' AND $12::text = 'next' THEN posted_at END DESC,
	CASE WHEN $13::text = 'r_posted_at' AND $12::text = 'prev' THEN posted_at END ASC,
	CASE WHEN $13::text = 'last_edited_at' AND $12::text = 'next' THEN last_edited_at END ASC,
	CASE WHEN $13::text = 'last_edited_at' AND $12::text = 'prev' THEN last_edited_at END DESC,
	CASE WHEN $13::text = 'r_last_edited_at' AND $12::text = 'next' THEN last_edited_at END DESC,
	CASE WHEN $13::text = 'r_last_edited_at' AND $12::text = 'prev' THEN last_edited_at END ASC,
	CASE WHEN $12::text = 'next' THEN t_records_pkey END ASC,
	CASE WHEN $12::text = 'prev' THEN t_records_pkey END DESC
LIMIT $1
`

type GetRecordsWithRecordTypeUseKeysetPaginateParams struct {
	Limit               int32       `json:"limit"`
	WhereInRecordType   bool        `json:"where_in_record_type"`
	InRecordType        uuid.UUID   `json:"in_record_type"`
	WhereLikeTitle      bool        `json:"where_like_title"`
	SearchTitle         string      `json:"search_title"`
	WhereInOrganization bool        `json:"where_in_organization"`
	InOrganization      pgtype.UUID `json:"in_organization"`
	WhereInPostedBy     bool        `json:"where_in_posted_by"`
	InPostedBy          pgtype.UUID `json:"in_posted_by"`
	WhereInLastEditedBy bool        `json:"where_in_last_edited_by"`
	InLastEditedBy      pgtype.UUID `json:"in_last_edited_by"`
	CursorDirection     string      `json:"cursor_direction"`
	OrderMethod         string      `json:"order_method"`
	TitleCursor         string      `json:"title_cursor"`
	Cursor              int32       `json:"cursor"`
	PostedAtCursor      time.Time   `json:"posted_at_cursor"`
	LastEditedAtCursor  time.Time   `json:"last_edited_at_cursor"`
}

type GetRecordsWithRecordTypeUseKeysetPaginateRow struct {
	Record     Record     `json:"record"`
	RecordType RecordType `json:"record_type"`
}

func (q *Queries) GetRecordsWithRecordTypeUseKeysetPaginate(ctx context.Context, arg GetRecordsWithRecordTypeUseKeysetPaginateParams) ([]GetRecordsWithRecordTypeUseKeysetPaginateRow, error) {
	rows, err := q.db.Query(ctx, getRecordsWithRecordTypeUseKeysetPaginate,
		arg.Limit,
		arg.WhereInRecordType,
		arg.InRecordType,
		arg.WhereLikeTitle,
		arg.SearchTitle,
		arg.WhereInOrganization,
		arg.InOrganization,
		arg.WhereInPostedBy,
		arg.InPostedBy,
		arg.WhereInLastEditedBy,
		arg.InLastEditedBy,
		arg.CursorDirection,
		arg.OrderMethod,
		arg.TitleCursor,
		arg.Cursor,
		arg.PostedAtCursor,
		arg.LastEditedAtCursor,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecordsWithRecordTypeUseKeysetPaginateRow{}
	for rows.Next() {
		var i GetRecordsWithRecordTypeUseKeysetPaginateRow
		if err := rows.Scan(
			&i.Record.TRecordsPkey,
			&i.Record.RecordID,
			&i.Record.RecordTypeID,
			&i.Record.Title,
			&i.Record.Body,
			&i.Record.OrganizationID,
			&i.Record.PostedBy,
			&i.Record.LastEditedBy,
			&i.Record.PostedAt,
			&i.Record.LastEditedAt,
			&i.RecordType.MRecordTypesPkey,
			&i.RecordType.RecordTypeID,
			&i.RecordType.Name,
			&i.RecordType.Key,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecordsWithRecordTypeUseNumberedPaginate = `-- name: GetRecordsWithRecordTypeUseNumberedPaginate :many
SELECT t_records.t_records_pkey, t_records.record_id, t_records.record_type_id, t_records.title, t_records.body, t_records.organization_id, t_records.posted_by, t_records.last_edited_by, t_records.posted_at, t_records.last_edited_at, m_record_types.m_record_types_pkey, m_record_types.record_type_id, m_record_types.name, m_record_types.key FROM t_records
LEFT JOIN m_record_types ON t_records.record_type_id = m_record_types.record_type_id
WHERE
	CASE WHEN $3::boolean = true THEN t_records.record_type_id = ANY($4) ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN title LIKE '%' || $6::text || '%' ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN organization_id = ANY($8) ELSE TRUE END
AND
	CASE WHEN $9::boolean = true THEN posted_by = ANY($10) ELSE TRUE END
AND
	CASE WHEN $11::boolean = true THEN last_edited_by = ANY($12) ELSE TRUE END
ORDER BY
	CASE WHEN $13::text = 'title' THEN title END ASC,
	CASE WHEN $13::text = 'r_title' THEN title END DESC,
	CASE WHEN $13::text = 'posted_at' THEN posted_at END ASC,
	CASE WHEN $13::text = 'r_posted_at' THEN posted_at END DESC,
	CASE WHEN $13::text = 'last_edited_at' THEN last_edited_at END ASC,
	CASE WHEN $13::text = 'r_last_edited_at' THEN last_edited_at END DESC,
	t_records_pkey ASC
LIMIT $1 OFFSET $2
`

type GetRecordsWithRecordTypeUseNumberedPaginateParams struct {
	Limit               int32       `json:"limit"`
	Offset              int32       `json:"offset"`
	WhereInRecordType   bool        `json:"where_in_record_type"`
	InRecordType        uuid.UUID   `json:"in_record_type"`
	WhereLikeTitle      bool        `json:"where_like_title"`
	SearchTitle         string      `json:"search_title"`
	WhereInOrganization bool        `json:"where_in_organization"`
	InOrganization      pgtype.UUID `json:"in_organization"`
	WhereInPostedBy     bool        `json:"where_in_posted_by"`
	InPostedBy          pgtype.UUID `json:"in_posted_by"`
	WhereInLastEditedBy bool        `json:"where_in_last_edited_by"`
	InLastEditedBy      pgtype.UUID `json:"in_last_edited_by"`
	OrderMethod         string      `json:"order_method"`
}

type GetRecordsWithRecordTypeUseNumberedPaginateRow struct {
	Record     Record     `json:"record"`
	RecordType RecordType `json:"record_type"`
}

func (q *Queries) GetRecordsWithRecordTypeUseNumberedPaginate(ctx context.Context, arg GetRecordsWithRecordTypeUseNumberedPaginateParams) ([]GetRecordsWithRecordTypeUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getRecordsWithRecordTypeUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.WhereInRecordType,
		arg.InRecordType,
		arg.WhereLikeTitle,
		arg.SearchTitle,
		arg.WhereInOrganization,
		arg.InOrganization,
		arg.WhereInPostedBy,
		arg.InPostedBy,
		arg.WhereInLastEditedBy,
		arg.InLastEditedBy,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecordsWithRecordTypeUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetRecordsWithRecordTypeUseNumberedPaginateRow
		if err := rows.Scan(
			&i.Record.TRecordsPkey,
			&i.Record.RecordID,
			&i.Record.RecordTypeID,
			&i.Record.Title,
			&i.Record.Body,
			&i.Record.OrganizationID,
			&i.Record.PostedBy,
			&i.Record.LastEditedBy,
			&i.Record.PostedAt,
			&i.Record.LastEditedAt,
			&i.RecordType.MRecordTypesPkey,
			&i.RecordType.RecordTypeID,
			&i.RecordType.Name,
			&i.RecordType.Key,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const pluralDeleteRecords = `-- name: PluralDeleteRecords :execrows
DELETE FROM t_records WHERE record_id = ANY($1::uuid[])
`

func (q *Queries) PluralDeleteRecords(ctx context.Context, dollar_1 []uuid.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, pluralDeleteRecords, dollar_1)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateRecord = `-- name: UpdateRecord :one
UPDATE t_records SET record_type_id = $2, title = $3, body = $4, organization_id = $5, last_edited_by = $6, last_edited_at = $7 WHERE record_id = $1 RETURNING t_records_pkey, record_id, record_type_id, title, body, organization_id, posted_by, last_edited_by, posted_at, last_edited_at
`

type UpdateRecordParams struct {
	RecordID       uuid.UUID   `json:"record_id"`
	RecordTypeID   uuid.UUID   `json:"record_type_id"`
	Title          string      `json:"title"`
	Body           pgtype.Text `json:"body"`
	OrganizationID pgtype.UUID `json:"organization_id"`
	LastEditedBy   pgtype.UUID `json:"last_edited_by"`
	LastEditedAt   time.Time   `json:"last_edited_at"`
}

func (q *Queries) UpdateRecord(ctx context.Context, arg UpdateRecordParams) (Record, error) {
	row := q.db.QueryRow(ctx, updateRecord,
		arg.RecordID,
		arg.RecordTypeID,
		arg.Title,
		arg.Body,
		arg.OrganizationID,
		arg.LastEditedBy,
		arg.LastEditedAt,
	)
	var i Record
	err := row.Scan(
		&i.TRecordsPkey,
		&i.RecordID,
		&i.RecordTypeID,
		&i.Title,
		&i.Body,
		&i.OrganizationID,
		&i.PostedBy,
		&i.LastEditedBy,
		&i.PostedAt,
		&i.LastEditedAt,
	)
	return i, err
}
