// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: role_association.sql

package query

import (
	"context"

	"github.com/google/uuid"
)

const countPoliciesByRoleID = `-- name: CountPoliciesByRoleID :one
SELECT COUNT(*) FROM m_role_associations WHERE role_id = $1
`

func (q *Queries) CountPoliciesByRoleID(ctx context.Context, roleID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countPoliciesByRoleID, roleID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countRolesByPolicyID = `-- name: CountRolesByPolicyID :one
SELECT COUNT(*) FROM m_role_associations WHERE policy_id = $1
`

func (q *Queries) CountRolesByPolicyID(ctx context.Context, policyID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countRolesByPolicyID, policyID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createRoleAssociation = `-- name: CreateRoleAssociation :one
INSERT INTO m_role_associations (role_id, policy_id) VALUES ($1, $2) RETURNING m_role_associations_pkey, role_id, policy_id
`

type CreateRoleAssociationParams struct {
	RoleID   uuid.UUID `json:"role_id"`
	PolicyID uuid.UUID `json:"policy_id"`
}

func (q *Queries) CreateRoleAssociation(ctx context.Context, arg CreateRoleAssociationParams) (RoleAssociation, error) {
	row := q.db.QueryRow(ctx, createRoleAssociation, arg.RoleID, arg.PolicyID)
	var i RoleAssociation
	err := row.Scan(&i.MRoleAssociationsPkey, &i.RoleID, &i.PolicyID)
	return i, err
}

type CreateRoleAssociationsParams struct {
	RoleID   uuid.UUID `json:"role_id"`
	PolicyID uuid.UUID `json:"policy_id"`
}

const deleteRoleAssociation = `-- name: DeleteRoleAssociation :exec
DELETE FROM m_role_associations WHERE role_id = $1 AND policy_id = $2
`

type DeleteRoleAssociationParams struct {
	RoleID   uuid.UUID `json:"role_id"`
	PolicyID uuid.UUID `json:"policy_id"`
}

func (q *Queries) DeleteRoleAssociation(ctx context.Context, arg DeleteRoleAssociationParams) error {
	_, err := q.db.Exec(ctx, deleteRoleAssociation, arg.RoleID, arg.PolicyID)
	return err
}

const getPoliciesByRoleID = `-- name: GetPoliciesByRoleID :many
SELECT m_role_associations.m_role_associations_pkey, m_role_associations.role_id, m_role_associations.policy_id, m_policies.m_policies_pkey, m_policies.policy_id, m_policies.name, m_policies.description, m_policies.key, m_policies.policy_category_id FROM m_role_associations
INNER JOIN m_policies ON m_role_associations.policy_id = m_policies.policy_id
WHERE role_id = $1
AND CASE
	WHEN $4::boolean = true THEN m_policies.name LIKE '%' || $5::text || '%'
END
ORDER BY
	CASE WHEN $6::text = 'name' THEN m_policies.name END ASC,
	m_role_associations_pkey DESC
LIMIT $2 OFFSET $3
`

type GetPoliciesByRoleIDParams struct {
	RoleID        uuid.UUID `json:"role_id"`
	Limit         int32     `json:"limit"`
	Offset        int32     `json:"offset"`
	WhereLikeName bool      `json:"where_like_name"`
	SearchName    string    `json:"search_name"`
	OrderMethod   string    `json:"order_method"`
}

type GetPoliciesByRoleIDRow struct {
	RoleAssociation RoleAssociation `json:"role_association"`
	Policy          Policy          `json:"policy"`
}

func (q *Queries) GetPoliciesByRoleID(ctx context.Context, arg GetPoliciesByRoleIDParams) ([]GetPoliciesByRoleIDRow, error) {
	rows, err := q.db.Query(ctx, getPoliciesByRoleID,
		arg.RoleID,
		arg.Limit,
		arg.Offset,
		arg.WhereLikeName,
		arg.SearchName,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPoliciesByRoleIDRow{}
	for rows.Next() {
		var i GetPoliciesByRoleIDRow
		if err := rows.Scan(
			&i.RoleAssociation.MRoleAssociationsPkey,
			&i.RoleAssociation.RoleID,
			&i.RoleAssociation.PolicyID,
			&i.Policy.MPoliciesPkey,
			&i.Policy.PolicyID,
			&i.Policy.Name,
			&i.Policy.Description,
			&i.Policy.Key,
			&i.Policy.PolicyCategoryID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRolesByPolicyID = `-- name: GetRolesByPolicyID :many
SELECT m_role_associations.m_role_associations_pkey, m_role_associations.role_id, m_role_associations.policy_id, m_roles.m_roles_pkey, m_roles.role_id, m_roles.name, m_roles.description, m_roles.created_at, m_roles.updated_at FROM m_role_associations
INNER JOIN m_roles ON m_role_associations.role_id = m_roles.role_id
WHERE policy_id = $1
AND CASE
	WHEN $4::boolean = true THEN m_roles.name LIKE '%' || $5::text || '%'
END
ORDER BY
	CASE WHEN $6::text = 'name' THEN m_roles.name END ASC,
	m_role_associations_pkey DESC
LIMIT $2 OFFSET $3
`

type GetRolesByPolicyIDParams struct {
	PolicyID      uuid.UUID `json:"policy_id"`
	Limit         int32     `json:"limit"`
	Offset        int32     `json:"offset"`
	WhereLikeName bool      `json:"where_like_name"`
	SearchName    string    `json:"search_name"`
	OrderMethod   string    `json:"order_method"`
}

type GetRolesByPolicyIDRow struct {
	RoleAssociation RoleAssociation `json:"role_association"`
	Role            Role            `json:"role"`
}

func (q *Queries) GetRolesByPolicyID(ctx context.Context, arg GetRolesByPolicyIDParams) ([]GetRolesByPolicyIDRow, error) {
	rows, err := q.db.Query(ctx, getRolesByPolicyID,
		arg.PolicyID,
		arg.Limit,
		arg.Offset,
		arg.WhereLikeName,
		arg.SearchName,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRolesByPolicyIDRow{}
	for rows.Next() {
		var i GetRolesByPolicyIDRow
		if err := rows.Scan(
			&i.RoleAssociation.MRoleAssociationsPkey,
			&i.RoleAssociation.RoleID,
			&i.RoleAssociation.PolicyID,
			&i.Role.MRolesPkey,
			&i.Role.RoleID,
			&i.Role.Name,
			&i.Role.Description,
			&i.Role.CreatedAt,
			&i.Role.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
