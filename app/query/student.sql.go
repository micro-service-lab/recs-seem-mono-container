// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: student.sql

package query

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countStudents = `-- name: CountStudents :one
SELECT COUNT(*) FROM m_students
`

func (q *Queries) CountStudents(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countStudents)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createStudent = `-- name: CreateStudent :one
INSERT INTO m_students (member_id) VALUES ($1) RETURNING m_students_pkey, student_id, member_id
`

func (q *Queries) CreateStudent(ctx context.Context, memberID uuid.UUID) (Student, error) {
	row := q.db.QueryRow(ctx, createStudent, memberID)
	var i Student
	err := row.Scan(&i.MStudentsPkey, &i.StudentID, &i.MemberID)
	return i, err
}

const deleteStudent = `-- name: DeleteStudent :execrows
DELETE FROM m_students WHERE student_id = $1
`

func (q *Queries) DeleteStudent(ctx context.Context, studentID uuid.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, deleteStudent, studentID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const findStudentByID = `-- name: FindStudentByID :one
SELECT m_students_pkey, student_id, member_id FROM m_students WHERE student_id = $1
`

func (q *Queries) FindStudentByID(ctx context.Context, studentID uuid.UUID) (Student, error) {
	row := q.db.QueryRow(ctx, findStudentByID, studentID)
	var i Student
	err := row.Scan(&i.MStudentsPkey, &i.StudentID, &i.MemberID)
	return i, err
}

const findStudentByIDWithMember = `-- name: FindStudentByIDWithMember :one
SELECT m_students.m_students_pkey, m_students.student_id, m_students.member_id, m_members.name member_name, m_members.first_name member_first_name, m_members.last_name member_last_name, m_members.email member_email,
m_members.profile_image_id member_profile_image_id, t_images.height member_profile_image_height,
t_images.width member_profile_image_width, t_images.attachable_item_id member_profile_image_attachable_item_id,
t_attachable_items.owner_id member_profile_image_owner_id, t_attachable_items.from_outer member_profile_image_from_outer, t_attachable_items.alias member_profile_image_alias,
t_attachable_items.url member_profile_image_url, t_attachable_items.size member_profile_image_size, t_attachable_items.mime_type_id member_profile_image_mime_type_id FROM m_students
LEFT JOIN m_members ON m_students.member_id = m_members.member_id
LEFT JOIN t_images ON m_members.profile_image_id = t_images.image_id
LEFT JOIN t_attachable_items ON t_images.attachable_item_id = t_attachable_items.attachable_item_id
WHERE student_id = $1
`

type FindStudentByIDWithMemberRow struct {
	MStudentsPkey                      pgtype.Int8   `json:"m_students_pkey"`
	StudentID                          uuid.UUID     `json:"student_id"`
	MemberID                           uuid.UUID     `json:"member_id"`
	MemberName                         pgtype.Text   `json:"member_name"`
	MemberFirstName                    pgtype.Text   `json:"member_first_name"`
	MemberLastName                     pgtype.Text   `json:"member_last_name"`
	MemberEmail                        pgtype.Text   `json:"member_email"`
	MemberProfileImageID               pgtype.UUID   `json:"member_profile_image_id"`
	MemberProfileImageHeight           pgtype.Float8 `json:"member_profile_image_height"`
	MemberProfileImageWidth            pgtype.Float8 `json:"member_profile_image_width"`
	MemberProfileImageAttachableItemID pgtype.UUID   `json:"member_profile_image_attachable_item_id"`
	MemberProfileImageOwnerID          pgtype.UUID   `json:"member_profile_image_owner_id"`
	MemberProfileImageFromOuter        pgtype.Bool   `json:"member_profile_image_from_outer"`
	MemberProfileImageAlias            pgtype.Text   `json:"member_profile_image_alias"`
	MemberProfileImageUrl              pgtype.Text   `json:"member_profile_image_url"`
	MemberProfileImageSize             pgtype.Float8 `json:"member_profile_image_size"`
	MemberProfileImageMimeTypeID       pgtype.UUID   `json:"member_profile_image_mime_type_id"`
}

func (q *Queries) FindStudentByIDWithMember(ctx context.Context, studentID uuid.UUID) (FindStudentByIDWithMemberRow, error) {
	row := q.db.QueryRow(ctx, findStudentByIDWithMember, studentID)
	var i FindStudentByIDWithMemberRow
	err := row.Scan(
		&i.MStudentsPkey,
		&i.StudentID,
		&i.MemberID,
		&i.MemberName,
		&i.MemberFirstName,
		&i.MemberLastName,
		&i.MemberEmail,
		&i.MemberProfileImageID,
		&i.MemberProfileImageHeight,
		&i.MemberProfileImageWidth,
		&i.MemberProfileImageAttachableItemID,
		&i.MemberProfileImageOwnerID,
		&i.MemberProfileImageFromOuter,
		&i.MemberProfileImageAlias,
		&i.MemberProfileImageUrl,
		&i.MemberProfileImageSize,
		&i.MemberProfileImageMimeTypeID,
	)
	return i, err
}

const getPluralStudents = `-- name: GetPluralStudents :many
SELECT m_students_pkey, student_id, member_id FROM m_students
WHERE student_id = ANY($1::uuid[])
ORDER BY
	m_students_pkey ASC
`

func (q *Queries) GetPluralStudents(ctx context.Context, studentIds []uuid.UUID) ([]Student, error) {
	rows, err := q.db.Query(ctx, getPluralStudents, studentIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Student{}
	for rows.Next() {
		var i Student
		if err := rows.Scan(&i.MStudentsPkey, &i.StudentID, &i.MemberID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralStudentsUseNumberedPaginate = `-- name: GetPluralStudentsUseNumberedPaginate :many
SELECT m_students_pkey, student_id, member_id FROM m_students
WHERE student_id = ANY($3::uuid[])
ORDER BY
	m_students_pkey ASC
LIMIT $1 OFFSET $2
`

type GetPluralStudentsUseNumberedPaginateParams struct {
	Limit      int32       `json:"limit"`
	Offset     int32       `json:"offset"`
	StudentIds []uuid.UUID `json:"student_ids"`
}

func (q *Queries) GetPluralStudentsUseNumberedPaginate(ctx context.Context, arg GetPluralStudentsUseNumberedPaginateParams) ([]Student, error) {
	rows, err := q.db.Query(ctx, getPluralStudentsUseNumberedPaginate, arg.Limit, arg.Offset, arg.StudentIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Student{}
	for rows.Next() {
		var i Student
		if err := rows.Scan(&i.MStudentsPkey, &i.StudentID, &i.MemberID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralStudentsWithMember = `-- name: GetPluralStudentsWithMember :many
SELECT m_students.m_students_pkey, m_students.student_id, m_students.member_id, m_members.name member_name, m_members.first_name member_first_name, m_members.last_name member_last_name, m_members.email member_email,
m_members.profile_image_id member_profile_image_id, t_images.height member_profile_image_height,
t_images.width member_profile_image_width, t_images.attachable_item_id member_profile_image_attachable_item_id,
t_attachable_items.owner_id member_profile_image_owner_id, t_attachable_items.from_outer member_profile_image_from_outer, t_attachable_items.alias member_profile_image_alias,
t_attachable_items.url member_profile_image_url, t_attachable_items.size member_profile_image_size, t_attachable_items.mime_type_id member_profile_image_mime_type_id FROM m_students
LEFT JOIN m_members ON m_students.member_id = m_members.member_id
LEFT JOIN t_images ON m_members.profile_image_id = t_images.image_id
LEFT JOIN t_attachable_items ON t_images.attachable_item_id = t_attachable_items.attachable_item_id
WHERE student_id = ANY($1::uuid[])
ORDER BY
	m_students_pkey ASC
`

type GetPluralStudentsWithMemberRow struct {
	MStudentsPkey                      pgtype.Int8   `json:"m_students_pkey"`
	StudentID                          uuid.UUID     `json:"student_id"`
	MemberID                           uuid.UUID     `json:"member_id"`
	MemberName                         pgtype.Text   `json:"member_name"`
	MemberFirstName                    pgtype.Text   `json:"member_first_name"`
	MemberLastName                     pgtype.Text   `json:"member_last_name"`
	MemberEmail                        pgtype.Text   `json:"member_email"`
	MemberProfileImageID               pgtype.UUID   `json:"member_profile_image_id"`
	MemberProfileImageHeight           pgtype.Float8 `json:"member_profile_image_height"`
	MemberProfileImageWidth            pgtype.Float8 `json:"member_profile_image_width"`
	MemberProfileImageAttachableItemID pgtype.UUID   `json:"member_profile_image_attachable_item_id"`
	MemberProfileImageOwnerID          pgtype.UUID   `json:"member_profile_image_owner_id"`
	MemberProfileImageFromOuter        pgtype.Bool   `json:"member_profile_image_from_outer"`
	MemberProfileImageAlias            pgtype.Text   `json:"member_profile_image_alias"`
	MemberProfileImageUrl              pgtype.Text   `json:"member_profile_image_url"`
	MemberProfileImageSize             pgtype.Float8 `json:"member_profile_image_size"`
	MemberProfileImageMimeTypeID       pgtype.UUID   `json:"member_profile_image_mime_type_id"`
}

func (q *Queries) GetPluralStudentsWithMember(ctx context.Context, studentIds []uuid.UUID) ([]GetPluralStudentsWithMemberRow, error) {
	rows, err := q.db.Query(ctx, getPluralStudentsWithMember, studentIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralStudentsWithMemberRow{}
	for rows.Next() {
		var i GetPluralStudentsWithMemberRow
		if err := rows.Scan(
			&i.MStudentsPkey,
			&i.StudentID,
			&i.MemberID,
			&i.MemberName,
			&i.MemberFirstName,
			&i.MemberLastName,
			&i.MemberEmail,
			&i.MemberProfileImageID,
			&i.MemberProfileImageHeight,
			&i.MemberProfileImageWidth,
			&i.MemberProfileImageAttachableItemID,
			&i.MemberProfileImageOwnerID,
			&i.MemberProfileImageFromOuter,
			&i.MemberProfileImageAlias,
			&i.MemberProfileImageUrl,
			&i.MemberProfileImageSize,
			&i.MemberProfileImageMimeTypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralStudentsWithMemberUseNumberedPaginate = `-- name: GetPluralStudentsWithMemberUseNumberedPaginate :many
SELECT m_students.m_students_pkey, m_students.student_id, m_students.member_id, m_members.name member_name, m_members.first_name member_first_name, m_members.last_name member_last_name, m_members.email member_email,
m_members.profile_image_id member_profile_image_id, t_images.height member_profile_image_height,
t_images.width member_profile_image_width, t_images.attachable_item_id member_profile_image_attachable_item_id,
t_attachable_items.owner_id member_profile_image_owner_id, t_attachable_items.from_outer member_profile_image_from_outer, t_attachable_items.alias member_profile_image_alias,
t_attachable_items.url member_profile_image_url, t_attachable_items.size member_profile_image_size, t_attachable_items.mime_type_id member_profile_image_mime_type_id FROM m_students
LEFT JOIN m_members ON m_students.member_id = m_members.member_id
LEFT JOIN t_images ON m_members.profile_image_id = t_images.image_id
LEFT JOIN t_attachable_items ON t_images.attachable_item_id = t_attachable_items.attachable_item_id
WHERE student_id = ANY($3::uuid[])
ORDER BY
	m_students_pkey ASC
LIMIT $1 OFFSET $2
`

type GetPluralStudentsWithMemberUseNumberedPaginateParams struct {
	Limit      int32       `json:"limit"`
	Offset     int32       `json:"offset"`
	StudentIds []uuid.UUID `json:"student_ids"`
}

type GetPluralStudentsWithMemberUseNumberedPaginateRow struct {
	MStudentsPkey                      pgtype.Int8   `json:"m_students_pkey"`
	StudentID                          uuid.UUID     `json:"student_id"`
	MemberID                           uuid.UUID     `json:"member_id"`
	MemberName                         pgtype.Text   `json:"member_name"`
	MemberFirstName                    pgtype.Text   `json:"member_first_name"`
	MemberLastName                     pgtype.Text   `json:"member_last_name"`
	MemberEmail                        pgtype.Text   `json:"member_email"`
	MemberProfileImageID               pgtype.UUID   `json:"member_profile_image_id"`
	MemberProfileImageHeight           pgtype.Float8 `json:"member_profile_image_height"`
	MemberProfileImageWidth            pgtype.Float8 `json:"member_profile_image_width"`
	MemberProfileImageAttachableItemID pgtype.UUID   `json:"member_profile_image_attachable_item_id"`
	MemberProfileImageOwnerID          pgtype.UUID   `json:"member_profile_image_owner_id"`
	MemberProfileImageFromOuter        pgtype.Bool   `json:"member_profile_image_from_outer"`
	MemberProfileImageAlias            pgtype.Text   `json:"member_profile_image_alias"`
	MemberProfileImageUrl              pgtype.Text   `json:"member_profile_image_url"`
	MemberProfileImageSize             pgtype.Float8 `json:"member_profile_image_size"`
	MemberProfileImageMimeTypeID       pgtype.UUID   `json:"member_profile_image_mime_type_id"`
}

func (q *Queries) GetPluralStudentsWithMemberUseNumberedPaginate(ctx context.Context, arg GetPluralStudentsWithMemberUseNumberedPaginateParams) ([]GetPluralStudentsWithMemberUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getPluralStudentsWithMemberUseNumberedPaginate, arg.Limit, arg.Offset, arg.StudentIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralStudentsWithMemberUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetPluralStudentsWithMemberUseNumberedPaginateRow
		if err := rows.Scan(
			&i.MStudentsPkey,
			&i.StudentID,
			&i.MemberID,
			&i.MemberName,
			&i.MemberFirstName,
			&i.MemberLastName,
			&i.MemberEmail,
			&i.MemberProfileImageID,
			&i.MemberProfileImageHeight,
			&i.MemberProfileImageWidth,
			&i.MemberProfileImageAttachableItemID,
			&i.MemberProfileImageOwnerID,
			&i.MemberProfileImageFromOuter,
			&i.MemberProfileImageAlias,
			&i.MemberProfileImageUrl,
			&i.MemberProfileImageSize,
			&i.MemberProfileImageMimeTypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStudents = `-- name: GetStudents :many
SELECT m_students_pkey, student_id, member_id FROM m_students
ORDER BY
	m_students_pkey ASC
`

func (q *Queries) GetStudents(ctx context.Context) ([]Student, error) {
	rows, err := q.db.Query(ctx, getStudents)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Student{}
	for rows.Next() {
		var i Student
		if err := rows.Scan(&i.MStudentsPkey, &i.StudentID, &i.MemberID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStudentsUseKeysetPaginate = `-- name: GetStudentsUseKeysetPaginate :many
SELECT m_students_pkey, student_id, member_id FROM m_students
WHERE
	CASE $2::text
		WHEN 'next' THEN
			m_students_pkey > $3::int
		WHEN 'prev' THEN
			m_students_pkey < $3::int
	END
ORDER BY
	CASE WHEN $2::text = 'next' THEN m_students_pkey END ASC,
	CASE WHEN $2::text = 'prev' THEN m_students_pkey END DESC
LIMIT $1
`

type GetStudentsUseKeysetPaginateParams struct {
	Limit           int32  `json:"limit"`
	CursorDirection string `json:"cursor_direction"`
	Cursor          int32  `json:"cursor"`
}

func (q *Queries) GetStudentsUseKeysetPaginate(ctx context.Context, arg GetStudentsUseKeysetPaginateParams) ([]Student, error) {
	rows, err := q.db.Query(ctx, getStudentsUseKeysetPaginate, arg.Limit, arg.CursorDirection, arg.Cursor)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Student{}
	for rows.Next() {
		var i Student
		if err := rows.Scan(&i.MStudentsPkey, &i.StudentID, &i.MemberID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStudentsUseNumberedPaginate = `-- name: GetStudentsUseNumberedPaginate :many
SELECT m_students_pkey, student_id, member_id FROM m_students
ORDER BY
	m_students_pkey ASC
LIMIT $1 OFFSET $2
`

type GetStudentsUseNumberedPaginateParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetStudentsUseNumberedPaginate(ctx context.Context, arg GetStudentsUseNumberedPaginateParams) ([]Student, error) {
	rows, err := q.db.Query(ctx, getStudentsUseNumberedPaginate, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Student{}
	for rows.Next() {
		var i Student
		if err := rows.Scan(&i.MStudentsPkey, &i.StudentID, &i.MemberID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStudentsWithMember = `-- name: GetStudentsWithMember :many
SELECT m_students.m_students_pkey, m_students.student_id, m_students.member_id, m_members.name member_name, m_members.first_name member_first_name, m_members.last_name member_last_name, m_members.email member_email,
m_members.profile_image_id member_profile_image_id, t_images.height member_profile_image_height,
t_images.width member_profile_image_width, t_images.attachable_item_id member_profile_image_attachable_item_id,
t_attachable_items.owner_id member_profile_image_owner_id, t_attachable_items.from_outer member_profile_image_from_outer, t_attachable_items.alias member_profile_image_alias,
t_attachable_items.url member_profile_image_url, t_attachable_items.size member_profile_image_size, t_attachable_items.mime_type_id member_profile_image_mime_type_id FROM m_students
LEFT JOIN m_members ON m_students.member_id = m_members.member_id
LEFT JOIN t_images ON m_members.profile_image_id = t_images.image_id
LEFT JOIN t_attachable_items ON t_images.attachable_item_id = t_attachable_items.attachable_item_id
ORDER BY
	m_students_pkey ASC
`

type GetStudentsWithMemberRow struct {
	MStudentsPkey                      pgtype.Int8   `json:"m_students_pkey"`
	StudentID                          uuid.UUID     `json:"student_id"`
	MemberID                           uuid.UUID     `json:"member_id"`
	MemberName                         pgtype.Text   `json:"member_name"`
	MemberFirstName                    pgtype.Text   `json:"member_first_name"`
	MemberLastName                     pgtype.Text   `json:"member_last_name"`
	MemberEmail                        pgtype.Text   `json:"member_email"`
	MemberProfileImageID               pgtype.UUID   `json:"member_profile_image_id"`
	MemberProfileImageHeight           pgtype.Float8 `json:"member_profile_image_height"`
	MemberProfileImageWidth            pgtype.Float8 `json:"member_profile_image_width"`
	MemberProfileImageAttachableItemID pgtype.UUID   `json:"member_profile_image_attachable_item_id"`
	MemberProfileImageOwnerID          pgtype.UUID   `json:"member_profile_image_owner_id"`
	MemberProfileImageFromOuter        pgtype.Bool   `json:"member_profile_image_from_outer"`
	MemberProfileImageAlias            pgtype.Text   `json:"member_profile_image_alias"`
	MemberProfileImageUrl              pgtype.Text   `json:"member_profile_image_url"`
	MemberProfileImageSize             pgtype.Float8 `json:"member_profile_image_size"`
	MemberProfileImageMimeTypeID       pgtype.UUID   `json:"member_profile_image_mime_type_id"`
}

func (q *Queries) GetStudentsWithMember(ctx context.Context) ([]GetStudentsWithMemberRow, error) {
	rows, err := q.db.Query(ctx, getStudentsWithMember)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetStudentsWithMemberRow{}
	for rows.Next() {
		var i GetStudentsWithMemberRow
		if err := rows.Scan(
			&i.MStudentsPkey,
			&i.StudentID,
			&i.MemberID,
			&i.MemberName,
			&i.MemberFirstName,
			&i.MemberLastName,
			&i.MemberEmail,
			&i.MemberProfileImageID,
			&i.MemberProfileImageHeight,
			&i.MemberProfileImageWidth,
			&i.MemberProfileImageAttachableItemID,
			&i.MemberProfileImageOwnerID,
			&i.MemberProfileImageFromOuter,
			&i.MemberProfileImageAlias,
			&i.MemberProfileImageUrl,
			&i.MemberProfileImageSize,
			&i.MemberProfileImageMimeTypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStudentsWithMemberUseKeysetPaginate = `-- name: GetStudentsWithMemberUseKeysetPaginate :many
SELECT m_students.m_students_pkey, m_students.student_id, m_students.member_id, m_members.name member_name, m_members.first_name member_first_name, m_members.last_name member_last_name, m_members.email member_email,
m_members.profile_image_id member_profile_image_id, t_images.height member_profile_image_height,
t_images.width member_profile_image_width, t_images.attachable_item_id member_profile_image_attachable_item_id,
t_attachable_items.owner_id member_profile_image_owner_id, t_attachable_items.from_outer member_profile_image_from_outer, t_attachable_items.alias member_profile_image_alias,
t_attachable_items.url member_profile_image_url, t_attachable_items.size member_profile_image_size, t_attachable_items.mime_type_id member_profile_image_mime_type_id FROM m_students
LEFT JOIN m_members ON m_students.member_id = m_members.member_id
LEFT JOIN t_images ON m_members.profile_image_id = t_images.image_id
LEFT JOIN t_attachable_items ON t_images.attachable_item_id = t_attachable_items.attachable_item_id
WHERE
	CASE $2::text
		WHEN 'next' THEN
			m_students_pkey > $3::int
		WHEN 'prev' THEN
			m_students_pkey < $3::int
	END
ORDER BY
	CASE WHEN $2::text = 'next' THEN m_students_pkey END ASC,
	CASE WHEN $2::text = 'prev' THEN m_students_pkey END DESC
LIMIT $1
`

type GetStudentsWithMemberUseKeysetPaginateParams struct {
	Limit           int32  `json:"limit"`
	CursorDirection string `json:"cursor_direction"`
	Cursor          int32  `json:"cursor"`
}

type GetStudentsWithMemberUseKeysetPaginateRow struct {
	MStudentsPkey                      pgtype.Int8   `json:"m_students_pkey"`
	StudentID                          uuid.UUID     `json:"student_id"`
	MemberID                           uuid.UUID     `json:"member_id"`
	MemberName                         pgtype.Text   `json:"member_name"`
	MemberFirstName                    pgtype.Text   `json:"member_first_name"`
	MemberLastName                     pgtype.Text   `json:"member_last_name"`
	MemberEmail                        pgtype.Text   `json:"member_email"`
	MemberProfileImageID               pgtype.UUID   `json:"member_profile_image_id"`
	MemberProfileImageHeight           pgtype.Float8 `json:"member_profile_image_height"`
	MemberProfileImageWidth            pgtype.Float8 `json:"member_profile_image_width"`
	MemberProfileImageAttachableItemID pgtype.UUID   `json:"member_profile_image_attachable_item_id"`
	MemberProfileImageOwnerID          pgtype.UUID   `json:"member_profile_image_owner_id"`
	MemberProfileImageFromOuter        pgtype.Bool   `json:"member_profile_image_from_outer"`
	MemberProfileImageAlias            pgtype.Text   `json:"member_profile_image_alias"`
	MemberProfileImageUrl              pgtype.Text   `json:"member_profile_image_url"`
	MemberProfileImageSize             pgtype.Float8 `json:"member_profile_image_size"`
	MemberProfileImageMimeTypeID       pgtype.UUID   `json:"member_profile_image_mime_type_id"`
}

func (q *Queries) GetStudentsWithMemberUseKeysetPaginate(ctx context.Context, arg GetStudentsWithMemberUseKeysetPaginateParams) ([]GetStudentsWithMemberUseKeysetPaginateRow, error) {
	rows, err := q.db.Query(ctx, getStudentsWithMemberUseKeysetPaginate, arg.Limit, arg.CursorDirection, arg.Cursor)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetStudentsWithMemberUseKeysetPaginateRow{}
	for rows.Next() {
		var i GetStudentsWithMemberUseKeysetPaginateRow
		if err := rows.Scan(
			&i.MStudentsPkey,
			&i.StudentID,
			&i.MemberID,
			&i.MemberName,
			&i.MemberFirstName,
			&i.MemberLastName,
			&i.MemberEmail,
			&i.MemberProfileImageID,
			&i.MemberProfileImageHeight,
			&i.MemberProfileImageWidth,
			&i.MemberProfileImageAttachableItemID,
			&i.MemberProfileImageOwnerID,
			&i.MemberProfileImageFromOuter,
			&i.MemberProfileImageAlias,
			&i.MemberProfileImageUrl,
			&i.MemberProfileImageSize,
			&i.MemberProfileImageMimeTypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStudentsWithMemberUseNumberedPaginate = `-- name: GetStudentsWithMemberUseNumberedPaginate :many
SELECT m_students.m_students_pkey, m_students.student_id, m_students.member_id, m_members.name member_name, m_members.first_name member_first_name, m_members.last_name member_last_name, m_members.email member_email,
m_members.profile_image_id member_profile_image_id, t_images.height member_profile_image_height,
t_images.width member_profile_image_width, t_images.attachable_item_id member_profile_image_attachable_item_id,
t_attachable_items.owner_id member_profile_image_owner_id, t_attachable_items.from_outer member_profile_image_from_outer, t_attachable_items.alias member_profile_image_alias,
t_attachable_items.url member_profile_image_url, t_attachable_items.size member_profile_image_size, t_attachable_items.mime_type_id member_profile_image_mime_type_id FROM m_students
LEFT JOIN m_members ON m_students.member_id = m_members.member_id
LEFT JOIN t_images ON m_members.profile_image_id = t_images.image_id
LEFT JOIN t_attachable_items ON t_images.attachable_item_id = t_attachable_items.attachable_item_id
ORDER BY
	m_students_pkey ASC
LIMIT $1 OFFSET $2
`

type GetStudentsWithMemberUseNumberedPaginateParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetStudentsWithMemberUseNumberedPaginateRow struct {
	MStudentsPkey                      pgtype.Int8   `json:"m_students_pkey"`
	StudentID                          uuid.UUID     `json:"student_id"`
	MemberID                           uuid.UUID     `json:"member_id"`
	MemberName                         pgtype.Text   `json:"member_name"`
	MemberFirstName                    pgtype.Text   `json:"member_first_name"`
	MemberLastName                     pgtype.Text   `json:"member_last_name"`
	MemberEmail                        pgtype.Text   `json:"member_email"`
	MemberProfileImageID               pgtype.UUID   `json:"member_profile_image_id"`
	MemberProfileImageHeight           pgtype.Float8 `json:"member_profile_image_height"`
	MemberProfileImageWidth            pgtype.Float8 `json:"member_profile_image_width"`
	MemberProfileImageAttachableItemID pgtype.UUID   `json:"member_profile_image_attachable_item_id"`
	MemberProfileImageOwnerID          pgtype.UUID   `json:"member_profile_image_owner_id"`
	MemberProfileImageFromOuter        pgtype.Bool   `json:"member_profile_image_from_outer"`
	MemberProfileImageAlias            pgtype.Text   `json:"member_profile_image_alias"`
	MemberProfileImageUrl              pgtype.Text   `json:"member_profile_image_url"`
	MemberProfileImageSize             pgtype.Float8 `json:"member_profile_image_size"`
	MemberProfileImageMimeTypeID       pgtype.UUID   `json:"member_profile_image_mime_type_id"`
}

func (q *Queries) GetStudentsWithMemberUseNumberedPaginate(ctx context.Context, arg GetStudentsWithMemberUseNumberedPaginateParams) ([]GetStudentsWithMemberUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getStudentsWithMemberUseNumberedPaginate, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetStudentsWithMemberUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetStudentsWithMemberUseNumberedPaginateRow
		if err := rows.Scan(
			&i.MStudentsPkey,
			&i.StudentID,
			&i.MemberID,
			&i.MemberName,
			&i.MemberFirstName,
			&i.MemberLastName,
			&i.MemberEmail,
			&i.MemberProfileImageID,
			&i.MemberProfileImageHeight,
			&i.MemberProfileImageWidth,
			&i.MemberProfileImageAttachableItemID,
			&i.MemberProfileImageOwnerID,
			&i.MemberProfileImageFromOuter,
			&i.MemberProfileImageAlias,
			&i.MemberProfileImageUrl,
			&i.MemberProfileImageSize,
			&i.MemberProfileImageMimeTypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const pluralDeleteStudents = `-- name: PluralDeleteStudents :execrows
DELETE FROM m_students WHERE student_id = ANY($1::uuid[])
`

func (q *Queries) PluralDeleteStudents(ctx context.Context, studentIds []uuid.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, pluralDeleteStudents, studentIds)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
