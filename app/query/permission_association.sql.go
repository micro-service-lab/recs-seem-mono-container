// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: permission_association.sql

package query

import (
	"context"

	"github.com/google/uuid"
)

const countPermissionsByWorkPositionID = `-- name: CountPermissionsByWorkPositionID :one
SELECT COUNT(*) FROM m_permission_associations WHERE work_position_id = $1
`

func (q *Queries) CountPermissionsByWorkPositionID(ctx context.Context, workPositionID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countPermissionsByWorkPositionID, workPositionID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countWorkPositionsByPermissionID = `-- name: CountWorkPositionsByPermissionID :one
SELECT COUNT(*) FROM m_permission_associations WHERE permission_id = $1
`

func (q *Queries) CountWorkPositionsByPermissionID(ctx context.Context, permissionID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countWorkPositionsByPermissionID, permissionID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createPermissionAssociation = `-- name: CreatePermissionAssociation :one
INSERT INTO m_permission_associations (permission_id, work_position_id) VALUES ($1, $2) RETURNING m_permission_associations_pkey, permission_id, work_position_id
`

type CreatePermissionAssociationParams struct {
	PermissionID   uuid.UUID `json:"permission_id"`
	WorkPositionID uuid.UUID `json:"work_position_id"`
}

func (q *Queries) CreatePermissionAssociation(ctx context.Context, arg CreatePermissionAssociationParams) (PermissionAssociation, error) {
	row := q.db.QueryRow(ctx, createPermissionAssociation, arg.PermissionID, arg.WorkPositionID)
	var i PermissionAssociation
	err := row.Scan(&i.MPermissionAssociationsPkey, &i.PermissionID, &i.WorkPositionID)
	return i, err
}

type CreatePermissionAssociationsParams struct {
	PermissionID   uuid.UUID `json:"permission_id"`
	WorkPositionID uuid.UUID `json:"work_position_id"`
}

const deletePermissionAssociation = `-- name: DeletePermissionAssociation :exec
DELETE FROM m_permission_associations WHERE permission_id = $1 AND work_position_id = $2
`

type DeletePermissionAssociationParams struct {
	PermissionID   uuid.UUID `json:"permission_id"`
	WorkPositionID uuid.UUID `json:"work_position_id"`
}

func (q *Queries) DeletePermissionAssociation(ctx context.Context, arg DeletePermissionAssociationParams) error {
	_, err := q.db.Exec(ctx, deletePermissionAssociation, arg.PermissionID, arg.WorkPositionID)
	return err
}

const getPermissionsByWorkPositionID = `-- name: GetPermissionsByWorkPositionID :many
SELECT m_permission_associations.m_permission_associations_pkey, m_permission_associations.permission_id, m_permission_associations.work_position_id, m_permissions.m_permissions_pkey, m_permissions.permission_id, m_permissions.name, m_permissions.description, m_permissions.key, m_permissions.permission_category_id FROM m_permission_associations
INNER JOIN m_permissions ON m_permission_associations.permission_id = m_permissions.permission_id
WHERE work_position_id = $1
AND CASE
	WHEN $4::boolean = true THEN m_permissions.name LIKE '%' || $5::text || '%'
END
ORDER BY
	CASE WHEN $6::text = 'name' THEN m_permissions.name END ASC,
	m_permission_associations_pkey DESC
LIMIT $2 OFFSET $3
`

type GetPermissionsByWorkPositionIDParams struct {
	WorkPositionID uuid.UUID `json:"work_position_id"`
	Limit          int32     `json:"limit"`
	Offset         int32     `json:"offset"`
	WhereLikeName  bool      `json:"where_like_name"`
	SearchName     string    `json:"search_name"`
	OrderMethod    string    `json:"order_method"`
}

type GetPermissionsByWorkPositionIDRow struct {
	PermissionAssociation PermissionAssociation `json:"permission_association"`
	Permission            Permission            `json:"permission"`
}

func (q *Queries) GetPermissionsByWorkPositionID(ctx context.Context, arg GetPermissionsByWorkPositionIDParams) ([]GetPermissionsByWorkPositionIDRow, error) {
	rows, err := q.db.Query(ctx, getPermissionsByWorkPositionID,
		arg.WorkPositionID,
		arg.Limit,
		arg.Offset,
		arg.WhereLikeName,
		arg.SearchName,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPermissionsByWorkPositionIDRow{}
	for rows.Next() {
		var i GetPermissionsByWorkPositionIDRow
		if err := rows.Scan(
			&i.PermissionAssociation.MPermissionAssociationsPkey,
			&i.PermissionAssociation.PermissionID,
			&i.PermissionAssociation.WorkPositionID,
			&i.Permission.MPermissionsPkey,
			&i.Permission.PermissionID,
			&i.Permission.Name,
			&i.Permission.Description,
			&i.Permission.Key,
			&i.Permission.PermissionCategoryID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWorkPositionsByPermissionID = `-- name: GetWorkPositionsByPermissionID :many
SELECT m_permission_associations.m_permission_associations_pkey, m_permission_associations.permission_id, m_permission_associations.work_position_id, m_work_positions.m_work_positions_pkey, m_work_positions.work_position_id, m_work_positions.name, m_work_positions.description, m_work_positions.created_at, m_work_positions.updated_at FROM m_permission_associations
INNER JOIN m_work_positions ON m_permission_associations.work_position_id = m_work_positions.work_position_id
WHERE permission_id = $1
AND CASE
	WHEN $4::boolean = true THEN m_work_positions.name LIKE '%' || $5::text || '%'
END
ORDER BY
	CASE WHEN $6::text = 'name' THEN m_work_positions.name END ASC,
	m_permission_associations_pkey DESC
LIMIT $2 OFFSET $3
`

type GetWorkPositionsByPermissionIDParams struct {
	PermissionID  uuid.UUID `json:"permission_id"`
	Limit         int32     `json:"limit"`
	Offset        int32     `json:"offset"`
	WhereLikeName bool      `json:"where_like_name"`
	SearchName    string    `json:"search_name"`
	OrderMethod   string    `json:"order_method"`
}

type GetWorkPositionsByPermissionIDRow struct {
	PermissionAssociation PermissionAssociation `json:"permission_association"`
	WorkPosition          WorkPosition          `json:"work_position"`
}

func (q *Queries) GetWorkPositionsByPermissionID(ctx context.Context, arg GetWorkPositionsByPermissionIDParams) ([]GetWorkPositionsByPermissionIDRow, error) {
	rows, err := q.db.Query(ctx, getWorkPositionsByPermissionID,
		arg.PermissionID,
		arg.Limit,
		arg.Offset,
		arg.WhereLikeName,
		arg.SearchName,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetWorkPositionsByPermissionIDRow{}
	for rows.Next() {
		var i GetWorkPositionsByPermissionIDRow
		if err := rows.Scan(
			&i.PermissionAssociation.MPermissionAssociationsPkey,
			&i.PermissionAssociation.PermissionID,
			&i.PermissionAssociation.WorkPositionID,
			&i.WorkPosition.MWorkPositionsPkey,
			&i.WorkPosition.WorkPositionID,
			&i.WorkPosition.Name,
			&i.WorkPosition.Description,
			&i.WorkPosition.CreatedAt,
			&i.WorkPosition.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
