// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: role_association.sql

package query

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countPoliciesOnRole = `-- name: CountPoliciesOnRole :one
SELECT COUNT(*) FROM m_role_associations
LEFT JOIN m_policies ON m_role_associations.policy_id = m_policies.policy_id
WHERE role_id = $1
AND
	CASE WHEN $2::boolean = true THEN m_policies.name LIKE '%' || $3::text || '%' ELSE TRUE END
`

type CountPoliciesOnRoleParams struct {
	RoleID        uuid.UUID `json:"role_id"`
	WhereLikeName bool      `json:"where_like_name"`
	SearchName    string    `json:"search_name"`
}

func (q *Queries) CountPoliciesOnRole(ctx context.Context, arg CountPoliciesOnRoleParams) (int64, error) {
	row := q.db.QueryRow(ctx, countPoliciesOnRole, arg.RoleID, arg.WhereLikeName, arg.SearchName)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countRolesOnPolicy = `-- name: CountRolesOnPolicy :one
SELECT COUNT(*) FROM m_role_associations
LEFT JOIN m_roles ON m_role_associations.role_id = m_roles.role_id
WHERE policy_id = $1
AND
	CASE WHEN $2::boolean = true THEN m_roles.name LIKE '%' || $3::text || '%' ELSE TRUE END
`

type CountRolesOnPolicyParams struct {
	PolicyID      uuid.UUID `json:"policy_id"`
	WhereLikeName bool      `json:"where_like_name"`
	SearchName    string    `json:"search_name"`
}

func (q *Queries) CountRolesOnPolicy(ctx context.Context, arg CountRolesOnPolicyParams) (int64, error) {
	row := q.db.QueryRow(ctx, countRolesOnPolicy, arg.PolicyID, arg.WhereLikeName, arg.SearchName)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createRoleAssociation = `-- name: CreateRoleAssociation :one
INSERT INTO m_role_associations (role_id, policy_id) VALUES ($1, $2) RETURNING m_role_associations_pkey, role_id, policy_id
`

type CreateRoleAssociationParams struct {
	RoleID   uuid.UUID `json:"role_id"`
	PolicyID uuid.UUID `json:"policy_id"`
}

func (q *Queries) CreateRoleAssociation(ctx context.Context, arg CreateRoleAssociationParams) (RoleAssociation, error) {
	row := q.db.QueryRow(ctx, createRoleAssociation, arg.RoleID, arg.PolicyID)
	var i RoleAssociation
	err := row.Scan(&i.MRoleAssociationsPkey, &i.RoleID, &i.PolicyID)
	return i, err
}

type CreateRoleAssociationsParams struct {
	RoleID   uuid.UUID `json:"role_id"`
	PolicyID uuid.UUID `json:"policy_id"`
}

const deleteRoleAssociation = `-- name: DeleteRoleAssociation :execrows
DELETE FROM m_role_associations WHERE role_id = $1 AND policy_id = $2
`

type DeleteRoleAssociationParams struct {
	RoleID   uuid.UUID `json:"role_id"`
	PolicyID uuid.UUID `json:"policy_id"`
}

func (q *Queries) DeleteRoleAssociation(ctx context.Context, arg DeleteRoleAssociationParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteRoleAssociation, arg.RoleID, arg.PolicyID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteRoleAssociationsOnPolicies = `-- name: DeleteRoleAssociationsOnPolicies :execrows
DELETE FROM m_role_associations WHERE policy_id = ANY($1::uuid[])
`

func (q *Queries) DeleteRoleAssociationsOnPolicies(ctx context.Context, policyIds []uuid.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, deleteRoleAssociationsOnPolicies, policyIds)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteRoleAssociationsOnPolicy = `-- name: DeleteRoleAssociationsOnPolicy :execrows
DELETE FROM m_role_associations WHERE policy_id = $1
`

func (q *Queries) DeleteRoleAssociationsOnPolicy(ctx context.Context, policyID uuid.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, deleteRoleAssociationsOnPolicy, policyID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteRoleAssociationsOnRole = `-- name: DeleteRoleAssociationsOnRole :execrows
DELETE FROM m_role_associations WHERE role_id = $1
`

func (q *Queries) DeleteRoleAssociationsOnRole(ctx context.Context, roleID uuid.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, deleteRoleAssociationsOnRole, roleID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteRoleAssociationsOnRoles = `-- name: DeleteRoleAssociationsOnRoles :execrows
DELETE FROM m_role_associations WHERE role_id = ANY($1::uuid[])
`

func (q *Queries) DeleteRoleAssociationsOnRoles(ctx context.Context, roleIds []uuid.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, deleteRoleAssociationsOnRoles, roleIds)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getPluralPoliciesOnRole = `-- name: GetPluralPoliciesOnRole :many
SELECT m_role_associations.m_role_associations_pkey, m_role_associations.role_id, m_role_associations.policy_id, m_policies.name policy_name, m_policies.key policy_key,
m_policies.description policy_description, m_policies.policy_category_id FROM m_role_associations
LEFT JOIN m_policies ON m_role_associations.policy_id = m_policies.policy_id
WHERE
	role_id = ANY($1::uuid[])
ORDER BY
	CASE WHEN $2::text = 'name' THEN m_policies.name END ASC,
	CASE WHEN $2::text = 'r_name' THEN m_policies.name END DESC,
	m_role_associations_pkey ASC
`

type GetPluralPoliciesOnRoleParams struct {
	RoleIds     []uuid.UUID `json:"role_ids"`
	OrderMethod string      `json:"order_method"`
}

type GetPluralPoliciesOnRoleRow struct {
	MRoleAssociationsPkey pgtype.Int8 `json:"m_role_associations_pkey"`
	RoleID                uuid.UUID   `json:"role_id"`
	PolicyID              uuid.UUID   `json:"policy_id"`
	PolicyName            pgtype.Text `json:"policy_name"`
	PolicyKey             pgtype.Text `json:"policy_key"`
	PolicyDescription     pgtype.Text `json:"policy_description"`
	PolicyCategoryID      pgtype.UUID `json:"policy_category_id"`
}

func (q *Queries) GetPluralPoliciesOnRole(ctx context.Context, arg GetPluralPoliciesOnRoleParams) ([]GetPluralPoliciesOnRoleRow, error) {
	rows, err := q.db.Query(ctx, getPluralPoliciesOnRole, arg.RoleIds, arg.OrderMethod)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralPoliciesOnRoleRow{}
	for rows.Next() {
		var i GetPluralPoliciesOnRoleRow
		if err := rows.Scan(
			&i.MRoleAssociationsPkey,
			&i.RoleID,
			&i.PolicyID,
			&i.PolicyName,
			&i.PolicyKey,
			&i.PolicyDescription,
			&i.PolicyCategoryID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralPoliciesOnRoleUseNumberedPaginate = `-- name: GetPluralPoliciesOnRoleUseNumberedPaginate :many
SELECT m_role_associations.m_role_associations_pkey, m_role_associations.role_id, m_role_associations.policy_id, m_policies.name policy_name, m_policies.key policy_key,
m_policies.description policy_description, m_policies.policy_category_id FROM m_role_associations
LEFT JOIN m_policies ON m_role_associations.policy_id = m_policies.policy_id
WHERE
	role_id = ANY($3::uuid[])
ORDER BY
	CASE WHEN $4::text = 'name' THEN m_policies.name END ASC,
	CASE WHEN $4::text = 'r_name' THEN m_policies.name END DESC,
	m_role_associations_pkey ASC
LIMIT $1 OFFSET $2
`

type GetPluralPoliciesOnRoleUseNumberedPaginateParams struct {
	Limit       int32       `json:"limit"`
	Offset      int32       `json:"offset"`
	RoleIds     []uuid.UUID `json:"role_ids"`
	OrderMethod string      `json:"order_method"`
}

type GetPluralPoliciesOnRoleUseNumberedPaginateRow struct {
	MRoleAssociationsPkey pgtype.Int8 `json:"m_role_associations_pkey"`
	RoleID                uuid.UUID   `json:"role_id"`
	PolicyID              uuid.UUID   `json:"policy_id"`
	PolicyName            pgtype.Text `json:"policy_name"`
	PolicyKey             pgtype.Text `json:"policy_key"`
	PolicyDescription     pgtype.Text `json:"policy_description"`
	PolicyCategoryID      pgtype.UUID `json:"policy_category_id"`
}

func (q *Queries) GetPluralPoliciesOnRoleUseNumberedPaginate(ctx context.Context, arg GetPluralPoliciesOnRoleUseNumberedPaginateParams) ([]GetPluralPoliciesOnRoleUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getPluralPoliciesOnRoleUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.RoleIds,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralPoliciesOnRoleUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetPluralPoliciesOnRoleUseNumberedPaginateRow
		if err := rows.Scan(
			&i.MRoleAssociationsPkey,
			&i.RoleID,
			&i.PolicyID,
			&i.PolicyName,
			&i.PolicyKey,
			&i.PolicyDescription,
			&i.PolicyCategoryID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralRolesOnPolicy = `-- name: GetPluralRolesOnPolicy :many
SELECT m_role_associations.m_role_associations_pkey, m_role_associations.role_id, m_role_associations.policy_id, m_roles.name role_name, m_roles.description role_description FROM m_role_associations
LEFT JOIN m_roles ON m_role_associations.role_id = m_roles.role_id
WHERE
	policy_id = ANY($1::uuid[])
ORDER BY
	CASE WHEN $2::text = 'name' THEN m_roles.name END ASC,
	CASE WHEN $2::text = 'r_name' THEN m_roles.name END DESC,
	m_role_associations_pkey ASC
`

type GetPluralRolesOnPolicyParams struct {
	PolicyIds   []uuid.UUID `json:"policy_ids"`
	OrderMethod string      `json:"order_method"`
}

type GetPluralRolesOnPolicyRow struct {
	MRoleAssociationsPkey pgtype.Int8 `json:"m_role_associations_pkey"`
	RoleID                uuid.UUID   `json:"role_id"`
	PolicyID              uuid.UUID   `json:"policy_id"`
	RoleName              pgtype.Text `json:"role_name"`
	RoleDescription       pgtype.Text `json:"role_description"`
}

func (q *Queries) GetPluralRolesOnPolicy(ctx context.Context, arg GetPluralRolesOnPolicyParams) ([]GetPluralRolesOnPolicyRow, error) {
	rows, err := q.db.Query(ctx, getPluralRolesOnPolicy, arg.PolicyIds, arg.OrderMethod)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralRolesOnPolicyRow{}
	for rows.Next() {
		var i GetPluralRolesOnPolicyRow
		if err := rows.Scan(
			&i.MRoleAssociationsPkey,
			&i.RoleID,
			&i.PolicyID,
			&i.RoleName,
			&i.RoleDescription,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralRolesOnPolicyUseNumberedPaginate = `-- name: GetPluralRolesOnPolicyUseNumberedPaginate :many
SELECT m_role_associations.m_role_associations_pkey, m_role_associations.role_id, m_role_associations.policy_id, m_roles.name role_name, m_roles.description role_description FROM m_role_associations
LEFT JOIN m_roles ON m_role_associations.role_id = m_roles.role_id
WHERE
	policy_id = ANY($3::uuid[])
ORDER BY
	CASE WHEN $4::text = 'name' THEN m_roles.name END ASC,
	CASE WHEN $4::text = 'r_name' THEN m_roles.name END DESC,
	m_role_associations_pkey ASC
LIMIT $1 OFFSET $2
`

type GetPluralRolesOnPolicyUseNumberedPaginateParams struct {
	Limit       int32       `json:"limit"`
	Offset      int32       `json:"offset"`
	PolicyIds   []uuid.UUID `json:"policy_ids"`
	OrderMethod string      `json:"order_method"`
}

type GetPluralRolesOnPolicyUseNumberedPaginateRow struct {
	MRoleAssociationsPkey pgtype.Int8 `json:"m_role_associations_pkey"`
	RoleID                uuid.UUID   `json:"role_id"`
	PolicyID              uuid.UUID   `json:"policy_id"`
	RoleName              pgtype.Text `json:"role_name"`
	RoleDescription       pgtype.Text `json:"role_description"`
}

func (q *Queries) GetPluralRolesOnPolicyUseNumberedPaginate(ctx context.Context, arg GetPluralRolesOnPolicyUseNumberedPaginateParams) ([]GetPluralRolesOnPolicyUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getPluralRolesOnPolicyUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.PolicyIds,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralRolesOnPolicyUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetPluralRolesOnPolicyUseNumberedPaginateRow
		if err := rows.Scan(
			&i.MRoleAssociationsPkey,
			&i.RoleID,
			&i.PolicyID,
			&i.RoleName,
			&i.RoleDescription,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPoliciesOnRole = `-- name: GetPoliciesOnRole :many
SELECT m_role_associations.m_role_associations_pkey, m_role_associations.role_id, m_role_associations.policy_id, m_policies.name policy_name, m_policies.key policy_key,
m_policies.description policy_description, m_policies.policy_category_id FROM m_role_associations
LEFT JOIN m_policies ON m_role_associations.policy_id = m_policies.policy_id
WHERE role_id = $1
AND
	CASE WHEN $2::boolean = true THEN m_policies.name LIKE '%' || $3::text || '%' ELSE TRUE END
ORDER BY
	CASE WHEN $4::text = 'name' THEN m_policies.name END ASC,
	CASE WHEN $4::text = 'r_name' THEN m_policies.name END DESC,
	m_role_associations_pkey ASC
`

type GetPoliciesOnRoleParams struct {
	RoleID        uuid.UUID `json:"role_id"`
	WhereLikeName bool      `json:"where_like_name"`
	SearchName    string    `json:"search_name"`
	OrderMethod   string    `json:"order_method"`
}

type GetPoliciesOnRoleRow struct {
	MRoleAssociationsPkey pgtype.Int8 `json:"m_role_associations_pkey"`
	RoleID                uuid.UUID   `json:"role_id"`
	PolicyID              uuid.UUID   `json:"policy_id"`
	PolicyName            pgtype.Text `json:"policy_name"`
	PolicyKey             pgtype.Text `json:"policy_key"`
	PolicyDescription     pgtype.Text `json:"policy_description"`
	PolicyCategoryID      pgtype.UUID `json:"policy_category_id"`
}

func (q *Queries) GetPoliciesOnRole(ctx context.Context, arg GetPoliciesOnRoleParams) ([]GetPoliciesOnRoleRow, error) {
	rows, err := q.db.Query(ctx, getPoliciesOnRole,
		arg.RoleID,
		arg.WhereLikeName,
		arg.SearchName,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPoliciesOnRoleRow{}
	for rows.Next() {
		var i GetPoliciesOnRoleRow
		if err := rows.Scan(
			&i.MRoleAssociationsPkey,
			&i.RoleID,
			&i.PolicyID,
			&i.PolicyName,
			&i.PolicyKey,
			&i.PolicyDescription,
			&i.PolicyCategoryID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPoliciesOnRoleUseKeysetPaginate = `-- name: GetPoliciesOnRoleUseKeysetPaginate :many
SELECT m_role_associations.m_role_associations_pkey, m_role_associations.role_id, m_role_associations.policy_id, m_policies.name policy_name, m_policies.key policy_key,
m_policies.description policy_description, m_policies.policy_category_id FROM m_role_associations
LEFT JOIN m_policies ON m_role_associations.policy_id = m_policies.policy_id
WHERE role_id = $1
AND
	CASE WHEN $3::boolean = true THEN m_policies.name LIKE '%' || $4::text || '%' ELSE TRUE END
AND
	CASE $5::text
		WHEN 'next' THEN
			CASE $6::text
				WHEN 'name' THEN m_policies.name > $7 OR (m_policies.name = $7 AND m_role_associations_pkey > $8::int)
				WHEN 'r_name' THEN m_policies.name < $7 OR (m_policies.name = $7 AND m_role_associations_pkey > $8::int)
				ELSE m_role_associations_pkey > $8::int
			END
		WHEN 'prev' THEN
			CASE $6::text
				WHEN 'name' THEN m_policies.name < $7 OR (m_policies.name = $7 AND m_role_associations_pkey < $8::int)
				WHEN 'r_name' THEN m_policies.name > $7 OR (m_policies.name = $7 AND m_role_associations_pkey < $8::int)
				ELSE m_role_associations_pkey < $8::int
			END
	END
ORDER BY
	CASE WHEN $6::text = 'name' AND $5::text = 'next' THEN m_policies.name END ASC,
	CASE WHEN $6::text = 'name' AND $5::text = 'prev' THEN m_policies.name END DESC,
	CASE WHEN $6::text = 'r_name' AND $5::text = 'next' THEN m_policies.name END DESC,
	CASE WHEN $6::text = 'r_name' AND $5::text = 'prev' THEN m_policies.name END ASC,
	CASE WHEN $5::text = 'next' THEN m_role_associations_pkey END ASC,
	CASE WHEN $5::text = 'prev' THEN m_role_associations_pkey END DESC
LIMIT $2
`

type GetPoliciesOnRoleUseKeysetPaginateParams struct {
	RoleID          uuid.UUID `json:"role_id"`
	Limit           int32     `json:"limit"`
	WhereLikeName   bool      `json:"where_like_name"`
	SearchName      string    `json:"search_name"`
	CursorDirection string    `json:"cursor_direction"`
	OrderMethod     string    `json:"order_method"`
	NameCursor      string    `json:"name_cursor"`
	Cursor          int32     `json:"cursor"`
}

type GetPoliciesOnRoleUseKeysetPaginateRow struct {
	MRoleAssociationsPkey pgtype.Int8 `json:"m_role_associations_pkey"`
	RoleID                uuid.UUID   `json:"role_id"`
	PolicyID              uuid.UUID   `json:"policy_id"`
	PolicyName            pgtype.Text `json:"policy_name"`
	PolicyKey             pgtype.Text `json:"policy_key"`
	PolicyDescription     pgtype.Text `json:"policy_description"`
	PolicyCategoryID      pgtype.UUID `json:"policy_category_id"`
}

func (q *Queries) GetPoliciesOnRoleUseKeysetPaginate(ctx context.Context, arg GetPoliciesOnRoleUseKeysetPaginateParams) ([]GetPoliciesOnRoleUseKeysetPaginateRow, error) {
	rows, err := q.db.Query(ctx, getPoliciesOnRoleUseKeysetPaginate,
		arg.RoleID,
		arg.Limit,
		arg.WhereLikeName,
		arg.SearchName,
		arg.CursorDirection,
		arg.OrderMethod,
		arg.NameCursor,
		arg.Cursor,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPoliciesOnRoleUseKeysetPaginateRow{}
	for rows.Next() {
		var i GetPoliciesOnRoleUseKeysetPaginateRow
		if err := rows.Scan(
			&i.MRoleAssociationsPkey,
			&i.RoleID,
			&i.PolicyID,
			&i.PolicyName,
			&i.PolicyKey,
			&i.PolicyDescription,
			&i.PolicyCategoryID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPoliciesOnRoleUseNumberedPaginate = `-- name: GetPoliciesOnRoleUseNumberedPaginate :many
SELECT m_role_associations.m_role_associations_pkey, m_role_associations.role_id, m_role_associations.policy_id, m_policies.name policy_name, m_policies.key policy_key,
m_policies.description policy_description, m_policies.policy_category_id FROM m_role_associations
LEFT JOIN m_policies ON m_role_associations.policy_id = m_policies.policy_id
WHERE role_id = $1
AND
	CASE WHEN $4::boolean = true THEN m_policies.name LIKE '%' || $5::text || '%' ELSE TRUE END
ORDER BY
	CASE WHEN $6::text = 'name' THEN m_policies.name END ASC,
	CASE WHEN $6::text = 'r_name' THEN m_policies.name END DESC,
	m_role_associations_pkey ASC
LIMIT $2 OFFSET $3
`

type GetPoliciesOnRoleUseNumberedPaginateParams struct {
	RoleID        uuid.UUID `json:"role_id"`
	Limit         int32     `json:"limit"`
	Offset        int32     `json:"offset"`
	WhereLikeName bool      `json:"where_like_name"`
	SearchName    string    `json:"search_name"`
	OrderMethod   string    `json:"order_method"`
}

type GetPoliciesOnRoleUseNumberedPaginateRow struct {
	MRoleAssociationsPkey pgtype.Int8 `json:"m_role_associations_pkey"`
	RoleID                uuid.UUID   `json:"role_id"`
	PolicyID              uuid.UUID   `json:"policy_id"`
	PolicyName            pgtype.Text `json:"policy_name"`
	PolicyKey             pgtype.Text `json:"policy_key"`
	PolicyDescription     pgtype.Text `json:"policy_description"`
	PolicyCategoryID      pgtype.UUID `json:"policy_category_id"`
}

func (q *Queries) GetPoliciesOnRoleUseNumberedPaginate(ctx context.Context, arg GetPoliciesOnRoleUseNumberedPaginateParams) ([]GetPoliciesOnRoleUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getPoliciesOnRoleUseNumberedPaginate,
		arg.RoleID,
		arg.Limit,
		arg.Offset,
		arg.WhereLikeName,
		arg.SearchName,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPoliciesOnRoleUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetPoliciesOnRoleUseNumberedPaginateRow
		if err := rows.Scan(
			&i.MRoleAssociationsPkey,
			&i.RoleID,
			&i.PolicyID,
			&i.PolicyName,
			&i.PolicyKey,
			&i.PolicyDescription,
			&i.PolicyCategoryID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRolesOnPolicy = `-- name: GetRolesOnPolicy :many
SELECT m_role_associations.m_role_associations_pkey, m_role_associations.role_id, m_role_associations.policy_id, m_roles.name role_name, m_roles.description role_description FROM m_role_associations
LEFT JOIN m_roles ON m_role_associations.role_id = m_roles.role_id
WHERE policy_id = $1
AND
	CASE WHEN $2::boolean = true THEN m_roles.name LIKE '%' || $3::text || '%' ELSE TRUE END
ORDER BY
	CASE WHEN $4::text = 'name' THEN m_roles.name END ASC,
	CASE WHEN $4::text = 'r_name' THEN m_roles.name END DESC,
	m_role_associations_pkey ASC
`

type GetRolesOnPolicyParams struct {
	PolicyID      uuid.UUID `json:"policy_id"`
	WhereLikeName bool      `json:"where_like_name"`
	SearchName    string    `json:"search_name"`
	OrderMethod   string    `json:"order_method"`
}

type GetRolesOnPolicyRow struct {
	MRoleAssociationsPkey pgtype.Int8 `json:"m_role_associations_pkey"`
	RoleID                uuid.UUID   `json:"role_id"`
	PolicyID              uuid.UUID   `json:"policy_id"`
	RoleName              pgtype.Text `json:"role_name"`
	RoleDescription       pgtype.Text `json:"role_description"`
}

func (q *Queries) GetRolesOnPolicy(ctx context.Context, arg GetRolesOnPolicyParams) ([]GetRolesOnPolicyRow, error) {
	rows, err := q.db.Query(ctx, getRolesOnPolicy,
		arg.PolicyID,
		arg.WhereLikeName,
		arg.SearchName,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRolesOnPolicyRow{}
	for rows.Next() {
		var i GetRolesOnPolicyRow
		if err := rows.Scan(
			&i.MRoleAssociationsPkey,
			&i.RoleID,
			&i.PolicyID,
			&i.RoleName,
			&i.RoleDescription,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRolesOnPolicyUseKeysetPaginate = `-- name: GetRolesOnPolicyUseKeysetPaginate :many
SELECT m_role_associations.m_role_associations_pkey, m_role_associations.role_id, m_role_associations.policy_id, m_roles.name role_name, m_roles.description role_description FROM m_role_associations
LEFT JOIN m_roles ON m_role_associations.role_id = m_roles.role_id
WHERE policy_id = $1
AND
	CASE WHEN $3::boolean = true THEN m_roles.name LIKE '%' || $4::text || '%' ELSE TRUE END
AND
	CASE $5::text
		WHEN 'next' THEN
			CASE $6::text
				WHEN 'name' THEN m_roles.name > $7 OR (m_roles.name = $7 AND m_role_associations_pkey > $8::int)
				WHEN 'r_name' THEN m_roles.name < $7 OR (m_roles.name = $7 AND m_role_associations_pkey > $8::int)
				ELSE m_role_associations_pkey > $8::int
			END
		WHEN 'prev' THEN
			CASE $6::text
				WHEN 'name' THEN m_roles.name < $7 OR (m_roles.name = $7 AND m_role_associations_pkey < $8::int)
				WHEN 'r_name' THEN m_roles.name > $7 OR (m_roles.name = $7 AND m_role_associations_pkey < $8::int)
				ELSE m_role_associations_pkey < $8::int
			END
	END
ORDER BY
	CASE WHEN $6::text = 'name' AND $5::text = 'next' THEN m_roles.name END ASC,
	CASE WHEN $6::text = 'name' AND $5::text = 'prev' THEN m_roles.name END DESC,
	CASE WHEN $6::text = 'r_name' AND $5::text = 'next' THEN m_roles.name END DESC,
	CASE WHEN $6::text = 'r_name' AND $5::text = 'prev' THEN m_roles.name END ASC,
	CASE WHEN $5::text = 'next' THEN m_role_associations_pkey END ASC,
	CASE WHEN $5::text = 'prev' THEN m_role_associations_pkey END DESC
LIMIT $2
`

type GetRolesOnPolicyUseKeysetPaginateParams struct {
	PolicyID        uuid.UUID `json:"policy_id"`
	Limit           int32     `json:"limit"`
	WhereLikeName   bool      `json:"where_like_name"`
	SearchName      string    `json:"search_name"`
	CursorDirection string    `json:"cursor_direction"`
	OrderMethod     string    `json:"order_method"`
	NameCursor      string    `json:"name_cursor"`
	Cursor          int32     `json:"cursor"`
}

type GetRolesOnPolicyUseKeysetPaginateRow struct {
	MRoleAssociationsPkey pgtype.Int8 `json:"m_role_associations_pkey"`
	RoleID                uuid.UUID   `json:"role_id"`
	PolicyID              uuid.UUID   `json:"policy_id"`
	RoleName              pgtype.Text `json:"role_name"`
	RoleDescription       pgtype.Text `json:"role_description"`
}

func (q *Queries) GetRolesOnPolicyUseKeysetPaginate(ctx context.Context, arg GetRolesOnPolicyUseKeysetPaginateParams) ([]GetRolesOnPolicyUseKeysetPaginateRow, error) {
	rows, err := q.db.Query(ctx, getRolesOnPolicyUseKeysetPaginate,
		arg.PolicyID,
		arg.Limit,
		arg.WhereLikeName,
		arg.SearchName,
		arg.CursorDirection,
		arg.OrderMethod,
		arg.NameCursor,
		arg.Cursor,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRolesOnPolicyUseKeysetPaginateRow{}
	for rows.Next() {
		var i GetRolesOnPolicyUseKeysetPaginateRow
		if err := rows.Scan(
			&i.MRoleAssociationsPkey,
			&i.RoleID,
			&i.PolicyID,
			&i.RoleName,
			&i.RoleDescription,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRolesOnPolicyUseNumberedPaginate = `-- name: GetRolesOnPolicyUseNumberedPaginate :many
SELECT m_role_associations.m_role_associations_pkey, m_role_associations.role_id, m_role_associations.policy_id, m_roles.name role_name, m_roles.description role_description FROM m_role_associations
LEFT JOIN m_roles ON m_role_associations.role_id = m_roles.role_id
WHERE policy_id = $1
AND
	CASE WHEN $4::boolean = true THEN m_roles.name LIKE '%' || $5::text || '%' ELSE TRUE END
ORDER BY
	CASE WHEN $6::text = 'name' THEN m_roles.name END ASC,
	CASE WHEN $6::text = 'r_name' THEN m_roles.name END DESC,
	m_role_associations_pkey ASC
LIMIT $2 OFFSET $3
`

type GetRolesOnPolicyUseNumberedPaginateParams struct {
	PolicyID      uuid.UUID `json:"policy_id"`
	Limit         int32     `json:"limit"`
	Offset        int32     `json:"offset"`
	WhereLikeName bool      `json:"where_like_name"`
	SearchName    string    `json:"search_name"`
	OrderMethod   string    `json:"order_method"`
}

type GetRolesOnPolicyUseNumberedPaginateRow struct {
	MRoleAssociationsPkey pgtype.Int8 `json:"m_role_associations_pkey"`
	RoleID                uuid.UUID   `json:"role_id"`
	PolicyID              uuid.UUID   `json:"policy_id"`
	RoleName              pgtype.Text `json:"role_name"`
	RoleDescription       pgtype.Text `json:"role_description"`
}

func (q *Queries) GetRolesOnPolicyUseNumberedPaginate(ctx context.Context, arg GetRolesOnPolicyUseNumberedPaginateParams) ([]GetRolesOnPolicyUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getRolesOnPolicyUseNumberedPaginate,
		arg.PolicyID,
		arg.Limit,
		arg.Offset,
		arg.WhereLikeName,
		arg.SearchName,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRolesOnPolicyUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetRolesOnPolicyUseNumberedPaginateRow
		if err := rows.Scan(
			&i.MRoleAssociationsPkey,
			&i.RoleID,
			&i.PolicyID,
			&i.RoleName,
			&i.RoleDescription,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const pluralDeleteRoleAssociationsOnPolicy = `-- name: PluralDeleteRoleAssociationsOnPolicy :execrows
DELETE FROM m_role_associations WHERE policy_id = $1 AND role_id = ANY($2::uuid[])
`

type PluralDeleteRoleAssociationsOnPolicyParams struct {
	PolicyID uuid.UUID   `json:"policy_id"`
	RoleIds  []uuid.UUID `json:"role_ids"`
}

func (q *Queries) PluralDeleteRoleAssociationsOnPolicy(ctx context.Context, arg PluralDeleteRoleAssociationsOnPolicyParams) (int64, error) {
	result, err := q.db.Exec(ctx, pluralDeleteRoleAssociationsOnPolicy, arg.PolicyID, arg.RoleIds)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const pluralDeleteRoleAssociationsOnRole = `-- name: PluralDeleteRoleAssociationsOnRole :execrows
DELETE FROM m_role_associations WHERE role_id = $1 AND policy_id = ANY($2::uuid[])
`

type PluralDeleteRoleAssociationsOnRoleParams struct {
	RoleID    uuid.UUID   `json:"role_id"`
	PolicyIds []uuid.UUID `json:"policy_ids"`
}

func (q *Queries) PluralDeleteRoleAssociationsOnRole(ctx context.Context, arg PluralDeleteRoleAssociationsOnRoleParams) (int64, error) {
	result, err := q.db.Exec(ctx, pluralDeleteRoleAssociationsOnRole, arg.RoleID, arg.PolicyIds)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
