// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: record_type.sql

package query

import (
	"context"

	"github.com/google/uuid"
)

const countRecordTypes = `-- name: CountRecordTypes :one
SELECT COUNT(*) FROM m_record_types
WHERE
	CASE WHEN $1::boolean = true THEN name LIKE '%' || $2::text || '%' ELSE TRUE END
`

type CountRecordTypesParams struct {
	WhereLikeName bool   `json:"where_like_name"`
	SearchName    string `json:"search_name"`
}

func (q *Queries) CountRecordTypes(ctx context.Context, arg CountRecordTypesParams) (int64, error) {
	row := q.db.QueryRow(ctx, countRecordTypes, arg.WhereLikeName, arg.SearchName)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createRecordType = `-- name: CreateRecordType :one
INSERT INTO m_record_types (name, key) VALUES ($1, $2) RETURNING m_record_types_pkey, record_type_id, name, key
`

type CreateRecordTypeParams struct {
	Name string `json:"name"`
	Key  string `json:"key"`
}

func (q *Queries) CreateRecordType(ctx context.Context, arg CreateRecordTypeParams) (RecordType, error) {
	row := q.db.QueryRow(ctx, createRecordType, arg.Name, arg.Key)
	var i RecordType
	err := row.Scan(
		&i.MRecordTypesPkey,
		&i.RecordTypeID,
		&i.Name,
		&i.Key,
	)
	return i, err
}

type CreateRecordTypesParams struct {
	Name string `json:"name"`
	Key  string `json:"key"`
}

const deleteRecordType = `-- name: DeleteRecordType :execrows
DELETE FROM m_record_types WHERE record_type_id = $1
`

func (q *Queries) DeleteRecordType(ctx context.Context, recordTypeID uuid.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, deleteRecordType, recordTypeID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteRecordTypeByKey = `-- name: DeleteRecordTypeByKey :execrows
DELETE FROM m_record_types WHERE key = $1
`

func (q *Queries) DeleteRecordTypeByKey(ctx context.Context, key string) (int64, error) {
	result, err := q.db.Exec(ctx, deleteRecordTypeByKey, key)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const findRecordTypeByID = `-- name: FindRecordTypeByID :one
SELECT m_record_types_pkey, record_type_id, name, key FROM m_record_types WHERE record_type_id = $1
`

func (q *Queries) FindRecordTypeByID(ctx context.Context, recordTypeID uuid.UUID) (RecordType, error) {
	row := q.db.QueryRow(ctx, findRecordTypeByID, recordTypeID)
	var i RecordType
	err := row.Scan(
		&i.MRecordTypesPkey,
		&i.RecordTypeID,
		&i.Name,
		&i.Key,
	)
	return i, err
}

const findRecordTypeByKey = `-- name: FindRecordTypeByKey :one
SELECT m_record_types_pkey, record_type_id, name, key FROM m_record_types WHERE key = $1
`

func (q *Queries) FindRecordTypeByKey(ctx context.Context, key string) (RecordType, error) {
	row := q.db.QueryRow(ctx, findRecordTypeByKey, key)
	var i RecordType
	err := row.Scan(
		&i.MRecordTypesPkey,
		&i.RecordTypeID,
		&i.Name,
		&i.Key,
	)
	return i, err
}

const getPluralRecordTypes = `-- name: GetPluralRecordTypes :many
SELECT m_record_types_pkey, record_type_id, name, key FROM m_record_types
WHERE
	record_type_id = ANY($1::uuid[])
ORDER BY
	CASE WHEN $2::text = 'name' THEN name END ASC,
	CASE WHEN $2::text = 'r_name' THEN name END DESC,
	m_record_types_pkey ASC
`

type GetPluralRecordTypesParams struct {
	RecordTypeIds []uuid.UUID `json:"record_type_ids"`
	OrderMethod   string      `json:"order_method"`
}

func (q *Queries) GetPluralRecordTypes(ctx context.Context, arg GetPluralRecordTypesParams) ([]RecordType, error) {
	rows, err := q.db.Query(ctx, getPluralRecordTypes, arg.RecordTypeIds, arg.OrderMethod)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RecordType{}
	for rows.Next() {
		var i RecordType
		if err := rows.Scan(
			&i.MRecordTypesPkey,
			&i.RecordTypeID,
			&i.Name,
			&i.Key,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralRecordTypesUseNumberedPaginate = `-- name: GetPluralRecordTypesUseNumberedPaginate :many
SELECT m_record_types_pkey, record_type_id, name, key FROM m_record_types
WHERE
	record_type_id = ANY($3::uuid[])
ORDER BY
	CASE WHEN $4::text = 'name' THEN name END ASC,
	CASE WHEN $4::text = 'r_name' THEN name END DESC,
	m_record_types_pkey ASC
LIMIT $1 OFFSET $2
`

type GetPluralRecordTypesUseNumberedPaginateParams struct {
	Limit         int32       `json:"limit"`
	Offset        int32       `json:"offset"`
	RecordTypeIds []uuid.UUID `json:"record_type_ids"`
	OrderMethod   string      `json:"order_method"`
}

func (q *Queries) GetPluralRecordTypesUseNumberedPaginate(ctx context.Context, arg GetPluralRecordTypesUseNumberedPaginateParams) ([]RecordType, error) {
	rows, err := q.db.Query(ctx, getPluralRecordTypesUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.RecordTypeIds,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RecordType{}
	for rows.Next() {
		var i RecordType
		if err := rows.Scan(
			&i.MRecordTypesPkey,
			&i.RecordTypeID,
			&i.Name,
			&i.Key,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecordTypes = `-- name: GetRecordTypes :many
SELECT m_record_types_pkey, record_type_id, name, key FROM m_record_types
WHERE
	CASE WHEN $1::boolean = true THEN m_record_types.name LIKE '%' || $2::text || '%' ELSE TRUE END
ORDER BY
	CASE WHEN $3::text = 'name' THEN name END ASC,
	CASE WHEN $3::text = 'r_name' THEN name END DESC,
	m_record_types_pkey ASC
`

type GetRecordTypesParams struct {
	WhereLikeName bool   `json:"where_like_name"`
	SearchName    string `json:"search_name"`
	OrderMethod   string `json:"order_method"`
}

func (q *Queries) GetRecordTypes(ctx context.Context, arg GetRecordTypesParams) ([]RecordType, error) {
	rows, err := q.db.Query(ctx, getRecordTypes, arg.WhereLikeName, arg.SearchName, arg.OrderMethod)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RecordType{}
	for rows.Next() {
		var i RecordType
		if err := rows.Scan(
			&i.MRecordTypesPkey,
			&i.RecordTypeID,
			&i.Name,
			&i.Key,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecordTypesUseKeysetPaginate = `-- name: GetRecordTypesUseKeysetPaginate :many
SELECT m_record_types_pkey, record_type_id, name, key FROM m_record_types
WHERE
	CASE WHEN $2::boolean = true THEN m_record_types.name LIKE '%' || $3::text || '%' ELSE TRUE END
AND
	CASE $4::text
		WHEN 'next' THEN
			CASE $5::text
				WHEN 'name' THEN name > $6 OR (name = $6 AND m_record_types_pkey > $7::int)
				WHEN 'r_name' THEN name < $6 OR (name = $6 AND m_record_types_pkey > $7::int)
				ELSE m_record_types_pkey > $7::int
			END
		WHEN 'prev' THEN
			CASE $5::text
				WHEN 'name' THEN name < $6 OR (name = $6 AND m_record_types_pkey < $7::int)
				WHEN 'r_name' THEN name > $6 OR (name = $6 AND m_record_types_pkey < $7::int)
				ELSE m_record_types_pkey < $7::int
			END
	END
ORDER BY
	CASE WHEN $5::text = 'name' AND $4::text = 'next' THEN name END ASC,
	CASE WHEN $5::text = 'name' AND $4::text = 'prev' THEN name END DESC,
	CASE WHEN $5::text = 'r_name' AND $4::text = 'next' THEN name END DESC,
	CASE WHEN $5::text = 'r_name' AND $4::text = 'prev' THEN name END ASC,
	CASE WHEN $4::text = 'next' THEN m_record_types_pkey END ASC,
	CASE WHEN $4::text = 'prev' THEN m_record_types_pkey END DESC
LIMIT $1
`

type GetRecordTypesUseKeysetPaginateParams struct {
	Limit           int32  `json:"limit"`
	WhereLikeName   bool   `json:"where_like_name"`
	SearchName      string `json:"search_name"`
	CursorDirection string `json:"cursor_direction"`
	OrderMethod     string `json:"order_method"`
	NameCursor      string `json:"name_cursor"`
	Cursor          int32  `json:"cursor"`
}

func (q *Queries) GetRecordTypesUseKeysetPaginate(ctx context.Context, arg GetRecordTypesUseKeysetPaginateParams) ([]RecordType, error) {
	rows, err := q.db.Query(ctx, getRecordTypesUseKeysetPaginate,
		arg.Limit,
		arg.WhereLikeName,
		arg.SearchName,
		arg.CursorDirection,
		arg.OrderMethod,
		arg.NameCursor,
		arg.Cursor,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RecordType{}
	for rows.Next() {
		var i RecordType
		if err := rows.Scan(
			&i.MRecordTypesPkey,
			&i.RecordTypeID,
			&i.Name,
			&i.Key,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecordTypesUseNumberedPaginate = `-- name: GetRecordTypesUseNumberedPaginate :many
SELECT m_record_types_pkey, record_type_id, name, key FROM m_record_types
WHERE
	CASE WHEN $3::boolean = true THEN m_record_types.name LIKE '%' || $4::text || '%' ELSE TRUE END
ORDER BY
	CASE WHEN $5::text = 'name' THEN name END ASC,
	CASE WHEN $5::text = 'r_name' THEN name END DESC,
	m_record_types_pkey ASC
LIMIT $1 OFFSET $2
`

type GetRecordTypesUseNumberedPaginateParams struct {
	Limit         int32  `json:"limit"`
	Offset        int32  `json:"offset"`
	WhereLikeName bool   `json:"where_like_name"`
	SearchName    string `json:"search_name"`
	OrderMethod   string `json:"order_method"`
}

func (q *Queries) GetRecordTypesUseNumberedPaginate(ctx context.Context, arg GetRecordTypesUseNumberedPaginateParams) ([]RecordType, error) {
	rows, err := q.db.Query(ctx, getRecordTypesUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.WhereLikeName,
		arg.SearchName,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RecordType{}
	for rows.Next() {
		var i RecordType
		if err := rows.Scan(
			&i.MRecordTypesPkey,
			&i.RecordTypeID,
			&i.Name,
			&i.Key,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const pluralDeleteRecordTypes = `-- name: PluralDeleteRecordTypes :execrows
DELETE FROM m_record_types WHERE record_type_id = ANY($1::uuid[])
`

func (q *Queries) PluralDeleteRecordTypes(ctx context.Context, recordTypeIds []uuid.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, pluralDeleteRecordTypes, recordTypeIds)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateRecordType = `-- name: UpdateRecordType :one
UPDATE m_record_types SET name = $2, key = $3 WHERE record_type_id = $1 RETURNING m_record_types_pkey, record_type_id, name, key
`

type UpdateRecordTypeParams struct {
	RecordTypeID uuid.UUID `json:"record_type_id"`
	Name         string    `json:"name"`
	Key          string    `json:"key"`
}

func (q *Queries) UpdateRecordType(ctx context.Context, arg UpdateRecordTypeParams) (RecordType, error) {
	row := q.db.QueryRow(ctx, updateRecordType, arg.RecordTypeID, arg.Name, arg.Key)
	var i RecordType
	err := row.Scan(
		&i.MRecordTypesPkey,
		&i.RecordTypeID,
		&i.Name,
		&i.Key,
	)
	return i, err
}

const updateRecordTypeByKey = `-- name: UpdateRecordTypeByKey :one
UPDATE m_record_types SET name = $2 WHERE key = $1 RETURNING m_record_types_pkey, record_type_id, name, key
`

type UpdateRecordTypeByKeyParams struct {
	Key  string `json:"key"`
	Name string `json:"name"`
}

func (q *Queries) UpdateRecordTypeByKey(ctx context.Context, arg UpdateRecordTypeByKeyParams) (RecordType, error) {
	row := q.db.QueryRow(ctx, updateRecordTypeByKey, arg.Key, arg.Name)
	var i RecordType
	err := row.Scan(
		&i.MRecordTypesPkey,
		&i.RecordTypeID,
		&i.Name,
		&i.Key,
	)
	return i, err
}
