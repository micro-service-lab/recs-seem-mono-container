// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: attachable_item.sql

package query

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countAttachableItems = `-- name: CountAttachableItems :one
SELECT COUNT(*) FROM t_attachable_items
WHERE
	CASE WHEN $1::boolean = true THEN mime_type_id = $2 ELSE TRUE END
`

type CountAttachableItemsParams struct {
	WhereMimeTypeID bool      `json:"where_mime_type_id"`
	MimeTypeID      uuid.UUID `json:"mime_type_id"`
}

func (q *Queries) CountAttachableItems(ctx context.Context, arg CountAttachableItemsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countAttachableItems, arg.WhereMimeTypeID, arg.MimeTypeID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAttachableItem = `-- name: CreateAttachableItem :one
INSERT INTO t_attachable_items (url, size, mime_type_id) VALUES ($1, $2, $3) RETURNING t_attachable_items_pkey, attachable_item_id, url, size, mime_type_id
`

type CreateAttachableItemParams struct {
	Url        string        `json:"url"`
	Size       pgtype.Float8 `json:"size"`
	MimeTypeID uuid.UUID     `json:"mime_type_id"`
}

func (q *Queries) CreateAttachableItem(ctx context.Context, arg CreateAttachableItemParams) (AttachableItem, error) {
	row := q.db.QueryRow(ctx, createAttachableItem, arg.Url, arg.Size, arg.MimeTypeID)
	var i AttachableItem
	err := row.Scan(
		&i.TAttachableItemsPkey,
		&i.AttachableItemID,
		&i.Url,
		&i.Size,
		&i.MimeTypeID,
	)
	return i, err
}

type CreateAttachableItemsParams struct {
	Url        string        `json:"url"`
	Size       pgtype.Float8 `json:"size"`
	MimeTypeID uuid.UUID     `json:"mime_type_id"`
}

const deleteAttachableItem = `-- name: DeleteAttachableItem :exec
DELETE FROM t_attachable_items WHERE attachable_item_id = $1
`

func (q *Queries) DeleteAttachableItem(ctx context.Context, attachableItemID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteAttachableItem, attachableItemID)
	return err
}

const findAttachableItemByID = `-- name: FindAttachableItemByID :one
SELECT t_attachable_items.t_attachable_items_pkey, t_attachable_items.attachable_item_id, t_attachable_items.url, t_attachable_items.size, t_attachable_items.mime_type_id, t_images.t_images_pkey, t_images.image_id, t_images.height, t_images.width, t_images.attachable_item_id, t_files.t_files_pkey, t_files.file_id, t_files.attachable_item_id FROM t_attachable_items
LEFT JOIN t_images ON t_attachable_items.attachable_item_id = t_images.attachable_item_id
LEFT JOIN t_files ON t_attachable_items.attachable_item_id = t_files.attachable_item_id
WHERE t_attachable_items.attachable_item_id = $1
`

type FindAttachableItemByIDRow struct {
	AttachableItem AttachableItem `json:"attachable_item"`
	Image          Image          `json:"image"`
	File           File           `json:"file"`
}

func (q *Queries) FindAttachableItemByID(ctx context.Context, attachableItemID uuid.UUID) (FindAttachableItemByIDRow, error) {
	row := q.db.QueryRow(ctx, findAttachableItemByID, attachableItemID)
	var i FindAttachableItemByIDRow
	err := row.Scan(
		&i.AttachableItem.TAttachableItemsPkey,
		&i.AttachableItem.AttachableItemID,
		&i.AttachableItem.Url,
		&i.AttachableItem.Size,
		&i.AttachableItem.MimeTypeID,
		&i.Image.TImagesPkey,
		&i.Image.ImageID,
		&i.Image.Height,
		&i.Image.Width,
		&i.Image.AttachableItemID,
		&i.File.TFilesPkey,
		&i.File.FileID,
		&i.File.AttachableItemID,
	)
	return i, err
}

const findAttachableItemByIDWithMimeType = `-- name: FindAttachableItemByIDWithMimeType :one
SELECT t_attachable_items.t_attachable_items_pkey, t_attachable_items.attachable_item_id, t_attachable_items.url, t_attachable_items.size, t_attachable_items.mime_type_id, m_mime_types.m_mime_types_pkey, m_mime_types.mime_type_id, m_mime_types.name, m_mime_types.key, t_images.t_images_pkey, t_images.image_id, t_images.height, t_images.width, t_images.attachable_item_id, t_files.t_files_pkey, t_files.file_id, t_files.attachable_item_id FROM t_attachable_items
LEFT JOIN m_mime_types ON t_attachable_items.mime_type_id = m_mime_types.mime_type_id
LEFT JOIN t_images ON t_attachable_items.attachable_item_id = t_images.attachable_item_id
LEFT JOIN t_files ON t_attachable_items.attachable_item_id = t_files.attachable_item_id
WHERE t_attachable_items.attachable_item_id = $1
`

type FindAttachableItemByIDWithMimeTypeRow struct {
	AttachableItem AttachableItem `json:"attachable_item"`
	MimeType       MimeType       `json:"mime_type"`
	Image          Image          `json:"image"`
	File           File           `json:"file"`
}

func (q *Queries) FindAttachableItemByIDWithMimeType(ctx context.Context, attachableItemID uuid.UUID) (FindAttachableItemByIDWithMimeTypeRow, error) {
	row := q.db.QueryRow(ctx, findAttachableItemByIDWithMimeType, attachableItemID)
	var i FindAttachableItemByIDWithMimeTypeRow
	err := row.Scan(
		&i.AttachableItem.TAttachableItemsPkey,
		&i.AttachableItem.AttachableItemID,
		&i.AttachableItem.Url,
		&i.AttachableItem.Size,
		&i.AttachableItem.MimeTypeID,
		&i.MimeType.MMimeTypesPkey,
		&i.MimeType.MimeTypeID,
		&i.MimeType.Name,
		&i.MimeType.Key,
		&i.Image.TImagesPkey,
		&i.Image.ImageID,
		&i.Image.Height,
		&i.Image.Width,
		&i.Image.AttachableItemID,
		&i.File.TFilesPkey,
		&i.File.FileID,
		&i.File.AttachableItemID,
	)
	return i, err
}

const getAttachableItems = `-- name: GetAttachableItems :many
SELECT t_attachable_items.t_attachable_items_pkey, t_attachable_items.attachable_item_id, t_attachable_items.url, t_attachable_items.size, t_attachable_items.mime_type_id, t_images.t_images_pkey, t_images.image_id, t_images.height, t_images.width, t_images.attachable_item_id, t_files.t_files_pkey, t_files.file_id, t_files.attachable_item_id FROM t_attachable_items
LEFT JOIN t_images ON t_attachable_items.attachable_item_id = t_images.attachable_item_id
LEFT JOIN t_files ON t_attachable_items.attachable_item_id = t_files.attachable_item_id
WHERE
	CASE WHEN $3::boolean = true THEN mime_type_id = $4 ELSE TRUE END
ORDER BY
	t_attachable_items_pkey DESC
LIMIT $1 OFFSET $2
`

type GetAttachableItemsParams struct {
	Limit           int32     `json:"limit"`
	Offset          int32     `json:"offset"`
	WhereMimeTypeID bool      `json:"where_mime_type_id"`
	MimeTypeID      uuid.UUID `json:"mime_type_id"`
}

type GetAttachableItemsRow struct {
	AttachableItem AttachableItem `json:"attachable_item"`
	Image          Image          `json:"image"`
	File           File           `json:"file"`
}

func (q *Queries) GetAttachableItems(ctx context.Context, arg GetAttachableItemsParams) ([]GetAttachableItemsRow, error) {
	rows, err := q.db.Query(ctx, getAttachableItems,
		arg.Limit,
		arg.Offset,
		arg.WhereMimeTypeID,
		arg.MimeTypeID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAttachableItemsRow{}
	for rows.Next() {
		var i GetAttachableItemsRow
		if err := rows.Scan(
			&i.AttachableItem.TAttachableItemsPkey,
			&i.AttachableItem.AttachableItemID,
			&i.AttachableItem.Url,
			&i.AttachableItem.Size,
			&i.AttachableItem.MimeTypeID,
			&i.Image.TImagesPkey,
			&i.Image.ImageID,
			&i.Image.Height,
			&i.Image.Width,
			&i.Image.AttachableItemID,
			&i.File.TFilesPkey,
			&i.File.FileID,
			&i.File.AttachableItemID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAttachableItemsByMimeTypeIDWithMimeType = `-- name: GetAttachableItemsByMimeTypeIDWithMimeType :many
SELECT t_attachable_items.t_attachable_items_pkey, t_attachable_items.attachable_item_id, t_attachable_items.url, t_attachable_items.size, t_attachable_items.mime_type_id, m_mime_types.m_mime_types_pkey, m_mime_types.mime_type_id, m_mime_types.name, m_mime_types.key, t_images.t_images_pkey, t_images.image_id, t_images.height, t_images.width, t_images.attachable_item_id, t_files.t_files_pkey, t_files.file_id, t_files.attachable_item_id FROM t_attachable_items
LEFT JOIN m_mime_types ON t_attachable_items.mime_type_id = m_mime_types.where_mime_type_id
LEFT JOIN t_images ON t_attachable_items.attachable_item_id = t_images.attachable_item_id
LEFT JOIN t_files ON t_attachable_items.attachable_item_id = t_files.attachable_item_id
WHERE
	CASE WHEN $3::boolean = true THEN t_attachable_items.mime_type_id = $4 ELSE TRUE END
ORDER BY
	t_attachable_items_pkey DESC
LIMIT $1 OFFSET $2
`

type GetAttachableItemsByMimeTypeIDWithMimeTypeParams struct {
	Limit           int32     `json:"limit"`
	Offset          int32     `json:"offset"`
	WhereMimeTypeID bool      `json:"where_mime_type_id"`
	MimeTypeID      uuid.UUID `json:"mime_type_id"`
}

type GetAttachableItemsByMimeTypeIDWithMimeTypeRow struct {
	AttachableItem AttachableItem `json:"attachable_item"`
	MimeType       MimeType       `json:"mime_type"`
	Image          Image          `json:"image"`
	File           File           `json:"file"`
}

func (q *Queries) GetAttachableItemsByMimeTypeIDWithMimeType(ctx context.Context, arg GetAttachableItemsByMimeTypeIDWithMimeTypeParams) ([]GetAttachableItemsByMimeTypeIDWithMimeTypeRow, error) {
	rows, err := q.db.Query(ctx, getAttachableItemsByMimeTypeIDWithMimeType,
		arg.Limit,
		arg.Offset,
		arg.WhereMimeTypeID,
		arg.MimeTypeID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAttachableItemsByMimeTypeIDWithMimeTypeRow{}
	for rows.Next() {
		var i GetAttachableItemsByMimeTypeIDWithMimeTypeRow
		if err := rows.Scan(
			&i.AttachableItem.TAttachableItemsPkey,
			&i.AttachableItem.AttachableItemID,
			&i.AttachableItem.Url,
			&i.AttachableItem.Size,
			&i.AttachableItem.MimeTypeID,
			&i.MimeType.MMimeTypesPkey,
			&i.MimeType.MimeTypeID,
			&i.MimeType.Name,
			&i.MimeType.Key,
			&i.Image.TImagesPkey,
			&i.Image.ImageID,
			&i.Image.Height,
			&i.Image.Width,
			&i.Image.AttachableItemID,
			&i.File.TFilesPkey,
			&i.File.FileID,
			&i.File.AttachableItemID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
