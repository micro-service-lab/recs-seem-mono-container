// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: attached_message.sql

package query

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countAttachableItemsOnMessage = `-- name: CountAttachableItemsOnMessage :one
SELECT COUNT(*) FROM t_attached_messages WHERE message_id = $1
`

func (q *Queries) CountAttachableItemsOnMessage(ctx context.Context, messageID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countAttachableItemsOnMessage, messageID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAttachedMessagesOnChatRoom = `-- name: CountAttachedMessagesOnChatRoom :one
SELECT COUNT(*) FROM t_attached_messages
WHERE message_id IN (
	SELECT message_id FROM t_messages WHERE chat_room_id = $1
)
`

func (q *Queries) CountAttachedMessagesOnChatRoom(ctx context.Context, chatRoomID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countAttachedMessagesOnChatRoom, chatRoomID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAttachedMessage = `-- name: CreateAttachedMessage :one
INSERT INTO t_attached_messages (message_id, attachable_item_id) VALUES ($1, $2) RETURNING t_attached_messages_pkey, message_id, attachable_item_id
`

type CreateAttachedMessageParams struct {
	MessageID        uuid.UUID `json:"message_id"`
	AttachableItemID uuid.UUID `json:"attachable_item_id"`
}

func (q *Queries) CreateAttachedMessage(ctx context.Context, arg CreateAttachedMessageParams) (AttachedMessage, error) {
	row := q.db.QueryRow(ctx, createAttachedMessage, arg.MessageID, arg.AttachableItemID)
	var i AttachedMessage
	err := row.Scan(&i.TAttachedMessagesPkey, &i.MessageID, &i.AttachableItemID)
	return i, err
}

type CreateAttachedMessagesParams struct {
	MessageID        uuid.UUID `json:"message_id"`
	AttachableItemID uuid.UUID `json:"attachable_item_id"`
}

const deleteAttachedMessage = `-- name: DeleteAttachedMessage :exec
DELETE FROM t_attached_messages WHERE message_id = $1 AND attachable_item_id = $2
`

type DeleteAttachedMessageParams struct {
	MessageID        uuid.UUID `json:"message_id"`
	AttachableItemID uuid.UUID `json:"attachable_item_id"`
}

func (q *Queries) DeleteAttachedMessage(ctx context.Context, arg DeleteAttachedMessageParams) error {
	_, err := q.db.Exec(ctx, deleteAttachedMessage, arg.MessageID, arg.AttachableItemID)
	return err
}

const getAttachableItemsOnMessage = `-- name: GetAttachableItemsOnMessage :many
SELECT t_attached_messages.t_attached_messages_pkey, t_attached_messages.message_id, t_attached_messages.attachable_item_id, t_attachable_items.t_attachable_items_pkey, t_attachable_items.attachable_item_id, t_attachable_items.url, t_attachable_items.size, t_attachable_items.mime_type_id, m_mime_types.m_mime_types_pkey, m_mime_types.mime_type_id, m_mime_types.name, m_mime_types.key, t_images.t_images_pkey, t_images.image_id, t_images.height, t_images.width, t_images.attachable_item_id, t_files.t_files_pkey, t_files.file_id, t_files.attachable_item_id FROM t_attached_messages
LEFT JOIN t_attachable_items ON t_attached_messages.attachable_item_id = t_attachable_items.attachable_item_id
LEFT JOIN m_mime_types ON t_attachable_items.mime_type_id = m_mime_types.mime_type_id
LEFT JOIN t_images ON t_attachable_items.attachable_item_id = t_images.attachable_item_id
LEFT JOIN t_files ON t_attachable_items.attachable_item_id = t_files.attachable_item_id
WHERE message_id = $1
ORDER BY
	t_attached_messages_pkey DESC
`

type GetAttachableItemsOnMessageRow struct {
	AttachedMessage AttachedMessage `json:"attached_message"`
	AttachableItem  AttachableItem  `json:"attachable_item"`
	MimeType        MimeType        `json:"mime_type"`
	Image           Image           `json:"image"`
	File            File            `json:"file"`
}

func (q *Queries) GetAttachableItemsOnMessage(ctx context.Context, messageID uuid.UUID) ([]GetAttachableItemsOnMessageRow, error) {
	rows, err := q.db.Query(ctx, getAttachableItemsOnMessage, messageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAttachableItemsOnMessageRow{}
	for rows.Next() {
		var i GetAttachableItemsOnMessageRow
		if err := rows.Scan(
			&i.AttachedMessage.TAttachedMessagesPkey,
			&i.AttachedMessage.MessageID,
			&i.AttachedMessage.AttachableItemID,
			&i.AttachableItem.TAttachableItemsPkey,
			&i.AttachableItem.AttachableItemID,
			&i.AttachableItem.Url,
			&i.AttachableItem.Size,
			&i.AttachableItem.MimeTypeID,
			&i.MimeType.MMimeTypesPkey,
			&i.MimeType.MimeTypeID,
			&i.MimeType.Name,
			&i.MimeType.Key,
			&i.Image.TImagesPkey,
			&i.Image.ImageID,
			&i.Image.Height,
			&i.Image.Width,
			&i.Image.AttachableItemID,
			&i.File.TFilesPkey,
			&i.File.FileID,
			&i.File.AttachableItemID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAttachableItemsOnMessageUseKeysetPaginate = `-- name: GetAttachableItemsOnMessageUseKeysetPaginate :many
SELECT t_attached_messages.t_attached_messages_pkey, t_attached_messages.message_id, t_attached_messages.attachable_item_id, t_attachable_items.t_attachable_items_pkey, t_attachable_items.attachable_item_id, t_attachable_items.url, t_attachable_items.size, t_attachable_items.mime_type_id, m_mime_types.m_mime_types_pkey, m_mime_types.mime_type_id, m_mime_types.name, m_mime_types.key, t_images.t_images_pkey, t_images.image_id, t_images.height, t_images.width, t_images.attachable_item_id, t_files.t_files_pkey, t_files.file_id, t_files.attachable_item_id FROM t_attached_messages
LEFT JOIN t_attachable_items ON t_attached_messages.attachable_item_id = t_attachable_items.attachable_item_id
LEFT JOIN m_mime_types ON t_attachable_items.mime_type_id = m_mime_types.mime_type_id
LEFT JOIN t_images ON t_attachable_items.attachable_item_id = t_images.attachable_item_id
LEFT JOIN t_files ON t_attachable_items.attachable_item_id = t_files.attachable_item_id
WHERE message_id = $1
AND
	CASE $3
		WHEN 'next' THEN
			t_attached_messages_pkey < $4
		WHEN 'prev' THEN
			t_attached_messages_pkey > $4
	END
ORDER BY
	t_attached_messages_pkey DESC
LIMIT $2
`

type GetAttachableItemsOnMessageUseKeysetPaginateParams struct {
	MessageID       uuid.UUID   `json:"message_id"`
	Limit           int32       `json:"limit"`
	CursorDirection interface{} `json:"cursor_direction"`
	Cursor          pgtype.Int8 `json:"cursor"`
}

type GetAttachableItemsOnMessageUseKeysetPaginateRow struct {
	AttachedMessage AttachedMessage `json:"attached_message"`
	AttachableItem  AttachableItem  `json:"attachable_item"`
	MimeType        MimeType        `json:"mime_type"`
	Image           Image           `json:"image"`
	File            File            `json:"file"`
}

func (q *Queries) GetAttachableItemsOnMessageUseKeysetPaginate(ctx context.Context, arg GetAttachableItemsOnMessageUseKeysetPaginateParams) ([]GetAttachableItemsOnMessageUseKeysetPaginateRow, error) {
	rows, err := q.db.Query(ctx, getAttachableItemsOnMessageUseKeysetPaginate,
		arg.MessageID,
		arg.Limit,
		arg.CursorDirection,
		arg.Cursor,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAttachableItemsOnMessageUseKeysetPaginateRow{}
	for rows.Next() {
		var i GetAttachableItemsOnMessageUseKeysetPaginateRow
		if err := rows.Scan(
			&i.AttachedMessage.TAttachedMessagesPkey,
			&i.AttachedMessage.MessageID,
			&i.AttachedMessage.AttachableItemID,
			&i.AttachableItem.TAttachableItemsPkey,
			&i.AttachableItem.AttachableItemID,
			&i.AttachableItem.Url,
			&i.AttachableItem.Size,
			&i.AttachableItem.MimeTypeID,
			&i.MimeType.MMimeTypesPkey,
			&i.MimeType.MimeTypeID,
			&i.MimeType.Name,
			&i.MimeType.Key,
			&i.Image.TImagesPkey,
			&i.Image.ImageID,
			&i.Image.Height,
			&i.Image.Width,
			&i.Image.AttachableItemID,
			&i.File.TFilesPkey,
			&i.File.FileID,
			&i.File.AttachableItemID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAttachableItemsOnMessageUseNumberedPaginate = `-- name: GetAttachableItemsOnMessageUseNumberedPaginate :many
SELECT t_attached_messages.t_attached_messages_pkey, t_attached_messages.message_id, t_attached_messages.attachable_item_id, t_attachable_items.t_attachable_items_pkey, t_attachable_items.attachable_item_id, t_attachable_items.url, t_attachable_items.size, t_attachable_items.mime_type_id, m_mime_types.m_mime_types_pkey, m_mime_types.mime_type_id, m_mime_types.name, m_mime_types.key, t_images.t_images_pkey, t_images.image_id, t_images.height, t_images.width, t_images.attachable_item_id, t_files.t_files_pkey, t_files.file_id, t_files.attachable_item_id FROM t_attached_messages
LEFT JOIN t_attachable_items ON t_attached_messages.attachable_item_id = t_attachable_items.attachable_item_id
LEFT JOIN m_mime_types ON t_attachable_items.mime_type_id = m_mime_types.mime_type_id
LEFT JOIN t_images ON t_attachable_items.attachable_item_id = t_images.attachable_item_id
LEFT JOIN t_files ON t_attachable_items.attachable_item_id = t_files.attachable_item_id
WHERE message_id = $1
ORDER BY
	t_attached_messages_pkey DESC
LIMIT $2 OFFSET $3
`

type GetAttachableItemsOnMessageUseNumberedPaginateParams struct {
	MessageID uuid.UUID `json:"message_id"`
	Limit     int32     `json:"limit"`
	Offset    int32     `json:"offset"`
}

type GetAttachableItemsOnMessageUseNumberedPaginateRow struct {
	AttachedMessage AttachedMessage `json:"attached_message"`
	AttachableItem  AttachableItem  `json:"attachable_item"`
	MimeType        MimeType        `json:"mime_type"`
	Image           Image           `json:"image"`
	File            File            `json:"file"`
}

func (q *Queries) GetAttachableItemsOnMessageUseNumberedPaginate(ctx context.Context, arg GetAttachableItemsOnMessageUseNumberedPaginateParams) ([]GetAttachableItemsOnMessageUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getAttachableItemsOnMessageUseNumberedPaginate, arg.MessageID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAttachableItemsOnMessageUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetAttachableItemsOnMessageUseNumberedPaginateRow
		if err := rows.Scan(
			&i.AttachedMessage.TAttachedMessagesPkey,
			&i.AttachedMessage.MessageID,
			&i.AttachedMessage.AttachableItemID,
			&i.AttachableItem.TAttachableItemsPkey,
			&i.AttachableItem.AttachableItemID,
			&i.AttachableItem.Url,
			&i.AttachableItem.Size,
			&i.AttachableItem.MimeTypeID,
			&i.MimeType.MMimeTypesPkey,
			&i.MimeType.MimeTypeID,
			&i.MimeType.Name,
			&i.MimeType.Key,
			&i.Image.TImagesPkey,
			&i.Image.ImageID,
			&i.Image.Height,
			&i.Image.Width,
			&i.Image.AttachableItemID,
			&i.File.TFilesPkey,
			&i.File.FileID,
			&i.File.AttachableItemID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAttachedMessagesOnChatRoom = `-- name: GetAttachedMessagesOnChatRoom :many
SELECT t_attached_messages.t_attached_messages_pkey, t_attached_messages.message_id, t_attached_messages.attachable_item_id, t_attachable_items.t_attachable_items_pkey, t_attachable_items.attachable_item_id, t_attachable_items.url, t_attachable_items.size, t_attachable_items.mime_type_id, m_mime_types.m_mime_types_pkey, m_mime_types.mime_type_id, m_mime_types.name, m_mime_types.key, t_images.t_images_pkey, t_images.image_id, t_images.height, t_images.width, t_images.attachable_item_id, t_files.t_files_pkey, t_files.file_id, t_files.attachable_item_id FROM t_attached_messages
LEFT JOIN t_attachable_items ON t_attached_messages.attachable_item_id = t_attachable_items.attachable_item_id
LEFT JOIN m_mime_types ON t_attachable_items.mime_type_id = m_mime_types.mime_type_id
LEFT JOIN t_images ON t_attachable_items.attachable_item_id = t_images.attachable_item_id
LEFT JOIN t_files ON t_attachable_items.attachable_item_id = t_files.attachable_item_id
WHERE message_id IN (
	SELECT message_id FROM t_messages WHERE chat_room_id = $1
)
ORDER BY
	t_attached_messages_pkey DESC
`

type GetAttachedMessagesOnChatRoomRow struct {
	AttachedMessage AttachedMessage `json:"attached_message"`
	AttachableItem  AttachableItem  `json:"attachable_item"`
	MimeType        MimeType        `json:"mime_type"`
	Image           Image           `json:"image"`
	File            File            `json:"file"`
}

func (q *Queries) GetAttachedMessagesOnChatRoom(ctx context.Context, chatRoomID uuid.UUID) ([]GetAttachedMessagesOnChatRoomRow, error) {
	rows, err := q.db.Query(ctx, getAttachedMessagesOnChatRoom, chatRoomID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAttachedMessagesOnChatRoomRow{}
	for rows.Next() {
		var i GetAttachedMessagesOnChatRoomRow
		if err := rows.Scan(
			&i.AttachedMessage.TAttachedMessagesPkey,
			&i.AttachedMessage.MessageID,
			&i.AttachedMessage.AttachableItemID,
			&i.AttachableItem.TAttachableItemsPkey,
			&i.AttachableItem.AttachableItemID,
			&i.AttachableItem.Url,
			&i.AttachableItem.Size,
			&i.AttachableItem.MimeTypeID,
			&i.MimeType.MMimeTypesPkey,
			&i.MimeType.MimeTypeID,
			&i.MimeType.Name,
			&i.MimeType.Key,
			&i.Image.TImagesPkey,
			&i.Image.ImageID,
			&i.Image.Height,
			&i.Image.Width,
			&i.Image.AttachableItemID,
			&i.File.TFilesPkey,
			&i.File.FileID,
			&i.File.AttachableItemID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAttachedMessagesOnChatRoomUseKeysetPaginate = `-- name: GetAttachedMessagesOnChatRoomUseKeysetPaginate :many
SELECT t_attached_messages.t_attached_messages_pkey, t_attached_messages.message_id, t_attached_messages.attachable_item_id, t_attachable_items.t_attachable_items_pkey, t_attachable_items.attachable_item_id, t_attachable_items.url, t_attachable_items.size, t_attachable_items.mime_type_id, m_mime_types.m_mime_types_pkey, m_mime_types.mime_type_id, m_mime_types.name, m_mime_types.key, t_images.t_images_pkey, t_images.image_id, t_images.height, t_images.width, t_images.attachable_item_id, t_files.t_files_pkey, t_files.file_id, t_files.attachable_item_id FROM t_attached_messages
LEFT JOIN t_attachable_items ON t_attached_messages.attachable_item_id = t_attachable_items.attachable_item_id
LEFT JOIN m_mime_types ON t_attachable_items.mime_type_id = m_mime_types.mime_type_id
LEFT JOIN t_images ON t_attachable_items.attachable_item_id = t_images.attachable_item_id
LEFT JOIN t_files ON t_attachable_items.attachable_item_id = t_files.attachable_item_id
WHERE message_id IN (
	SELECT message_id FROM t_messages WHERE chat_room_id = $1
)
AND
	CASE $3
		WHEN 'next' THEN
			t_attached_messages_pkey < $4
		WHEN 'prev' THEN
			t_attached_messages_pkey > $4
	END
ORDER BY
	t_attached_messages_pkey DESC
LIMIT $2
`

type GetAttachedMessagesOnChatRoomUseKeysetPaginateParams struct {
	ChatRoomID      uuid.UUID   `json:"chat_room_id"`
	Limit           int32       `json:"limit"`
	CursorDirection interface{} `json:"cursor_direction"`
	Cursor          pgtype.Int8 `json:"cursor"`
}

type GetAttachedMessagesOnChatRoomUseKeysetPaginateRow struct {
	AttachedMessage AttachedMessage `json:"attached_message"`
	AttachableItem  AttachableItem  `json:"attachable_item"`
	MimeType        MimeType        `json:"mime_type"`
	Image           Image           `json:"image"`
	File            File            `json:"file"`
}

func (q *Queries) GetAttachedMessagesOnChatRoomUseKeysetPaginate(ctx context.Context, arg GetAttachedMessagesOnChatRoomUseKeysetPaginateParams) ([]GetAttachedMessagesOnChatRoomUseKeysetPaginateRow, error) {
	rows, err := q.db.Query(ctx, getAttachedMessagesOnChatRoomUseKeysetPaginate,
		arg.ChatRoomID,
		arg.Limit,
		arg.CursorDirection,
		arg.Cursor,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAttachedMessagesOnChatRoomUseKeysetPaginateRow{}
	for rows.Next() {
		var i GetAttachedMessagesOnChatRoomUseKeysetPaginateRow
		if err := rows.Scan(
			&i.AttachedMessage.TAttachedMessagesPkey,
			&i.AttachedMessage.MessageID,
			&i.AttachedMessage.AttachableItemID,
			&i.AttachableItem.TAttachableItemsPkey,
			&i.AttachableItem.AttachableItemID,
			&i.AttachableItem.Url,
			&i.AttachableItem.Size,
			&i.AttachableItem.MimeTypeID,
			&i.MimeType.MMimeTypesPkey,
			&i.MimeType.MimeTypeID,
			&i.MimeType.Name,
			&i.MimeType.Key,
			&i.Image.TImagesPkey,
			&i.Image.ImageID,
			&i.Image.Height,
			&i.Image.Width,
			&i.Image.AttachableItemID,
			&i.File.TFilesPkey,
			&i.File.FileID,
			&i.File.AttachableItemID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAttachedMessagesOnChatRoomUseNumberedPaginate = `-- name: GetAttachedMessagesOnChatRoomUseNumberedPaginate :many
SELECT t_attached_messages.t_attached_messages_pkey, t_attached_messages.message_id, t_attached_messages.attachable_item_id, t_attachable_items.t_attachable_items_pkey, t_attachable_items.attachable_item_id, t_attachable_items.url, t_attachable_items.size, t_attachable_items.mime_type_id, m_mime_types.m_mime_types_pkey, m_mime_types.mime_type_id, m_mime_types.name, m_mime_types.key, t_images.t_images_pkey, t_images.image_id, t_images.height, t_images.width, t_images.attachable_item_id, t_files.t_files_pkey, t_files.file_id, t_files.attachable_item_id FROM t_attached_messages
LEFT JOIN t_attachable_items ON t_attached_messages.attachable_item_id = t_attachable_items.attachable_item_id
LEFT JOIN m_mime_types ON t_attachable_items.mime_type_id = m_mime_types.mime_type_id
LEFT JOIN t_images ON t_attachable_items.attachable_item_id = t_images.attachable_item_id
LEFT JOIN t_files ON t_attachable_items.attachable_item_id = t_files.attachable_item_id
WHERE message_id IN (
	SELECT message_id FROM t_messages WHERE chat_room_id = $1
)
ORDER BY
	t_attached_messages_pkey DESC
LIMIT $2 OFFSET $3
`

type GetAttachedMessagesOnChatRoomUseNumberedPaginateParams struct {
	ChatRoomID uuid.UUID `json:"chat_room_id"`
	Limit      int32     `json:"limit"`
	Offset     int32     `json:"offset"`
}

type GetAttachedMessagesOnChatRoomUseNumberedPaginateRow struct {
	AttachedMessage AttachedMessage `json:"attached_message"`
	AttachableItem  AttachableItem  `json:"attachable_item"`
	MimeType        MimeType        `json:"mime_type"`
	Image           Image           `json:"image"`
	File            File            `json:"file"`
}

func (q *Queries) GetAttachedMessagesOnChatRoomUseNumberedPaginate(ctx context.Context, arg GetAttachedMessagesOnChatRoomUseNumberedPaginateParams) ([]GetAttachedMessagesOnChatRoomUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getAttachedMessagesOnChatRoomUseNumberedPaginate, arg.ChatRoomID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAttachedMessagesOnChatRoomUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetAttachedMessagesOnChatRoomUseNumberedPaginateRow
		if err := rows.Scan(
			&i.AttachedMessage.TAttachedMessagesPkey,
			&i.AttachedMessage.MessageID,
			&i.AttachedMessage.AttachableItemID,
			&i.AttachableItem.TAttachableItemsPkey,
			&i.AttachableItem.AttachableItemID,
			&i.AttachableItem.Url,
			&i.AttachableItem.Size,
			&i.AttachableItem.MimeTypeID,
			&i.MimeType.MMimeTypesPkey,
			&i.MimeType.MimeTypeID,
			&i.MimeType.Name,
			&i.MimeType.Key,
			&i.Image.TImagesPkey,
			&i.Image.ImageID,
			&i.Image.Height,
			&i.Image.Width,
			&i.Image.AttachableItemID,
			&i.File.TFilesPkey,
			&i.File.FileID,
			&i.File.AttachableItemID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
