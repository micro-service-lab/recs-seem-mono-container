// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: organization.sql

package query

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countOrganizations = `-- name: CountOrganizations :one
SELECT COUNT(*) FROM m_organizations
WHERE
	CASE WHEN $1::boolean = true THEN m_organizations.name LIKE '%' || $2::text || '%' END
AND
	CASE WHEN $3::boolean = true THEN m_organizations.is_whole = $4 END
AND
	CASE WHEN $5::boolean = true THEN m_organizations.is_personal = $6 AND EXISTS (SELECT m_members_pkey, member_id, login_id, password, email, name, first_name, last_name, attend_status_id, profile_image_id, grade_id, group_id, personal_organization_id, role_id, created_at, updated_at FROM m_members WHERE m_members.personal_organization_id = m_organizations.organization_id AND m_members.member_id = $7::uuid) END
AND
	CASE WHEN $8::boolean = true THEN EXISTS (SELECT m_groups_pkey, group_id, key, organization_id FROM m_groups WHERE m_groups.organization_id = m_organizations.organization_id) END
AND
	CASE WHEN $9::boolean = true THEN EXISTS (SELECT m_grades_pkey, grade_id, key, organization_id FROM m_grades WHERE m_grades.organization_id = m_organizations.organization_id) END
`

type CountOrganizationsParams struct {
	WhereLikeName    bool      `json:"where_like_name"`
	SearchName       string    `json:"search_name"`
	WhereIsWhole     bool      `json:"where_is_whole"`
	IsWhole          bool      `json:"is_whole"`
	WhereIsPersonal  bool      `json:"where_is_personal"`
	IsPersonal       bool      `json:"is_personal"`
	PersonalMemberID uuid.UUID `json:"personal_member_id"`
	WhereIsGroup     bool      `json:"where_is_group"`
	WhereIsGrade     bool      `json:"where_is_grade"`
}

func (q *Queries) CountOrganizations(ctx context.Context, arg CountOrganizationsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countOrganizations,
		arg.WhereLikeName,
		arg.SearchName,
		arg.WhereIsWhole,
		arg.IsWhole,
		arg.WhereIsPersonal,
		arg.IsPersonal,
		arg.PersonalMemberID,
		arg.WhereIsGroup,
		arg.WhereIsGrade,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createOrganization = `-- name: CreateOrganization :one
INSERT INTO m_organizations (name, description, color, is_personal, is_whole, chat_room_id, created_at, updated_at) VALUES ($1, $2, $3, $4, $5, $6, $7, $8) RETURNING m_organizations_pkey, organization_id, name, description, color, is_personal, is_whole, created_at, updated_at, chat_room_id
`

type CreateOrganizationParams struct {
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
	Color       pgtype.Text `json:"color"`
	IsPersonal  bool        `json:"is_personal"`
	IsWhole     bool        `json:"is_whole"`
	ChatRoomID  pgtype.UUID `json:"chat_room_id"`
	CreatedAt   time.Time   `json:"created_at"`
	UpdatedAt   time.Time   `json:"updated_at"`
}

func (q *Queries) CreateOrganization(ctx context.Context, arg CreateOrganizationParams) (Organization, error) {
	row := q.db.QueryRow(ctx, createOrganization,
		arg.Name,
		arg.Description,
		arg.Color,
		arg.IsPersonal,
		arg.IsWhole,
		arg.ChatRoomID,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Organization
	err := row.Scan(
		&i.MOrganizationsPkey,
		&i.OrganizationID,
		&i.Name,
		&i.Description,
		&i.Color,
		&i.IsPersonal,
		&i.IsWhole,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ChatRoomID,
	)
	return i, err
}

type CreateOrganizationsParams struct {
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
	Color       pgtype.Text `json:"color"`
	IsPersonal  bool        `json:"is_personal"`
	IsWhole     bool        `json:"is_whole"`
	ChatRoomID  pgtype.UUID `json:"chat_room_id"`
	CreatedAt   time.Time   `json:"created_at"`
	UpdatedAt   time.Time   `json:"updated_at"`
}

const deleteOrganization = `-- name: DeleteOrganization :execrows
DELETE FROM m_organizations WHERE organization_id = $1
`

func (q *Queries) DeleteOrganization(ctx context.Context, organizationID uuid.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, deleteOrganization, organizationID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const findOrganizationByID = `-- name: FindOrganizationByID :one
SELECT m_organizations_pkey, organization_id, name, description, color, is_personal, is_whole, created_at, updated_at, chat_room_id FROM m_organizations WHERE organization_id = $1
`

func (q *Queries) FindOrganizationByID(ctx context.Context, organizationID uuid.UUID) (Organization, error) {
	row := q.db.QueryRow(ctx, findOrganizationByID, organizationID)
	var i Organization
	err := row.Scan(
		&i.MOrganizationsPkey,
		&i.OrganizationID,
		&i.Name,
		&i.Description,
		&i.Color,
		&i.IsPersonal,
		&i.IsWhole,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ChatRoomID,
	)
	return i, err
}

const findOrganizationByIDWithChatRoom = `-- name: FindOrganizationByIDWithChatRoom :one
SELECT m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.color, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at, m_organizations.chat_room_id, m_chat_rooms.name chat_room_name, m_chat_rooms.is_private chat_room_is_private,
m_chat_rooms.from_organization chat_room_from_organization, m_chat_rooms.owner_id chat_room_owner_id,
m_chat_rooms.cover_image_id chat_room_cover_image_id, t_images.height chat_room_cover_image_height,
t_images.width chat_room_cover_image_width, t_images.attachable_item_id chat_room_cover_image_attachable_item_id,
t_attachable_items.owner_id chat_room_cover_image_owner_id, t_attachable_items.from_outer chat_room_cover_image_from_outer,
t_attachable_items.url chat_room_cover_image_url, t_attachable_items.size chat_room_cover_image_size, t_attachable_items.mime_type_id chat_room_cover_image_mime_type_id
FROM m_organizations
LEFT JOIN m_chat_rooms ON m_organizations.chat_room_id = m_chat_rooms.chat_room_id
LEFT JOIN t_images ON m_chat_rooms.cover_image_id = t_images.image_id
LEFT JOIN t_attachable_items ON t_images.attachable_item_id = t_attachable_items.attachable_item_id
WHERE m_organizations.organization_id = $1
`

type FindOrganizationByIDWithChatRoomRow struct {
	MOrganizationsPkey                 pgtype.Int8   `json:"m_organizations_pkey"`
	OrganizationID                     uuid.UUID     `json:"organization_id"`
	Name                               string        `json:"name"`
	Description                        pgtype.Text   `json:"description"`
	Color                              pgtype.Text   `json:"color"`
	IsPersonal                         bool          `json:"is_personal"`
	IsWhole                            bool          `json:"is_whole"`
	CreatedAt                          time.Time     `json:"created_at"`
	UpdatedAt                          time.Time     `json:"updated_at"`
	ChatRoomID                         pgtype.UUID   `json:"chat_room_id"`
	ChatRoomName                       pgtype.Text   `json:"chat_room_name"`
	ChatRoomIsPrivate                  pgtype.Bool   `json:"chat_room_is_private"`
	ChatRoomFromOrganization           pgtype.Bool   `json:"chat_room_from_organization"`
	ChatRoomOwnerID                    pgtype.UUID   `json:"chat_room_owner_id"`
	ChatRoomCoverImageID               pgtype.UUID   `json:"chat_room_cover_image_id"`
	ChatRoomCoverImageHeight           pgtype.Float8 `json:"chat_room_cover_image_height"`
	ChatRoomCoverImageWidth            pgtype.Float8 `json:"chat_room_cover_image_width"`
	ChatRoomCoverImageAttachableItemID pgtype.UUID   `json:"chat_room_cover_image_attachable_item_id"`
	ChatRoomCoverImageOwnerID          pgtype.UUID   `json:"chat_room_cover_image_owner_id"`
	ChatRoomCoverImageFromOuter        pgtype.Bool   `json:"chat_room_cover_image_from_outer"`
	ChatRoomCoverImageUrl              pgtype.Text   `json:"chat_room_cover_image_url"`
	ChatRoomCoverImageSize             pgtype.Float8 `json:"chat_room_cover_image_size"`
	ChatRoomCoverImageMimeTypeID       pgtype.UUID   `json:"chat_room_cover_image_mime_type_id"`
}

func (q *Queries) FindOrganizationByIDWithChatRoom(ctx context.Context, organizationID uuid.UUID) (FindOrganizationByIDWithChatRoomRow, error) {
	row := q.db.QueryRow(ctx, findOrganizationByIDWithChatRoom, organizationID)
	var i FindOrganizationByIDWithChatRoomRow
	err := row.Scan(
		&i.MOrganizationsPkey,
		&i.OrganizationID,
		&i.Name,
		&i.Description,
		&i.Color,
		&i.IsPersonal,
		&i.IsWhole,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ChatRoomID,
		&i.ChatRoomName,
		&i.ChatRoomIsPrivate,
		&i.ChatRoomFromOrganization,
		&i.ChatRoomOwnerID,
		&i.ChatRoomCoverImageID,
		&i.ChatRoomCoverImageHeight,
		&i.ChatRoomCoverImageWidth,
		&i.ChatRoomCoverImageAttachableItemID,
		&i.ChatRoomCoverImageOwnerID,
		&i.ChatRoomCoverImageFromOuter,
		&i.ChatRoomCoverImageUrl,
		&i.ChatRoomCoverImageSize,
		&i.ChatRoomCoverImageMimeTypeID,
	)
	return i, err
}

const findOrganizationByIDWithChatRoomAndDetail = `-- name: FindOrganizationByIDWithChatRoomAndDetail :one
SELECT m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.color, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at, m_organizations.chat_room_id, m_groups.group_id, m_groups.key group_key, m_grades.key grade_key, m_grades.grade_id, m_chat_rooms.name chat_room_name, m_chat_rooms.is_private chat_room_is_private,
m_chat_rooms.from_organization chat_room_from_organization, m_chat_rooms.owner_id chat_room_owner_id,
m_chat_rooms.cover_image_id chat_room_cover_image_id, t_images.height chat_room_cover_image_height,
t_images.width chat_room_cover_image_width, t_images.attachable_item_id chat_room_cover_image_attachable_item_id,
t_attachable_items.owner_id chat_room_cover_image_owner_id, t_attachable_items.from_outer chat_room_cover_image_from_outer,
t_attachable_items.url chat_room_cover_image_url, t_attachable_items.size chat_room_cover_image_size, t_attachable_items.mime_type_id chat_room_cover_image_mime_type_id
FROM m_organizations
LEFT JOIN m_groups ON m_organizations.organization_id = m_groups.organization_id
LEFT JOIN m_grades ON m_organizations.organization_id = m_grades.organization_id
LEFT JOIN m_chat_rooms ON m_organizations.chat_room_id = m_chat_rooms.chat_room_id
LEFT JOIN t_images ON m_chat_rooms.cover_image_id = t_images.image_id
LEFT JOIN t_attachable_items ON t_images.attachable_item_id = t_attachable_items.attachable_item_id
WHERE m_organizations.organization_id = $1
`

type FindOrganizationByIDWithChatRoomAndDetailRow struct {
	MOrganizationsPkey                 pgtype.Int8   `json:"m_organizations_pkey"`
	OrganizationID                     uuid.UUID     `json:"organization_id"`
	Name                               string        `json:"name"`
	Description                        pgtype.Text   `json:"description"`
	Color                              pgtype.Text   `json:"color"`
	IsPersonal                         bool          `json:"is_personal"`
	IsWhole                            bool          `json:"is_whole"`
	CreatedAt                          time.Time     `json:"created_at"`
	UpdatedAt                          time.Time     `json:"updated_at"`
	ChatRoomID                         pgtype.UUID   `json:"chat_room_id"`
	GroupID                            pgtype.UUID   `json:"group_id"`
	GroupKey                           pgtype.Text   `json:"group_key"`
	GradeKey                           pgtype.Text   `json:"grade_key"`
	GradeID                            pgtype.UUID   `json:"grade_id"`
	ChatRoomName                       pgtype.Text   `json:"chat_room_name"`
	ChatRoomIsPrivate                  pgtype.Bool   `json:"chat_room_is_private"`
	ChatRoomFromOrganization           pgtype.Bool   `json:"chat_room_from_organization"`
	ChatRoomOwnerID                    pgtype.UUID   `json:"chat_room_owner_id"`
	ChatRoomCoverImageID               pgtype.UUID   `json:"chat_room_cover_image_id"`
	ChatRoomCoverImageHeight           pgtype.Float8 `json:"chat_room_cover_image_height"`
	ChatRoomCoverImageWidth            pgtype.Float8 `json:"chat_room_cover_image_width"`
	ChatRoomCoverImageAttachableItemID pgtype.UUID   `json:"chat_room_cover_image_attachable_item_id"`
	ChatRoomCoverImageOwnerID          pgtype.UUID   `json:"chat_room_cover_image_owner_id"`
	ChatRoomCoverImageFromOuter        pgtype.Bool   `json:"chat_room_cover_image_from_outer"`
	ChatRoomCoverImageUrl              pgtype.Text   `json:"chat_room_cover_image_url"`
	ChatRoomCoverImageSize             pgtype.Float8 `json:"chat_room_cover_image_size"`
	ChatRoomCoverImageMimeTypeID       pgtype.UUID   `json:"chat_room_cover_image_mime_type_id"`
}

func (q *Queries) FindOrganizationByIDWithChatRoomAndDetail(ctx context.Context, organizationID uuid.UUID) (FindOrganizationByIDWithChatRoomAndDetailRow, error) {
	row := q.db.QueryRow(ctx, findOrganizationByIDWithChatRoomAndDetail, organizationID)
	var i FindOrganizationByIDWithChatRoomAndDetailRow
	err := row.Scan(
		&i.MOrganizationsPkey,
		&i.OrganizationID,
		&i.Name,
		&i.Description,
		&i.Color,
		&i.IsPersonal,
		&i.IsWhole,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ChatRoomID,
		&i.GroupID,
		&i.GroupKey,
		&i.GradeKey,
		&i.GradeID,
		&i.ChatRoomName,
		&i.ChatRoomIsPrivate,
		&i.ChatRoomFromOrganization,
		&i.ChatRoomOwnerID,
		&i.ChatRoomCoverImageID,
		&i.ChatRoomCoverImageHeight,
		&i.ChatRoomCoverImageWidth,
		&i.ChatRoomCoverImageAttachableItemID,
		&i.ChatRoomCoverImageOwnerID,
		&i.ChatRoomCoverImageFromOuter,
		&i.ChatRoomCoverImageUrl,
		&i.ChatRoomCoverImageSize,
		&i.ChatRoomCoverImageMimeTypeID,
	)
	return i, err
}

const findOrganizationByIDWithDetail = `-- name: FindOrganizationByIDWithDetail :one
SELECT m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.color, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at, m_organizations.chat_room_id, m_groups.group_id, m_groups.key group_key, m_grades.key grade_key, m_grades.grade_id FROM m_organizations
LEFT JOIN m_groups ON m_organizations.organization_id = m_groups.organization_id
LEFT JOIN m_grades ON m_organizations.organization_id = m_grades.organization_id
WHERE m_organizations.organization_id = $1
`

type FindOrganizationByIDWithDetailRow struct {
	MOrganizationsPkey pgtype.Int8 `json:"m_organizations_pkey"`
	OrganizationID     uuid.UUID   `json:"organization_id"`
	Name               string      `json:"name"`
	Description        pgtype.Text `json:"description"`
	Color              pgtype.Text `json:"color"`
	IsPersonal         bool        `json:"is_personal"`
	IsWhole            bool        `json:"is_whole"`
	CreatedAt          time.Time   `json:"created_at"`
	UpdatedAt          time.Time   `json:"updated_at"`
	ChatRoomID         pgtype.UUID `json:"chat_room_id"`
	GroupID            pgtype.UUID `json:"group_id"`
	GroupKey           pgtype.Text `json:"group_key"`
	GradeKey           pgtype.Text `json:"grade_key"`
	GradeID            pgtype.UUID `json:"grade_id"`
}

func (q *Queries) FindOrganizationByIDWithDetail(ctx context.Context, organizationID uuid.UUID) (FindOrganizationByIDWithDetailRow, error) {
	row := q.db.QueryRow(ctx, findOrganizationByIDWithDetail, organizationID)
	var i FindOrganizationByIDWithDetailRow
	err := row.Scan(
		&i.MOrganizationsPkey,
		&i.OrganizationID,
		&i.Name,
		&i.Description,
		&i.Color,
		&i.IsPersonal,
		&i.IsWhole,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ChatRoomID,
		&i.GroupID,
		&i.GroupKey,
		&i.GradeKey,
		&i.GradeID,
	)
	return i, err
}

const findPersonalOrganization = `-- name: FindPersonalOrganization :one
SELECT m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.color, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at, m_organizations.chat_room_id FROM m_organizations
WHERE m_organizations.is_personal = true AND EXISTS (SELECT m_members_pkey, member_id, login_id, password, email, name, first_name, last_name, attend_status_id, profile_image_id, grade_id, group_id, personal_organization_id, role_id, created_at, updated_at FROM m_members WHERE m_members.personal_organization_id = m_organizations.organization_id AND m_members.member_id = $1)
`

func (q *Queries) FindPersonalOrganization(ctx context.Context, memberID uuid.UUID) (Organization, error) {
	row := q.db.QueryRow(ctx, findPersonalOrganization, memberID)
	var i Organization
	err := row.Scan(
		&i.MOrganizationsPkey,
		&i.OrganizationID,
		&i.Name,
		&i.Description,
		&i.Color,
		&i.IsPersonal,
		&i.IsWhole,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ChatRoomID,
	)
	return i, err
}

const findWholeOrganization = `-- name: FindWholeOrganization :one
SELECT m_organizations_pkey, organization_id, name, description, color, is_personal, is_whole, created_at, updated_at, chat_room_id FROM m_organizations WHERE is_whole = true
`

func (q *Queries) FindWholeOrganization(ctx context.Context) (Organization, error) {
	row := q.db.QueryRow(ctx, findWholeOrganization)
	var i Organization
	err := row.Scan(
		&i.MOrganizationsPkey,
		&i.OrganizationID,
		&i.Name,
		&i.Description,
		&i.Color,
		&i.IsPersonal,
		&i.IsWhole,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ChatRoomID,
	)
	return i, err
}

const findWholeOrganizationWithChatRoom = `-- name: FindWholeOrganizationWithChatRoom :one
SELECT m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.color, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at, m_organizations.chat_room_id, m_chat_rooms.name chat_room_name, m_chat_rooms.is_private chat_room_is_private,
m_chat_rooms.from_organization chat_room_from_organization, m_chat_rooms.owner_id chat_room_owner_id,
m_chat_rooms.cover_image_id chat_room_cover_image_id, t_images.height chat_room_cover_image_height,
t_images.width chat_room_cover_image_width, t_images.attachable_item_id chat_room_cover_image_attachable_item_id,
t_attachable_items.owner_id chat_room_cover_image_owner_id, t_attachable_items.from_outer chat_room_cover_image_from_outer,
t_attachable_items.url chat_room_cover_image_url, t_attachable_items.size chat_room_cover_image_size, t_attachable_items.mime_type_id chat_room_cover_image_mime_type_id
FROM m_organizations
LEFT JOIN m_chat_rooms ON m_organizations.chat_room_id = m_chat_rooms.chat_room_id
LEFT JOIN t_images ON m_chat_rooms.cover_image_id = t_images.image_id
LEFT JOIN t_attachable_items ON t_images.attachable_item_id = t_attachable_items.attachable_item_id
WHERE m_organizations.is_whole = true
`

type FindWholeOrganizationWithChatRoomRow struct {
	MOrganizationsPkey                 pgtype.Int8   `json:"m_organizations_pkey"`
	OrganizationID                     uuid.UUID     `json:"organization_id"`
	Name                               string        `json:"name"`
	Description                        pgtype.Text   `json:"description"`
	Color                              pgtype.Text   `json:"color"`
	IsPersonal                         bool          `json:"is_personal"`
	IsWhole                            bool          `json:"is_whole"`
	CreatedAt                          time.Time     `json:"created_at"`
	UpdatedAt                          time.Time     `json:"updated_at"`
	ChatRoomID                         pgtype.UUID   `json:"chat_room_id"`
	ChatRoomName                       pgtype.Text   `json:"chat_room_name"`
	ChatRoomIsPrivate                  pgtype.Bool   `json:"chat_room_is_private"`
	ChatRoomFromOrganization           pgtype.Bool   `json:"chat_room_from_organization"`
	ChatRoomOwnerID                    pgtype.UUID   `json:"chat_room_owner_id"`
	ChatRoomCoverImageID               pgtype.UUID   `json:"chat_room_cover_image_id"`
	ChatRoomCoverImageHeight           pgtype.Float8 `json:"chat_room_cover_image_height"`
	ChatRoomCoverImageWidth            pgtype.Float8 `json:"chat_room_cover_image_width"`
	ChatRoomCoverImageAttachableItemID pgtype.UUID   `json:"chat_room_cover_image_attachable_item_id"`
	ChatRoomCoverImageOwnerID          pgtype.UUID   `json:"chat_room_cover_image_owner_id"`
	ChatRoomCoverImageFromOuter        pgtype.Bool   `json:"chat_room_cover_image_from_outer"`
	ChatRoomCoverImageUrl              pgtype.Text   `json:"chat_room_cover_image_url"`
	ChatRoomCoverImageSize             pgtype.Float8 `json:"chat_room_cover_image_size"`
	ChatRoomCoverImageMimeTypeID       pgtype.UUID   `json:"chat_room_cover_image_mime_type_id"`
}

func (q *Queries) FindWholeOrganizationWithChatRoom(ctx context.Context) (FindWholeOrganizationWithChatRoomRow, error) {
	row := q.db.QueryRow(ctx, findWholeOrganizationWithChatRoom)
	var i FindWholeOrganizationWithChatRoomRow
	err := row.Scan(
		&i.MOrganizationsPkey,
		&i.OrganizationID,
		&i.Name,
		&i.Description,
		&i.Color,
		&i.IsPersonal,
		&i.IsWhole,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ChatRoomID,
		&i.ChatRoomName,
		&i.ChatRoomIsPrivate,
		&i.ChatRoomFromOrganization,
		&i.ChatRoomOwnerID,
		&i.ChatRoomCoverImageID,
		&i.ChatRoomCoverImageHeight,
		&i.ChatRoomCoverImageWidth,
		&i.ChatRoomCoverImageAttachableItemID,
		&i.ChatRoomCoverImageOwnerID,
		&i.ChatRoomCoverImageFromOuter,
		&i.ChatRoomCoverImageUrl,
		&i.ChatRoomCoverImageSize,
		&i.ChatRoomCoverImageMimeTypeID,
	)
	return i, err
}

const getOrganizations = `-- name: GetOrganizations :many
SELECT m_organizations_pkey, organization_id, name, description, color, is_personal, is_whole, created_at, updated_at, chat_room_id FROM m_organizations
WHERE
	CASE WHEN $1::boolean = true THEN m_organizations.name LIKE '%' || $2::text || '%' END
AND
	CASE WHEN $3::boolean = true THEN m_organizations.is_whole = $4 END
AND
	CASE WHEN $5::boolean = true THEN m_organizations.is_personal = $6 AND EXISTS (SELECT m_members_pkey, member_id, login_id, password, email, name, first_name, last_name, attend_status_id, profile_image_id, grade_id, group_id, personal_organization_id, role_id, created_at, updated_at FROM m_members WHERE m_members.personal_organization_id = m_organizations.organization_id AND m_members.member_id = $7::uuid) END
AND
	CASE WHEN $8::boolean = true THEN EXISTS (SELECT m_groups_pkey, group_id, key, organization_id FROM m_groups WHERE m_groups.organization_id = m_organizations.organization_id) END
AND
	CASE WHEN $9::boolean = true THEN EXISTS (SELECT m_grades_pkey, grade_id, key, organization_id FROM m_grades WHERE m_grades.organization_id = m_organizations.organization_id) END
ORDER BY
	CASE WHEN $10::text = 'name' THEN m_organizations.name END ASC,
	CASE WHEN $10::text = 'r_name' THEN m_organizations.name END DESC,
	m_organizations_pkey ASC
`

type GetOrganizationsParams struct {
	WhereLikeName    bool      `json:"where_like_name"`
	SearchName       string    `json:"search_name"`
	WhereIsWhole     bool      `json:"where_is_whole"`
	IsWhole          bool      `json:"is_whole"`
	WhereIsPersonal  bool      `json:"where_is_personal"`
	IsPersonal       bool      `json:"is_personal"`
	PersonalMemberID uuid.UUID `json:"personal_member_id"`
	WhereIsGroup     bool      `json:"where_is_group"`
	WhereIsGrade     bool      `json:"where_is_grade"`
	OrderMethod      string    `json:"order_method"`
}

func (q *Queries) GetOrganizations(ctx context.Context, arg GetOrganizationsParams) ([]Organization, error) {
	rows, err := q.db.Query(ctx, getOrganizations,
		arg.WhereLikeName,
		arg.SearchName,
		arg.WhereIsWhole,
		arg.IsWhole,
		arg.WhereIsPersonal,
		arg.IsPersonal,
		arg.PersonalMemberID,
		arg.WhereIsGroup,
		arg.WhereIsGrade,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Organization{}
	for rows.Next() {
		var i Organization
		if err := rows.Scan(
			&i.MOrganizationsPkey,
			&i.OrganizationID,
			&i.Name,
			&i.Description,
			&i.Color,
			&i.IsPersonal,
			&i.IsWhole,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ChatRoomID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrganizationsUseKeysetPaginate = `-- name: GetOrganizationsUseKeysetPaginate :many
SELECT m_organizations_pkey, organization_id, name, description, color, is_personal, is_whole, created_at, updated_at, chat_room_id FROM m_organizations
WHERE
	CASE WHEN $2::boolean = true THEN m_organizations.name LIKE '%' || $3::text || '%' END
AND
	CASE WHEN $4::boolean = true THEN m_organizations.is_whole = $5 END
AND
	CASE WHEN $6::boolean = true THEN m_organizations.is_personal = $7 AND EXISTS (SELECT m_members_pkey, member_id, login_id, password, email, name, first_name, last_name, attend_status_id, profile_image_id, grade_id, group_id, personal_organization_id, role_id, created_at, updated_at FROM m_members WHERE m_members.personal_organization_id = m_organizations.organization_id AND m_members.member_id = $8::uuid) END
AND
	CASE WHEN $9::boolean = true THEN EXISTS (SELECT m_groups_pkey, group_id, key, organization_id FROM m_groups WHERE m_groups.organization_id = m_organizations.organization_id) END
AND
	CASE WHEN $10::boolean = true THEN EXISTS (SELECT m_grades_pkey, grade_id, key, organization_id FROM m_grades WHERE m_grades.organization_id = m_organizations.organization_id) END
AND
	CASE $11::text
		WHEN 'next' THEN
			CASE $12::text
				WHEN 'name' THEN m_organizations.name > $13 OR (m_organizations.name = $13 AND m_organizations_pkey > $14::int)
				WHEN 'r_name' THEN m_organizations.name < $13 OR (m_organizations.name = $13 AND m_organizations_pkey > $14::int)
				ELSE m_organizations_pkey > $14::int
			END
		WHEN 'prev' THEN
			CASE $12::text
				WHEN 'name' THEN m_organizations.name < $13 OR (m_organizations.name = $13 AND m_organizations_pkey < $14::int)
				WHEN 'r_name' THEN m_organizations.name > $13 OR (m_organizations.name = $13 AND m_organizations_pkey < $14::int)
				ELSE m_organizations_pkey < $14::int
			END
	END
ORDER BY
	CASE WHEN $12::text = 'name' AND $11::text = 'next' THEN m_organizations.name END ASC,
	CASE WHEN $12::text = 'name' AND $11::text = 'prev' THEN m_organizations.name END DESC,
	CASE WHEN $12::text = 'r_name' AND $11::text = 'next' THEN m_organizations.name END DESC,
	CASE WHEN $12::text = 'r_name' AND $11::text = 'prev' THEN m_organizations.name END ASC,
	CASE WHEN $11::text = 'next' THEN m_organizations_pkey END ASC,
	CASE WHEN $11::text = 'prev' THEN m_organizations_pkey END DESC
LIMIT $1
`

type GetOrganizationsUseKeysetPaginateParams struct {
	Limit            int32     `json:"limit"`
	WhereLikeName    bool      `json:"where_like_name"`
	SearchName       string    `json:"search_name"`
	WhereIsWhole     bool      `json:"where_is_whole"`
	IsWhole          bool      `json:"is_whole"`
	WhereIsPersonal  bool      `json:"where_is_personal"`
	IsPersonal       bool      `json:"is_personal"`
	PersonalMemberID uuid.UUID `json:"personal_member_id"`
	WhereIsGroup     bool      `json:"where_is_group"`
	WhereIsGrade     bool      `json:"where_is_grade"`
	CursorDirection  string    `json:"cursor_direction"`
	OrderMethod      string    `json:"order_method"`
	NameCursor       string    `json:"name_cursor"`
	Cursor           int32     `json:"cursor"`
}

func (q *Queries) GetOrganizationsUseKeysetPaginate(ctx context.Context, arg GetOrganizationsUseKeysetPaginateParams) ([]Organization, error) {
	rows, err := q.db.Query(ctx, getOrganizationsUseKeysetPaginate,
		arg.Limit,
		arg.WhereLikeName,
		arg.SearchName,
		arg.WhereIsWhole,
		arg.IsWhole,
		arg.WhereIsPersonal,
		arg.IsPersonal,
		arg.PersonalMemberID,
		arg.WhereIsGroup,
		arg.WhereIsGrade,
		arg.CursorDirection,
		arg.OrderMethod,
		arg.NameCursor,
		arg.Cursor,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Organization{}
	for rows.Next() {
		var i Organization
		if err := rows.Scan(
			&i.MOrganizationsPkey,
			&i.OrganizationID,
			&i.Name,
			&i.Description,
			&i.Color,
			&i.IsPersonal,
			&i.IsWhole,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ChatRoomID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrganizationsUseNumberedPaginate = `-- name: GetOrganizationsUseNumberedPaginate :many
SELECT m_organizations_pkey, organization_id, name, description, color, is_personal, is_whole, created_at, updated_at, chat_room_id FROM m_organizations
WHERE
	CASE WHEN $3::boolean = true THEN m_organizations.name LIKE '%' || $4::text || '%' END
AND
	CASE WHEN $5::boolean = true THEN m_organizations.is_whole = $6 END
AND
	CASE WHEN $7::boolean = true THEN m_organizations.is_personal = $8 AND EXISTS (SELECT m_members_pkey, member_id, login_id, password, email, name, first_name, last_name, attend_status_id, profile_image_id, grade_id, group_id, personal_organization_id, role_id, created_at, updated_at FROM m_members WHERE m_members.personal_organization_id = m_organizations.organization_id AND m_members.member_id = $9::uuid) END
AND
	CASE WHEN $10::boolean = true THEN EXISTS (SELECT m_groups_pkey, group_id, key, organization_id FROM m_groups WHERE m_groups.organization_id = m_organizations.organization_id) END
AND
	CASE WHEN $11::boolean = true THEN EXISTS (SELECT m_grades_pkey, grade_id, key, organization_id FROM m_grades WHERE m_grades.organization_id = m_organizations.organization_id) END
ORDER BY
	CASE WHEN $12::text = 'name' THEN m_organizations.name END ASC,
	CASE WHEN $12::text = 'r_name' THEN m_organizations.name END DESC,
	m_organizations_pkey ASC
LIMIT $1 OFFSET $2
`

type GetOrganizationsUseNumberedPaginateParams struct {
	Limit            int32     `json:"limit"`
	Offset           int32     `json:"offset"`
	WhereLikeName    bool      `json:"where_like_name"`
	SearchName       string    `json:"search_name"`
	WhereIsWhole     bool      `json:"where_is_whole"`
	IsWhole          bool      `json:"is_whole"`
	WhereIsPersonal  bool      `json:"where_is_personal"`
	IsPersonal       bool      `json:"is_personal"`
	PersonalMemberID uuid.UUID `json:"personal_member_id"`
	WhereIsGroup     bool      `json:"where_is_group"`
	WhereIsGrade     bool      `json:"where_is_grade"`
	OrderMethod      string    `json:"order_method"`
}

func (q *Queries) GetOrganizationsUseNumberedPaginate(ctx context.Context, arg GetOrganizationsUseNumberedPaginateParams) ([]Organization, error) {
	rows, err := q.db.Query(ctx, getOrganizationsUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.WhereLikeName,
		arg.SearchName,
		arg.WhereIsWhole,
		arg.IsWhole,
		arg.WhereIsPersonal,
		arg.IsPersonal,
		arg.PersonalMemberID,
		arg.WhereIsGroup,
		arg.WhereIsGrade,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Organization{}
	for rows.Next() {
		var i Organization
		if err := rows.Scan(
			&i.MOrganizationsPkey,
			&i.OrganizationID,
			&i.Name,
			&i.Description,
			&i.Color,
			&i.IsPersonal,
			&i.IsWhole,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ChatRoomID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrganizationsWithChatRoom = `-- name: GetOrganizationsWithChatRoom :many
SELECT m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.color, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at, m_organizations.chat_room_id, m_chat_rooms.name chat_room_name, m_chat_rooms.is_private chat_room_is_private,
m_chat_rooms.from_organization chat_room_from_organization, m_chat_rooms.owner_id chat_room_owner_id,
m_chat_rooms.cover_image_id chat_room_cover_image_id, t_images.height chat_room_cover_image_height,
t_images.width chat_room_cover_image_width, t_images.attachable_item_id chat_room_cover_image_attachable_item_id,
t_attachable_items.owner_id chat_room_cover_image_owner_id, t_attachable_items.from_outer chat_room_cover_image_from_outer,
t_attachable_items.url chat_room_cover_image_url, t_attachable_items.size chat_room_cover_image_size, t_attachable_items.mime_type_id chat_room_cover_image_mime_type_id
FROM m_organizations
LEFT JOIN m_chat_rooms ON m_organizations.chat_room_id = m_chat_rooms.chat_room_id
LEFT JOIN t_images ON m_chat_rooms.cover_image_id = t_images.image_id
LEFT JOIN t_attachable_items ON t_images.attachable_item_id = t_attachable_items.attachable_item_id
WHERE
	CASE WHEN $1::boolean = true THEN m_organizations.name LIKE '%' || $2::text || '%' END
AND
	CASE WHEN $3::boolean = true THEN m_organizations.is_whole = $4 END
AND
	CASE WHEN $5::boolean = true THEN m_organizations.is_personal = $6 AND EXISTS (SELECT m_members_pkey, member_id, login_id, password, email, name, first_name, last_name, attend_status_id, profile_image_id, grade_id, group_id, personal_organization_id, role_id, created_at, updated_at FROM m_members WHERE m_members.personal_organization_id = m_organizations.organization_id AND m_members.member_id = $7::uuid) END
AND
	CASE WHEN $8::boolean = true THEN EXISTS (SELECT m_groups_pkey, group_id, key, organization_id FROM m_groups WHERE m_groups.organization_id = m_organizations.organization_id) END
AND
	CASE WHEN $9::boolean = true THEN EXISTS (SELECT m_grades_pkey, grade_id, key, organization_id FROM m_grades WHERE m_grades.organization_id = m_organizations.organization_id) END
ORDER BY
	CASE WHEN $10::text = 'name' THEN m_organizations.name END ASC,
	CASE WHEN $10::text = 'r_name' THEN m_organizations.name END DESC,
	m_organizations_pkey ASC
`

type GetOrganizationsWithChatRoomParams struct {
	WhereLikeName    bool      `json:"where_like_name"`
	SearchName       string    `json:"search_name"`
	WhereIsWhole     bool      `json:"where_is_whole"`
	IsWhole          bool      `json:"is_whole"`
	WhereIsPersonal  bool      `json:"where_is_personal"`
	IsPersonal       bool      `json:"is_personal"`
	PersonalMemberID uuid.UUID `json:"personal_member_id"`
	WhereIsGroup     bool      `json:"where_is_group"`
	WhereIsGrade     bool      `json:"where_is_grade"`
	OrderMethod      string    `json:"order_method"`
}

type GetOrganizationsWithChatRoomRow struct {
	MOrganizationsPkey                 pgtype.Int8   `json:"m_organizations_pkey"`
	OrganizationID                     uuid.UUID     `json:"organization_id"`
	Name                               string        `json:"name"`
	Description                        pgtype.Text   `json:"description"`
	Color                              pgtype.Text   `json:"color"`
	IsPersonal                         bool          `json:"is_personal"`
	IsWhole                            bool          `json:"is_whole"`
	CreatedAt                          time.Time     `json:"created_at"`
	UpdatedAt                          time.Time     `json:"updated_at"`
	ChatRoomID                         pgtype.UUID   `json:"chat_room_id"`
	ChatRoomName                       pgtype.Text   `json:"chat_room_name"`
	ChatRoomIsPrivate                  pgtype.Bool   `json:"chat_room_is_private"`
	ChatRoomFromOrganization           pgtype.Bool   `json:"chat_room_from_organization"`
	ChatRoomOwnerID                    pgtype.UUID   `json:"chat_room_owner_id"`
	ChatRoomCoverImageID               pgtype.UUID   `json:"chat_room_cover_image_id"`
	ChatRoomCoverImageHeight           pgtype.Float8 `json:"chat_room_cover_image_height"`
	ChatRoomCoverImageWidth            pgtype.Float8 `json:"chat_room_cover_image_width"`
	ChatRoomCoverImageAttachableItemID pgtype.UUID   `json:"chat_room_cover_image_attachable_item_id"`
	ChatRoomCoverImageOwnerID          pgtype.UUID   `json:"chat_room_cover_image_owner_id"`
	ChatRoomCoverImageFromOuter        pgtype.Bool   `json:"chat_room_cover_image_from_outer"`
	ChatRoomCoverImageUrl              pgtype.Text   `json:"chat_room_cover_image_url"`
	ChatRoomCoverImageSize             pgtype.Float8 `json:"chat_room_cover_image_size"`
	ChatRoomCoverImageMimeTypeID       pgtype.UUID   `json:"chat_room_cover_image_mime_type_id"`
}

func (q *Queries) GetOrganizationsWithChatRoom(ctx context.Context, arg GetOrganizationsWithChatRoomParams) ([]GetOrganizationsWithChatRoomRow, error) {
	rows, err := q.db.Query(ctx, getOrganizationsWithChatRoom,
		arg.WhereLikeName,
		arg.SearchName,
		arg.WhereIsWhole,
		arg.IsWhole,
		arg.WhereIsPersonal,
		arg.IsPersonal,
		arg.PersonalMemberID,
		arg.WhereIsGroup,
		arg.WhereIsGrade,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOrganizationsWithChatRoomRow{}
	for rows.Next() {
		var i GetOrganizationsWithChatRoomRow
		if err := rows.Scan(
			&i.MOrganizationsPkey,
			&i.OrganizationID,
			&i.Name,
			&i.Description,
			&i.Color,
			&i.IsPersonal,
			&i.IsWhole,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ChatRoomID,
			&i.ChatRoomName,
			&i.ChatRoomIsPrivate,
			&i.ChatRoomFromOrganization,
			&i.ChatRoomOwnerID,
			&i.ChatRoomCoverImageID,
			&i.ChatRoomCoverImageHeight,
			&i.ChatRoomCoverImageWidth,
			&i.ChatRoomCoverImageAttachableItemID,
			&i.ChatRoomCoverImageOwnerID,
			&i.ChatRoomCoverImageFromOuter,
			&i.ChatRoomCoverImageUrl,
			&i.ChatRoomCoverImageSize,
			&i.ChatRoomCoverImageMimeTypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrganizationsWithChatRoomAndDetail = `-- name: GetOrganizationsWithChatRoomAndDetail :many
SELECT m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.color, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at, m_organizations.chat_room_id, m_groups.group_id, m_groups.key group_key, m_grades.key grade_key, m_grades.grade_id, m_chat_rooms.name chat_room_name, m_chat_rooms.is_private chat_room_is_private,
m_chat_rooms.from_organization chat_room_from_organization, m_chat_rooms.owner_id chat_room_owner_id,
m_chat_rooms.cover_image_id chat_room_cover_image_id, t_images.height chat_room_cover_image_height,
t_images.width chat_room_cover_image_width, t_images.attachable_item_id chat_room_cover_image_attachable_item_id,
t_attachable_items.owner_id chat_room_cover_image_owner_id, t_attachable_items.from_outer chat_room_cover_image_from_outer,
t_attachable_items.url chat_room_cover_image_url, t_attachable_items.size chat_room_cover_image_size, t_attachable_items.mime_type_id chat_room_cover_image_mime_type_id
FROM m_organizations
LEFT JOIN m_groups ON m_organizations.organization_id = m_groups.organization_id
LEFT JOIN m_grades ON m_organizations.organization_id = m_grades.organization_id
LEFT JOIN m_chat_rooms ON m_organizations.chat_room_id = m_chat_rooms.chat_room_id
LEFT JOIN t_images ON m_chat_rooms.cover_image_id = t_images.image_id
LEFT JOIN t_attachable_items ON t_images.attachable_item_id = t_attachable_items.attachable_item_id
WHERE
	CASE WHEN $1::boolean = true THEN m_organizations.name LIKE '%' || $2::text || '%' END
AND
	CASE WHEN $3::boolean = true THEN m_organizations.is_whole = $4 END
AND
	CASE WHEN $5::boolean = true THEN m_organizations.is_personal = $6 AND EXISTS (SELECT m_members_pkey, member_id, login_id, password, email, name, first_name, last_name, attend_status_id, profile_image_id, grade_id, group_id, personal_organization_id, role_id, created_at, updated_at FROM m_members WHERE m_members.personal_organization_id = m_organizations.organization_id AND m_members.member_id = $7::uuid) END
AND
	CASE WHEN $8::boolean = true THEN EXISTS (SELECT m_groups_pkey, group_id, key, organization_id FROM m_groups WHERE m_groups.organization_id = m_organizations.organization_id) END
AND
	CASE WHEN $9::boolean = true THEN EXISTS (SELECT m_grades_pkey, grade_id, key, organization_id FROM m_grades WHERE m_grades.organization_id = m_organizations.organization_id) END
ORDER BY
	CASE WHEN $10::text = 'name' THEN m_organizations.name END ASC,
	CASE WHEN $10::text = 'r_name' THEN m_organizations.name END DESC,
	m_organizations_pkey ASC
`

type GetOrganizationsWithChatRoomAndDetailParams struct {
	WhereLikeName    bool      `json:"where_like_name"`
	SearchName       string    `json:"search_name"`
	WhereIsWhole     bool      `json:"where_is_whole"`
	IsWhole          bool      `json:"is_whole"`
	WhereIsPersonal  bool      `json:"where_is_personal"`
	IsPersonal       bool      `json:"is_personal"`
	PersonalMemberID uuid.UUID `json:"personal_member_id"`
	WhereIsGroup     bool      `json:"where_is_group"`
	WhereIsGrade     bool      `json:"where_is_grade"`
	OrderMethod      string    `json:"order_method"`
}

type GetOrganizationsWithChatRoomAndDetailRow struct {
	MOrganizationsPkey                 pgtype.Int8   `json:"m_organizations_pkey"`
	OrganizationID                     uuid.UUID     `json:"organization_id"`
	Name                               string        `json:"name"`
	Description                        pgtype.Text   `json:"description"`
	Color                              pgtype.Text   `json:"color"`
	IsPersonal                         bool          `json:"is_personal"`
	IsWhole                            bool          `json:"is_whole"`
	CreatedAt                          time.Time     `json:"created_at"`
	UpdatedAt                          time.Time     `json:"updated_at"`
	ChatRoomID                         pgtype.UUID   `json:"chat_room_id"`
	GroupID                            pgtype.UUID   `json:"group_id"`
	GroupKey                           pgtype.Text   `json:"group_key"`
	GradeKey                           pgtype.Text   `json:"grade_key"`
	GradeID                            pgtype.UUID   `json:"grade_id"`
	ChatRoomName                       pgtype.Text   `json:"chat_room_name"`
	ChatRoomIsPrivate                  pgtype.Bool   `json:"chat_room_is_private"`
	ChatRoomFromOrganization           pgtype.Bool   `json:"chat_room_from_organization"`
	ChatRoomOwnerID                    pgtype.UUID   `json:"chat_room_owner_id"`
	ChatRoomCoverImageID               pgtype.UUID   `json:"chat_room_cover_image_id"`
	ChatRoomCoverImageHeight           pgtype.Float8 `json:"chat_room_cover_image_height"`
	ChatRoomCoverImageWidth            pgtype.Float8 `json:"chat_room_cover_image_width"`
	ChatRoomCoverImageAttachableItemID pgtype.UUID   `json:"chat_room_cover_image_attachable_item_id"`
	ChatRoomCoverImageOwnerID          pgtype.UUID   `json:"chat_room_cover_image_owner_id"`
	ChatRoomCoverImageFromOuter        pgtype.Bool   `json:"chat_room_cover_image_from_outer"`
	ChatRoomCoverImageUrl              pgtype.Text   `json:"chat_room_cover_image_url"`
	ChatRoomCoverImageSize             pgtype.Float8 `json:"chat_room_cover_image_size"`
	ChatRoomCoverImageMimeTypeID       pgtype.UUID   `json:"chat_room_cover_image_mime_type_id"`
}

func (q *Queries) GetOrganizationsWithChatRoomAndDetail(ctx context.Context, arg GetOrganizationsWithChatRoomAndDetailParams) ([]GetOrganizationsWithChatRoomAndDetailRow, error) {
	rows, err := q.db.Query(ctx, getOrganizationsWithChatRoomAndDetail,
		arg.WhereLikeName,
		arg.SearchName,
		arg.WhereIsWhole,
		arg.IsWhole,
		arg.WhereIsPersonal,
		arg.IsPersonal,
		arg.PersonalMemberID,
		arg.WhereIsGroup,
		arg.WhereIsGrade,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOrganizationsWithChatRoomAndDetailRow{}
	for rows.Next() {
		var i GetOrganizationsWithChatRoomAndDetailRow
		if err := rows.Scan(
			&i.MOrganizationsPkey,
			&i.OrganizationID,
			&i.Name,
			&i.Description,
			&i.Color,
			&i.IsPersonal,
			&i.IsWhole,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ChatRoomID,
			&i.GroupID,
			&i.GroupKey,
			&i.GradeKey,
			&i.GradeID,
			&i.ChatRoomName,
			&i.ChatRoomIsPrivate,
			&i.ChatRoomFromOrganization,
			&i.ChatRoomOwnerID,
			&i.ChatRoomCoverImageID,
			&i.ChatRoomCoverImageHeight,
			&i.ChatRoomCoverImageWidth,
			&i.ChatRoomCoverImageAttachableItemID,
			&i.ChatRoomCoverImageOwnerID,
			&i.ChatRoomCoverImageFromOuter,
			&i.ChatRoomCoverImageUrl,
			&i.ChatRoomCoverImageSize,
			&i.ChatRoomCoverImageMimeTypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrganizationsWithChatRoomAndDetailUseKeysetPaginate = `-- name: GetOrganizationsWithChatRoomAndDetailUseKeysetPaginate :many
SELECT m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.color, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at, m_organizations.chat_room_id, m_groups.group_id, m_groups.key group_key, m_grades.key grade_key, m_grades.grade_id, m_chat_rooms.name chat_room_name, m_chat_rooms.is_private chat_room_is_private,
m_chat_rooms.from_organization chat_room_from_organization, m_chat_rooms.owner_id chat_room_owner_id,
m_chat_rooms.cover_image_id chat_room_cover_image_id, t_images.height chat_room_cover_image_height,
t_images.width chat_room_cover_image_width, t_images.attachable_item_id chat_room_cover_image_attachable_item_id,
t_attachable_items.owner_id chat_room_cover_image_owner_id, t_attachable_items.from_outer chat_room_cover_image_from_outer,
t_attachable_items.url chat_room_cover_image_url, t_attachable_items.size chat_room_cover_image_size, t_attachable_items.mime_type_id chat_room_cover_image_mime_type_id
FROM m_organizations
LEFT JOIN m_groups ON m_organizations.organization_id = m_groups.organization_id
LEFT JOIN m_grades ON m_organizations.organization_id = m_grades.organization_id
LEFT JOIN m_chat_rooms ON m_organizations.chat_room_id = m_chat_rooms.chat_room_id
LEFT JOIN t_images ON m_chat_rooms.cover_image_id = t_images.image_id
LEFT JOIN t_attachable_items ON t_images.attachable_item_id = t_attachable_items.attachable_item_id
WHERE
	CASE WHEN $2::boolean = true THEN m_organizations.name LIKE '%' || $3::text || '%' END
AND
	CASE WHEN $4::boolean = true THEN m_organizations.is_whole = $5 END
AND
	CASE WHEN $6::boolean = true THEN m_organizations.is_personal = $7 AND EXISTS (SELECT m_members_pkey, member_id, login_id, password, email, name, first_name, last_name, attend_status_id, profile_image_id, grade_id, group_id, personal_organization_id, role_id, created_at, updated_at FROM m_members WHERE m_members.personal_organization_id = m_organizations.organization_id AND m_members.member_id = $8::uuid) END
AND
	CASE WHEN $9::boolean = true THEN EXISTS (SELECT m_groups_pkey, group_id, key, organization_id FROM m_groups WHERE m_groups.organization_id = m_organizations.organization_id) END
AND
	CASE WHEN $10::boolean = true THEN EXISTS (SELECT m_grades_pkey, grade_id, key, organization_id FROM m_grades WHERE m_grades.organization_id = m_organizations.organization_id) END
AND
	CASE $11::text
		WHEN 'next' THEN
			CASE $12::text
				WHEN 'name' THEN m_organizations.name > $13 OR (m_organizations.name = $13 AND m_organizations_pkey > $14::int)
				WHEN 'r_name' THEN m_organizations.name < $13 OR (m_organizations.name = $13 AND m_organizations_pkey > $14::int)
				ELSE m_organizations_pkey > $14::int
			END
		WHEN 'prev' THEN
			CASE $12::text
				WHEN 'name' THEN m_organizations.name < $13 OR (m_organizations.name = $13 AND m_organizations_pkey < $14::int)
				WHEN 'r_name' THEN m_organizations.name > $13 OR (m_organizations.name = $13 AND m_organizations_pkey < $14::int)
				ELSE m_organizations_pkey < $14::int
			END
	END
ORDER BY
	CASE WHEN $12::text = 'name' AND $11::text = 'next' THEN m_organizations.name END ASC,
	CASE WHEN $12::text = 'name' AND $11::text = 'prev' THEN m_organizations.name END DESC,
	CASE WHEN $12::text = 'r_name' AND $11::text = 'next' THEN m_organizations.name END DESC,
	CASE WHEN $12::text = 'r_name' AND $11::text = 'prev' THEN m_organizations.name END ASC,
	CASE WHEN $11::text = 'next' THEN m_organizations_pkey END ASC,
	CASE WHEN $11::text = 'prev' THEN m_organizations_pkey END DESC
LIMIT $1
`

type GetOrganizationsWithChatRoomAndDetailUseKeysetPaginateParams struct {
	Limit            int32     `json:"limit"`
	WhereLikeName    bool      `json:"where_like_name"`
	SearchName       string    `json:"search_name"`
	WhereIsWhole     bool      `json:"where_is_whole"`
	IsWhole          bool      `json:"is_whole"`
	WhereIsPersonal  bool      `json:"where_is_personal"`
	IsPersonal       bool      `json:"is_personal"`
	PersonalMemberID uuid.UUID `json:"personal_member_id"`
	WhereIsGroup     bool      `json:"where_is_group"`
	WhereIsGrade     bool      `json:"where_is_grade"`
	CursorDirection  string    `json:"cursor_direction"`
	OrderMethod      string    `json:"order_method"`
	NameCursor       string    `json:"name_cursor"`
	Cursor           int32     `json:"cursor"`
}

type GetOrganizationsWithChatRoomAndDetailUseKeysetPaginateRow struct {
	MOrganizationsPkey                 pgtype.Int8   `json:"m_organizations_pkey"`
	OrganizationID                     uuid.UUID     `json:"organization_id"`
	Name                               string        `json:"name"`
	Description                        pgtype.Text   `json:"description"`
	Color                              pgtype.Text   `json:"color"`
	IsPersonal                         bool          `json:"is_personal"`
	IsWhole                            bool          `json:"is_whole"`
	CreatedAt                          time.Time     `json:"created_at"`
	UpdatedAt                          time.Time     `json:"updated_at"`
	ChatRoomID                         pgtype.UUID   `json:"chat_room_id"`
	GroupID                            pgtype.UUID   `json:"group_id"`
	GroupKey                           pgtype.Text   `json:"group_key"`
	GradeKey                           pgtype.Text   `json:"grade_key"`
	GradeID                            pgtype.UUID   `json:"grade_id"`
	ChatRoomName                       pgtype.Text   `json:"chat_room_name"`
	ChatRoomIsPrivate                  pgtype.Bool   `json:"chat_room_is_private"`
	ChatRoomFromOrganization           pgtype.Bool   `json:"chat_room_from_organization"`
	ChatRoomOwnerID                    pgtype.UUID   `json:"chat_room_owner_id"`
	ChatRoomCoverImageID               pgtype.UUID   `json:"chat_room_cover_image_id"`
	ChatRoomCoverImageHeight           pgtype.Float8 `json:"chat_room_cover_image_height"`
	ChatRoomCoverImageWidth            pgtype.Float8 `json:"chat_room_cover_image_width"`
	ChatRoomCoverImageAttachableItemID pgtype.UUID   `json:"chat_room_cover_image_attachable_item_id"`
	ChatRoomCoverImageOwnerID          pgtype.UUID   `json:"chat_room_cover_image_owner_id"`
	ChatRoomCoverImageFromOuter        pgtype.Bool   `json:"chat_room_cover_image_from_outer"`
	ChatRoomCoverImageUrl              pgtype.Text   `json:"chat_room_cover_image_url"`
	ChatRoomCoverImageSize             pgtype.Float8 `json:"chat_room_cover_image_size"`
	ChatRoomCoverImageMimeTypeID       pgtype.UUID   `json:"chat_room_cover_image_mime_type_id"`
}

func (q *Queries) GetOrganizationsWithChatRoomAndDetailUseKeysetPaginate(ctx context.Context, arg GetOrganizationsWithChatRoomAndDetailUseKeysetPaginateParams) ([]GetOrganizationsWithChatRoomAndDetailUseKeysetPaginateRow, error) {
	rows, err := q.db.Query(ctx, getOrganizationsWithChatRoomAndDetailUseKeysetPaginate,
		arg.Limit,
		arg.WhereLikeName,
		arg.SearchName,
		arg.WhereIsWhole,
		arg.IsWhole,
		arg.WhereIsPersonal,
		arg.IsPersonal,
		arg.PersonalMemberID,
		arg.WhereIsGroup,
		arg.WhereIsGrade,
		arg.CursorDirection,
		arg.OrderMethod,
		arg.NameCursor,
		arg.Cursor,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOrganizationsWithChatRoomAndDetailUseKeysetPaginateRow{}
	for rows.Next() {
		var i GetOrganizationsWithChatRoomAndDetailUseKeysetPaginateRow
		if err := rows.Scan(
			&i.MOrganizationsPkey,
			&i.OrganizationID,
			&i.Name,
			&i.Description,
			&i.Color,
			&i.IsPersonal,
			&i.IsWhole,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ChatRoomID,
			&i.GroupID,
			&i.GroupKey,
			&i.GradeKey,
			&i.GradeID,
			&i.ChatRoomName,
			&i.ChatRoomIsPrivate,
			&i.ChatRoomFromOrganization,
			&i.ChatRoomOwnerID,
			&i.ChatRoomCoverImageID,
			&i.ChatRoomCoverImageHeight,
			&i.ChatRoomCoverImageWidth,
			&i.ChatRoomCoverImageAttachableItemID,
			&i.ChatRoomCoverImageOwnerID,
			&i.ChatRoomCoverImageFromOuter,
			&i.ChatRoomCoverImageUrl,
			&i.ChatRoomCoverImageSize,
			&i.ChatRoomCoverImageMimeTypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrganizationsWithChatRoomAndDetailUseNumberedPaginate = `-- name: GetOrganizationsWithChatRoomAndDetailUseNumberedPaginate :many
SELECT m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.color, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at, m_organizations.chat_room_id, m_groups.group_id, m_groups.key group_key, m_grades.key grade_key, m_grades.grade_id, m_chat_rooms.name chat_room_name, m_chat_rooms.is_private chat_room_is_private,
m_chat_rooms.from_organization chat_room_from_organization, m_chat_rooms.owner_id chat_room_owner_id,
m_chat_rooms.cover_image_id chat_room_cover_image_id, t_images.height chat_room_cover_image_height,
t_images.width chat_room_cover_image_width, t_images.attachable_item_id chat_room_cover_image_attachable_item_id,
t_attachable_items.owner_id chat_room_cover_image_owner_id, t_attachable_items.from_outer chat_room_cover_image_from_outer,
t_attachable_items.url chat_room_cover_image_url, t_attachable_items.size chat_room_cover_image_size, t_attachable_items.mime_type_id chat_room_cover_image_mime_type_id
FROM m_organizations
LEFT JOIN m_groups ON m_organizations.organization_id = m_groups.organization_id
LEFT JOIN m_grades ON m_organizations.organization_id = m_grades.organization_id
LEFT JOIN m_chat_rooms ON m_organizations.chat_room_id = m_chat_rooms.chat_room_id
LEFT JOIN t_images ON m_chat_rooms.cover_image_id = t_images.image_id
LEFT JOIN t_attachable_items ON t_images.attachable_item_id = t_attachable_items.attachable_item_id
WHERE
	CASE WHEN $3::boolean = true THEN m_organizations.name LIKE '%' || $4::text || '%' END
AND
	CASE WHEN $5::boolean = true THEN m_organizations.is_whole = $6 END
AND
	CASE WHEN $7::boolean = true THEN m_organizations.is_personal = $8 AND EXISTS (SELECT m_members_pkey, member_id, login_id, password, email, name, first_name, last_name, attend_status_id, profile_image_id, grade_id, group_id, personal_organization_id, role_id, created_at, updated_at FROM m_members WHERE m_members.personal_organization_id = m_organizations.organization_id AND m_members.member_id = $9::uuid) END
AND
	CASE WHEN $10::boolean = true THEN EXISTS (SELECT m_groups_pkey, group_id, key, organization_id FROM m_groups WHERE m_groups.organization_id = m_organizations.organization_id) END
AND
	CASE WHEN $11::boolean = true THEN EXISTS (SELECT m_grades_pkey, grade_id, key, organization_id FROM m_grades WHERE m_grades.organization_id = m_organizations.organization_id) END
ORDER BY
	CASE WHEN $12::text = 'name' THEN m_organizations.name END ASC,
	CASE WHEN $12::text = 'r_name' THEN m_organizations.name END DESC,
	m_organizations_pkey ASC
LIMIT $1 OFFSET $2
`

type GetOrganizationsWithChatRoomAndDetailUseNumberedPaginateParams struct {
	Limit            int32     `json:"limit"`
	Offset           int32     `json:"offset"`
	WhereLikeName    bool      `json:"where_like_name"`
	SearchName       string    `json:"search_name"`
	WhereIsWhole     bool      `json:"where_is_whole"`
	IsWhole          bool      `json:"is_whole"`
	WhereIsPersonal  bool      `json:"where_is_personal"`
	IsPersonal       bool      `json:"is_personal"`
	PersonalMemberID uuid.UUID `json:"personal_member_id"`
	WhereIsGroup     bool      `json:"where_is_group"`
	WhereIsGrade     bool      `json:"where_is_grade"`
	OrderMethod      string    `json:"order_method"`
}

type GetOrganizationsWithChatRoomAndDetailUseNumberedPaginateRow struct {
	MOrganizationsPkey                 pgtype.Int8   `json:"m_organizations_pkey"`
	OrganizationID                     uuid.UUID     `json:"organization_id"`
	Name                               string        `json:"name"`
	Description                        pgtype.Text   `json:"description"`
	Color                              pgtype.Text   `json:"color"`
	IsPersonal                         bool          `json:"is_personal"`
	IsWhole                            bool          `json:"is_whole"`
	CreatedAt                          time.Time     `json:"created_at"`
	UpdatedAt                          time.Time     `json:"updated_at"`
	ChatRoomID                         pgtype.UUID   `json:"chat_room_id"`
	GroupID                            pgtype.UUID   `json:"group_id"`
	GroupKey                           pgtype.Text   `json:"group_key"`
	GradeKey                           pgtype.Text   `json:"grade_key"`
	GradeID                            pgtype.UUID   `json:"grade_id"`
	ChatRoomName                       pgtype.Text   `json:"chat_room_name"`
	ChatRoomIsPrivate                  pgtype.Bool   `json:"chat_room_is_private"`
	ChatRoomFromOrganization           pgtype.Bool   `json:"chat_room_from_organization"`
	ChatRoomOwnerID                    pgtype.UUID   `json:"chat_room_owner_id"`
	ChatRoomCoverImageID               pgtype.UUID   `json:"chat_room_cover_image_id"`
	ChatRoomCoverImageHeight           pgtype.Float8 `json:"chat_room_cover_image_height"`
	ChatRoomCoverImageWidth            pgtype.Float8 `json:"chat_room_cover_image_width"`
	ChatRoomCoverImageAttachableItemID pgtype.UUID   `json:"chat_room_cover_image_attachable_item_id"`
	ChatRoomCoverImageOwnerID          pgtype.UUID   `json:"chat_room_cover_image_owner_id"`
	ChatRoomCoverImageFromOuter        pgtype.Bool   `json:"chat_room_cover_image_from_outer"`
	ChatRoomCoverImageUrl              pgtype.Text   `json:"chat_room_cover_image_url"`
	ChatRoomCoverImageSize             pgtype.Float8 `json:"chat_room_cover_image_size"`
	ChatRoomCoverImageMimeTypeID       pgtype.UUID   `json:"chat_room_cover_image_mime_type_id"`
}

func (q *Queries) GetOrganizationsWithChatRoomAndDetailUseNumberedPaginate(ctx context.Context, arg GetOrganizationsWithChatRoomAndDetailUseNumberedPaginateParams) ([]GetOrganizationsWithChatRoomAndDetailUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getOrganizationsWithChatRoomAndDetailUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.WhereLikeName,
		arg.SearchName,
		arg.WhereIsWhole,
		arg.IsWhole,
		arg.WhereIsPersonal,
		arg.IsPersonal,
		arg.PersonalMemberID,
		arg.WhereIsGroup,
		arg.WhereIsGrade,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOrganizationsWithChatRoomAndDetailUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetOrganizationsWithChatRoomAndDetailUseNumberedPaginateRow
		if err := rows.Scan(
			&i.MOrganizationsPkey,
			&i.OrganizationID,
			&i.Name,
			&i.Description,
			&i.Color,
			&i.IsPersonal,
			&i.IsWhole,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ChatRoomID,
			&i.GroupID,
			&i.GroupKey,
			&i.GradeKey,
			&i.GradeID,
			&i.ChatRoomName,
			&i.ChatRoomIsPrivate,
			&i.ChatRoomFromOrganization,
			&i.ChatRoomOwnerID,
			&i.ChatRoomCoverImageID,
			&i.ChatRoomCoverImageHeight,
			&i.ChatRoomCoverImageWidth,
			&i.ChatRoomCoverImageAttachableItemID,
			&i.ChatRoomCoverImageOwnerID,
			&i.ChatRoomCoverImageFromOuter,
			&i.ChatRoomCoverImageUrl,
			&i.ChatRoomCoverImageSize,
			&i.ChatRoomCoverImageMimeTypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrganizationsWithChatRoomUseKeysetPaginate = `-- name: GetOrganizationsWithChatRoomUseKeysetPaginate :many
SELECT m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.color, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at, m_organizations.chat_room_id, m_chat_rooms.name chat_room_name, m_chat_rooms.is_private chat_room_is_private,
m_chat_rooms.from_organization chat_room_from_organization, m_chat_rooms.owner_id chat_room_owner_id,
m_chat_rooms.cover_image_id chat_room_cover_image_id, t_images.height chat_room_cover_image_height,
t_images.width chat_room_cover_image_width, t_images.attachable_item_id chat_room_cover_image_attachable_item_id,
t_attachable_items.owner_id chat_room_cover_image_owner_id, t_attachable_items.from_outer chat_room_cover_image_from_outer,
t_attachable_items.url chat_room_cover_image_url, t_attachable_items.size chat_room_cover_image_size, t_attachable_items.mime_type_id chat_room_cover_image_mime_type_id
FROM m_organizations
LEFT JOIN m_chat_rooms ON m_organizations.chat_room_id = m_chat_rooms.chat_room_id
LEFT JOIN t_images ON m_chat_rooms.cover_image_id = t_images.image_id
LEFT JOIN t_attachable_items ON t_images.attachable_item_id = t_attachable_items.attachable_item_id
WHERE
	CASE WHEN $2::boolean = true THEN m_organizations.name LIKE '%' || $3::text || '%' END
AND
	CASE WHEN $4::boolean = true THEN m_organizations.is_whole = $5 END
AND
	CASE WHEN $6::boolean = true THEN m_organizations.is_personal = $7 AND EXISTS (SELECT m_members_pkey, member_id, login_id, password, email, name, first_name, last_name, attend_status_id, profile_image_id, grade_id, group_id, personal_organization_id, role_id, created_at, updated_at FROM m_members WHERE m_members.personal_organization_id = m_organizations.organization_id AND m_members.member_id = $8::uuid) END
AND
	CASE WHEN $9::boolean = true THEN EXISTS (SELECT m_groups_pkey, group_id, key, organization_id FROM m_groups WHERE m_groups.organization_id = m_organizations.organization_id) END
AND
	CASE WHEN $10::boolean = true THEN EXISTS (SELECT m_grades_pkey, grade_id, key, organization_id FROM m_grades WHERE m_grades.organization_id = m_organizations.organization_id) END
AND
	CASE $11::text
		WHEN 'next' THEN
			CASE $12::text
				WHEN 'name' THEN m_organizations.name > $13 OR (m_organizations.name = $13 AND m_organizations_pkey > $14::int)
				WHEN 'r_name' THEN m_organizations.name < $13 OR (m_organizations.name = $13 AND m_organizations_pkey > $14::int)
				ELSE m_organizations_pkey > $14::int
			END
		WHEN 'prev' THEN
			CASE $12::text
				WHEN 'name' THEN m_organizations.name < $13 OR (m_organizations.name = $13 AND m_organizations_pkey < $14::int)
				WHEN 'r_name' THEN m_organizations.name > $13 OR (m_organizations.name = $13 AND m_organizations_pkey < $14::int)
				ELSE m_organizations_pkey < $14::int
			END
	END
ORDER BY
	CASE WHEN $12::text = 'name' AND $11::text = 'next' THEN m_organizations.name END ASC,
	CASE WHEN $12::text = 'name' AND $11::text = 'prev' THEN m_organizations.name END DESC,
	CASE WHEN $12::text = 'r_name' AND $11::text = 'next' THEN m_organizations.name END DESC,
	CASE WHEN $12::text = 'r_name' AND $11::text = 'prev' THEN m_organizations.name END ASC,
	CASE WHEN $11::text = 'next' THEN m_organizations_pkey END ASC,
	CASE WHEN $11::text = 'prev' THEN m_organizations_pkey END DESC
LIMIT $1
`

type GetOrganizationsWithChatRoomUseKeysetPaginateParams struct {
	Limit            int32     `json:"limit"`
	WhereLikeName    bool      `json:"where_like_name"`
	SearchName       string    `json:"search_name"`
	WhereIsWhole     bool      `json:"where_is_whole"`
	IsWhole          bool      `json:"is_whole"`
	WhereIsPersonal  bool      `json:"where_is_personal"`
	IsPersonal       bool      `json:"is_personal"`
	PersonalMemberID uuid.UUID `json:"personal_member_id"`
	WhereIsGroup     bool      `json:"where_is_group"`
	WhereIsGrade     bool      `json:"where_is_grade"`
	CursorDirection  string    `json:"cursor_direction"`
	OrderMethod      string    `json:"order_method"`
	NameCursor       string    `json:"name_cursor"`
	Cursor           int32     `json:"cursor"`
}

type GetOrganizationsWithChatRoomUseKeysetPaginateRow struct {
	MOrganizationsPkey                 pgtype.Int8   `json:"m_organizations_pkey"`
	OrganizationID                     uuid.UUID     `json:"organization_id"`
	Name                               string        `json:"name"`
	Description                        pgtype.Text   `json:"description"`
	Color                              pgtype.Text   `json:"color"`
	IsPersonal                         bool          `json:"is_personal"`
	IsWhole                            bool          `json:"is_whole"`
	CreatedAt                          time.Time     `json:"created_at"`
	UpdatedAt                          time.Time     `json:"updated_at"`
	ChatRoomID                         pgtype.UUID   `json:"chat_room_id"`
	ChatRoomName                       pgtype.Text   `json:"chat_room_name"`
	ChatRoomIsPrivate                  pgtype.Bool   `json:"chat_room_is_private"`
	ChatRoomFromOrganization           pgtype.Bool   `json:"chat_room_from_organization"`
	ChatRoomOwnerID                    pgtype.UUID   `json:"chat_room_owner_id"`
	ChatRoomCoverImageID               pgtype.UUID   `json:"chat_room_cover_image_id"`
	ChatRoomCoverImageHeight           pgtype.Float8 `json:"chat_room_cover_image_height"`
	ChatRoomCoverImageWidth            pgtype.Float8 `json:"chat_room_cover_image_width"`
	ChatRoomCoverImageAttachableItemID pgtype.UUID   `json:"chat_room_cover_image_attachable_item_id"`
	ChatRoomCoverImageOwnerID          pgtype.UUID   `json:"chat_room_cover_image_owner_id"`
	ChatRoomCoverImageFromOuter        pgtype.Bool   `json:"chat_room_cover_image_from_outer"`
	ChatRoomCoverImageUrl              pgtype.Text   `json:"chat_room_cover_image_url"`
	ChatRoomCoverImageSize             pgtype.Float8 `json:"chat_room_cover_image_size"`
	ChatRoomCoverImageMimeTypeID       pgtype.UUID   `json:"chat_room_cover_image_mime_type_id"`
}

func (q *Queries) GetOrganizationsWithChatRoomUseKeysetPaginate(ctx context.Context, arg GetOrganizationsWithChatRoomUseKeysetPaginateParams) ([]GetOrganizationsWithChatRoomUseKeysetPaginateRow, error) {
	rows, err := q.db.Query(ctx, getOrganizationsWithChatRoomUseKeysetPaginate,
		arg.Limit,
		arg.WhereLikeName,
		arg.SearchName,
		arg.WhereIsWhole,
		arg.IsWhole,
		arg.WhereIsPersonal,
		arg.IsPersonal,
		arg.PersonalMemberID,
		arg.WhereIsGroup,
		arg.WhereIsGrade,
		arg.CursorDirection,
		arg.OrderMethod,
		arg.NameCursor,
		arg.Cursor,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOrganizationsWithChatRoomUseKeysetPaginateRow{}
	for rows.Next() {
		var i GetOrganizationsWithChatRoomUseKeysetPaginateRow
		if err := rows.Scan(
			&i.MOrganizationsPkey,
			&i.OrganizationID,
			&i.Name,
			&i.Description,
			&i.Color,
			&i.IsPersonal,
			&i.IsWhole,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ChatRoomID,
			&i.ChatRoomName,
			&i.ChatRoomIsPrivate,
			&i.ChatRoomFromOrganization,
			&i.ChatRoomOwnerID,
			&i.ChatRoomCoverImageID,
			&i.ChatRoomCoverImageHeight,
			&i.ChatRoomCoverImageWidth,
			&i.ChatRoomCoverImageAttachableItemID,
			&i.ChatRoomCoverImageOwnerID,
			&i.ChatRoomCoverImageFromOuter,
			&i.ChatRoomCoverImageUrl,
			&i.ChatRoomCoverImageSize,
			&i.ChatRoomCoverImageMimeTypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrganizationsWithChatRoomUseNumberedPaginate = `-- name: GetOrganizationsWithChatRoomUseNumberedPaginate :many
SELECT m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.color, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at, m_organizations.chat_room_id, m_chat_rooms.name chat_room_name, m_chat_rooms.is_private chat_room_is_private,
m_chat_rooms.from_organization chat_room_from_organization, m_chat_rooms.owner_id chat_room_owner_id,
m_chat_rooms.cover_image_id chat_room_cover_image_id, t_images.height chat_room_cover_image_height,
t_images.width chat_room_cover_image_width, t_images.attachable_item_id chat_room_cover_image_attachable_item_id,
t_attachable_items.owner_id chat_room_cover_image_owner_id, t_attachable_items.from_outer chat_room_cover_image_from_outer,
t_attachable_items.url chat_room_cover_image_url, t_attachable_items.size chat_room_cover_image_size, t_attachable_items.mime_type_id chat_room_cover_image_mime_type_id
FROM m_organizations
LEFT JOIN m_chat_rooms ON m_organizations.chat_room_id = m_chat_rooms.chat_room_id
LEFT JOIN t_images ON m_chat_rooms.cover_image_id = t_images.image_id
LEFT JOIN t_attachable_items ON t_images.attachable_item_id = t_attachable_items.attachable_item_id
WHERE
	CASE WHEN $3::boolean = true THEN m_organizations.name LIKE '%' || $4::text || '%' END
AND
	CASE WHEN $5::boolean = true THEN m_organizations.is_whole = $6 END
AND
	CASE WHEN $7::boolean = true THEN m_organizations.is_personal = $8 AND EXISTS (SELECT m_members_pkey, member_id, login_id, password, email, name, first_name, last_name, attend_status_id, profile_image_id, grade_id, group_id, personal_organization_id, role_id, created_at, updated_at FROM m_members WHERE m_members.personal_organization_id = m_organizations.organization_id AND m_members.member_id = $9::uuid) END
AND
	CASE WHEN $10::boolean = true THEN EXISTS (SELECT m_groups_pkey, group_id, key, organization_id FROM m_groups WHERE m_groups.organization_id = m_organizations.organization_id) END
AND
	CASE WHEN $11::boolean = true THEN EXISTS (SELECT m_grades_pkey, grade_id, key, organization_id FROM m_grades WHERE m_grades.organization_id = m_organizations.organization_id) END
ORDER BY
	CASE WHEN $12::text = 'name' THEN m_organizations.name END ASC,
	CASE WHEN $12::text = 'r_name' THEN m_organizations.name END DESC,
	m_organizations_pkey ASC
LIMIT $1 OFFSET $2
`

type GetOrganizationsWithChatRoomUseNumberedPaginateParams struct {
	Limit            int32     `json:"limit"`
	Offset           int32     `json:"offset"`
	WhereLikeName    bool      `json:"where_like_name"`
	SearchName       string    `json:"search_name"`
	WhereIsWhole     bool      `json:"where_is_whole"`
	IsWhole          bool      `json:"is_whole"`
	WhereIsPersonal  bool      `json:"where_is_personal"`
	IsPersonal       bool      `json:"is_personal"`
	PersonalMemberID uuid.UUID `json:"personal_member_id"`
	WhereIsGroup     bool      `json:"where_is_group"`
	WhereIsGrade     bool      `json:"where_is_grade"`
	OrderMethod      string    `json:"order_method"`
}

type GetOrganizationsWithChatRoomUseNumberedPaginateRow struct {
	MOrganizationsPkey                 pgtype.Int8   `json:"m_organizations_pkey"`
	OrganizationID                     uuid.UUID     `json:"organization_id"`
	Name                               string        `json:"name"`
	Description                        pgtype.Text   `json:"description"`
	Color                              pgtype.Text   `json:"color"`
	IsPersonal                         bool          `json:"is_personal"`
	IsWhole                            bool          `json:"is_whole"`
	CreatedAt                          time.Time     `json:"created_at"`
	UpdatedAt                          time.Time     `json:"updated_at"`
	ChatRoomID                         pgtype.UUID   `json:"chat_room_id"`
	ChatRoomName                       pgtype.Text   `json:"chat_room_name"`
	ChatRoomIsPrivate                  pgtype.Bool   `json:"chat_room_is_private"`
	ChatRoomFromOrganization           pgtype.Bool   `json:"chat_room_from_organization"`
	ChatRoomOwnerID                    pgtype.UUID   `json:"chat_room_owner_id"`
	ChatRoomCoverImageID               pgtype.UUID   `json:"chat_room_cover_image_id"`
	ChatRoomCoverImageHeight           pgtype.Float8 `json:"chat_room_cover_image_height"`
	ChatRoomCoverImageWidth            pgtype.Float8 `json:"chat_room_cover_image_width"`
	ChatRoomCoverImageAttachableItemID pgtype.UUID   `json:"chat_room_cover_image_attachable_item_id"`
	ChatRoomCoverImageOwnerID          pgtype.UUID   `json:"chat_room_cover_image_owner_id"`
	ChatRoomCoverImageFromOuter        pgtype.Bool   `json:"chat_room_cover_image_from_outer"`
	ChatRoomCoverImageUrl              pgtype.Text   `json:"chat_room_cover_image_url"`
	ChatRoomCoverImageSize             pgtype.Float8 `json:"chat_room_cover_image_size"`
	ChatRoomCoverImageMimeTypeID       pgtype.UUID   `json:"chat_room_cover_image_mime_type_id"`
}

func (q *Queries) GetOrganizationsWithChatRoomUseNumberedPaginate(ctx context.Context, arg GetOrganizationsWithChatRoomUseNumberedPaginateParams) ([]GetOrganizationsWithChatRoomUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getOrganizationsWithChatRoomUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.WhereLikeName,
		arg.SearchName,
		arg.WhereIsWhole,
		arg.IsWhole,
		arg.WhereIsPersonal,
		arg.IsPersonal,
		arg.PersonalMemberID,
		arg.WhereIsGroup,
		arg.WhereIsGrade,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOrganizationsWithChatRoomUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetOrganizationsWithChatRoomUseNumberedPaginateRow
		if err := rows.Scan(
			&i.MOrganizationsPkey,
			&i.OrganizationID,
			&i.Name,
			&i.Description,
			&i.Color,
			&i.IsPersonal,
			&i.IsWhole,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ChatRoomID,
			&i.ChatRoomName,
			&i.ChatRoomIsPrivate,
			&i.ChatRoomFromOrganization,
			&i.ChatRoomOwnerID,
			&i.ChatRoomCoverImageID,
			&i.ChatRoomCoverImageHeight,
			&i.ChatRoomCoverImageWidth,
			&i.ChatRoomCoverImageAttachableItemID,
			&i.ChatRoomCoverImageOwnerID,
			&i.ChatRoomCoverImageFromOuter,
			&i.ChatRoomCoverImageUrl,
			&i.ChatRoomCoverImageSize,
			&i.ChatRoomCoverImageMimeTypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrganizationsWithDetail = `-- name: GetOrganizationsWithDetail :many
SELECT m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.color, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at, m_organizations.chat_room_id, m_groups.group_id, m_groups.key group_key, m_grades.key grade_key, m_grades.grade_id FROM m_organizations
LEFT JOIN m_groups ON m_organizations.organization_id = m_groups.organization_id
LEFT JOIN m_grades ON m_organizations.organization_id = m_grades.organization_id
WHERE
	CASE WHEN $1::boolean = true THEN m_organizations.name LIKE '%' || $2::text || '%' END
AND
	CASE WHEN $3::boolean = true THEN m_organizations.is_whole = $4 END
AND
	CASE WHEN $5::boolean = true THEN m_organizations.is_personal = $6 AND EXISTS (SELECT m_members_pkey, member_id, login_id, password, email, name, first_name, last_name, attend_status_id, profile_image_id, grade_id, group_id, personal_organization_id, role_id, created_at, updated_at FROM m_members WHERE m_members.personal_organization_id = m_organizations.organization_id AND m_members.member_id = $7::uuid) END
AND
	CASE WHEN $8::boolean = true THEN EXISTS (SELECT m_groups_pkey, group_id, key, organization_id FROM m_groups WHERE m_groups.organization_id = m_organizations.organization_id) END
AND
	CASE WHEN $9::boolean = true THEN EXISTS (SELECT m_grades_pkey, grade_id, key, organization_id FROM m_grades WHERE m_grades.organization_id = m_organizations.organization_id) END
ORDER BY
	CASE WHEN $10::text = 'name' THEN m_organizations.name END ASC,
	CASE WHEN $10::text = 'r_name' THEN m_organizations.name END DESC,
	m_organizations_pkey ASC
`

type GetOrganizationsWithDetailParams struct {
	WhereLikeName    bool      `json:"where_like_name"`
	SearchName       string    `json:"search_name"`
	WhereIsWhole     bool      `json:"where_is_whole"`
	IsWhole          bool      `json:"is_whole"`
	WhereIsPersonal  bool      `json:"where_is_personal"`
	IsPersonal       bool      `json:"is_personal"`
	PersonalMemberID uuid.UUID `json:"personal_member_id"`
	WhereIsGroup     bool      `json:"where_is_group"`
	WhereIsGrade     bool      `json:"where_is_grade"`
	OrderMethod      string    `json:"order_method"`
}

type GetOrganizationsWithDetailRow struct {
	MOrganizationsPkey pgtype.Int8 `json:"m_organizations_pkey"`
	OrganizationID     uuid.UUID   `json:"organization_id"`
	Name               string      `json:"name"`
	Description        pgtype.Text `json:"description"`
	Color              pgtype.Text `json:"color"`
	IsPersonal         bool        `json:"is_personal"`
	IsWhole            bool        `json:"is_whole"`
	CreatedAt          time.Time   `json:"created_at"`
	UpdatedAt          time.Time   `json:"updated_at"`
	ChatRoomID         pgtype.UUID `json:"chat_room_id"`
	GroupID            pgtype.UUID `json:"group_id"`
	GroupKey           pgtype.Text `json:"group_key"`
	GradeKey           pgtype.Text `json:"grade_key"`
	GradeID            pgtype.UUID `json:"grade_id"`
}

func (q *Queries) GetOrganizationsWithDetail(ctx context.Context, arg GetOrganizationsWithDetailParams) ([]GetOrganizationsWithDetailRow, error) {
	rows, err := q.db.Query(ctx, getOrganizationsWithDetail,
		arg.WhereLikeName,
		arg.SearchName,
		arg.WhereIsWhole,
		arg.IsWhole,
		arg.WhereIsPersonal,
		arg.IsPersonal,
		arg.PersonalMemberID,
		arg.WhereIsGroup,
		arg.WhereIsGrade,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOrganizationsWithDetailRow{}
	for rows.Next() {
		var i GetOrganizationsWithDetailRow
		if err := rows.Scan(
			&i.MOrganizationsPkey,
			&i.OrganizationID,
			&i.Name,
			&i.Description,
			&i.Color,
			&i.IsPersonal,
			&i.IsWhole,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ChatRoomID,
			&i.GroupID,
			&i.GroupKey,
			&i.GradeKey,
			&i.GradeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrganizationsWithDetailUseKeysetPaginate = `-- name: GetOrganizationsWithDetailUseKeysetPaginate :many
SELECT m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.color, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at, m_organizations.chat_room_id, m_groups.group_id, m_groups.key group_key, m_grades.key grade_key, m_grades.grade_id FROM m_organizations
LEFT JOIN m_groups ON m_organizations.organization_id = m_groups.organization_id
LEFT JOIN m_grades ON m_organizations.organization_id = m_grades.organization_id
WHERE
	CASE WHEN $2::boolean = true THEN m_organizations.name LIKE '%' || $3::text || '%' END
AND
	CASE WHEN $4::boolean = true THEN m_organizations.is_whole = $5 END
AND
	CASE WHEN $6::boolean = true THEN m_organizations.is_personal = $7 AND EXISTS (SELECT m_members_pkey, member_id, login_id, password, email, name, first_name, last_name, attend_status_id, profile_image_id, grade_id, group_id, personal_organization_id, role_id, created_at, updated_at FROM m_members WHERE m_members.personal_organization_id = m_organizations.organization_id AND m_members.member_id = $8::uuid) END
AND
	CASE WHEN $9::boolean = true THEN EXISTS (SELECT m_groups_pkey, group_id, key, organization_id FROM m_groups WHERE m_groups.organization_id = m_organizations.organization_id) END
AND
	CASE WHEN $10::boolean = true THEN EXISTS (SELECT m_grades_pkey, grade_id, key, organization_id FROM m_grades WHERE m_grades.organization_id = m_organizations.organization_id) END
AND
	CASE $11::text
		WHEN 'next' THEN
			CASE $12::text
				WHEN 'name' THEN m_organizations.name > $13 OR (m_organizations.name = $13 AND m_organizations_pkey > $14::int)
				WHEN 'r_name' THEN m_organizations.name < $13 OR (m_organizations.name = $13 AND m_organizations_pkey > $14::int)
				ELSE m_organizations_pkey > $14::int
			END
		WHEN 'prev' THEN
			CASE $12::text
				WHEN 'name' THEN m_organizations.name < $13 OR (m_organizations.name = $13 AND m_organizations_pkey < $14::int)
				WHEN 'r_name' THEN m_organizations.name > $13 OR (m_organizations.name = $13 AND m_organizations_pkey < $14::int)
				ELSE m_organizations_pkey < $14::int
			END
	END
ORDER BY
	CASE WHEN $12::text = 'name' AND $11::text = 'next' THEN m_organizations.name END ASC,
	CASE WHEN $12::text = 'name' AND $11::text = 'prev' THEN m_organizations.name END DESC,
	CASE WHEN $12::text = 'r_name' AND $11::text = 'next' THEN m_organizations.name END DESC,
	CASE WHEN $12::text = 'r_name' AND $11::text = 'prev' THEN m_organizations.name END ASC,
	CASE WHEN $11::text = 'next' THEN m_organizations_pkey END ASC,
	CASE WHEN $11::text = 'prev' THEN m_organizations_pkey END DESC
LIMIT $1
`

type GetOrganizationsWithDetailUseKeysetPaginateParams struct {
	Limit            int32     `json:"limit"`
	WhereLikeName    bool      `json:"where_like_name"`
	SearchName       string    `json:"search_name"`
	WhereIsWhole     bool      `json:"where_is_whole"`
	IsWhole          bool      `json:"is_whole"`
	WhereIsPersonal  bool      `json:"where_is_personal"`
	IsPersonal       bool      `json:"is_personal"`
	PersonalMemberID uuid.UUID `json:"personal_member_id"`
	WhereIsGroup     bool      `json:"where_is_group"`
	WhereIsGrade     bool      `json:"where_is_grade"`
	CursorDirection  string    `json:"cursor_direction"`
	OrderMethod      string    `json:"order_method"`
	NameCursor       string    `json:"name_cursor"`
	Cursor           int32     `json:"cursor"`
}

type GetOrganizationsWithDetailUseKeysetPaginateRow struct {
	MOrganizationsPkey pgtype.Int8 `json:"m_organizations_pkey"`
	OrganizationID     uuid.UUID   `json:"organization_id"`
	Name               string      `json:"name"`
	Description        pgtype.Text `json:"description"`
	Color              pgtype.Text `json:"color"`
	IsPersonal         bool        `json:"is_personal"`
	IsWhole            bool        `json:"is_whole"`
	CreatedAt          time.Time   `json:"created_at"`
	UpdatedAt          time.Time   `json:"updated_at"`
	ChatRoomID         pgtype.UUID `json:"chat_room_id"`
	GroupID            pgtype.UUID `json:"group_id"`
	GroupKey           pgtype.Text `json:"group_key"`
	GradeKey           pgtype.Text `json:"grade_key"`
	GradeID            pgtype.UUID `json:"grade_id"`
}

func (q *Queries) GetOrganizationsWithDetailUseKeysetPaginate(ctx context.Context, arg GetOrganizationsWithDetailUseKeysetPaginateParams) ([]GetOrganizationsWithDetailUseKeysetPaginateRow, error) {
	rows, err := q.db.Query(ctx, getOrganizationsWithDetailUseKeysetPaginate,
		arg.Limit,
		arg.WhereLikeName,
		arg.SearchName,
		arg.WhereIsWhole,
		arg.IsWhole,
		arg.WhereIsPersonal,
		arg.IsPersonal,
		arg.PersonalMemberID,
		arg.WhereIsGroup,
		arg.WhereIsGrade,
		arg.CursorDirection,
		arg.OrderMethod,
		arg.NameCursor,
		arg.Cursor,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOrganizationsWithDetailUseKeysetPaginateRow{}
	for rows.Next() {
		var i GetOrganizationsWithDetailUseKeysetPaginateRow
		if err := rows.Scan(
			&i.MOrganizationsPkey,
			&i.OrganizationID,
			&i.Name,
			&i.Description,
			&i.Color,
			&i.IsPersonal,
			&i.IsWhole,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ChatRoomID,
			&i.GroupID,
			&i.GroupKey,
			&i.GradeKey,
			&i.GradeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrganizationsWithDetailUseNumberedPaginate = `-- name: GetOrganizationsWithDetailUseNumberedPaginate :many
SELECT m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.color, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at, m_organizations.chat_room_id, m_groups.group_id, m_groups.key group_key, m_grades.key grade_key, m_grades.grade_id FROM m_organizations
LEFT JOIN m_groups ON m_organizations.organization_id = m_groups.organization_id
LEFT JOIN m_grades ON m_organizations.organization_id = m_grades.organization_id
WHERE
	CASE WHEN $3::boolean = true THEN m_organizations.name LIKE '%' || $4::text || '%' END
AND
	CASE WHEN $5::boolean = true THEN m_organizations.is_whole = $6 END
AND
	CASE WHEN $7::boolean = true THEN m_organizations.is_personal = $8 AND EXISTS (SELECT m_members_pkey, member_id, login_id, password, email, name, first_name, last_name, attend_status_id, profile_image_id, grade_id, group_id, personal_organization_id, role_id, created_at, updated_at FROM m_members WHERE m_members.personal_organization_id = m_organizations.organization_id AND m_members.member_id = $9::uuid) END
AND
	CASE WHEN $10::boolean = true THEN EXISTS (SELECT m_groups_pkey, group_id, key, organization_id FROM m_groups WHERE m_groups.organization_id = m_organizations.organization_id) END
AND
	CASE WHEN $11::boolean = true THEN EXISTS (SELECT m_grades_pkey, grade_id, key, organization_id FROM m_grades WHERE m_grades.organization_id = m_organizations.organization_id) END
ORDER BY
	CASE WHEN $12::text = 'name' THEN m_organizations.name END ASC,
	CASE WHEN $12::text = 'r_name' THEN m_organizations.name END DESC,
	m_organizations_pkey ASC
LIMIT $1 OFFSET $2
`

type GetOrganizationsWithDetailUseNumberedPaginateParams struct {
	Limit            int32     `json:"limit"`
	Offset           int32     `json:"offset"`
	WhereLikeName    bool      `json:"where_like_name"`
	SearchName       string    `json:"search_name"`
	WhereIsWhole     bool      `json:"where_is_whole"`
	IsWhole          bool      `json:"is_whole"`
	WhereIsPersonal  bool      `json:"where_is_personal"`
	IsPersonal       bool      `json:"is_personal"`
	PersonalMemberID uuid.UUID `json:"personal_member_id"`
	WhereIsGroup     bool      `json:"where_is_group"`
	WhereIsGrade     bool      `json:"where_is_grade"`
	OrderMethod      string    `json:"order_method"`
}

type GetOrganizationsWithDetailUseNumberedPaginateRow struct {
	MOrganizationsPkey pgtype.Int8 `json:"m_organizations_pkey"`
	OrganizationID     uuid.UUID   `json:"organization_id"`
	Name               string      `json:"name"`
	Description        pgtype.Text `json:"description"`
	Color              pgtype.Text `json:"color"`
	IsPersonal         bool        `json:"is_personal"`
	IsWhole            bool        `json:"is_whole"`
	CreatedAt          time.Time   `json:"created_at"`
	UpdatedAt          time.Time   `json:"updated_at"`
	ChatRoomID         pgtype.UUID `json:"chat_room_id"`
	GroupID            pgtype.UUID `json:"group_id"`
	GroupKey           pgtype.Text `json:"group_key"`
	GradeKey           pgtype.Text `json:"grade_key"`
	GradeID            pgtype.UUID `json:"grade_id"`
}

func (q *Queries) GetOrganizationsWithDetailUseNumberedPaginate(ctx context.Context, arg GetOrganizationsWithDetailUseNumberedPaginateParams) ([]GetOrganizationsWithDetailUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getOrganizationsWithDetailUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.WhereLikeName,
		arg.SearchName,
		arg.WhereIsWhole,
		arg.IsWhole,
		arg.WhereIsPersonal,
		arg.IsPersonal,
		arg.PersonalMemberID,
		arg.WhereIsGroup,
		arg.WhereIsGrade,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOrganizationsWithDetailUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetOrganizationsWithDetailUseNumberedPaginateRow
		if err := rows.Scan(
			&i.MOrganizationsPkey,
			&i.OrganizationID,
			&i.Name,
			&i.Description,
			&i.Color,
			&i.IsPersonal,
			&i.IsWhole,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ChatRoomID,
			&i.GroupID,
			&i.GroupKey,
			&i.GradeKey,
			&i.GradeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralOrganizations = `-- name: GetPluralOrganizations :many
SELECT m_organizations_pkey, organization_id, name, description, color, is_personal, is_whole, created_at, updated_at, chat_room_id FROM m_organizations WHERE organization_id = ANY($1::uuid[])
ORDER BY
	CASE WHEN $2::text = 'name' THEN m_organizations.name END ASC,
	CASE WHEN $2::text = 'r_name' THEN m_organizations.name END DESC,
	m_organizations_pkey ASC
`

type GetPluralOrganizationsParams struct {
	OrganizationIds []uuid.UUID `json:"organization_ids"`
	OrderMethod     string      `json:"order_method"`
}

func (q *Queries) GetPluralOrganizations(ctx context.Context, arg GetPluralOrganizationsParams) ([]Organization, error) {
	rows, err := q.db.Query(ctx, getPluralOrganizations, arg.OrganizationIds, arg.OrderMethod)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Organization{}
	for rows.Next() {
		var i Organization
		if err := rows.Scan(
			&i.MOrganizationsPkey,
			&i.OrganizationID,
			&i.Name,
			&i.Description,
			&i.Color,
			&i.IsPersonal,
			&i.IsWhole,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ChatRoomID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralOrganizationsUseNumberedPaginate = `-- name: GetPluralOrganizationsUseNumberedPaginate :many
SELECT m_organizations_pkey, organization_id, name, description, color, is_personal, is_whole, created_at, updated_at, chat_room_id FROM m_organizations WHERE organization_id = ANY($3::uuid[])
ORDER BY
	CASE WHEN $4::text = 'name' THEN m_organizations.name END ASC,
	CASE WHEN $4::text = 'r_name' THEN m_organizations.name END DESC,
	m_organizations_pkey ASC
LIMIT $1 OFFSET $2
`

type GetPluralOrganizationsUseNumberedPaginateParams struct {
	Limit           int32       `json:"limit"`
	Offset          int32       `json:"offset"`
	OrganizationIds []uuid.UUID `json:"organization_ids"`
	OrderMethod     string      `json:"order_method"`
}

func (q *Queries) GetPluralOrganizationsUseNumberedPaginate(ctx context.Context, arg GetPluralOrganizationsUseNumberedPaginateParams) ([]Organization, error) {
	rows, err := q.db.Query(ctx, getPluralOrganizationsUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.OrganizationIds,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Organization{}
	for rows.Next() {
		var i Organization
		if err := rows.Scan(
			&i.MOrganizationsPkey,
			&i.OrganizationID,
			&i.Name,
			&i.Description,
			&i.Color,
			&i.IsPersonal,
			&i.IsWhole,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ChatRoomID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralOrganizationsWithChatRoom = `-- name: GetPluralOrganizationsWithChatRoom :many
SELECT m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.color, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at, m_organizations.chat_room_id, m_chat_rooms.name chat_room_name, m_chat_rooms.is_private chat_room_is_private,
m_chat_rooms.from_organization chat_room_from_organization, m_chat_rooms.owner_id chat_room_owner_id,
m_chat_rooms.cover_image_id chat_room_cover_image_id, t_images.height chat_room_cover_image_height,
t_images.width chat_room_cover_image_width, t_images.attachable_item_id chat_room_cover_image_attachable_item_id,
t_attachable_items.owner_id chat_room_cover_image_owner_id, t_attachable_items.from_outer chat_room_cover_image_from_outer,
t_attachable_items.url chat_room_cover_image_url, t_attachable_items.size chat_room_cover_image_size, t_attachable_items.mime_type_id chat_room_cover_image_mime_type_id
FROM m_organizations
LEFT JOIN m_chat_rooms ON m_organizations.chat_room_id = m_chat_rooms.chat_room_id
LEFT JOIN t_images ON m_chat_rooms.cover_image_id = t_images.image_id
LEFT JOIN t_attachable_items ON t_images.attachable_item_id = t_attachable_items.attachable_item_id
WHERE organization_id = ANY($1::uuid[])
ORDER BY
	CASE WHEN $2::text = 'name' THEN m_organizations.name END ASC,
	CASE WHEN $2::text = 'r_name' THEN m_organizations.name END DESC,
	m_organizations_pkey ASC
`

type GetPluralOrganizationsWithChatRoomParams struct {
	OrganizationIds []uuid.UUID `json:"organization_ids"`
	OrderMethod     string      `json:"order_method"`
}

type GetPluralOrganizationsWithChatRoomRow struct {
	MOrganizationsPkey                 pgtype.Int8   `json:"m_organizations_pkey"`
	OrganizationID                     uuid.UUID     `json:"organization_id"`
	Name                               string        `json:"name"`
	Description                        pgtype.Text   `json:"description"`
	Color                              pgtype.Text   `json:"color"`
	IsPersonal                         bool          `json:"is_personal"`
	IsWhole                            bool          `json:"is_whole"`
	CreatedAt                          time.Time     `json:"created_at"`
	UpdatedAt                          time.Time     `json:"updated_at"`
	ChatRoomID                         pgtype.UUID   `json:"chat_room_id"`
	ChatRoomName                       pgtype.Text   `json:"chat_room_name"`
	ChatRoomIsPrivate                  pgtype.Bool   `json:"chat_room_is_private"`
	ChatRoomFromOrganization           pgtype.Bool   `json:"chat_room_from_organization"`
	ChatRoomOwnerID                    pgtype.UUID   `json:"chat_room_owner_id"`
	ChatRoomCoverImageID               pgtype.UUID   `json:"chat_room_cover_image_id"`
	ChatRoomCoverImageHeight           pgtype.Float8 `json:"chat_room_cover_image_height"`
	ChatRoomCoverImageWidth            pgtype.Float8 `json:"chat_room_cover_image_width"`
	ChatRoomCoverImageAttachableItemID pgtype.UUID   `json:"chat_room_cover_image_attachable_item_id"`
	ChatRoomCoverImageOwnerID          pgtype.UUID   `json:"chat_room_cover_image_owner_id"`
	ChatRoomCoverImageFromOuter        pgtype.Bool   `json:"chat_room_cover_image_from_outer"`
	ChatRoomCoverImageUrl              pgtype.Text   `json:"chat_room_cover_image_url"`
	ChatRoomCoverImageSize             pgtype.Float8 `json:"chat_room_cover_image_size"`
	ChatRoomCoverImageMimeTypeID       pgtype.UUID   `json:"chat_room_cover_image_mime_type_id"`
}

func (q *Queries) GetPluralOrganizationsWithChatRoom(ctx context.Context, arg GetPluralOrganizationsWithChatRoomParams) ([]GetPluralOrganizationsWithChatRoomRow, error) {
	rows, err := q.db.Query(ctx, getPluralOrganizationsWithChatRoom, arg.OrganizationIds, arg.OrderMethod)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralOrganizationsWithChatRoomRow{}
	for rows.Next() {
		var i GetPluralOrganizationsWithChatRoomRow
		if err := rows.Scan(
			&i.MOrganizationsPkey,
			&i.OrganizationID,
			&i.Name,
			&i.Description,
			&i.Color,
			&i.IsPersonal,
			&i.IsWhole,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ChatRoomID,
			&i.ChatRoomName,
			&i.ChatRoomIsPrivate,
			&i.ChatRoomFromOrganization,
			&i.ChatRoomOwnerID,
			&i.ChatRoomCoverImageID,
			&i.ChatRoomCoverImageHeight,
			&i.ChatRoomCoverImageWidth,
			&i.ChatRoomCoverImageAttachableItemID,
			&i.ChatRoomCoverImageOwnerID,
			&i.ChatRoomCoverImageFromOuter,
			&i.ChatRoomCoverImageUrl,
			&i.ChatRoomCoverImageSize,
			&i.ChatRoomCoverImageMimeTypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralOrganizationsWithChatRoomAndDetail = `-- name: GetPluralOrganizationsWithChatRoomAndDetail :many
SELECT m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.color, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at, m_organizations.chat_room_id, m_groups.group_id, m_groups.key group_key, m_grades.key grade_key, m_grades.grade_id, m_chat_rooms.name chat_room_name, m_chat_rooms.is_private chat_room_is_private,
m_chat_rooms.from_organization chat_room_from_organization, m_chat_rooms.owner_id chat_room_owner_id,
m_chat_rooms.cover_image_id chat_room_cover_image_id, t_images.height chat_room_cover_image_height,
t_images.width chat_room_cover_image_width, t_images.attachable_item_id chat_room_cover_image_attachable_item_id,
t_attachable_items.owner_id chat_room_cover_image_owner_id, t_attachable_items.from_outer chat_room_cover_image_from_outer,
t_attachable_items.url chat_room_cover_image_url, t_attachable_items.size chat_room_cover_image_size, t_attachable_items.mime_type_id chat_room_cover_image_mime_type_id
FROM m_organizations
LEFT JOIN m_groups ON m_organizations.organization_id = m_groups.organization_id
LEFT JOIN m_grades ON m_organizations.organization_id = m_grades.organization_id
LEFT JOIN m_chat_rooms ON m_organizations.chat_room_id = m_chat_rooms.chat_room_id
LEFT JOIN t_images ON m_chat_rooms.cover_image_id = t_images.image_id
LEFT JOIN t_attachable_items ON t_images.attachable_item_id = t_attachable_items.attachable_item_id
WHERE organization_id = ANY($1::uuid[])
ORDER BY
	CASE WHEN $2::text = 'name' THEN m_organizations.name END ASC,
	CASE WHEN $2::text = 'r_name' THEN m_organizations.name END DESC,
	m_organizations_pkey ASC
`

type GetPluralOrganizationsWithChatRoomAndDetailParams struct {
	OrganizationIds []uuid.UUID `json:"organization_ids"`
	OrderMethod     string      `json:"order_method"`
}

type GetPluralOrganizationsWithChatRoomAndDetailRow struct {
	MOrganizationsPkey                 pgtype.Int8   `json:"m_organizations_pkey"`
	OrganizationID                     uuid.UUID     `json:"organization_id"`
	Name                               string        `json:"name"`
	Description                        pgtype.Text   `json:"description"`
	Color                              pgtype.Text   `json:"color"`
	IsPersonal                         bool          `json:"is_personal"`
	IsWhole                            bool          `json:"is_whole"`
	CreatedAt                          time.Time     `json:"created_at"`
	UpdatedAt                          time.Time     `json:"updated_at"`
	ChatRoomID                         pgtype.UUID   `json:"chat_room_id"`
	GroupID                            pgtype.UUID   `json:"group_id"`
	GroupKey                           pgtype.Text   `json:"group_key"`
	GradeKey                           pgtype.Text   `json:"grade_key"`
	GradeID                            pgtype.UUID   `json:"grade_id"`
	ChatRoomName                       pgtype.Text   `json:"chat_room_name"`
	ChatRoomIsPrivate                  pgtype.Bool   `json:"chat_room_is_private"`
	ChatRoomFromOrganization           pgtype.Bool   `json:"chat_room_from_organization"`
	ChatRoomOwnerID                    pgtype.UUID   `json:"chat_room_owner_id"`
	ChatRoomCoverImageID               pgtype.UUID   `json:"chat_room_cover_image_id"`
	ChatRoomCoverImageHeight           pgtype.Float8 `json:"chat_room_cover_image_height"`
	ChatRoomCoverImageWidth            pgtype.Float8 `json:"chat_room_cover_image_width"`
	ChatRoomCoverImageAttachableItemID pgtype.UUID   `json:"chat_room_cover_image_attachable_item_id"`
	ChatRoomCoverImageOwnerID          pgtype.UUID   `json:"chat_room_cover_image_owner_id"`
	ChatRoomCoverImageFromOuter        pgtype.Bool   `json:"chat_room_cover_image_from_outer"`
	ChatRoomCoverImageUrl              pgtype.Text   `json:"chat_room_cover_image_url"`
	ChatRoomCoverImageSize             pgtype.Float8 `json:"chat_room_cover_image_size"`
	ChatRoomCoverImageMimeTypeID       pgtype.UUID   `json:"chat_room_cover_image_mime_type_id"`
}

func (q *Queries) GetPluralOrganizationsWithChatRoomAndDetail(ctx context.Context, arg GetPluralOrganizationsWithChatRoomAndDetailParams) ([]GetPluralOrganizationsWithChatRoomAndDetailRow, error) {
	rows, err := q.db.Query(ctx, getPluralOrganizationsWithChatRoomAndDetail, arg.OrganizationIds, arg.OrderMethod)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralOrganizationsWithChatRoomAndDetailRow{}
	for rows.Next() {
		var i GetPluralOrganizationsWithChatRoomAndDetailRow
		if err := rows.Scan(
			&i.MOrganizationsPkey,
			&i.OrganizationID,
			&i.Name,
			&i.Description,
			&i.Color,
			&i.IsPersonal,
			&i.IsWhole,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ChatRoomID,
			&i.GroupID,
			&i.GroupKey,
			&i.GradeKey,
			&i.GradeID,
			&i.ChatRoomName,
			&i.ChatRoomIsPrivate,
			&i.ChatRoomFromOrganization,
			&i.ChatRoomOwnerID,
			&i.ChatRoomCoverImageID,
			&i.ChatRoomCoverImageHeight,
			&i.ChatRoomCoverImageWidth,
			&i.ChatRoomCoverImageAttachableItemID,
			&i.ChatRoomCoverImageOwnerID,
			&i.ChatRoomCoverImageFromOuter,
			&i.ChatRoomCoverImageUrl,
			&i.ChatRoomCoverImageSize,
			&i.ChatRoomCoverImageMimeTypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralOrganizationsWithChatRoomAndDetailUseNumberedPaginate = `-- name: GetPluralOrganizationsWithChatRoomAndDetailUseNumberedPaginate :many
SELECT m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.color, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at, m_organizations.chat_room_id, m_groups.group_id, m_groups.key group_key, m_grades.key grade_key, m_grades.grade_id, m_chat_rooms.name chat_room_name, m_chat_rooms.is_private chat_room_is_private,
m_chat_rooms.from_organization chat_room_from_organization, m_chat_rooms.owner_id chat_room_owner_id,
m_chat_rooms.cover_image_id chat_room_cover_image_id, t_images.height chat_room_cover_image_height,
t_images.width chat_room_cover_image_width, t_images.attachable_item_id chat_room_cover_image_attachable_item_id,
t_attachable_items.owner_id chat_room_cover_image_owner_id, t_attachable_items.from_outer chat_room_cover_image_from_outer,
t_attachable_items.url chat_room_cover_image_url, t_attachable_items.size chat_room_cover_image_size, t_attachable_items.mime_type_id chat_room_cover_image_mime_type_id
FROM m_organizations
LEFT JOIN m_groups ON m_organizations.organization_id = m_groups.organization_id
LEFT JOIN m_grades ON m_organizations.organization_id = m_grades.organization_id
LEFT JOIN m_chat_rooms ON m_organizations.chat_room_id = m_chat_rooms.chat_room_id
LEFT JOIN t_images ON m_chat_rooms.cover_image_id = t_images.image_id
LEFT JOIN t_attachable_items ON t_images.attachable_item_id = t_attachable_items.attachable_item_id
WHERE organization_id = ANY($3::uuid[])
ORDER BY
	CASE WHEN $4::text = 'name' THEN m_organizations.name END ASC,
	CASE WHEN $4::text = 'r_name' THEN m_organizations.name END DESC,
	m_organizations_pkey ASC
LIMIT $1 OFFSET $2
`

type GetPluralOrganizationsWithChatRoomAndDetailUseNumberedPaginateParams struct {
	Limit           int32       `json:"limit"`
	Offset          int32       `json:"offset"`
	OrganizationIds []uuid.UUID `json:"organization_ids"`
	OrderMethod     string      `json:"order_method"`
}

type GetPluralOrganizationsWithChatRoomAndDetailUseNumberedPaginateRow struct {
	MOrganizationsPkey                 pgtype.Int8   `json:"m_organizations_pkey"`
	OrganizationID                     uuid.UUID     `json:"organization_id"`
	Name                               string        `json:"name"`
	Description                        pgtype.Text   `json:"description"`
	Color                              pgtype.Text   `json:"color"`
	IsPersonal                         bool          `json:"is_personal"`
	IsWhole                            bool          `json:"is_whole"`
	CreatedAt                          time.Time     `json:"created_at"`
	UpdatedAt                          time.Time     `json:"updated_at"`
	ChatRoomID                         pgtype.UUID   `json:"chat_room_id"`
	GroupID                            pgtype.UUID   `json:"group_id"`
	GroupKey                           pgtype.Text   `json:"group_key"`
	GradeKey                           pgtype.Text   `json:"grade_key"`
	GradeID                            pgtype.UUID   `json:"grade_id"`
	ChatRoomName                       pgtype.Text   `json:"chat_room_name"`
	ChatRoomIsPrivate                  pgtype.Bool   `json:"chat_room_is_private"`
	ChatRoomFromOrganization           pgtype.Bool   `json:"chat_room_from_organization"`
	ChatRoomOwnerID                    pgtype.UUID   `json:"chat_room_owner_id"`
	ChatRoomCoverImageID               pgtype.UUID   `json:"chat_room_cover_image_id"`
	ChatRoomCoverImageHeight           pgtype.Float8 `json:"chat_room_cover_image_height"`
	ChatRoomCoverImageWidth            pgtype.Float8 `json:"chat_room_cover_image_width"`
	ChatRoomCoverImageAttachableItemID pgtype.UUID   `json:"chat_room_cover_image_attachable_item_id"`
	ChatRoomCoverImageOwnerID          pgtype.UUID   `json:"chat_room_cover_image_owner_id"`
	ChatRoomCoverImageFromOuter        pgtype.Bool   `json:"chat_room_cover_image_from_outer"`
	ChatRoomCoverImageUrl              pgtype.Text   `json:"chat_room_cover_image_url"`
	ChatRoomCoverImageSize             pgtype.Float8 `json:"chat_room_cover_image_size"`
	ChatRoomCoverImageMimeTypeID       pgtype.UUID   `json:"chat_room_cover_image_mime_type_id"`
}

func (q *Queries) GetPluralOrganizationsWithChatRoomAndDetailUseNumberedPaginate(ctx context.Context, arg GetPluralOrganizationsWithChatRoomAndDetailUseNumberedPaginateParams) ([]GetPluralOrganizationsWithChatRoomAndDetailUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getPluralOrganizationsWithChatRoomAndDetailUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.OrganizationIds,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralOrganizationsWithChatRoomAndDetailUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetPluralOrganizationsWithChatRoomAndDetailUseNumberedPaginateRow
		if err := rows.Scan(
			&i.MOrganizationsPkey,
			&i.OrganizationID,
			&i.Name,
			&i.Description,
			&i.Color,
			&i.IsPersonal,
			&i.IsWhole,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ChatRoomID,
			&i.GroupID,
			&i.GroupKey,
			&i.GradeKey,
			&i.GradeID,
			&i.ChatRoomName,
			&i.ChatRoomIsPrivate,
			&i.ChatRoomFromOrganization,
			&i.ChatRoomOwnerID,
			&i.ChatRoomCoverImageID,
			&i.ChatRoomCoverImageHeight,
			&i.ChatRoomCoverImageWidth,
			&i.ChatRoomCoverImageAttachableItemID,
			&i.ChatRoomCoverImageOwnerID,
			&i.ChatRoomCoverImageFromOuter,
			&i.ChatRoomCoverImageUrl,
			&i.ChatRoomCoverImageSize,
			&i.ChatRoomCoverImageMimeTypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralOrganizationsWithChatRoomUseNumberedPaginate = `-- name: GetPluralOrganizationsWithChatRoomUseNumberedPaginate :many
SELECT m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.color, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at, m_organizations.chat_room_id, m_chat_rooms.name chat_room_name, m_chat_rooms.is_private chat_room_is_private,
m_chat_rooms.from_organization chat_room_from_organization, m_chat_rooms.owner_id chat_room_owner_id,
m_chat_rooms.cover_image_id chat_room_cover_image_id, t_images.height chat_room_cover_image_height,
t_images.width chat_room_cover_image_width, t_images.attachable_item_id chat_room_cover_image_attachable_item_id,
t_attachable_items.owner_id chat_room_cover_image_owner_id, t_attachable_items.from_outer chat_room_cover_image_from_outer,
t_attachable_items.url chat_room_cover_image_url, t_attachable_items.size chat_room_cover_image_size, t_attachable_items.mime_type_id chat_room_cover_image_mime_type_id
FROM m_organizations
LEFT JOIN m_chat_rooms ON m_organizations.chat_room_id = m_chat_rooms.chat_room_id
LEFT JOIN t_images ON m_chat_rooms.cover_image_id = t_images.image_id
LEFT JOIN t_attachable_items ON t_images.attachable_item_id = t_attachable_items.attachable_item_id
WHERE organization_id = ANY($3::uuid[])
ORDER BY
	CASE WHEN $4::text = 'name' THEN m_organizations.name END ASC,
	CASE WHEN $4::text = 'r_name' THEN m_organizations.name END DESC,
	m_organizations_pkey ASC
LIMIT $1 OFFSET $2
`

type GetPluralOrganizationsWithChatRoomUseNumberedPaginateParams struct {
	Limit           int32       `json:"limit"`
	Offset          int32       `json:"offset"`
	OrganizationIds []uuid.UUID `json:"organization_ids"`
	OrderMethod     string      `json:"order_method"`
}

type GetPluralOrganizationsWithChatRoomUseNumberedPaginateRow struct {
	MOrganizationsPkey                 pgtype.Int8   `json:"m_organizations_pkey"`
	OrganizationID                     uuid.UUID     `json:"organization_id"`
	Name                               string        `json:"name"`
	Description                        pgtype.Text   `json:"description"`
	Color                              pgtype.Text   `json:"color"`
	IsPersonal                         bool          `json:"is_personal"`
	IsWhole                            bool          `json:"is_whole"`
	CreatedAt                          time.Time     `json:"created_at"`
	UpdatedAt                          time.Time     `json:"updated_at"`
	ChatRoomID                         pgtype.UUID   `json:"chat_room_id"`
	ChatRoomName                       pgtype.Text   `json:"chat_room_name"`
	ChatRoomIsPrivate                  pgtype.Bool   `json:"chat_room_is_private"`
	ChatRoomFromOrganization           pgtype.Bool   `json:"chat_room_from_organization"`
	ChatRoomOwnerID                    pgtype.UUID   `json:"chat_room_owner_id"`
	ChatRoomCoverImageID               pgtype.UUID   `json:"chat_room_cover_image_id"`
	ChatRoomCoverImageHeight           pgtype.Float8 `json:"chat_room_cover_image_height"`
	ChatRoomCoverImageWidth            pgtype.Float8 `json:"chat_room_cover_image_width"`
	ChatRoomCoverImageAttachableItemID pgtype.UUID   `json:"chat_room_cover_image_attachable_item_id"`
	ChatRoomCoverImageOwnerID          pgtype.UUID   `json:"chat_room_cover_image_owner_id"`
	ChatRoomCoverImageFromOuter        pgtype.Bool   `json:"chat_room_cover_image_from_outer"`
	ChatRoomCoverImageUrl              pgtype.Text   `json:"chat_room_cover_image_url"`
	ChatRoomCoverImageSize             pgtype.Float8 `json:"chat_room_cover_image_size"`
	ChatRoomCoverImageMimeTypeID       pgtype.UUID   `json:"chat_room_cover_image_mime_type_id"`
}

func (q *Queries) GetPluralOrganizationsWithChatRoomUseNumberedPaginate(ctx context.Context, arg GetPluralOrganizationsWithChatRoomUseNumberedPaginateParams) ([]GetPluralOrganizationsWithChatRoomUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getPluralOrganizationsWithChatRoomUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.OrganizationIds,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralOrganizationsWithChatRoomUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetPluralOrganizationsWithChatRoomUseNumberedPaginateRow
		if err := rows.Scan(
			&i.MOrganizationsPkey,
			&i.OrganizationID,
			&i.Name,
			&i.Description,
			&i.Color,
			&i.IsPersonal,
			&i.IsWhole,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ChatRoomID,
			&i.ChatRoomName,
			&i.ChatRoomIsPrivate,
			&i.ChatRoomFromOrganization,
			&i.ChatRoomOwnerID,
			&i.ChatRoomCoverImageID,
			&i.ChatRoomCoverImageHeight,
			&i.ChatRoomCoverImageWidth,
			&i.ChatRoomCoverImageAttachableItemID,
			&i.ChatRoomCoverImageOwnerID,
			&i.ChatRoomCoverImageFromOuter,
			&i.ChatRoomCoverImageUrl,
			&i.ChatRoomCoverImageSize,
			&i.ChatRoomCoverImageMimeTypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralOrganizationsWithDetail = `-- name: GetPluralOrganizationsWithDetail :many
SELECT m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.color, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at, m_organizations.chat_room_id, m_groups.group_id, m_groups.key group_key, m_grades.key grade_key, m_grades.grade_id FROM m_organizations
LEFT JOIN m_groups ON m_organizations.organization_id = m_groups.organization_id
LEFT JOIN m_grades ON m_organizations.organization_id = m_grades.organization_id
WHERE organization_id = ANY($1::uuid[])
ORDER BY
	CASE WHEN $2::text = 'name' THEN m_organizations.name END ASC,
	CASE WHEN $2::text = 'r_name' THEN m_organizations.name END DESC,
	m_organizations_pkey ASC
`

type GetPluralOrganizationsWithDetailParams struct {
	OrganizationIds []uuid.UUID `json:"organization_ids"`
	OrderMethod     string      `json:"order_method"`
}

type GetPluralOrganizationsWithDetailRow struct {
	MOrganizationsPkey pgtype.Int8 `json:"m_organizations_pkey"`
	OrganizationID     uuid.UUID   `json:"organization_id"`
	Name               string      `json:"name"`
	Description        pgtype.Text `json:"description"`
	Color              pgtype.Text `json:"color"`
	IsPersonal         bool        `json:"is_personal"`
	IsWhole            bool        `json:"is_whole"`
	CreatedAt          time.Time   `json:"created_at"`
	UpdatedAt          time.Time   `json:"updated_at"`
	ChatRoomID         pgtype.UUID `json:"chat_room_id"`
	GroupID            pgtype.UUID `json:"group_id"`
	GroupKey           pgtype.Text `json:"group_key"`
	GradeKey           pgtype.Text `json:"grade_key"`
	GradeID            pgtype.UUID `json:"grade_id"`
}

func (q *Queries) GetPluralOrganizationsWithDetail(ctx context.Context, arg GetPluralOrganizationsWithDetailParams) ([]GetPluralOrganizationsWithDetailRow, error) {
	rows, err := q.db.Query(ctx, getPluralOrganizationsWithDetail, arg.OrganizationIds, arg.OrderMethod)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralOrganizationsWithDetailRow{}
	for rows.Next() {
		var i GetPluralOrganizationsWithDetailRow
		if err := rows.Scan(
			&i.MOrganizationsPkey,
			&i.OrganizationID,
			&i.Name,
			&i.Description,
			&i.Color,
			&i.IsPersonal,
			&i.IsWhole,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ChatRoomID,
			&i.GroupID,
			&i.GroupKey,
			&i.GradeKey,
			&i.GradeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralOrganizationsWithDetailUseNumberedPaginate = `-- name: GetPluralOrganizationsWithDetailUseNumberedPaginate :many
SELECT m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.color, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at, m_organizations.chat_room_id, m_groups.group_id, m_groups.key group_key, m_grades.key grade_key, m_grades.grade_id FROM m_organizations
LEFT JOIN m_groups ON m_organizations.organization_id = m_groups.organization_id
LEFT JOIN m_grades ON m_organizations.organization_id = m_grades.organization_id
WHERE organization_id = ANY($3::uuid[])
ORDER BY
	CASE WHEN $4::text = 'name' THEN m_organizations.name END ASC,
	CASE WHEN $4::text = 'r_name' THEN m_organizations.name END DESC,
	m_organizations_pkey ASC
LIMIT $1 OFFSET $2
`

type GetPluralOrganizationsWithDetailUseNumberedPaginateParams struct {
	Limit           int32       `json:"limit"`
	Offset          int32       `json:"offset"`
	OrganizationIds []uuid.UUID `json:"organization_ids"`
	OrderMethod     string      `json:"order_method"`
}

type GetPluralOrganizationsWithDetailUseNumberedPaginateRow struct {
	MOrganizationsPkey pgtype.Int8 `json:"m_organizations_pkey"`
	OrganizationID     uuid.UUID   `json:"organization_id"`
	Name               string      `json:"name"`
	Description        pgtype.Text `json:"description"`
	Color              pgtype.Text `json:"color"`
	IsPersonal         bool        `json:"is_personal"`
	IsWhole            bool        `json:"is_whole"`
	CreatedAt          time.Time   `json:"created_at"`
	UpdatedAt          time.Time   `json:"updated_at"`
	ChatRoomID         pgtype.UUID `json:"chat_room_id"`
	GroupID            pgtype.UUID `json:"group_id"`
	GroupKey           pgtype.Text `json:"group_key"`
	GradeKey           pgtype.Text `json:"grade_key"`
	GradeID            pgtype.UUID `json:"grade_id"`
}

func (q *Queries) GetPluralOrganizationsWithDetailUseNumberedPaginate(ctx context.Context, arg GetPluralOrganizationsWithDetailUseNumberedPaginateParams) ([]GetPluralOrganizationsWithDetailUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getPluralOrganizationsWithDetailUseNumberedPaginate,
		arg.Limit,
		arg.Offset,
		arg.OrganizationIds,
		arg.OrderMethod,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralOrganizationsWithDetailUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetPluralOrganizationsWithDetailUseNumberedPaginateRow
		if err := rows.Scan(
			&i.MOrganizationsPkey,
			&i.OrganizationID,
			&i.Name,
			&i.Description,
			&i.Color,
			&i.IsPersonal,
			&i.IsWhole,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ChatRoomID,
			&i.GroupID,
			&i.GroupKey,
			&i.GradeKey,
			&i.GradeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const pluralDeleteOrganizations = `-- name: PluralDeleteOrganizations :execrows
DELETE FROM m_organizations WHERE organization_id = ANY($1::uuid[])
`

func (q *Queries) PluralDeleteOrganizations(ctx context.Context, organizationIds []uuid.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, pluralDeleteOrganizations, organizationIds)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateOrganization = `-- name: UpdateOrganization :one
UPDATE m_organizations SET name = $2, color = $3, description = $4, updated_at = $5 WHERE organization_id = $1 RETURNING m_organizations_pkey, organization_id, name, description, color, is_personal, is_whole, created_at, updated_at, chat_room_id
`

type UpdateOrganizationParams struct {
	OrganizationID uuid.UUID   `json:"organization_id"`
	Name           string      `json:"name"`
	Color          pgtype.Text `json:"color"`
	Description    pgtype.Text `json:"description"`
	UpdatedAt      time.Time   `json:"updated_at"`
}

func (q *Queries) UpdateOrganization(ctx context.Context, arg UpdateOrganizationParams) (Organization, error) {
	row := q.db.QueryRow(ctx, updateOrganization,
		arg.OrganizationID,
		arg.Name,
		arg.Color,
		arg.Description,
		arg.UpdatedAt,
	)
	var i Organization
	err := row.Scan(
		&i.MOrganizationsPkey,
		&i.OrganizationID,
		&i.Name,
		&i.Description,
		&i.Color,
		&i.IsPersonal,
		&i.IsWhole,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ChatRoomID,
	)
	return i, err
}
