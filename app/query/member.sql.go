// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: member.sql

package query

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const countMembers = `-- name: CountMembers :one
SELECT COUNT(*) FROM m_members
`

func (q *Queries) CountMembers(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countMembers)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createMember = `-- name: CreateMember :one
INSERT INTO m_members (login_id, password, email, name, attend_status_id, grade_id, group_id, personal_organization_id, created_at, updated_at) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10) RETURNING m_members_pkey, member_id, login_id, password, email, name, attend_status_id, profile_image_id, grade_id, group_id, personal_organization_id, role_id, created_at, updated_at
`

type CreateMemberParams struct {
	LoginID                string    `json:"login_id"`
	Password               string    `json:"password"`
	Email                  string    `json:"email"`
	Name                   string    `json:"name"`
	AttendStatusID         uuid.UUID `json:"attend_status_id"`
	GradeID                uuid.UUID `json:"grade_id"`
	GroupID                uuid.UUID `json:"group_id"`
	PersonalOrganizationID uuid.UUID `json:"personal_organization_id"`
	CreatedAt              time.Time `json:"created_at"`
	UpdatedAt              time.Time `json:"updated_at"`
}

func (q *Queries) CreateMember(ctx context.Context, arg CreateMemberParams) (Member, error) {
	row := q.db.QueryRow(ctx, createMember,
		arg.LoginID,
		arg.Password,
		arg.Email,
		arg.Name,
		arg.AttendStatusID,
		arg.GradeID,
		arg.GroupID,
		arg.PersonalOrganizationID,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Member
	err := row.Scan(
		&i.MMembersPkey,
		&i.MemberID,
		&i.LoginID,
		&i.Password,
		&i.Email,
		&i.Name,
		&i.AttendStatusID,
		&i.ProfileImageID,
		&i.GradeID,
		&i.GroupID,
		&i.PersonalOrganizationID,
		&i.RoleID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

type CreateMembersParams struct {
	LoginID                string    `json:"login_id"`
	Password               string    `json:"password"`
	Email                  string    `json:"email"`
	Name                   string    `json:"name"`
	AttendStatusID         uuid.UUID `json:"attend_status_id"`
	GradeID                uuid.UUID `json:"grade_id"`
	GroupID                uuid.UUID `json:"group_id"`
	PersonalOrganizationID uuid.UUID `json:"personal_organization_id"`
	CreatedAt              time.Time `json:"created_at"`
	UpdatedAt              time.Time `json:"updated_at"`
}

const deleteMember = `-- name: DeleteMember :exec
DELETE FROM m_members WHERE member_id = $1
`

func (q *Queries) DeleteMember(ctx context.Context, memberID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteMember, memberID)
	return err
}

const findMemberByID = `-- name: FindMemberByID :one
SELECT m_members_pkey, member_id, login_id, password, email, name, attend_status_id, profile_image_id, grade_id, group_id, personal_organization_id, role_id, created_at, updated_at FROM m_members WHERE member_id = $1
`

func (q *Queries) FindMemberByID(ctx context.Context, memberID uuid.UUID) (Member, error) {
	row := q.db.QueryRow(ctx, findMemberByID, memberID)
	var i Member
	err := row.Scan(
		&i.MMembersPkey,
		&i.MemberID,
		&i.LoginID,
		&i.Password,
		&i.Email,
		&i.Name,
		&i.AttendStatusID,
		&i.ProfileImageID,
		&i.GradeID,
		&i.GroupID,
		&i.PersonalOrganizationID,
		&i.RoleID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findMemberByIDWithAttendStatus = `-- name: FindMemberByIDWithAttendStatus :one
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_attend_statuses.m_attend_statuses_pkey, m_attend_statuses.attend_status_id, m_attend_statuses.name, m_attend_statuses.key FROM m_members
INNER JOIN m_attend_statuses ON m_members.attend_status_id = m_attend_statuses.attend_status_id
WHERE member_id = $1
`

type FindMemberByIDWithAttendStatusRow struct {
	Member       Member       `json:"member"`
	AttendStatus AttendStatus `json:"attend_status"`
}

func (q *Queries) FindMemberByIDWithAttendStatus(ctx context.Context, memberID uuid.UUID) (FindMemberByIDWithAttendStatusRow, error) {
	row := q.db.QueryRow(ctx, findMemberByIDWithAttendStatus, memberID)
	var i FindMemberByIDWithAttendStatusRow
	err := row.Scan(
		&i.Member.MMembersPkey,
		&i.Member.MemberID,
		&i.Member.LoginID,
		&i.Member.Password,
		&i.Member.Email,
		&i.Member.Name,
		&i.Member.AttendStatusID,
		&i.Member.ProfileImageID,
		&i.Member.GradeID,
		&i.Member.GroupID,
		&i.Member.PersonalOrganizationID,
		&i.Member.RoleID,
		&i.Member.CreatedAt,
		&i.Member.UpdatedAt,
		&i.AttendStatus.MAttendStatusesPkey,
		&i.AttendStatus.AttendStatusID,
		&i.AttendStatus.Name,
		&i.AttendStatus.Key,
	)
	return i, err
}

const findMemberByIDWithGrade = `-- name: FindMemberByIDWithGrade :one
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_grades.m_grades_pkey, m_grades.grade_id, m_grades.key, m_grades.organization_id FROM m_members
INNER JOIN m_grades ON m_members.grade_id = m_grades.grade_id
INNER JOIN m_organizations ON m_grades.organization_id = m_organizations.organization_id
WHERE member_id = $1
`

type FindMemberByIDWithGradeRow struct {
	Member Member `json:"member"`
	Grade  Grade  `json:"grade"`
}

func (q *Queries) FindMemberByIDWithGrade(ctx context.Context, memberID uuid.UUID) (FindMemberByIDWithGradeRow, error) {
	row := q.db.QueryRow(ctx, findMemberByIDWithGrade, memberID)
	var i FindMemberByIDWithGradeRow
	err := row.Scan(
		&i.Member.MMembersPkey,
		&i.Member.MemberID,
		&i.Member.LoginID,
		&i.Member.Password,
		&i.Member.Email,
		&i.Member.Name,
		&i.Member.AttendStatusID,
		&i.Member.ProfileImageID,
		&i.Member.GradeID,
		&i.Member.GroupID,
		&i.Member.PersonalOrganizationID,
		&i.Member.RoleID,
		&i.Member.CreatedAt,
		&i.Member.UpdatedAt,
		&i.Grade.MGradesPkey,
		&i.Grade.GradeID,
		&i.Grade.Key,
		&i.Grade.OrganizationID,
	)
	return i, err
}

const findMemberByIDWithGroup = `-- name: FindMemberByIDWithGroup :one
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_groups.m_groups_pkey, m_groups.group_id, m_groups.key, m_groups.organization_id FROM m_members
INNER JOIN m_groups ON m_members.group_id = m_groups.group_id
INNER JOIN m_organizations ON m_groups.organization_id = m_organizations.organization_id
WHERE member_id = $1
`

type FindMemberByIDWithGroupRow struct {
	Member Member `json:"member"`
	Group  Group  `json:"group"`
}

func (q *Queries) FindMemberByIDWithGroup(ctx context.Context, memberID uuid.UUID) (FindMemberByIDWithGroupRow, error) {
	row := q.db.QueryRow(ctx, findMemberByIDWithGroup, memberID)
	var i FindMemberByIDWithGroupRow
	err := row.Scan(
		&i.Member.MMembersPkey,
		&i.Member.MemberID,
		&i.Member.LoginID,
		&i.Member.Password,
		&i.Member.Email,
		&i.Member.Name,
		&i.Member.AttendStatusID,
		&i.Member.ProfileImageID,
		&i.Member.GradeID,
		&i.Member.GroupID,
		&i.Member.PersonalOrganizationID,
		&i.Member.RoleID,
		&i.Member.CreatedAt,
		&i.Member.UpdatedAt,
		&i.Group.MGroupsPkey,
		&i.Group.GroupID,
		&i.Group.Key,
		&i.Group.OrganizationID,
	)
	return i, err
}

const findMemberByIDWithPersonalOrganization = `-- name: FindMemberByIDWithPersonalOrganization :one
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at FROM m_members
INNER JOIN m_organizations ON m_members.personal_organization_id = m_organizations.organization_id
WHERE member_id = $1
`

type FindMemberByIDWithPersonalOrganizationRow struct {
	Member       Member       `json:"member"`
	Organization Organization `json:"organization"`
}

func (q *Queries) FindMemberByIDWithPersonalOrganization(ctx context.Context, memberID uuid.UUID) (FindMemberByIDWithPersonalOrganizationRow, error) {
	row := q.db.QueryRow(ctx, findMemberByIDWithPersonalOrganization, memberID)
	var i FindMemberByIDWithPersonalOrganizationRow
	err := row.Scan(
		&i.Member.MMembersPkey,
		&i.Member.MemberID,
		&i.Member.LoginID,
		&i.Member.Password,
		&i.Member.Email,
		&i.Member.Name,
		&i.Member.AttendStatusID,
		&i.Member.ProfileImageID,
		&i.Member.GradeID,
		&i.Member.GroupID,
		&i.Member.PersonalOrganizationID,
		&i.Member.RoleID,
		&i.Member.CreatedAt,
		&i.Member.UpdatedAt,
		&i.Organization.MOrganizationsPkey,
		&i.Organization.OrganizationID,
		&i.Organization.Name,
		&i.Organization.Description,
		&i.Organization.IsPersonal,
		&i.Organization.IsWhole,
		&i.Organization.CreatedAt,
		&i.Organization.UpdatedAt,
	)
	return i, err
}

const findMemberByIDWithRole = `-- name: FindMemberByIDWithRole :one
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_roles.m_roles_pkey, m_roles.role_id, m_roles.name, m_roles.description, m_roles.created_at, m_roles.updated_at FROM m_members
LEFT JOIN m_roles ON m_members.role_id = m_roles.role_id
WHERE member_id = $1
`

type FindMemberByIDWithRoleRow struct {
	Member Member `json:"member"`
	Role   Role   `json:"role"`
}

func (q *Queries) FindMemberByIDWithRole(ctx context.Context, memberID uuid.UUID) (FindMemberByIDWithRoleRow, error) {
	row := q.db.QueryRow(ctx, findMemberByIDWithRole, memberID)
	var i FindMemberByIDWithRoleRow
	err := row.Scan(
		&i.Member.MMembersPkey,
		&i.Member.MemberID,
		&i.Member.LoginID,
		&i.Member.Password,
		&i.Member.Email,
		&i.Member.Name,
		&i.Member.AttendStatusID,
		&i.Member.ProfileImageID,
		&i.Member.GradeID,
		&i.Member.GroupID,
		&i.Member.PersonalOrganizationID,
		&i.Member.RoleID,
		&i.Member.CreatedAt,
		&i.Member.UpdatedAt,
		&i.Role.MRolesPkey,
		&i.Role.RoleID,
		&i.Role.Name,
		&i.Role.Description,
		&i.Role.CreatedAt,
		&i.Role.UpdatedAt,
	)
	return i, err
}

const findMemberByLoginID = `-- name: FindMemberByLoginID :one
SELECT m_members_pkey, member_id, login_id, password, email, name, attend_status_id, profile_image_id, grade_id, group_id, personal_organization_id, role_id, created_at, updated_at FROM m_members WHERE login_id = $1
`

func (q *Queries) FindMemberByLoginID(ctx context.Context, loginID string) (Member, error) {
	row := q.db.QueryRow(ctx, findMemberByLoginID, loginID)
	var i Member
	err := row.Scan(
		&i.MMembersPkey,
		&i.MemberID,
		&i.LoginID,
		&i.Password,
		&i.Email,
		&i.Name,
		&i.AttendStatusID,
		&i.ProfileImageID,
		&i.GradeID,
		&i.GroupID,
		&i.PersonalOrganizationID,
		&i.RoleID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMembers = `-- name: GetMembers :many
SELECT m_members_pkey, member_id, login_id, password, email, name, attend_status_id, profile_image_id, grade_id, group_id, personal_organization_id, role_id, created_at, updated_at FROM m_members
ORDER BY
	m_members_pkey DESC
LIMIT $1 OFFSET $2
`

type GetMembersParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetMembers(ctx context.Context, arg GetMembersParams) ([]Member, error) {
	rows, err := q.db.Query(ctx, getMembers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Member{}
	for rows.Next() {
		var i Member
		if err := rows.Scan(
			&i.MMembersPkey,
			&i.MemberID,
			&i.LoginID,
			&i.Password,
			&i.Email,
			&i.Name,
			&i.AttendStatusID,
			&i.ProfileImageID,
			&i.GradeID,
			&i.GroupID,
			&i.PersonalOrganizationID,
			&i.RoleID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMembersWithAttendStatus = `-- name: GetMembersWithAttendStatus :many
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_attend_statuses.m_attend_statuses_pkey, m_attend_statuses.attend_status_id, m_attend_statuses.name, m_attend_statuses.key FROM m_members
INNER JOIN m_attend_statuses ON m_members.attend_status_id = m_attend_statuses.attend_status_id
ORDER BY
	m_members_pkey DESC
LIMIT $1 OFFSET $2
`

type GetMembersWithAttendStatusParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetMembersWithAttendStatusRow struct {
	Member       Member       `json:"member"`
	AttendStatus AttendStatus `json:"attend_status"`
}

func (q *Queries) GetMembersWithAttendStatus(ctx context.Context, arg GetMembersWithAttendStatusParams) ([]GetMembersWithAttendStatusRow, error) {
	rows, err := q.db.Query(ctx, getMembersWithAttendStatus, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMembersWithAttendStatusRow{}
	for rows.Next() {
		var i GetMembersWithAttendStatusRow
		if err := rows.Scan(
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageID,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
			&i.AttendStatus.MAttendStatusesPkey,
			&i.AttendStatus.AttendStatusID,
			&i.AttendStatus.Name,
			&i.AttendStatus.Key,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMembersWithGrade = `-- name: GetMembersWithGrade :many
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_grades.m_grades_pkey, m_grades.grade_id, m_grades.key, m_grades.organization_id FROM m_members
INNER JOIN m_grades ON m_members.grade_id = m_grades.grade_id
INNER JOIN m_organizations ON m_grades.organization_id = m_organizations.organization_id
ORDER BY
	m_members_pkey DESC
LIMIT $1 OFFSET $2
`

type GetMembersWithGradeParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetMembersWithGradeRow struct {
	Member Member `json:"member"`
	Grade  Grade  `json:"grade"`
}

func (q *Queries) GetMembersWithGrade(ctx context.Context, arg GetMembersWithGradeParams) ([]GetMembersWithGradeRow, error) {
	rows, err := q.db.Query(ctx, getMembersWithGrade, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMembersWithGradeRow{}
	for rows.Next() {
		var i GetMembersWithGradeRow
		if err := rows.Scan(
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageID,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
			&i.Grade.MGradesPkey,
			&i.Grade.GradeID,
			&i.Grade.Key,
			&i.Grade.OrganizationID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMembersWithGroup = `-- name: GetMembersWithGroup :many
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_groups.m_groups_pkey, m_groups.group_id, m_groups.key, m_groups.organization_id FROM m_members
INNER JOIN m_groups ON m_members.group_id = m_groups.group_id
INNER JOIN m_organizations ON m_groups.organization_id = m_organizations.organization_id
ORDER BY
	m_members_pkey DESC
LIMIT $1 OFFSET $2
`

type GetMembersWithGroupParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetMembersWithGroupRow struct {
	Member Member `json:"member"`
	Group  Group  `json:"group"`
}

func (q *Queries) GetMembersWithGroup(ctx context.Context, arg GetMembersWithGroupParams) ([]GetMembersWithGroupRow, error) {
	rows, err := q.db.Query(ctx, getMembersWithGroup, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMembersWithGroupRow{}
	for rows.Next() {
		var i GetMembersWithGroupRow
		if err := rows.Scan(
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageID,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
			&i.Group.MGroupsPkey,
			&i.Group.GroupID,
			&i.Group.Key,
			&i.Group.OrganizationID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMembersWithPersonalOrganization = `-- name: GetMembersWithPersonalOrganization :many
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_organizations.m_organizations_pkey, m_organizations.organization_id, m_organizations.name, m_organizations.description, m_organizations.is_personal, m_organizations.is_whole, m_organizations.created_at, m_organizations.updated_at FROM m_members
INNER JOIN m_organizations ON m_members.personal_organization_id = m_organizations.organization_id
ORDER BY
	m_members_pkey DESC
LIMIT $1 OFFSET $2
`

type GetMembersWithPersonalOrganizationParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetMembersWithPersonalOrganizationRow struct {
	Member       Member       `json:"member"`
	Organization Organization `json:"organization"`
}

func (q *Queries) GetMembersWithPersonalOrganization(ctx context.Context, arg GetMembersWithPersonalOrganizationParams) ([]GetMembersWithPersonalOrganizationRow, error) {
	rows, err := q.db.Query(ctx, getMembersWithPersonalOrganization, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMembersWithPersonalOrganizationRow{}
	for rows.Next() {
		var i GetMembersWithPersonalOrganizationRow
		if err := rows.Scan(
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageID,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
			&i.Organization.MOrganizationsPkey,
			&i.Organization.OrganizationID,
			&i.Organization.Name,
			&i.Organization.Description,
			&i.Organization.IsPersonal,
			&i.Organization.IsWhole,
			&i.Organization.CreatedAt,
			&i.Organization.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMembersWithRole = `-- name: GetMembersWithRole :many
SELECT m_members.m_members_pkey, m_members.member_id, m_members.login_id, m_members.password, m_members.email, m_members.name, m_members.attend_status_id, m_members.profile_image_id, m_members.grade_id, m_members.group_id, m_members.personal_organization_id, m_members.role_id, m_members.created_at, m_members.updated_at, m_roles.m_roles_pkey, m_roles.role_id, m_roles.name, m_roles.description, m_roles.created_at, m_roles.updated_at FROM m_members
LEFT JOIN m_roles ON m_members.role_id = m_roles.role_id
ORDER BY
	m_members_pkey DESC
LIMIT $1 OFFSET $2
`

type GetMembersWithRoleParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetMembersWithRoleRow struct {
	Member Member `json:"member"`
	Role   Role   `json:"role"`
}

func (q *Queries) GetMembersWithRole(ctx context.Context, arg GetMembersWithRoleParams) ([]GetMembersWithRoleRow, error) {
	rows, err := q.db.Query(ctx, getMembersWithRole, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMembersWithRoleRow{}
	for rows.Next() {
		var i GetMembersWithRoleRow
		if err := rows.Scan(
			&i.Member.MMembersPkey,
			&i.Member.MemberID,
			&i.Member.LoginID,
			&i.Member.Password,
			&i.Member.Email,
			&i.Member.Name,
			&i.Member.AttendStatusID,
			&i.Member.ProfileImageID,
			&i.Member.GradeID,
			&i.Member.GroupID,
			&i.Member.PersonalOrganizationID,
			&i.Member.RoleID,
			&i.Member.CreatedAt,
			&i.Member.UpdatedAt,
			&i.Role.MRolesPkey,
			&i.Role.RoleID,
			&i.Role.Name,
			&i.Role.Description,
			&i.Role.CreatedAt,
			&i.Role.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
