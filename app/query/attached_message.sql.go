// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: attached_message.sql

package query

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countAttachedItemsOnChatRoom = `-- name: CountAttachedItemsOnChatRoom :one
SELECT COUNT(*) FROM t_attached_messages
WHERE message_id IN (
	SELECT message_id FROM t_messages WHERE chat_room_id = $1
)
AND
	CASE WHEN $2::boolean = true THEN t_attachable_items.mime_type_id = ANY($3::uuid[]) ELSE TRUE END
AND
	CASE WHEN $4::boolean = true THEN EXISTS (SELECT 1 FROM t_images WHERE t_images.attachable_item_id = t_attachable_items.attachable_item_id) ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN EXISTS (SELECT 1 FROM t_files WHERE t_files.attachable_item_id = t_attachable_items.attachable_item_id) ELSE TRUE END
`

type CountAttachedItemsOnChatRoomParams struct {
	ChatRoomID      uuid.UUID   `json:"chat_room_id"`
	WhereInMimeType bool        `json:"where_in_mime_type"`
	InMimeTypes     []uuid.UUID `json:"in_mime_types"`
	WhereIsImage    bool        `json:"where_is_image"`
	WhereIsFile     bool        `json:"where_is_file"`
}

func (q *Queries) CountAttachedItemsOnChatRoom(ctx context.Context, arg CountAttachedItemsOnChatRoomParams) (int64, error) {
	row := q.db.QueryRow(ctx, countAttachedItemsOnChatRoom,
		arg.ChatRoomID,
		arg.WhereInMimeType,
		arg.InMimeTypes,
		arg.WhereIsImage,
		arg.WhereIsFile,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAttachedItemsOnMessage = `-- name: CountAttachedItemsOnMessage :one
SELECT COUNT(*) FROM t_attached_messages WHERE message_id = $1
AND
	CASE WHEN $2::boolean = true THEN t_attachable_items.mime_type_id = ANY($3::uuid[]) ELSE TRUE END
AND
	CASE WHEN $4::boolean = true THEN EXISTS (SELECT 1 FROM t_images WHERE t_images.attachable_item_id = t_attachable_items.attachable_item_id) ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN EXISTS (SELECT 1 FROM t_files WHERE t_files.attachable_item_id = t_attachable_items.attachable_item_id) ELSE TRUE END
`

type CountAttachedItemsOnMessageParams struct {
	MessageID       uuid.UUID   `json:"message_id"`
	WhereInMimeType bool        `json:"where_in_mime_type"`
	InMimeTypes     []uuid.UUID `json:"in_mime_types"`
	WhereIsImage    bool        `json:"where_is_image"`
	WhereIsFile     bool        `json:"where_is_file"`
}

func (q *Queries) CountAttachedItemsOnMessage(ctx context.Context, arg CountAttachedItemsOnMessageParams) (int64, error) {
	row := q.db.QueryRow(ctx, countAttachedItemsOnMessage,
		arg.MessageID,
		arg.WhereInMimeType,
		arg.InMimeTypes,
		arg.WhereIsImage,
		arg.WhereIsFile,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAttachedMessage = `-- name: CreateAttachedMessage :one
INSERT INTO t_attached_messages (message_id, attachable_item_id) VALUES ($1, $2) RETURNING t_attached_messages_pkey, attached_message_id, message_id, attachable_item_id
`

type CreateAttachedMessageParams struct {
	MessageID        uuid.UUID   `json:"message_id"`
	AttachableItemID pgtype.UUID `json:"attachable_item_id"`
}

func (q *Queries) CreateAttachedMessage(ctx context.Context, arg CreateAttachedMessageParams) (AttachedMessage, error) {
	row := q.db.QueryRow(ctx, createAttachedMessage, arg.MessageID, arg.AttachableItemID)
	var i AttachedMessage
	err := row.Scan(
		&i.TAttachedMessagesPkey,
		&i.AttachedMessageID,
		&i.MessageID,
		&i.AttachableItemID,
	)
	return i, err
}

type CreateAttachedMessagesParams struct {
	MessageID        uuid.UUID   `json:"message_id"`
	AttachableItemID pgtype.UUID `json:"attachable_item_id"`
}

const deleteAttachedMessage = `-- name: DeleteAttachedMessage :execrows
DELETE FROM t_attached_messages WHERE attached_message_id = $1
`

func (q *Queries) DeleteAttachedMessage(ctx context.Context, attachedMessageID uuid.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, deleteAttachedMessage, attachedMessageID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteAttachedMessagesOnMessage = `-- name: DeleteAttachedMessagesOnMessage :execrows
DELETE FROM t_attached_messages WHERE message_id = $1
`

func (q *Queries) DeleteAttachedMessagesOnMessage(ctx context.Context, messageID uuid.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, deleteAttachedMessagesOnMessage, messageID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteAttachedMessagesOnMessages = `-- name: DeleteAttachedMessagesOnMessages :execrows
DELETE FROM t_attached_messages WHERE message_id = ANY($1::uuid[])
`

func (q *Queries) DeleteAttachedMessagesOnMessages(ctx context.Context, messageIds []uuid.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, deleteAttachedMessagesOnMessages, messageIds)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getAttachedItemsOnChatRoom = `-- name: GetAttachedItemsOnChatRoom :many
SELECT t_attached_messages.t_attached_messages_pkey, t_attached_messages.attached_message_id, t_attached_messages.message_id, t_attached_messages.attachable_item_id, t_attachable_items.url attached_item_url, t_attachable_items.alias attached_item_alias,
t_attachable_items.size attached_item_size, t_attachable_items.mime_type_id attached_item_mime_type_id,
t_attachable_items.owner_id attached_item_owner_id, t_attachable_items.from_outer attached_item_from_outer,
t_messages.sender_id message_sender_id, t_messages.body message_body, t_messages.posted_at message_posted_at, t_messages.last_edited_at message_last_edited_at
FROM t_attached_messages
LEFT JOIN t_messages ON t_attached_messages.message_id = t_messages.message_id
LEFT JOIN t_attachable_items ON t_attached_messages.attachable_item_id = t_attachable_items.attachable_item_id
WHERE message_id IN (
	SELECT message_id FROM t_messages m WHERE m.chat_room_id = $1
)
AND
	CASE WHEN $2::boolean = true THEN t_attachable_items.mime_type_id = ANY($3::uuid[]) ELSE TRUE END
AND
	CASE WHEN $4::boolean = true THEN EXISTS (SELECT 1 FROM t_images WHERE t_images.attachable_item_id = t_attachable_items.attachable_item_id) ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN EXISTS (SELECT 1 FROM t_files WHERE t_files.attachable_item_id = t_attachable_items.attachable_item_id) ELSE TRUE END
ORDER BY
	t_attached_messages_pkey ASC
`

type GetAttachedItemsOnChatRoomParams struct {
	ChatRoomID      uuid.UUID   `json:"chat_room_id"`
	WhereInMimeType bool        `json:"where_in_mime_type"`
	InMimeTypes     []uuid.UUID `json:"in_mime_types"`
	WhereIsImage    bool        `json:"where_is_image"`
	WhereIsFile     bool        `json:"where_is_file"`
}

type GetAttachedItemsOnChatRoomRow struct {
	TAttachedMessagesPkey  pgtype.Int8        `json:"t_attached_messages_pkey"`
	AttachedMessageID      uuid.UUID          `json:"attached_message_id"`
	MessageID              uuid.UUID          `json:"message_id"`
	AttachableItemID       pgtype.UUID        `json:"attachable_item_id"`
	AttachedItemUrl        pgtype.Text        `json:"attached_item_url"`
	AttachedItemAlias      pgtype.Text        `json:"attached_item_alias"`
	AttachedItemSize       pgtype.Float8      `json:"attached_item_size"`
	AttachedItemMimeTypeID pgtype.UUID        `json:"attached_item_mime_type_id"`
	AttachedItemOwnerID    pgtype.UUID        `json:"attached_item_owner_id"`
	AttachedItemFromOuter  pgtype.Bool        `json:"attached_item_from_outer"`
	MessageSenderID        pgtype.UUID        `json:"message_sender_id"`
	MessageBody            pgtype.Text        `json:"message_body"`
	MessagePostedAt        pgtype.Timestamptz `json:"message_posted_at"`
	MessageLastEditedAt    pgtype.Timestamptz `json:"message_last_edited_at"`
}

func (q *Queries) GetAttachedItemsOnChatRoom(ctx context.Context, arg GetAttachedItemsOnChatRoomParams) ([]GetAttachedItemsOnChatRoomRow, error) {
	rows, err := q.db.Query(ctx, getAttachedItemsOnChatRoom,
		arg.ChatRoomID,
		arg.WhereInMimeType,
		arg.InMimeTypes,
		arg.WhereIsImage,
		arg.WhereIsFile,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAttachedItemsOnChatRoomRow{}
	for rows.Next() {
		var i GetAttachedItemsOnChatRoomRow
		if err := rows.Scan(
			&i.TAttachedMessagesPkey,
			&i.AttachedMessageID,
			&i.MessageID,
			&i.AttachableItemID,
			&i.AttachedItemUrl,
			&i.AttachedItemAlias,
			&i.AttachedItemSize,
			&i.AttachedItemMimeTypeID,
			&i.AttachedItemOwnerID,
			&i.AttachedItemFromOuter,
			&i.MessageSenderID,
			&i.MessageBody,
			&i.MessagePostedAt,
			&i.MessageLastEditedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAttachedItemsOnChatRoomUseKeysetPaginate = `-- name: GetAttachedItemsOnChatRoomUseKeysetPaginate :many
SELECT t_attached_messages.t_attached_messages_pkey, t_attached_messages.attached_message_id, t_attached_messages.message_id, t_attached_messages.attachable_item_id, t_attachable_items.url attached_item_url, t_attachable_items.alias attached_item_alias,
t_attachable_items.size attached_item_size, t_attachable_items.mime_type_id attached_item_mime_type_id,
t_attachable_items.owner_id attached_item_owner_id, t_attachable_items.from_outer attached_item_from_outer,
t_messages.sender_id message_sender_id, t_messages.body message_body, t_messages.posted_at message_posted_at, t_messages.last_edited_at message_last_edited_at
FROM t_attached_messages
LEFT JOIN t_messages ON t_attached_messages.message_id = t_messages.message_id
LEFT JOIN t_attachable_items ON t_attached_messages.attachable_item_id = t_attachable_items.attachable_item_id
WHERE message_id IN (
	SELECT message_id FROM t_messages m WHERE m.chat_room_id = $1
)
AND
	CASE WHEN $3::boolean = true THEN t_attachable_items.mime_type_id = ANY($4::uuid[]) ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN EXISTS (SELECT 1 FROM t_images WHERE t_images.attachable_item_id = t_attachable_items.attachable_item_id) ELSE TRUE END
AND
	CASE WHEN $6::boolean = true THEN EXISTS (SELECT 1 FROM t_files WHERE t_files.attachable_item_id = t_attachable_items.attachable_item_id) ELSE TRUE END
AND
	CASE $7::text
		WHEN 'next' THEN
			t_attached_messages_pkey > $8::int
		WHEN 'prev' THEN
			t_attached_messages_pkey < $8::int
	END
ORDER BY
	CASE WHEN $7::text = 'next' THEN t_attached_messages_pkey END ASC,
	CASE WHEN $7::text = 'prev' THEN t_attached_messages_pkey END DESC
LIMIT $2
`

type GetAttachedItemsOnChatRoomUseKeysetPaginateParams struct {
	ChatRoomID      uuid.UUID   `json:"chat_room_id"`
	Limit           int32       `json:"limit"`
	WhereInMimeType bool        `json:"where_in_mime_type"`
	InMimeTypes     []uuid.UUID `json:"in_mime_types"`
	WhereIsImage    bool        `json:"where_is_image"`
	WhereIsFile     bool        `json:"where_is_file"`
	CursorDirection string      `json:"cursor_direction"`
	Cursor          int32       `json:"cursor"`
}

type GetAttachedItemsOnChatRoomUseKeysetPaginateRow struct {
	TAttachedMessagesPkey  pgtype.Int8        `json:"t_attached_messages_pkey"`
	AttachedMessageID      uuid.UUID          `json:"attached_message_id"`
	MessageID              uuid.UUID          `json:"message_id"`
	AttachableItemID       pgtype.UUID        `json:"attachable_item_id"`
	AttachedItemUrl        pgtype.Text        `json:"attached_item_url"`
	AttachedItemAlias      pgtype.Text        `json:"attached_item_alias"`
	AttachedItemSize       pgtype.Float8      `json:"attached_item_size"`
	AttachedItemMimeTypeID pgtype.UUID        `json:"attached_item_mime_type_id"`
	AttachedItemOwnerID    pgtype.UUID        `json:"attached_item_owner_id"`
	AttachedItemFromOuter  pgtype.Bool        `json:"attached_item_from_outer"`
	MessageSenderID        pgtype.UUID        `json:"message_sender_id"`
	MessageBody            pgtype.Text        `json:"message_body"`
	MessagePostedAt        pgtype.Timestamptz `json:"message_posted_at"`
	MessageLastEditedAt    pgtype.Timestamptz `json:"message_last_edited_at"`
}

func (q *Queries) GetAttachedItemsOnChatRoomUseKeysetPaginate(ctx context.Context, arg GetAttachedItemsOnChatRoomUseKeysetPaginateParams) ([]GetAttachedItemsOnChatRoomUseKeysetPaginateRow, error) {
	rows, err := q.db.Query(ctx, getAttachedItemsOnChatRoomUseKeysetPaginate,
		arg.ChatRoomID,
		arg.Limit,
		arg.WhereInMimeType,
		arg.InMimeTypes,
		arg.WhereIsImage,
		arg.WhereIsFile,
		arg.CursorDirection,
		arg.Cursor,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAttachedItemsOnChatRoomUseKeysetPaginateRow{}
	for rows.Next() {
		var i GetAttachedItemsOnChatRoomUseKeysetPaginateRow
		if err := rows.Scan(
			&i.TAttachedMessagesPkey,
			&i.AttachedMessageID,
			&i.MessageID,
			&i.AttachableItemID,
			&i.AttachedItemUrl,
			&i.AttachedItemAlias,
			&i.AttachedItemSize,
			&i.AttachedItemMimeTypeID,
			&i.AttachedItemOwnerID,
			&i.AttachedItemFromOuter,
			&i.MessageSenderID,
			&i.MessageBody,
			&i.MessagePostedAt,
			&i.MessageLastEditedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAttachedItemsOnChatRoomUseNumberedPaginate = `-- name: GetAttachedItemsOnChatRoomUseNumberedPaginate :many
SELECT t_attached_messages.t_attached_messages_pkey, t_attached_messages.attached_message_id, t_attached_messages.message_id, t_attached_messages.attachable_item_id, t_attachable_items.url attached_item_url, t_attachable_items.alias attached_item_alias,
t_attachable_items.size attached_item_size, t_attachable_items.mime_type_id attached_item_mime_type_id,
t_attachable_items.owner_id attached_item_owner_id, t_attachable_items.from_outer attached_item_from_outer,
t_messages.sender_id message_sender_id, t_messages.body message_body, t_messages.posted_at message_posted_at, t_messages.last_edited_at message_last_edited_at
FROM t_attached_messages
LEFT JOIN t_messages ON t_attached_messages.message_id = t_messages.message_id
LEFT JOIN t_attachable_items ON t_attached_messages.attachable_item_id = t_attachable_items.attachable_item_id
WHERE message_id IN (
	SELECT message_id FROM t_messages m WHERE m.chat_room_id = $1
)
AND
	CASE WHEN $4::boolean = true THEN t_attachable_items.mime_type_id = ANY($5::uuid[]) ELSE TRUE END
AND
	CASE WHEN $6::boolean = true THEN EXISTS (SELECT 1 FROM t_images WHERE t_images.attachable_item_id = t_attachable_items.attachable_item_id) ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN EXISTS (SELECT 1 FROM t_files WHERE t_files.attachable_item_id = t_attachable_items.attachable_item_id) ELSE TRUE END
ORDER BY
	t_attached_messages_pkey ASC
LIMIT $2 OFFSET $3
`

type GetAttachedItemsOnChatRoomUseNumberedPaginateParams struct {
	ChatRoomID      uuid.UUID   `json:"chat_room_id"`
	Limit           int32       `json:"limit"`
	Offset          int32       `json:"offset"`
	WhereInMimeType bool        `json:"where_in_mime_type"`
	InMimeTypes     []uuid.UUID `json:"in_mime_types"`
	WhereIsImage    bool        `json:"where_is_image"`
	WhereIsFile     bool        `json:"where_is_file"`
}

type GetAttachedItemsOnChatRoomUseNumberedPaginateRow struct {
	TAttachedMessagesPkey  pgtype.Int8        `json:"t_attached_messages_pkey"`
	AttachedMessageID      uuid.UUID          `json:"attached_message_id"`
	MessageID              uuid.UUID          `json:"message_id"`
	AttachableItemID       pgtype.UUID        `json:"attachable_item_id"`
	AttachedItemUrl        pgtype.Text        `json:"attached_item_url"`
	AttachedItemAlias      pgtype.Text        `json:"attached_item_alias"`
	AttachedItemSize       pgtype.Float8      `json:"attached_item_size"`
	AttachedItemMimeTypeID pgtype.UUID        `json:"attached_item_mime_type_id"`
	AttachedItemOwnerID    pgtype.UUID        `json:"attached_item_owner_id"`
	AttachedItemFromOuter  pgtype.Bool        `json:"attached_item_from_outer"`
	MessageSenderID        pgtype.UUID        `json:"message_sender_id"`
	MessageBody            pgtype.Text        `json:"message_body"`
	MessagePostedAt        pgtype.Timestamptz `json:"message_posted_at"`
	MessageLastEditedAt    pgtype.Timestamptz `json:"message_last_edited_at"`
}

func (q *Queries) GetAttachedItemsOnChatRoomUseNumberedPaginate(ctx context.Context, arg GetAttachedItemsOnChatRoomUseNumberedPaginateParams) ([]GetAttachedItemsOnChatRoomUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getAttachedItemsOnChatRoomUseNumberedPaginate,
		arg.ChatRoomID,
		arg.Limit,
		arg.Offset,
		arg.WhereInMimeType,
		arg.InMimeTypes,
		arg.WhereIsImage,
		arg.WhereIsFile,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAttachedItemsOnChatRoomUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetAttachedItemsOnChatRoomUseNumberedPaginateRow
		if err := rows.Scan(
			&i.TAttachedMessagesPkey,
			&i.AttachedMessageID,
			&i.MessageID,
			&i.AttachableItemID,
			&i.AttachedItemUrl,
			&i.AttachedItemAlias,
			&i.AttachedItemSize,
			&i.AttachedItemMimeTypeID,
			&i.AttachedItemOwnerID,
			&i.AttachedItemFromOuter,
			&i.MessageSenderID,
			&i.MessageBody,
			&i.MessagePostedAt,
			&i.MessageLastEditedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAttachedItemsOnMessage = `-- name: GetAttachedItemsOnMessage :many
SELECT t_attached_messages.t_attached_messages_pkey, t_attached_messages.attached_message_id, t_attached_messages.message_id, t_attached_messages.attachable_item_id, t_attachable_items.url attached_item_url, t_attachable_items.alias attached_item_alias,
t_attachable_items.size attached_item_size, t_attachable_items.mime_type_id attached_item_mime_type_id,
t_attachable_items.owner_id attached_item_owner_id, t_attachable_items.from_outer attached_item_from_outer
FROM t_attached_messages
LEFT JOIN t_attachable_items ON t_attached_messages.attachable_item_id = t_attachable_items.attachable_item_id
WHERE message_id = $1
AND
	CASE WHEN $2::boolean = true THEN t_attachable_items.mime_type_id = ANY($3::uuid[]) ELSE TRUE END
AND
	CASE WHEN $4::boolean = true THEN EXISTS (SELECT 1 FROM t_images WHERE t_images.attachable_item_id = t_attachable_items.attachable_item_id) ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN EXISTS (SELECT 1 FROM t_files WHERE t_files.attachable_item_id = t_attachable_items.attachable_item_id) ELSE TRUE END
ORDER BY
	t_attached_messages_pkey ASC
`

type GetAttachedItemsOnMessageParams struct {
	MessageID       uuid.UUID   `json:"message_id"`
	WhereInMimeType bool        `json:"where_in_mime_type"`
	InMimeTypes     []uuid.UUID `json:"in_mime_types"`
	WhereIsImage    bool        `json:"where_is_image"`
	WhereIsFile     bool        `json:"where_is_file"`
}

type GetAttachedItemsOnMessageRow struct {
	TAttachedMessagesPkey  pgtype.Int8   `json:"t_attached_messages_pkey"`
	AttachedMessageID      uuid.UUID     `json:"attached_message_id"`
	MessageID              uuid.UUID     `json:"message_id"`
	AttachableItemID       pgtype.UUID   `json:"attachable_item_id"`
	AttachedItemUrl        pgtype.Text   `json:"attached_item_url"`
	AttachedItemAlias      pgtype.Text   `json:"attached_item_alias"`
	AttachedItemSize       pgtype.Float8 `json:"attached_item_size"`
	AttachedItemMimeTypeID pgtype.UUID   `json:"attached_item_mime_type_id"`
	AttachedItemOwnerID    pgtype.UUID   `json:"attached_item_owner_id"`
	AttachedItemFromOuter  pgtype.Bool   `json:"attached_item_from_outer"`
}

func (q *Queries) GetAttachedItemsOnMessage(ctx context.Context, arg GetAttachedItemsOnMessageParams) ([]GetAttachedItemsOnMessageRow, error) {
	rows, err := q.db.Query(ctx, getAttachedItemsOnMessage,
		arg.MessageID,
		arg.WhereInMimeType,
		arg.InMimeTypes,
		arg.WhereIsImage,
		arg.WhereIsFile,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAttachedItemsOnMessageRow{}
	for rows.Next() {
		var i GetAttachedItemsOnMessageRow
		if err := rows.Scan(
			&i.TAttachedMessagesPkey,
			&i.AttachedMessageID,
			&i.MessageID,
			&i.AttachableItemID,
			&i.AttachedItemUrl,
			&i.AttachedItemAlias,
			&i.AttachedItemSize,
			&i.AttachedItemMimeTypeID,
			&i.AttachedItemOwnerID,
			&i.AttachedItemFromOuter,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAttachedItemsOnMessageUseKeysetPaginate = `-- name: GetAttachedItemsOnMessageUseKeysetPaginate :many
SELECT t_attached_messages.t_attached_messages_pkey, t_attached_messages.attached_message_id, t_attached_messages.message_id, t_attached_messages.attachable_item_id, t_attachable_items.url attached_item_url, t_attachable_items.alias attached_item_alias,
t_attachable_items.size attached_item_size, t_attachable_items.mime_type_id attached_item_mime_type_id,
t_attachable_items.owner_id attached_item_owner_id, t_attachable_items.from_outer attached_item_from_outer
FROM t_attached_messages
LEFT JOIN t_attachable_items ON t_attached_messages.attachable_item_id = t_attachable_items.attachable_item_id
WHERE message_id = $1
AND
	CASE WHEN $3::boolean = true THEN t_attachable_items.mime_type_id = ANY($4::uuid[]) ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN EXISTS (SELECT 1 FROM t_images WHERE t_images.attachable_item_id = t_attachable_items.attachable_item_id) ELSE TRUE END
AND
	CASE WHEN $6::boolean = true THEN EXISTS (SELECT 1 FROM t_files WHERE t_files.attachable_item_id = t_attachable_items.attachable_item_id) ELSE TRUE END
AND
	CASE $7::text
		WHEN 'next' THEN
			t_attached_messages_pkey > $8::int
		WHEN 'prev' THEN
			t_attached_messages_pkey < $8::int
	END
ORDER BY
	CASE WHEN $7::text = 'next' THEN t_attached_messages_pkey END ASC,
	CASE WHEN $7::text = 'prev' THEN t_attached_messages_pkey END DESC
LIMIT $2
`

type GetAttachedItemsOnMessageUseKeysetPaginateParams struct {
	MessageID       uuid.UUID   `json:"message_id"`
	Limit           int32       `json:"limit"`
	WhereInMimeType bool        `json:"where_in_mime_type"`
	InMimeTypes     []uuid.UUID `json:"in_mime_types"`
	WhereIsImage    bool        `json:"where_is_image"`
	WhereIsFile     bool        `json:"where_is_file"`
	CursorDirection string      `json:"cursor_direction"`
	Cursor          int32       `json:"cursor"`
}

type GetAttachedItemsOnMessageUseKeysetPaginateRow struct {
	TAttachedMessagesPkey  pgtype.Int8   `json:"t_attached_messages_pkey"`
	AttachedMessageID      uuid.UUID     `json:"attached_message_id"`
	MessageID              uuid.UUID     `json:"message_id"`
	AttachableItemID       pgtype.UUID   `json:"attachable_item_id"`
	AttachedItemUrl        pgtype.Text   `json:"attached_item_url"`
	AttachedItemAlias      pgtype.Text   `json:"attached_item_alias"`
	AttachedItemSize       pgtype.Float8 `json:"attached_item_size"`
	AttachedItemMimeTypeID pgtype.UUID   `json:"attached_item_mime_type_id"`
	AttachedItemOwnerID    pgtype.UUID   `json:"attached_item_owner_id"`
	AttachedItemFromOuter  pgtype.Bool   `json:"attached_item_from_outer"`
}

func (q *Queries) GetAttachedItemsOnMessageUseKeysetPaginate(ctx context.Context, arg GetAttachedItemsOnMessageUseKeysetPaginateParams) ([]GetAttachedItemsOnMessageUseKeysetPaginateRow, error) {
	rows, err := q.db.Query(ctx, getAttachedItemsOnMessageUseKeysetPaginate,
		arg.MessageID,
		arg.Limit,
		arg.WhereInMimeType,
		arg.InMimeTypes,
		arg.WhereIsImage,
		arg.WhereIsFile,
		arg.CursorDirection,
		arg.Cursor,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAttachedItemsOnMessageUseKeysetPaginateRow{}
	for rows.Next() {
		var i GetAttachedItemsOnMessageUseKeysetPaginateRow
		if err := rows.Scan(
			&i.TAttachedMessagesPkey,
			&i.AttachedMessageID,
			&i.MessageID,
			&i.AttachableItemID,
			&i.AttachedItemUrl,
			&i.AttachedItemAlias,
			&i.AttachedItemSize,
			&i.AttachedItemMimeTypeID,
			&i.AttachedItemOwnerID,
			&i.AttachedItemFromOuter,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAttachedItemsOnMessageUseNumberedPaginate = `-- name: GetAttachedItemsOnMessageUseNumberedPaginate :many
SELECT t_attached_messages.t_attached_messages_pkey, t_attached_messages.attached_message_id, t_attached_messages.message_id, t_attached_messages.attachable_item_id, t_attachable_items.url attached_item_url, t_attachable_items.alias attached_item_alias,
t_attachable_items.size attached_item_size, t_attachable_items.mime_type_id attached_item_mime_type_id,
t_attachable_items.owner_id attached_item_owner_id, t_attachable_items.from_outer attached_item_from_outer
FROM t_attached_messages
LEFT JOIN t_attachable_items ON t_attached_messages.attachable_item_id = t_attachable_items.attachable_item_id
WHERE message_id = $1
AND
	CASE WHEN $4::boolean = true THEN t_attachable_items.mime_type_id = ANY($5::uuid[]) ELSE TRUE END
	AND
	CASE WHEN $6::boolean = true THEN EXISTS (SELECT 1 FROM t_images WHERE t_images.attachable_item_id = t_attachable_items.attachable_item_id) ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN EXISTS (SELECT 1 FROM t_files WHERE t_files.attachable_item_id = t_attachable_items.attachable_item_id) ELSE TRUE END
ORDER BY
	t_attached_messages_pkey ASC
LIMIT $2 OFFSET $3
`

type GetAttachedItemsOnMessageUseNumberedPaginateParams struct {
	MessageID       uuid.UUID   `json:"message_id"`
	Limit           int32       `json:"limit"`
	Offset          int32       `json:"offset"`
	WhereInMimeType bool        `json:"where_in_mime_type"`
	InMimeTypes     []uuid.UUID `json:"in_mime_types"`
	WhereIsImage    bool        `json:"where_is_image"`
	WhereIsFile     bool        `json:"where_is_file"`
}

type GetAttachedItemsOnMessageUseNumberedPaginateRow struct {
	TAttachedMessagesPkey  pgtype.Int8   `json:"t_attached_messages_pkey"`
	AttachedMessageID      uuid.UUID     `json:"attached_message_id"`
	MessageID              uuid.UUID     `json:"message_id"`
	AttachableItemID       pgtype.UUID   `json:"attachable_item_id"`
	AttachedItemUrl        pgtype.Text   `json:"attached_item_url"`
	AttachedItemAlias      pgtype.Text   `json:"attached_item_alias"`
	AttachedItemSize       pgtype.Float8 `json:"attached_item_size"`
	AttachedItemMimeTypeID pgtype.UUID   `json:"attached_item_mime_type_id"`
	AttachedItemOwnerID    pgtype.UUID   `json:"attached_item_owner_id"`
	AttachedItemFromOuter  pgtype.Bool   `json:"attached_item_from_outer"`
}

func (q *Queries) GetAttachedItemsOnMessageUseNumberedPaginate(ctx context.Context, arg GetAttachedItemsOnMessageUseNumberedPaginateParams) ([]GetAttachedItemsOnMessageUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getAttachedItemsOnMessageUseNumberedPaginate,
		arg.MessageID,
		arg.Limit,
		arg.Offset,
		arg.WhereInMimeType,
		arg.InMimeTypes,
		arg.WhereIsImage,
		arg.WhereIsFile,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAttachedItemsOnMessageUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetAttachedItemsOnMessageUseNumberedPaginateRow
		if err := rows.Scan(
			&i.TAttachedMessagesPkey,
			&i.AttachedMessageID,
			&i.MessageID,
			&i.AttachableItemID,
			&i.AttachedItemUrl,
			&i.AttachedItemAlias,
			&i.AttachedItemSize,
			&i.AttachedItemMimeTypeID,
			&i.AttachedItemOwnerID,
			&i.AttachedItemFromOuter,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAttachedItemsOnMessageWithMimeType = `-- name: GetAttachedItemsOnMessageWithMimeType :many
SELECT t_attached_messages.t_attached_messages_pkey, t_attached_messages.attached_message_id, t_attached_messages.message_id, t_attached_messages.attachable_item_id, t_attachable_items.url attached_item_url, t_attachable_items.alias attached_item_alias,
t_attachable_items.size attached_item_size, t_attachable_items.mime_type_id attached_item_mime_type_id,
t_attachable_items.owner_id attached_item_owner_id, t_attachable_items.from_outer attached_item_from_outer,
m_mime_types.name mime_type_name, m_mime_types.key mime_type_key, m_mime_types.kind mime_type_kind
FROM t_attached_messages
LEFT JOIN t_attachable_items ON t_attached_messages.attachable_item_id = t_attachable_items.attachable_item_id
LEFT JOIN m_mime_types ON t_attachable_items.mime_type_id = m_mime_types.mime_type_id
WHERE message_id = $1
AND
	CASE WHEN $2::boolean = true THEN t_attachable_items.mime_type_id = ANY($3::uuid[]) ELSE TRUE END
AND
	CASE WHEN $4::boolean = true THEN EXISTS (SELECT 1 FROM t_images WHERE t_images.attachable_item_id = t_attachable_items.attachable_item_id) ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN EXISTS (SELECT 1 FROM t_files WHERE t_files.attachable_item_id = t_attachable_items.attachable_item_id) ELSE TRUE END
ORDER BY
	t_attached_messages_pkey ASC
`

type GetAttachedItemsOnMessageWithMimeTypeParams struct {
	MessageID       uuid.UUID   `json:"message_id"`
	WhereInMimeType bool        `json:"where_in_mime_type"`
	InMimeTypes     []uuid.UUID `json:"in_mime_types"`
	WhereIsImage    bool        `json:"where_is_image"`
	WhereIsFile     bool        `json:"where_is_file"`
}

type GetAttachedItemsOnMessageWithMimeTypeRow struct {
	TAttachedMessagesPkey  pgtype.Int8   `json:"t_attached_messages_pkey"`
	AttachedMessageID      uuid.UUID     `json:"attached_message_id"`
	MessageID              uuid.UUID     `json:"message_id"`
	AttachableItemID       pgtype.UUID   `json:"attachable_item_id"`
	AttachedItemUrl        pgtype.Text   `json:"attached_item_url"`
	AttachedItemAlias      pgtype.Text   `json:"attached_item_alias"`
	AttachedItemSize       pgtype.Float8 `json:"attached_item_size"`
	AttachedItemMimeTypeID pgtype.UUID   `json:"attached_item_mime_type_id"`
	AttachedItemOwnerID    pgtype.UUID   `json:"attached_item_owner_id"`
	AttachedItemFromOuter  pgtype.Bool   `json:"attached_item_from_outer"`
	MimeTypeName           pgtype.Text   `json:"mime_type_name"`
	MimeTypeKey            pgtype.Text   `json:"mime_type_key"`
	MimeTypeKind           pgtype.Text   `json:"mime_type_kind"`
}

func (q *Queries) GetAttachedItemsOnMessageWithMimeType(ctx context.Context, arg GetAttachedItemsOnMessageWithMimeTypeParams) ([]GetAttachedItemsOnMessageWithMimeTypeRow, error) {
	rows, err := q.db.Query(ctx, getAttachedItemsOnMessageWithMimeType,
		arg.MessageID,
		arg.WhereInMimeType,
		arg.InMimeTypes,
		arg.WhereIsImage,
		arg.WhereIsFile,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAttachedItemsOnMessageWithMimeTypeRow{}
	for rows.Next() {
		var i GetAttachedItemsOnMessageWithMimeTypeRow
		if err := rows.Scan(
			&i.TAttachedMessagesPkey,
			&i.AttachedMessageID,
			&i.MessageID,
			&i.AttachableItemID,
			&i.AttachedItemUrl,
			&i.AttachedItemAlias,
			&i.AttachedItemSize,
			&i.AttachedItemMimeTypeID,
			&i.AttachedItemOwnerID,
			&i.AttachedItemFromOuter,
			&i.MimeTypeName,
			&i.MimeTypeKey,
			&i.MimeTypeKind,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAttachedItemsOnMessageWithMimeTypeUseKeysetPaginate = `-- name: GetAttachedItemsOnMessageWithMimeTypeUseKeysetPaginate :many
SELECT t_attached_messages.t_attached_messages_pkey, t_attached_messages.attached_message_id, t_attached_messages.message_id, t_attached_messages.attachable_item_id, t_attachable_items.url attached_item_url, t_attachable_items.alias attached_item_alias,
t_attachable_items.size attached_item_size, t_attachable_items.mime_type_id attached_item_mime_type_id,
t_attachable_items.owner_id attached_item_owner_id, t_attachable_items.from_outer attached_item_from_outer,
m_mime_types.name mime_type_name, m_mime_types.key mime_type_key, m_mime_types.kind mime_type_kind
FROM t_attached_messages
LEFT JOIN t_attachable_items ON t_attached_messages.attachable_item_id = t_attachable_items.attachable_item_id
LEFT JOIN m_mime_types ON t_attachable_items.mime_type_id = m_mime_types.mime_type_id
WHERE message_id = $1
AND
	CASE WHEN $3::boolean = true THEN t_attachable_items.mime_type_id = ANY($4::uuid[]) ELSE TRUE END
AND
	CASE WHEN $5::boolean = true THEN EXISTS (SELECT 1 FROM t_images WHERE t_images.attachable_item_id = t_attachable_items.attachable_item_id) ELSE TRUE END
AND
	CASE WHEN $6::boolean = true THEN EXISTS (SELECT 1 FROM t_files WHERE t_files.attachable_item_id = t_attachable_items.attachable_item_id) ELSE TRUE END
AND
	CASE $7::text
		WHEN 'next' THEN
			t_attached_messages_pkey > $8::int
		WHEN 'prev' THEN
			t_attached_messages_pkey < $8::int
	END
ORDER BY
	CASE WHEN $7::text = 'next' THEN t_attached_messages_pkey END ASC,
	CASE WHEN $7::text = 'prev' THEN t_attached_messages_pkey END DESC
LIMIT $2
`

type GetAttachedItemsOnMessageWithMimeTypeUseKeysetPaginateParams struct {
	MessageID       uuid.UUID   `json:"message_id"`
	Limit           int32       `json:"limit"`
	WhereInMimeType bool        `json:"where_in_mime_type"`
	InMimeTypes     []uuid.UUID `json:"in_mime_types"`
	WhereIsImage    bool        `json:"where_is_image"`
	WhereIsFile     bool        `json:"where_is_file"`
	CursorDirection string      `json:"cursor_direction"`
	Cursor          int32       `json:"cursor"`
}

type GetAttachedItemsOnMessageWithMimeTypeUseKeysetPaginateRow struct {
	TAttachedMessagesPkey  pgtype.Int8   `json:"t_attached_messages_pkey"`
	AttachedMessageID      uuid.UUID     `json:"attached_message_id"`
	MessageID              uuid.UUID     `json:"message_id"`
	AttachableItemID       pgtype.UUID   `json:"attachable_item_id"`
	AttachedItemUrl        pgtype.Text   `json:"attached_item_url"`
	AttachedItemAlias      pgtype.Text   `json:"attached_item_alias"`
	AttachedItemSize       pgtype.Float8 `json:"attached_item_size"`
	AttachedItemMimeTypeID pgtype.UUID   `json:"attached_item_mime_type_id"`
	AttachedItemOwnerID    pgtype.UUID   `json:"attached_item_owner_id"`
	AttachedItemFromOuter  pgtype.Bool   `json:"attached_item_from_outer"`
	MimeTypeName           pgtype.Text   `json:"mime_type_name"`
	MimeTypeKey            pgtype.Text   `json:"mime_type_key"`
	MimeTypeKind           pgtype.Text   `json:"mime_type_kind"`
}

func (q *Queries) GetAttachedItemsOnMessageWithMimeTypeUseKeysetPaginate(ctx context.Context, arg GetAttachedItemsOnMessageWithMimeTypeUseKeysetPaginateParams) ([]GetAttachedItemsOnMessageWithMimeTypeUseKeysetPaginateRow, error) {
	rows, err := q.db.Query(ctx, getAttachedItemsOnMessageWithMimeTypeUseKeysetPaginate,
		arg.MessageID,
		arg.Limit,
		arg.WhereInMimeType,
		arg.InMimeTypes,
		arg.WhereIsImage,
		arg.WhereIsFile,
		arg.CursorDirection,
		arg.Cursor,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAttachedItemsOnMessageWithMimeTypeUseKeysetPaginateRow{}
	for rows.Next() {
		var i GetAttachedItemsOnMessageWithMimeTypeUseKeysetPaginateRow
		if err := rows.Scan(
			&i.TAttachedMessagesPkey,
			&i.AttachedMessageID,
			&i.MessageID,
			&i.AttachableItemID,
			&i.AttachedItemUrl,
			&i.AttachedItemAlias,
			&i.AttachedItemSize,
			&i.AttachedItemMimeTypeID,
			&i.AttachedItemOwnerID,
			&i.AttachedItemFromOuter,
			&i.MimeTypeName,
			&i.MimeTypeKey,
			&i.MimeTypeKind,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAttachedItemsOnMessageWithMimeTypeUseNumberedPaginate = `-- name: GetAttachedItemsOnMessageWithMimeTypeUseNumberedPaginate :many
SELECT t_attached_messages.t_attached_messages_pkey, t_attached_messages.attached_message_id, t_attached_messages.message_id, t_attached_messages.attachable_item_id, t_attachable_items.url attached_item_url, t_attachable_items.alias attached_item_alias,
t_attachable_items.size attached_item_size, t_attachable_items.mime_type_id attached_item_mime_type_id,
t_attachable_items.owner_id attached_item_owner_id, t_attachable_items.from_outer attached_item_from_outer,
m_mime_types.name mime_type_name, m_mime_types.key mime_type_key, m_mime_types.kind mime_type_kind
FROM t_attached_messages
LEFT JOIN t_attachable_items ON t_attached_messages.attachable_item_id = t_attachable_items.attachable_item_id
LEFT JOIN m_mime_types ON t_attachable_items.mime_type_id = m_mime_types.mime_type_id
WHERE message_id = $1
AND
	CASE WHEN $4::boolean = true THEN t_attachable_items.mime_type_id = ANY($5::uuid[]) ELSE TRUE END
AND
	CASE WHEN $6::boolean = true THEN EXISTS (SELECT 1 FROM t_images WHERE t_images.attachable_item_id = t_attachable_items.attachable_item_id) ELSE TRUE END
AND
	CASE WHEN $7::boolean = true THEN EXISTS (SELECT 1 FROM t_files WHERE t_files.attachable_item_id = t_attachable_items.attachable_item_id) ELSE TRUE END
ORDER BY
	t_attached_messages_pkey ASC
LIMIT $2 OFFSET $3
`

type GetAttachedItemsOnMessageWithMimeTypeUseNumberedPaginateParams struct {
	MessageID       uuid.UUID   `json:"message_id"`
	Limit           int32       `json:"limit"`
	Offset          int32       `json:"offset"`
	WhereInMimeType bool        `json:"where_in_mime_type"`
	InMimeTypes     []uuid.UUID `json:"in_mime_types"`
	WhereIsImage    bool        `json:"where_is_image"`
	WhereIsFile     bool        `json:"where_is_file"`
}

type GetAttachedItemsOnMessageWithMimeTypeUseNumberedPaginateRow struct {
	TAttachedMessagesPkey  pgtype.Int8   `json:"t_attached_messages_pkey"`
	AttachedMessageID      uuid.UUID     `json:"attached_message_id"`
	MessageID              uuid.UUID     `json:"message_id"`
	AttachableItemID       pgtype.UUID   `json:"attachable_item_id"`
	AttachedItemUrl        pgtype.Text   `json:"attached_item_url"`
	AttachedItemAlias      pgtype.Text   `json:"attached_item_alias"`
	AttachedItemSize       pgtype.Float8 `json:"attached_item_size"`
	AttachedItemMimeTypeID pgtype.UUID   `json:"attached_item_mime_type_id"`
	AttachedItemOwnerID    pgtype.UUID   `json:"attached_item_owner_id"`
	AttachedItemFromOuter  pgtype.Bool   `json:"attached_item_from_outer"`
	MimeTypeName           pgtype.Text   `json:"mime_type_name"`
	MimeTypeKey            pgtype.Text   `json:"mime_type_key"`
	MimeTypeKind           pgtype.Text   `json:"mime_type_kind"`
}

func (q *Queries) GetAttachedItemsOnMessageWithMimeTypeUseNumberedPaginate(ctx context.Context, arg GetAttachedItemsOnMessageWithMimeTypeUseNumberedPaginateParams) ([]GetAttachedItemsOnMessageWithMimeTypeUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getAttachedItemsOnMessageWithMimeTypeUseNumberedPaginate,
		arg.MessageID,
		arg.Limit,
		arg.Offset,
		arg.WhereInMimeType,
		arg.InMimeTypes,
		arg.WhereIsImage,
		arg.WhereIsFile,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAttachedItemsOnMessageWithMimeTypeUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetAttachedItemsOnMessageWithMimeTypeUseNumberedPaginateRow
		if err := rows.Scan(
			&i.TAttachedMessagesPkey,
			&i.AttachedMessageID,
			&i.MessageID,
			&i.AttachableItemID,
			&i.AttachedItemUrl,
			&i.AttachedItemAlias,
			&i.AttachedItemSize,
			&i.AttachedItemMimeTypeID,
			&i.AttachedItemOwnerID,
			&i.AttachedItemFromOuter,
			&i.MimeTypeName,
			&i.MimeTypeKey,
			&i.MimeTypeKind,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralAttachedItemsOnMessage = `-- name: GetPluralAttachedItemsOnMessage :many
SELECT t_attached_messages.t_attached_messages_pkey, t_attached_messages.attached_message_id, t_attached_messages.message_id, t_attached_messages.attachable_item_id, t_attachable_items.url attached_item_url, t_attachable_items.alias attached_item_alias,
t_attachable_items.size attached_item_size, t_attachable_items.mime_type_id attached_item_mime_type_id,
t_attachable_items.owner_id attached_item_owner_id, t_attachable_items.from_outer attached_item_from_outer
FROM t_attached_messages
LEFT JOIN t_attachable_items ON t_attached_messages.attachable_item_id = t_attachable_items.attachable_item_id
WHERE message_id = ANY($1::uuid[])
ORDER BY
	t_attached_messages_pkey ASC
`

type GetPluralAttachedItemsOnMessageRow struct {
	TAttachedMessagesPkey  pgtype.Int8   `json:"t_attached_messages_pkey"`
	AttachedMessageID      uuid.UUID     `json:"attached_message_id"`
	MessageID              uuid.UUID     `json:"message_id"`
	AttachableItemID       pgtype.UUID   `json:"attachable_item_id"`
	AttachedItemUrl        pgtype.Text   `json:"attached_item_url"`
	AttachedItemAlias      pgtype.Text   `json:"attached_item_alias"`
	AttachedItemSize       pgtype.Float8 `json:"attached_item_size"`
	AttachedItemMimeTypeID pgtype.UUID   `json:"attached_item_mime_type_id"`
	AttachedItemOwnerID    pgtype.UUID   `json:"attached_item_owner_id"`
	AttachedItemFromOuter  pgtype.Bool   `json:"attached_item_from_outer"`
}

func (q *Queries) GetPluralAttachedItemsOnMessage(ctx context.Context, messageIds []uuid.UUID) ([]GetPluralAttachedItemsOnMessageRow, error) {
	rows, err := q.db.Query(ctx, getPluralAttachedItemsOnMessage, messageIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralAttachedItemsOnMessageRow{}
	for rows.Next() {
		var i GetPluralAttachedItemsOnMessageRow
		if err := rows.Scan(
			&i.TAttachedMessagesPkey,
			&i.AttachedMessageID,
			&i.MessageID,
			&i.AttachableItemID,
			&i.AttachedItemUrl,
			&i.AttachedItemAlias,
			&i.AttachedItemSize,
			&i.AttachedItemMimeTypeID,
			&i.AttachedItemOwnerID,
			&i.AttachedItemFromOuter,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralAttachedItemsOnMessageUseNumberedPaginate = `-- name: GetPluralAttachedItemsOnMessageUseNumberedPaginate :many
SELECT t_attached_messages.t_attached_messages_pkey, t_attached_messages.attached_message_id, t_attached_messages.message_id, t_attached_messages.attachable_item_id, t_attachable_items.url attached_item_url, t_attachable_items.alias attached_item_alias,
t_attachable_items.size attached_item_size, t_attachable_items.mime_type_id attached_item_mime_type_id,
t_attachable_items.owner_id attached_item_owner_id, t_attachable_items.from_outer attached_item_from_outer
FROM t_attached_messages
LEFT JOIN t_attachable_items ON t_attached_messages.attachable_item_id = t_attachable_items.attachable_item_id
WHERE message_id = ANY($3::uuid[])
ORDER BY
	t_attached_messages_pkey ASC
LIMIT $1 OFFSET $2
`

type GetPluralAttachedItemsOnMessageUseNumberedPaginateParams struct {
	Limit      int32       `json:"limit"`
	Offset     int32       `json:"offset"`
	MessageIds []uuid.UUID `json:"message_ids"`
}

type GetPluralAttachedItemsOnMessageUseNumberedPaginateRow struct {
	TAttachedMessagesPkey  pgtype.Int8   `json:"t_attached_messages_pkey"`
	AttachedMessageID      uuid.UUID     `json:"attached_message_id"`
	MessageID              uuid.UUID     `json:"message_id"`
	AttachableItemID       pgtype.UUID   `json:"attachable_item_id"`
	AttachedItemUrl        pgtype.Text   `json:"attached_item_url"`
	AttachedItemAlias      pgtype.Text   `json:"attached_item_alias"`
	AttachedItemSize       pgtype.Float8 `json:"attached_item_size"`
	AttachedItemMimeTypeID pgtype.UUID   `json:"attached_item_mime_type_id"`
	AttachedItemOwnerID    pgtype.UUID   `json:"attached_item_owner_id"`
	AttachedItemFromOuter  pgtype.Bool   `json:"attached_item_from_outer"`
}

func (q *Queries) GetPluralAttachedItemsOnMessageUseNumberedPaginate(ctx context.Context, arg GetPluralAttachedItemsOnMessageUseNumberedPaginateParams) ([]GetPluralAttachedItemsOnMessageUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getPluralAttachedItemsOnMessageUseNumberedPaginate, arg.Limit, arg.Offset, arg.MessageIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralAttachedItemsOnMessageUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetPluralAttachedItemsOnMessageUseNumberedPaginateRow
		if err := rows.Scan(
			&i.TAttachedMessagesPkey,
			&i.AttachedMessageID,
			&i.MessageID,
			&i.AttachableItemID,
			&i.AttachedItemUrl,
			&i.AttachedItemAlias,
			&i.AttachedItemSize,
			&i.AttachedItemMimeTypeID,
			&i.AttachedItemOwnerID,
			&i.AttachedItemFromOuter,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralAttachedItemsOnMessageWithMimeType = `-- name: GetPluralAttachedItemsOnMessageWithMimeType :many
SELECT t_attached_messages.t_attached_messages_pkey, t_attached_messages.attached_message_id, t_attached_messages.message_id, t_attached_messages.attachable_item_id, t_attachable_items.url attached_item_url, t_attachable_items.alias attached_item_alias,
t_attachable_items.size attached_item_size, t_attachable_items.mime_type_id attached_item_mime_type_id,
t_attachable_items.owner_id attached_item_owner_id, t_attachable_items.from_outer attached_item_from_outer,
m_mime_types.name mime_type_name, m_mime_types.key mime_type_key, m_mime_types.kind mime_type_kind
FROM t_attached_messages
LEFT JOIN t_attachable_items ON t_attached_messages.attachable_item_id = t_attachable_items.attachable_item_id
LEFT JOIN m_mime_types ON t_attachable_items.mime_type_id = m_mime_types.mime_type_id
WHERE message_id = ANY($1::uuid[])
ORDER BY
	t_attached_messages_pkey ASC
`

type GetPluralAttachedItemsOnMessageWithMimeTypeRow struct {
	TAttachedMessagesPkey  pgtype.Int8   `json:"t_attached_messages_pkey"`
	AttachedMessageID      uuid.UUID     `json:"attached_message_id"`
	MessageID              uuid.UUID     `json:"message_id"`
	AttachableItemID       pgtype.UUID   `json:"attachable_item_id"`
	AttachedItemUrl        pgtype.Text   `json:"attached_item_url"`
	AttachedItemAlias      pgtype.Text   `json:"attached_item_alias"`
	AttachedItemSize       pgtype.Float8 `json:"attached_item_size"`
	AttachedItemMimeTypeID pgtype.UUID   `json:"attached_item_mime_type_id"`
	AttachedItemOwnerID    pgtype.UUID   `json:"attached_item_owner_id"`
	AttachedItemFromOuter  pgtype.Bool   `json:"attached_item_from_outer"`
	MimeTypeName           pgtype.Text   `json:"mime_type_name"`
	MimeTypeKey            pgtype.Text   `json:"mime_type_key"`
	MimeTypeKind           pgtype.Text   `json:"mime_type_kind"`
}

func (q *Queries) GetPluralAttachedItemsOnMessageWithMimeType(ctx context.Context, messageIds []uuid.UUID) ([]GetPluralAttachedItemsOnMessageWithMimeTypeRow, error) {
	rows, err := q.db.Query(ctx, getPluralAttachedItemsOnMessageWithMimeType, messageIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralAttachedItemsOnMessageWithMimeTypeRow{}
	for rows.Next() {
		var i GetPluralAttachedItemsOnMessageWithMimeTypeRow
		if err := rows.Scan(
			&i.TAttachedMessagesPkey,
			&i.AttachedMessageID,
			&i.MessageID,
			&i.AttachableItemID,
			&i.AttachedItemUrl,
			&i.AttachedItemAlias,
			&i.AttachedItemSize,
			&i.AttachedItemMimeTypeID,
			&i.AttachedItemOwnerID,
			&i.AttachedItemFromOuter,
			&i.MimeTypeName,
			&i.MimeTypeKey,
			&i.MimeTypeKind,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluralAttachedItemsOnMessageWithMimeTypeUseNumberedPaginate = `-- name: GetPluralAttachedItemsOnMessageWithMimeTypeUseNumberedPaginate :many
SELECT t_attached_messages.t_attached_messages_pkey, t_attached_messages.attached_message_id, t_attached_messages.message_id, t_attached_messages.attachable_item_id, t_attachable_items.url attached_item_url, t_attachable_items.alias attached_item_alias,
t_attachable_items.size attached_item_size, t_attachable_items.mime_type_id attached_item_mime_type_id,
t_attachable_items.owner_id attached_item_owner_id, t_attachable_items.from_outer attached_item_from_outer,
m_mime_types.name mime_type_name, m_mime_types.key mime_type_key, m_mime_types.kind mime_type_kind
FROM t_attached_messages
LEFT JOIN t_attachable_items ON t_attached_messages.attachable_item_id = t_attachable_items.attachable_item_id
LEFT JOIN m_mime_types ON t_attachable_items.mime_type_id = m_mime_types.mime_type_id
WHERE message_id = ANY($3::uuid[])
ORDER BY
	t_attached_messages_pkey ASC
LIMIT $1 OFFSET $2
`

type GetPluralAttachedItemsOnMessageWithMimeTypeUseNumberedPaginateParams struct {
	Limit      int32       `json:"limit"`
	Offset     int32       `json:"offset"`
	MessageIds []uuid.UUID `json:"message_ids"`
}

type GetPluralAttachedItemsOnMessageWithMimeTypeUseNumberedPaginateRow struct {
	TAttachedMessagesPkey  pgtype.Int8   `json:"t_attached_messages_pkey"`
	AttachedMessageID      uuid.UUID     `json:"attached_message_id"`
	MessageID              uuid.UUID     `json:"message_id"`
	AttachableItemID       pgtype.UUID   `json:"attachable_item_id"`
	AttachedItemUrl        pgtype.Text   `json:"attached_item_url"`
	AttachedItemAlias      pgtype.Text   `json:"attached_item_alias"`
	AttachedItemSize       pgtype.Float8 `json:"attached_item_size"`
	AttachedItemMimeTypeID pgtype.UUID   `json:"attached_item_mime_type_id"`
	AttachedItemOwnerID    pgtype.UUID   `json:"attached_item_owner_id"`
	AttachedItemFromOuter  pgtype.Bool   `json:"attached_item_from_outer"`
	MimeTypeName           pgtype.Text   `json:"mime_type_name"`
	MimeTypeKey            pgtype.Text   `json:"mime_type_key"`
	MimeTypeKind           pgtype.Text   `json:"mime_type_kind"`
}

func (q *Queries) GetPluralAttachedItemsOnMessageWithMimeTypeUseNumberedPaginate(ctx context.Context, arg GetPluralAttachedItemsOnMessageWithMimeTypeUseNumberedPaginateParams) ([]GetPluralAttachedItemsOnMessageWithMimeTypeUseNumberedPaginateRow, error) {
	rows, err := q.db.Query(ctx, getPluralAttachedItemsOnMessageWithMimeTypeUseNumberedPaginate, arg.Limit, arg.Offset, arg.MessageIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPluralAttachedItemsOnMessageWithMimeTypeUseNumberedPaginateRow{}
	for rows.Next() {
		var i GetPluralAttachedItemsOnMessageWithMimeTypeUseNumberedPaginateRow
		if err := rows.Scan(
			&i.TAttachedMessagesPkey,
			&i.AttachedMessageID,
			&i.MessageID,
			&i.AttachableItemID,
			&i.AttachedItemUrl,
			&i.AttachedItemAlias,
			&i.AttachedItemSize,
			&i.AttachedItemMimeTypeID,
			&i.AttachedItemOwnerID,
			&i.AttachedItemFromOuter,
			&i.MimeTypeName,
			&i.MimeTypeKey,
			&i.MimeTypeKind,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
